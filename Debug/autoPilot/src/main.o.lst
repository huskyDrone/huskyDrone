   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"main.c"
  23              	.Ltext0:
  24              		.file 1 "../autoPilot/src/main.c"
 4488              		.align	2
 4489              	.LC0:
 4490 0000 4C454400 		.ascii	"LED\000"
 4491              		.text
 4492              		.align	2
 4493              		.global	main
 4494              		.thumb
 4495              		.thumb_func
 4497              	main:
 4498              	.LFB55:
   1:../autoPilot/src/main.c **** /*
   2:../autoPilot/src/main.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../autoPilot/src/main.c **** 	
   4:../autoPilot/src/main.c **** 
   5:../autoPilot/src/main.c ****     ***************************************************************************
   6:../autoPilot/src/main.c ****      *                                                                       *
   7:../autoPilot/src/main.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../autoPilot/src/main.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../autoPilot/src/main.c ****      *    available.                                                         *
  10:../autoPilot/src/main.c ****      *                                                                       *
  11:../autoPilot/src/main.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../autoPilot/src/main.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../autoPilot/src/main.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../autoPilot/src/main.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../autoPilot/src/main.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../autoPilot/src/main.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../autoPilot/src/main.c ****      *                                                                       *
  18:../autoPilot/src/main.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../autoPilot/src/main.c ****      *                                                                       *
  20:../autoPilot/src/main.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../autoPilot/src/main.c ****      *                                                                       *
  22:../autoPilot/src/main.c ****     ***************************************************************************
  23:../autoPilot/src/main.c **** 
  24:../autoPilot/src/main.c **** 
  25:../autoPilot/src/main.c ****     This file is part of the FreeRTOS distribution.
  26:../autoPilot/src/main.c **** 
  27:../autoPilot/src/main.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../autoPilot/src/main.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../autoPilot/src/main.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../autoPilot/src/main.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../autoPilot/src/main.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../autoPilot/src/main.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../autoPilot/src/main.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../autoPilot/src/main.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../autoPilot/src/main.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../autoPilot/src/main.c ****     more details. You should have received a copy of the GNU General Public
  37:../autoPilot/src/main.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../autoPilot/src/main.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../autoPilot/src/main.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../autoPilot/src/main.c ****     FreeRTOS WEB site.
  41:../autoPilot/src/main.c **** 
  42:../autoPilot/src/main.c ****     1 tab == 4 spaces!
  43:../autoPilot/src/main.c **** 
  44:../autoPilot/src/main.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../autoPilot/src/main.c ****     contact details.
  46:../autoPilot/src/main.c **** 
  47:../autoPilot/src/main.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../autoPilot/src/main.c ****     critical systems.
  49:../autoPilot/src/main.c **** 
  50:../autoPilot/src/main.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../autoPilot/src/main.c ****     licensing and training services.
  52:../autoPilot/src/main.c **** */
  53:../autoPilot/src/main.c **** 
  54:../autoPilot/src/main.c **** /* Standard includes. */
  55:../autoPilot/src/main.c **** #include "stdio.h"
  56:../autoPilot/src/main.c **** 
  57:../autoPilot/src/main.c **** #define ARM_MATH_CM3
  58:../autoPilot/src/main.c **** 
  59:../autoPilot/src/main.c **** 
  60:../autoPilot/src/main.c **** /* Scheduler includes. */
  61:../autoPilot/src/main.c **** #include "FreeRTOSConfig.h"
  62:../autoPilot/src/main.c **** #include "FreeRTOS.h"
  63:../autoPilot/src/main.c **** #include "task.h"
  64:../autoPilot/src/main.c **** #include "queue.h"
  65:../autoPilot/src/main.c **** #include "semphr.h"
  66:../autoPilot/src/main.c **** 
  67:../autoPilot/src/main.c **** #include "hwConfig.h"
  68:../autoPilot/src/main.c **** #include "taskLed.h"
  69:../autoPilot/src/main.c **** #include "driverGps.h"
  70:../autoPilot/src/main.c **** 
  71:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
  72:../autoPilot/src/main.c **** 
  73:../autoPilot/src/main.c **** /* The time between cycles of the 'check' functionality (defined within the
  74:../autoPilot/src/main.c **** tick hook. */
  75:../autoPilot/src/main.c **** #define mainCHECK_DELAY						( ( portTickType ) 5000 / portTICK_RATE_MS )
  76:../autoPilot/src/main.c **** 
  77:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
  78:../autoPilot/src/main.c **** 
  79:../autoPilot/src/main.c **** // contains the handles for all tasks
  80:../autoPilot/src/main.c **** // define one more taskHandle than you need, zero the last entry
  81:../autoPilot/src/main.c **** xTaskHandle taskHandles[5];  //TODO: need to know how many there will be
  82:../autoPilot/src/main.c **** 
  83:../autoPilot/src/main.c **** // current GPS Rx status
  84:../autoPilot/src/main.c **** __IO SetState gpsRxReady;
  85:../autoPilot/src/main.c **** 
  86:../autoPilot/src/main.c **** int main( void )
  87:../autoPilot/src/main.c **** {
 4499              		.loc 1 87 0
 4500              		@ args = 0, pretend = 0, frame = 0
 4501              		@ frame_needed = 1, uses_anonymous_args = 0
 4502 0000 80B5     		push	{r7, lr}
 4503              	.LCFI0:
 4504 0002 84B0     		sub	sp, sp, #16
 4505              	.LCFI1:
 4506 0004 04AF     		add	r7, sp, #16
 4507              	.LCFI2:
  88:../autoPilot/src/main.c **** 	// configure the system
  89:../autoPilot/src/main.c ****     setSystem();
 4508              		.loc 1 89 0
 4509 0006 FFF7FEFF 		bl	setSystem
  90:../autoPilot/src/main.c **** 
  91:../autoPilot/src/main.c ****     // create the LED task
  92:../autoPilot/src/main.c ****     if(xTaskCreate(vLedTask, (signed portCHAR*) "LED",128,NULL, 1, &taskHandles[0]) != pdPASS)
 4510              		.loc 1 92 0
 4511 000a 40F20003 		movw	r3, #:lower16:.LC0
 4512 000e C0F20003 		movt	r3, #:upper16:.LC0
 4513 0012 4FF00102 		mov	r2, #1
 4514 0016 0092     		str	r2, [sp, #0]
 4515 0018 40F20002 		movw	r2, #:lower16:taskHandles
 4516 001c C0F20002 		movt	r2, #:upper16:taskHandles
 4517 0020 0192     		str	r2, [sp, #4]
 4518 0022 4FF00002 		mov	r2, #0
 4519 0026 0292     		str	r2, [sp, #8]
 4520 0028 4FF00002 		mov	r2, #0
 4521 002c 0392     		str	r2, [sp, #12]
 4522 002e 40F20000 		movw	r0, #:lower16:vLedTask
 4523 0032 C0F20000 		movt	r0, #:upper16:vLedTask
 4524 0036 1946     		mov	r1, r3
 4525 0038 4FF08002 		mov	r2, #128
 4526 003c 4FF00003 		mov	r3, #0
 4527 0040 FFF7FEFF 		bl	xTaskGenericCreate
  93:../autoPilot/src/main.c ****     {
  94:../autoPilot/src/main.c ****     	//TODO: the task was not created, do something
  95:../autoPilot/src/main.c ****     }
  96:../autoPilot/src/main.c **** 
  97:../autoPilot/src/main.c ****     taskHandles[4] = 0; //TODO: will need to change when we know how many tasks there will be
 4528              		.loc 1 97 0
 4529 0044 40F20003 		movw	r3, #:lower16:taskHandles
 4530 0048 C0F20003 		movt	r3, #:upper16:taskHandles
 4531 004c 4FF00002 		mov	r2, #0
 4532 0050 1A61     		str	r2, [r3, #16]
  98:../autoPilot/src/main.c **** 
  99:../autoPilot/src/main.c ****     // enable the interrupts
 100:../autoPilot/src/main.c ****     portENABLE_INTERRUPTS();
 4533              		.loc 1 100 0
 4534              	@ 100 "../autoPilot/src/main.c" 1
 4535 0052 4FF00000 			mov r0, #0					
 4536 0056 80F31188 		msr basepri, r0				
 4537              	
 4538              	@ 0 "" 2
 101:../autoPilot/src/main.c **** 
 102:../autoPilot/src/main.c ****     // start the scheduler
 103:../autoPilot/src/main.c **** 	vTaskStartScheduler();
 4539              		.loc 1 103 0
 4540              		.thumb
 4541 005a FFF7FEFF 		bl	vTaskStartScheduler
 4542              	.L2:
 104:../autoPilot/src/main.c **** 
 105:../autoPilot/src/main.c ****     // will only get here if there was insufficient memory to create the idle
 106:../autoPilot/src/main.c ****     // task.  The idle task is created within vTaskStartScheduler().
 107:../autoPilot/src/main.c **** 	for( ;; );
 4543              		.loc 1 107 0
 4544 005e FEE7     		b	.L2
 4545              	.LFE55:
 4547              		.align	2
 4548              		.global	vApplicationTickHook
 4549              		.thumb
 4550              		.thumb_func
 4552              	vApplicationTickHook:
 4553              	.LFB56:
 108:../autoPilot/src/main.c **** 
 109:../autoPilot/src/main.c **** 	return 0; // never gets here
 110:../autoPilot/src/main.c **** }
 111:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
 112:../autoPilot/src/main.c **** 
 113:../autoPilot/src/main.c **** void vApplicationTickHook( void )
 114:../autoPilot/src/main.c **** {
 4554              		.loc 1 114 0
 4555              		@ args = 0, pretend = 0, frame = 0
 4556              		@ frame_needed = 1, uses_anonymous_args = 0
 4557              		@ link register save eliminated.
 4558 0060 80B4     		push	{r7}
 4559              	.LCFI3:
 4560 0062 00AF     		add	r7, sp, #0
 4561              	.LCFI4:
 115:../autoPilot/src/main.c **** static unsigned long ulTicksSinceLastDisplay = 0;
 116:../autoPilot/src/main.c **** 
 117:../autoPilot/src/main.c **** 	// Called from every tick interrupt as described in the comments at the top
 118:../autoPilot/src/main.c **** 	//of this file.
 119:../autoPilot/src/main.c **** 
 120:../autoPilot/src/main.c **** 	//Have enough ticks passed to make it	time to perform our health status
 121:../autoPilot/src/main.c **** 	//check again?
 122:../autoPilot/src/main.c **** /*
 123:../autoPilot/src/main.c **** 	ulTicksSinceLastDisplay++;
 124:../autoPilot/src/main.c **** 	if( ulTicksSinceLastDisplay >= mainCHECK_DELAY )
 125:../autoPilot/src/main.c **** 	{
 126:../autoPilot/src/main.c **** 		// Reset the counter so these checks run again in mainCHECK_DELA  ticks time.
 127:../autoPilot/src/main.c **** 		ulTicksSinceLastDisplay = 0;
 128:../autoPilot/src/main.c **** 
 129:../autoPilot/src/main.c **** 		// Has an error been found in any task?
 130:../autoPilot/src/main.c **** 		if( xAreGenericQueueTasksStillRunning() != pdTRUE )
 131:../autoPilot/src/main.c **** 		{
 132:../autoPilot/src/main.c **** 			pcStatusMessage = "An error has been detected in the Generic Queue test/demo.";
 133:../autoPilot/src/main.c **** 		}
 134:../autoPilot/src/main.c **** 		else if( xAreQueuePeekTasksStillRunning() != pdTRUE )
 135:../autoPilot/src/main.c **** 		{
 136:../autoPilot/src/main.c **** 			pcStatusMessage = "An error has been detected in the Peek Queue test/demo.";
 137:../autoPilot/src/main.c **** 		}
 138:../autoPilot/src/main.c **** 		else if( xAreBlockingQueuesStillRunning() != pdTRUE )
 139:../autoPilot/src/main.c **** 		{
 140:../autoPilot/src/main.c **** 			pcStatusMessage = "An error has been detected in the Block Queue test/demo.";
 141:../autoPilot/src/main.c **** 		}
 142:../autoPilot/src/main.c **** 		else if( xAreBlockTimeTestTasksStillRunning() != pdTRUE )
 143:../autoPilot/src/main.c **** 		{
 144:../autoPilot/src/main.c **** 			pcStatusMessage = "An error has been detected in the Block Time test/demo.";
 145:../autoPilot/src/main.c **** 		}
 146:../autoPilot/src/main.c **** 	    else if( xAreSemaphoreTasksStillRunning() != pdTRUE )
 147:../autoPilot/src/main.c **** 	    {
 148:../autoPilot/src/main.c **** 	        pcStatusMessage = "An error has been detected in the Semaphore test/demo.";
 149:../autoPilot/src/main.c **** 	    }
 150:../autoPilot/src/main.c **** 	    else if( xArePollingQueuesStillRunning() != pdTRUE )
 151:../autoPilot/src/main.c **** 	    {
 152:../autoPilot/src/main.c **** 	        pcStatusMessage = "An error has been detected in the Poll Queue test/demo.";
 153:../autoPilot/src/main.c **** 	    }
 154:../autoPilot/src/main.c **** 	    else if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
 155:../autoPilot/src/main.c **** 	    {
 156:../autoPilot/src/main.c **** 	        pcStatusMessage = "An error has been detected in the Int Math test/demo.";
 157:../autoPilot/src/main.c **** 	    }
 158:../autoPilot/src/main.c **** 	    else if( xAreRecursiveMutexTasksStillRunning() != pdTRUE )
 159:../autoPilot/src/main.c **** 	    {
 160:../autoPilot/src/main.c **** 	    	pcStatusMessage = "An error has been detected in the Mutex test/demo.";
 161:../autoPilot/src/main.c **** 	    }
 162:../autoPilot/src/main.c **** 	}
 163:../autoPilot/src/main.c **** 	*/
 164:../autoPilot/src/main.c **** }
 4562              		.loc 1 164 0
 4563 0064 BD46     		mov	sp, r7
 4564 0066 80BC     		pop	{r7}
 4565 0068 7047     		bx	lr
 4566              	.LFE56:
 4568 006a 00BF     		.align	2
 4569              		.global	vApplicationStackOverflowHook
 4570              		.thumb
 4571              		.thumb_func
 4573              	vApplicationStackOverflowHook:
 4574              	.LFB57:
 165:../autoPilot/src/main.c **** 
 166:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
 167:../autoPilot/src/main.c **** 
 168:../autoPilot/src/main.c **** void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName )
 169:../autoPilot/src/main.c **** {
 4575              		.loc 1 169 0
 4576              		@ args = 0, pretend = 0, frame = 8
 4577              		@ frame_needed = 1, uses_anonymous_args = 0
 4578              		@ link register save eliminated.
 4579 006c 80B4     		push	{r7}
 4580              	.LCFI5:
 4581 006e 83B0     		sub	sp, sp, #12
 4582              	.LCFI6:
 4583 0070 00AF     		add	r7, sp, #0
 4584              	.LCFI7:
 4585 0072 7860     		str	r0, [r7, #4]
 4586 0074 3960     		str	r1, [r7, #0]
 4587              	.L7:
 170:../autoPilot/src/main.c **** 	/* This function will get called if a task overflows its stack. */
 171:../autoPilot/src/main.c **** 
 172:../autoPilot/src/main.c **** 	( void ) pxTask;
 173:../autoPilot/src/main.c **** 	( void ) pcTaskName;
 174:../autoPilot/src/main.c **** 
 175:../autoPilot/src/main.c **** 	for( ;; );
 4588              		.loc 1 175 0
 4589 0076 FEE7     		b	.L7
 4590              	.LFE57:
 4592              		.align	2
 4593              		.global	vConfigureTimerForRunTimeStats
 4594              		.thumb
 4595              		.thumb_func
 4597              	vConfigureTimerForRunTimeStats:
 4598              	.LFB58:
 176:../autoPilot/src/main.c **** }
 177:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
 178:../autoPilot/src/main.c **** 
 179:../autoPilot/src/main.c **** void vConfigureTimerForRunTimeStats( void )
 180:../autoPilot/src/main.c **** {
 4599              		.loc 1 180 0
 4600              		@ args = 0, pretend = 0, frame = 16
 4601              		@ frame_needed = 1, uses_anonymous_args = 0
 4602              		@ link register save eliminated.
 4603 0078 80B4     		push	{r7}
 4604              	.LCFI8:
 4605 007a 85B0     		sub	sp, sp, #20
 4606              	.LCFI9:
 4607 007c 00AF     		add	r7, sp, #0
 4608              	.LCFI10:
 181:../autoPilot/src/main.c **** const unsigned long TCR_COUNT_RESET = 2, CTCR_CTM_TIMER = 0x00, TCR_COUNT_ENABLE = 0x01;
 4609              		.loc 1 181 0
 4610 007e 4FF00203 		mov	r3, #2
 4611 0082 7B60     		str	r3, [r7, #4]
 4612 0084 4FF00003 		mov	r3, #0
 4613 0088 BB60     		str	r3, [r7, #8]
 4614 008a 4FF00103 		mov	r3, #1
 4615 008e FB60     		str	r3, [r7, #12]
 182:../autoPilot/src/main.c **** 
 183:../autoPilot/src/main.c **** 	/* This function configures a timer that is used as the time base when
 184:../autoPilot/src/main.c **** 	collecting run time statistical information - basically the percentage
 185:../autoPilot/src/main.c **** 	of CPU time that each task is utilising.  It is called automatically when
 186:../autoPilot/src/main.c **** 	the scheduler is started (assuming configGENERATE_RUN_TIME_STATS is set
 187:../autoPilot/src/main.c **** 	to 1). */
 188:../autoPilot/src/main.c **** 
 189:../autoPilot/src/main.c **** 	/* Power up and feed the timer. */
 190:../autoPilot/src/main.c **** 	LPC_SC->PCONP |= 0x02UL;
 4616              		.loc 1 190 0
 4617 0090 4CF20003 		movw	r3, #:lower16:1074774016
 4618 0094 C4F20F03 		movt	r3, #:upper16:1074774016
 4619 0098 4CF20002 		movw	r2, #:lower16:1074774016
 4620 009c C4F20F02 		movt	r2, #:upper16:1074774016
 4621 00a0 D2F8C420 		ldr	r2, [r2, #196]
 4622 00a4 42F00202 		orr	r2, r2, #2
 4623 00a8 C3F8C420 		str	r2, [r3, #196]
 191:../autoPilot/src/main.c **** 	LPC_SC->PCLKSEL0 = (LPC_SC->PCLKSEL0 & (~(0x3<<2))) | (0x01 << 2);
 4624              		.loc 1 191 0
 4625 00ac 4CF20003 		movw	r3, #:lower16:1074774016
 4626 00b0 C4F20F03 		movt	r3, #:upper16:1074774016
 4627 00b4 4CF20002 		movw	r2, #:lower16:1074774016
 4628 00b8 C4F20F02 		movt	r2, #:upper16:1074774016
 4629 00bc D2F8A821 		ldr	r2, [r2, #424]
 4630 00c0 22F00C02 		bic	r2, r2, #12
 4631 00c4 42F00402 		orr	r2, r2, #4
 4632 00c8 C3F8A821 		str	r2, [r3, #424]
 192:../autoPilot/src/main.c **** 
 193:../autoPilot/src/main.c **** 	/* Reset Timer 0 */
 194:../autoPilot/src/main.c **** 	LPC_TIM0->TCR = TCR_COUNT_RESET;
 4633              		.loc 1 194 0
 4634 00cc 44F20003 		movw	r3, #:lower16:1073758208
 4635 00d0 C4F20003 		movt	r3, #:upper16:1073758208
 4636 00d4 7A68     		ldr	r2, [r7, #4]
 4637 00d6 5A60     		str	r2, [r3, #4]
 195:../autoPilot/src/main.c **** 
 196:../autoPilot/src/main.c **** 	/* Just count up. */
 197:../autoPilot/src/main.c **** 	LPC_TIM0->CTCR = CTCR_CTM_TIMER;
 4638              		.loc 1 197 0
 4639 00d8 44F20003 		movw	r3, #:lower16:1073758208
 4640 00dc C4F20003 		movt	r3, #:upper16:1073758208
 4641 00e0 BA68     		ldr	r2, [r7, #8]
 4642 00e2 1A67     		str	r2, [r3, #112]
 198:../autoPilot/src/main.c **** 
 199:../autoPilot/src/main.c **** 	/* Prescale to a frequency that is good enough to get a decent resolution,
 200:../autoPilot/src/main.c **** 	but not too fast so as to overflow all the time. */
 201:../autoPilot/src/main.c **** 	LPC_TIM0->PR =  ( configCPU_CLOCK_HZ / 10000UL ) - 1UL;
 4643              		.loc 1 201 0
 4644 00e4 44F20003 		movw	r3, #:lower16:1073758208
 4645 00e8 C4F20003 		movt	r3, #:upper16:1073758208
 4646 00ec 42F2AB62 		movw	r2, #9899
 4647 00f0 DA60     		str	r2, [r3, #12]
 202:../autoPilot/src/main.c **** 
 203:../autoPilot/src/main.c **** 	/* Start the counter. */
 204:../autoPilot/src/main.c **** 	LPC_TIM0->TCR = TCR_COUNT_ENABLE;
 4648              		.loc 1 204 0
 4649 00f2 44F20003 		movw	r3, #:lower16:1073758208
 4650 00f6 C4F20003 		movt	r3, #:upper16:1073758208
 4651 00fa FA68     		ldr	r2, [r7, #12]
 4652 00fc 5A60     		str	r2, [r3, #4]
 205:../autoPilot/src/main.c **** }
 4653              		.loc 1 205 0
 4654 00fe 07F11407 		add	r7, r7, #20
 4655 0102 BD46     		mov	sp, r7
 4656 0104 80BC     		pop	{r7}
 4657 0106 7047     		bx	lr
 4658              	.LFE58:
 4660              		.bss
 4661              		.align	2
 4662              	ulTicksSinceLastDisplay.4143:
 4663 0000 00000000 		.space	4
 4772              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
                            *COM*:0000000000000014 taskHandles
                            *COM*:0000000000000001 gpsRxReady
/var/tmp//cc1NwBgs.s:4488   .rodata:0000000000000000 $d
/var/tmp//cc1NwBgs.s:4489   .rodata:0000000000000000 .LC0
/var/tmp//cc1NwBgs.s:4492   .text:0000000000000000 $t
/var/tmp//cc1NwBgs.s:4497   .text:0000000000000000 main
/var/tmp//cc1NwBgs.s:4552   .text:0000000000000060 vApplicationTickHook
/var/tmp//cc1NwBgs.s:4573   .text:000000000000006c vApplicationStackOverflowHook
/var/tmp//cc1NwBgs.s:4597   .text:0000000000000078 vConfigureTimerForRunTimeStats
/var/tmp//cc1NwBgs.s:4661   .bss:0000000000000000 $d
/var/tmp//cc1NwBgs.s:4662   .bss:0000000000000000 ulTicksSinceLastDisplay.4143
/var/tmp//cc1NwBgs.s:4677   .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
setSystem
vLedTask
xTaskGenericCreate
vTaskStartScheduler
