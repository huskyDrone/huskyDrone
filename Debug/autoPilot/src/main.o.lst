   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"main.c"
  23              	.Ltext0:
  24              		.file 1 "../autoPilot/src/main.c"
 4408              		.align	2
 4409              	.LC0:
 4410 0000 4C454400 		.ascii	"LED\000"
 4411              		.text
 4412              		.align	2
 4413              		.global	main
 4414              		.thumb
 4415              		.thumb_func
 4417              	main:
 4418              	.LFB55:
   1:../autoPilot/src/main.c **** /*
   2:../autoPilot/src/main.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../autoPilot/src/main.c **** 	
   4:../autoPilot/src/main.c **** 
   5:../autoPilot/src/main.c ****     ***************************************************************************
   6:../autoPilot/src/main.c ****      *                                                                       *
   7:../autoPilot/src/main.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../autoPilot/src/main.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../autoPilot/src/main.c ****      *    available.                                                         *
  10:../autoPilot/src/main.c ****      *                                                                       *
  11:../autoPilot/src/main.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../autoPilot/src/main.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../autoPilot/src/main.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../autoPilot/src/main.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../autoPilot/src/main.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../autoPilot/src/main.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../autoPilot/src/main.c ****      *                                                                       *
  18:../autoPilot/src/main.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../autoPilot/src/main.c ****      *                                                                       *
  20:../autoPilot/src/main.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../autoPilot/src/main.c ****      *                                                                       *
  22:../autoPilot/src/main.c ****     ***************************************************************************
  23:../autoPilot/src/main.c **** 
  24:../autoPilot/src/main.c **** 
  25:../autoPilot/src/main.c ****     This file is part of the FreeRTOS distribution.
  26:../autoPilot/src/main.c **** 
  27:../autoPilot/src/main.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../autoPilot/src/main.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../autoPilot/src/main.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../autoPilot/src/main.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../autoPilot/src/main.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../autoPilot/src/main.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../autoPilot/src/main.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../autoPilot/src/main.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../autoPilot/src/main.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../autoPilot/src/main.c ****     more details. You should have received a copy of the GNU General Public
  37:../autoPilot/src/main.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../autoPilot/src/main.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../autoPilot/src/main.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../autoPilot/src/main.c ****     FreeRTOS WEB site.
  41:../autoPilot/src/main.c **** 
  42:../autoPilot/src/main.c ****     1 tab == 4 spaces!
  43:../autoPilot/src/main.c **** 
  44:../autoPilot/src/main.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../autoPilot/src/main.c ****     contact details.
  46:../autoPilot/src/main.c **** 
  47:../autoPilot/src/main.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../autoPilot/src/main.c ****     critical systems.
  49:../autoPilot/src/main.c **** 
  50:../autoPilot/src/main.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../autoPilot/src/main.c ****     licensing and training services.
  52:../autoPilot/src/main.c **** */
  53:../autoPilot/src/main.c **** 
  54:../autoPilot/src/main.c **** /* Standard includes. */
  55:../autoPilot/src/main.c **** #include "stdio.h"
  56:../autoPilot/src/main.c **** 
  57:../autoPilot/src/main.c **** #define ARM_MATH_CM3
  58:../autoPilot/src/main.c **** 
  59:../autoPilot/src/main.c **** 
  60:../autoPilot/src/main.c **** /* Scheduler includes. */
  61:../autoPilot/src/main.c **** #include "FreeRTOSConfig.h"
  62:../autoPilot/src/main.c **** #include "FreeRTOS.h"
  63:../autoPilot/src/main.c **** #include "task.h"
  64:../autoPilot/src/main.c **** #include "queue.h"
  65:../autoPilot/src/main.c **** #include "semphr.h"
  66:../autoPilot/src/main.c **** 
  67:../autoPilot/src/main.c **** #include "hwConfig.h"
  68:../autoPilot/src/main.c **** #include "taskLed.h"
  69:../autoPilot/src/main.c **** 
  70:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
  71:../autoPilot/src/main.c **** 
  72:../autoPilot/src/main.c **** /* The time between cycles of the 'check' functionality (defined within the
  73:../autoPilot/src/main.c **** tick hook. */
  74:../autoPilot/src/main.c **** #define mainCHECK_DELAY						( ( portTickType ) 5000 / portTICK_RATE_MS )
  75:../autoPilot/src/main.c **** 
  76:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
  77:../autoPilot/src/main.c **** 
  78:../autoPilot/src/main.c **** // contains the handles for all tasks
  79:../autoPilot/src/main.c **** // define one more taskHandle than you need, zero the last entry
  80:../autoPilot/src/main.c **** xTaskHandle taskHandles[5];  //TODO: need to know how many there will be
  81:../autoPilot/src/main.c **** 
  82:../autoPilot/src/main.c **** int main( void )
  83:../autoPilot/src/main.c **** {
 4419              		.loc 1 83 0
 4420              		.cfi_startproc
 4421              		@ args = 0, pretend = 0, frame = 0
 4422              		@ frame_needed = 1, uses_anonymous_args = 0
 4423 0000 80B5     		push	{r7, lr}
 4424              	.LCFI0:
 4425              		.cfi_def_cfa_offset 8
 4426 0002 84B0     		sub	sp, sp, #16
 4427              	.LCFI1:
 4428              		.cfi_def_cfa_offset 24
 4429 0004 04AF     		add	r7, sp, #16
 4430              		.cfi_offset 14, -4
 4431              		.cfi_offset 7, -8
 4432              	.LCFI2:
 4433              		.cfi_def_cfa 7, 8
  84:../autoPilot/src/main.c **** 	// configure the system
  85:../autoPilot/src/main.c ****     setSystem();
 4434              		.loc 1 85 0
 4435 0006 FFF7FEFF 		bl	setSystem
  86:../autoPilot/src/main.c **** 
  87:../autoPilot/src/main.c ****     // create the LED task
  88:../autoPilot/src/main.c ****     if(xTaskCreate(vLedTask, (signed portCHAR*) "LED",128,NULL, 1, &taskHandles[0]) != pdPASS)
 4436              		.loc 1 88 0
 4437 000a 0F4B     		ldr	r3, .L3
 4438 000c 4FF00102 		mov	r2, #1
 4439 0010 0092     		str	r2, [sp, #0]
 4440 0012 0E4A     		ldr	r2, .L3+4
 4441 0014 0192     		str	r2, [sp, #4]
 4442 0016 4FF00002 		mov	r2, #0
 4443 001a 0292     		str	r2, [sp, #8]
 4444 001c 4FF00002 		mov	r2, #0
 4445 0020 0392     		str	r2, [sp, #12]
 4446 0022 0B48     		ldr	r0, .L3+8
 4447 0024 1946     		mov	r1, r3
 4448 0026 4FF08002 		mov	r2, #128
 4449 002a 4FF00003 		mov	r3, #0
 4450 002e FFF7FEFF 		bl	xTaskGenericCreate
  89:../autoPilot/src/main.c ****     {
  90:../autoPilot/src/main.c ****     	//TODO: the task was not created, do something
  91:../autoPilot/src/main.c ****     }
  92:../autoPilot/src/main.c **** 
  93:../autoPilot/src/main.c ****     taskHandles[4] = 0; //TODO: will need to change when we know how many tasks there will be
 4451              		.loc 1 93 0
 4452 0032 064B     		ldr	r3, .L3+4
 4453 0034 4FF00002 		mov	r2, #0
 4454 0038 1A61     		str	r2, [r3, #16]
  94:../autoPilot/src/main.c **** 
  95:../autoPilot/src/main.c ****     // enable the interrupts
  96:../autoPilot/src/main.c ****     portENABLE_INTERRUPTS();
 4455              		.loc 1 96 0
 4456              	@ 96 "../autoPilot/src/main.c" 1
 4457 003a 4FF00000 			mov r0, #0					
 4458 003e 80F31188 		msr basepri, r0				
 4459              	
 4460              	@ 0 "" 2
  97:../autoPilot/src/main.c **** 
  98:../autoPilot/src/main.c ****     // start the scheduler
  99:../autoPilot/src/main.c **** 	vTaskStartScheduler();
 4461              		.loc 1 99 0
 4462              		.thumb
 4463 0042 FFF7FEFF 		bl	vTaskStartScheduler
 4464              	.L2:
 100:../autoPilot/src/main.c **** 
 101:../autoPilot/src/main.c ****     // will only get here if there was insufficient memory to create the idle
 102:../autoPilot/src/main.c ****     // task.  The idle task is created within vTaskStartScheduler().
 103:../autoPilot/src/main.c **** 	for( ;; );
 4465              		.loc 1 103 0 discriminator 1
 4466 0046 FEE7     		b	.L2
 4467              	.L4:
 4468              		.align	2
 4469              	.L3:
 4470 0048 00000000 		.word	.LC0
 4471 004c 00000000 		.word	taskHandles
 4472 0050 00000000 		.word	vLedTask
 4473              		.cfi_endproc
 4474              	.LFE55:
 4476              		.align	2
 4477              		.global	vApplicationTickHook
 4478              		.thumb
 4479              		.thumb_func
 4481              	vApplicationTickHook:
 4482              	.LFB56:
 104:../autoPilot/src/main.c **** 
 105:../autoPilot/src/main.c **** 	return 0; // never gets here
 106:../autoPilot/src/main.c **** }
 107:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
 108:../autoPilot/src/main.c **** 
 109:../autoPilot/src/main.c **** void vApplicationTickHook( void )
 110:../autoPilot/src/main.c **** {
 4483              		.loc 1 110 0
 4484              		.cfi_startproc
 4485              		@ args = 0, pretend = 0, frame = 0
 4486              		@ frame_needed = 1, uses_anonymous_args = 0
 4487              		@ link register save eliminated.
 4488 0054 80B4     		push	{r7}
 4489              	.LCFI3:
 4490              		.cfi_def_cfa_offset 4
 4491 0056 00AF     		add	r7, sp, #0
 4492              		.cfi_offset 7, -4
 4493              	.LCFI4:
 4494              		.cfi_def_cfa_register 7
 111:../autoPilot/src/main.c **** static unsigned long ulTicksSinceLastDisplay = 0;
 112:../autoPilot/src/main.c **** 
 113:../autoPilot/src/main.c **** 	// Called from every tick interrupt as described in the comments at the top
 114:../autoPilot/src/main.c **** 	//of this file.
 115:../autoPilot/src/main.c **** 
 116:../autoPilot/src/main.c **** 	//Have enough ticks passed to make it	time to perform our health status
 117:../autoPilot/src/main.c **** 	//check again?
 118:../autoPilot/src/main.c **** /*
 119:../autoPilot/src/main.c **** 	ulTicksSinceLastDisplay++;
 120:../autoPilot/src/main.c **** 	if( ulTicksSinceLastDisplay >= mainCHECK_DELAY )
 121:../autoPilot/src/main.c **** 	{
 122:../autoPilot/src/main.c **** 		// Reset the counter so these checks run again in mainCHECK_DELA  ticks time.
 123:../autoPilot/src/main.c **** 		ulTicksSinceLastDisplay = 0;
 124:../autoPilot/src/main.c **** 
 125:../autoPilot/src/main.c **** 		// Has an error been found in any task?
 126:../autoPilot/src/main.c **** 		if( xAreGenericQueueTasksStillRunning() != pdTRUE )
 127:../autoPilot/src/main.c **** 		{
 128:../autoPilot/src/main.c **** 			pcStatusMessage = "An error has been detected in the Generic Queue test/demo.";
 129:../autoPilot/src/main.c **** 		}
 130:../autoPilot/src/main.c **** 		else if( xAreQueuePeekTasksStillRunning() != pdTRUE )
 131:../autoPilot/src/main.c **** 		{
 132:../autoPilot/src/main.c **** 			pcStatusMessage = "An error has been detected in the Peek Queue test/demo.";
 133:../autoPilot/src/main.c **** 		}
 134:../autoPilot/src/main.c **** 		else if( xAreBlockingQueuesStillRunning() != pdTRUE )
 135:../autoPilot/src/main.c **** 		{
 136:../autoPilot/src/main.c **** 			pcStatusMessage = "An error has been detected in the Block Queue test/demo.";
 137:../autoPilot/src/main.c **** 		}
 138:../autoPilot/src/main.c **** 		else if( xAreBlockTimeTestTasksStillRunning() != pdTRUE )
 139:../autoPilot/src/main.c **** 		{
 140:../autoPilot/src/main.c **** 			pcStatusMessage = "An error has been detected in the Block Time test/demo.";
 141:../autoPilot/src/main.c **** 		}
 142:../autoPilot/src/main.c **** 	    else if( xAreSemaphoreTasksStillRunning() != pdTRUE )
 143:../autoPilot/src/main.c **** 	    {
 144:../autoPilot/src/main.c **** 	        pcStatusMessage = "An error has been detected in the Semaphore test/demo.";
 145:../autoPilot/src/main.c **** 	    }
 146:../autoPilot/src/main.c **** 	    else if( xArePollingQueuesStillRunning() != pdTRUE )
 147:../autoPilot/src/main.c **** 	    {
 148:../autoPilot/src/main.c **** 	        pcStatusMessage = "An error has been detected in the Poll Queue test/demo.";
 149:../autoPilot/src/main.c **** 	    }
 150:../autoPilot/src/main.c **** 	    else if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
 151:../autoPilot/src/main.c **** 	    {
 152:../autoPilot/src/main.c **** 	        pcStatusMessage = "An error has been detected in the Int Math test/demo.";
 153:../autoPilot/src/main.c **** 	    }
 154:../autoPilot/src/main.c **** 	    else if( xAreRecursiveMutexTasksStillRunning() != pdTRUE )
 155:../autoPilot/src/main.c **** 	    {
 156:../autoPilot/src/main.c **** 	    	pcStatusMessage = "An error has been detected in the Mutex test/demo.";
 157:../autoPilot/src/main.c **** 	    }
 158:../autoPilot/src/main.c **** 	}
 159:../autoPilot/src/main.c **** 	*/
 160:../autoPilot/src/main.c **** }
 4495              		.loc 1 160 0
 4496 0058 BD46     		mov	sp, r7
 4497 005a 80BC     		pop	{r7}
 4498 005c 7047     		bx	lr
 4499              		.cfi_endproc
 4500              	.LFE56:
 4502 005e 00BF     		.align	2
 4503              		.global	vApplicationStackOverflowHook
 4504              		.thumb
 4505              		.thumb_func
 4507              	vApplicationStackOverflowHook:
 4508              	.LFB57:
 161:../autoPilot/src/main.c **** 
 162:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
 163:../autoPilot/src/main.c **** 
 164:../autoPilot/src/main.c **** void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName )
 165:../autoPilot/src/main.c **** {
 4509              		.loc 1 165 0
 4510              		.cfi_startproc
 4511              		@ args = 0, pretend = 0, frame = 8
 4512              		@ frame_needed = 1, uses_anonymous_args = 0
 4513              		@ link register save eliminated.
 4514 0060 80B4     		push	{r7}
 4515              	.LCFI5:
 4516              		.cfi_def_cfa_offset 4
 4517 0062 83B0     		sub	sp, sp, #12
 4518              	.LCFI6:
 4519              		.cfi_def_cfa_offset 16
 4520 0064 00AF     		add	r7, sp, #0
 4521              		.cfi_offset 7, -4
 4522              	.LCFI7:
 4523              		.cfi_def_cfa_register 7
 4524 0066 7860     		str	r0, [r7, #4]
 4525 0068 3960     		str	r1, [r7, #0]
 4526              	.L7:
 166:../autoPilot/src/main.c **** 	/* This function will get called if a task overflows its stack. */
 167:../autoPilot/src/main.c **** 
 168:../autoPilot/src/main.c **** 	( void ) pxTask;
 169:../autoPilot/src/main.c **** 	( void ) pcTaskName;
 170:../autoPilot/src/main.c **** 
 171:../autoPilot/src/main.c **** 	for( ;; );
 4527              		.loc 1 171 0 discriminator 1
 4528 006a FEE7     		b	.L7
 4529              		.cfi_endproc
 4530              	.LFE57:
 4532              		.align	2
 4533              		.global	vConfigureTimerForRunTimeStats
 4534              		.thumb
 4535              		.thumb_func
 4537              	vConfigureTimerForRunTimeStats:
 4538              	.LFB58:
 172:../autoPilot/src/main.c **** }
 173:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
 174:../autoPilot/src/main.c **** 
 175:../autoPilot/src/main.c **** void vConfigureTimerForRunTimeStats( void )
 176:../autoPilot/src/main.c **** {
 4539              		.loc 1 176 0
 4540              		.cfi_startproc
 4541              		@ args = 0, pretend = 0, frame = 16
 4542              		@ frame_needed = 1, uses_anonymous_args = 0
 4543              		@ link register save eliminated.
 4544 006c 80B4     		push	{r7}
 4545              	.LCFI8:
 4546              		.cfi_def_cfa_offset 4
 4547 006e 85B0     		sub	sp, sp, #20
 4548              	.LCFI9:
 4549              		.cfi_def_cfa_offset 24
 4550 0070 00AF     		add	r7, sp, #0
 4551              		.cfi_offset 7, -4
 4552              	.LCFI10:
 4553              		.cfi_def_cfa_register 7
 177:../autoPilot/src/main.c **** const unsigned long TCR_COUNT_RESET = 2, CTCR_CTM_TIMER = 0x00, TCR_COUNT_ENABLE = 0x01;
 4554              		.loc 1 177 0
 4555 0072 4FF00203 		mov	r3, #2
 4556 0076 FB60     		str	r3, [r7, #12]
 4557 0078 4FF00003 		mov	r3, #0
 4558 007c BB60     		str	r3, [r7, #8]
 4559 007e 4FF00103 		mov	r3, #1
 4560 0082 7B60     		str	r3, [r7, #4]
 178:../autoPilot/src/main.c **** 
 179:../autoPilot/src/main.c **** 	/* This function configures a timer that is used as the time base when
 180:../autoPilot/src/main.c **** 	collecting run time statistical information - basically the percentage
 181:../autoPilot/src/main.c **** 	of CPU time that each task is utilising.  It is called automatically when
 182:../autoPilot/src/main.c **** 	the scheduler is started (assuming configGENERATE_RUN_TIME_STATS is set
 183:../autoPilot/src/main.c **** 	to 1). */
 184:../autoPilot/src/main.c **** 
 185:../autoPilot/src/main.c **** 	/* Power up and feed the timer. */
 186:../autoPilot/src/main.c **** 	LPC_SC->PCONP |= 0x02UL;
 4561              		.loc 1 186 0
 4562 0084 134B     		ldr	r3, .L9
 4563 0086 134A     		ldr	r2, .L9
 4564 0088 D2F8C420 		ldr	r2, [r2, #196]
 4565 008c 42F00202 		orr	r2, r2, #2
 4566 0090 C3F8C420 		str	r2, [r3, #196]
 187:../autoPilot/src/main.c **** 	LPC_SC->PCLKSEL0 = (LPC_SC->PCLKSEL0 & (~(0x3<<2))) | (0x01 << 2);
 4567              		.loc 1 187 0
 4568 0094 0F4B     		ldr	r3, .L9
 4569 0096 0F4A     		ldr	r2, .L9
 4570 0098 D2F8A821 		ldr	r2, [r2, #424]
 4571 009c 22F00C02 		bic	r2, r2, #12
 4572 00a0 42F00402 		orr	r2, r2, #4
 4573 00a4 C3F8A821 		str	r2, [r3, #424]
 188:../autoPilot/src/main.c **** 
 189:../autoPilot/src/main.c **** 	/* Reset Timer 0 */
 190:../autoPilot/src/main.c **** 	LPC_TIM0->TCR = TCR_COUNT_RESET;
 4574              		.loc 1 190 0
 4575 00a8 4FF04023 		mov	r3, #1073758208
 4576 00ac FA68     		ldr	r2, [r7, #12]
 4577 00ae 5A60     		str	r2, [r3, #4]
 191:../autoPilot/src/main.c **** 
 192:../autoPilot/src/main.c **** 	/* Just count up. */
 193:../autoPilot/src/main.c **** 	LPC_TIM0->CTCR = CTCR_CTM_TIMER;
 4578              		.loc 1 193 0
 4579 00b0 4FF04023 		mov	r3, #1073758208
 4580 00b4 BA68     		ldr	r2, [r7, #8]
 4581 00b6 1A67     		str	r2, [r3, #112]
 194:../autoPilot/src/main.c **** 
 195:../autoPilot/src/main.c **** 	/* Prescale to a frequency that is good enough to get a decent resolution,
 196:../autoPilot/src/main.c **** 	but not too fast so as to overflow all the time. */
 197:../autoPilot/src/main.c **** 	LPC_TIM0->PR =  ( configCPU_CLOCK_HZ / 10000UL ) - 1UL;
 4582              		.loc 1 197 0
 4583 00b8 4FF04023 		mov	r3, #1073758208
 4584 00bc 42F2AB62 		movw	r2, #9899
 4585 00c0 DA60     		str	r2, [r3, #12]
 198:../autoPilot/src/main.c **** 
 199:../autoPilot/src/main.c **** 	/* Start the counter. */
 200:../autoPilot/src/main.c **** 	LPC_TIM0->TCR = TCR_COUNT_ENABLE;
 4586              		.loc 1 200 0
 4587 00c2 4FF04023 		mov	r3, #1073758208
 4588 00c6 7A68     		ldr	r2, [r7, #4]
 4589 00c8 5A60     		str	r2, [r3, #4]
 201:../autoPilot/src/main.c **** }
 4590              		.loc 1 201 0
 4591 00ca 07F11407 		add	r7, r7, #20
 4592 00ce BD46     		mov	sp, r7
 4593 00d0 80BC     		pop	{r7}
 4594 00d2 7047     		bx	lr
 4595              	.L10:
 4596              		.align	2
 4597              	.L9:
 4598 00d4 00C00F40 		.word	1074774016
 4599              		.cfi_endproc
 4600              	.LFE58:
 4602              		.bss
 4603              		.align	2
 4604              	ulTicksSinceLastDisplay.6231:
 4605 0000 00000000 		.space	4
 4606              		.text
 4607              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
                            *COM*:00000014 taskHandles
     /tmp/ccagZ117.s:4408   .rodata:00000000 $d
     /tmp/ccagZ117.s:4412   .text:00000000 $t
     /tmp/ccagZ117.s:4417   .text:00000000 main
     /tmp/ccagZ117.s:4470   .text:00000048 $d
     /tmp/ccagZ117.s:4476   .text:00000054 $t
     /tmp/ccagZ117.s:4481   .text:00000054 vApplicationTickHook
     /tmp/ccagZ117.s:4507   .text:00000060 vApplicationStackOverflowHook
     /tmp/ccagZ117.s:4537   .text:0000006c vConfigureTimerForRunTimeStats
     /tmp/ccagZ117.s:4598   .text:000000d4 $d
     /tmp/ccagZ117.s:4603   .bss:00000000 $d
     /tmp/ccagZ117.s:4604   .bss:00000000 ulTicksSinceLastDisplay.6231
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
setSystem
xTaskGenericCreate
vTaskStartScheduler
vLedTask
