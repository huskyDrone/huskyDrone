   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"main.c"
  23              	.Ltext0:
  24              		.file 1 "../autoPilot/src/main.c"
 4383              		.align	2
 4384              	.LC0:
 4385 0000 4C454400 		.ascii	"LED\000"
 4386              		.text
 4387              		.align	2
 4388              		.global	main
 4389              		.thumb
 4390              		.thumb_func
 4392              	main:
 4393              	.LFB29:
   1:../autoPilot/src/main.c **** /*
   2:../autoPilot/src/main.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../autoPilot/src/main.c **** 	
   4:../autoPilot/src/main.c **** 
   5:../autoPilot/src/main.c ****     ***************************************************************************
   6:../autoPilot/src/main.c ****      *                                                                       *
   7:../autoPilot/src/main.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../autoPilot/src/main.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../autoPilot/src/main.c ****      *    available.                                                         *
  10:../autoPilot/src/main.c ****      *                                                                       *
  11:../autoPilot/src/main.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../autoPilot/src/main.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../autoPilot/src/main.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../autoPilot/src/main.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../autoPilot/src/main.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../autoPilot/src/main.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../autoPilot/src/main.c ****      *                                                                       *
  18:../autoPilot/src/main.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../autoPilot/src/main.c ****      *                                                                       *
  20:../autoPilot/src/main.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../autoPilot/src/main.c ****      *                                                                       *
  22:../autoPilot/src/main.c ****     ***************************************************************************
  23:../autoPilot/src/main.c **** 
  24:../autoPilot/src/main.c **** 
  25:../autoPilot/src/main.c ****     This file is part of the FreeRTOS distribution.
  26:../autoPilot/src/main.c **** 
  27:../autoPilot/src/main.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../autoPilot/src/main.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../autoPilot/src/main.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../autoPilot/src/main.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../autoPilot/src/main.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../autoPilot/src/main.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../autoPilot/src/main.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../autoPilot/src/main.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../autoPilot/src/main.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../autoPilot/src/main.c ****     more details. You should have received a copy of the GNU General Public
  37:../autoPilot/src/main.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../autoPilot/src/main.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../autoPilot/src/main.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../autoPilot/src/main.c ****     FreeRTOS WEB site.
  41:../autoPilot/src/main.c **** 
  42:../autoPilot/src/main.c ****     1 tab == 4 spaces!
  43:../autoPilot/src/main.c **** 
  44:../autoPilot/src/main.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../autoPilot/src/main.c ****     contact details.
  46:../autoPilot/src/main.c **** 
  47:../autoPilot/src/main.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../autoPilot/src/main.c ****     critical systems.
  49:../autoPilot/src/main.c **** 
  50:../autoPilot/src/main.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../autoPilot/src/main.c ****     licensing and training services.
  52:../autoPilot/src/main.c **** */
  53:../autoPilot/src/main.c **** 
  54:../autoPilot/src/main.c **** 
  55:../autoPilot/src/main.c **** //#error The batch file Demo\CORTEX_LPC1768_GCC_RedSuite\CreateProjectDirectoryStructure.bat must b
  56:../autoPilot/src/main.c **** 
  57:../autoPilot/src/main.c **** 
  58:../autoPilot/src/main.c **** 
  59:../autoPilot/src/main.c **** /*
  60:../autoPilot/src/main.c ****  * Creates all the demo application tasks, then starts the scheduler.  The WEB
  61:../autoPilot/src/main.c ****  * documentation provides more details of the standard demo application tasks
  62:../autoPilot/src/main.c ****  * (which just exist to test the kernel port and provide an example of how to use
  63:../autoPilot/src/main.c ****  * each FreeRTOS API function).
  64:../autoPilot/src/main.c ****  *
  65:../autoPilot/src/main.c ****  * In addition to the standard demo tasks, the following tasks and tests are
  66:../autoPilot/src/main.c ****  * defined and/or created within this file:
  67:../autoPilot/src/main.c ****  *
  68:../autoPilot/src/main.c ****  * "Check" hook -  This only executes fully every five seconds from the tick
  69:../autoPilot/src/main.c ****  * hook.  Its main function is to check that all the standard demo tasks are
  70:../autoPilot/src/main.c ****  * still operational.  The status can be viewed using on the Task Stats page
  71:../autoPilot/src/main.c ****  * served by the WEB server.
  72:../autoPilot/src/main.c ****  *
  73:../autoPilot/src/main.c ****  * "uIP" task -  This is the task that handles the uIP stack.  All TCP/IP
  74:../autoPilot/src/main.c ****  * processing is performed in this task.
  75:../autoPilot/src/main.c ****  * 
  76:../autoPilot/src/main.c ****  * "USB" task - Enumerates the USB device as a CDC class, then echoes back all
  77:../autoPilot/src/main.c ****  * received characters with a configurable offset (for example, if the offset
  78:../autoPilot/src/main.c ****  * is 1 and 'A' is received then 'B' will be sent back).  A dumb terminal such
  79:../autoPilot/src/main.c ****  * as Hyperterminal can be used to talk to the USB task.
  80:../autoPilot/src/main.c ****  */
  81:../autoPilot/src/main.c **** 
  82:../autoPilot/src/main.c **** /* Standard includes. */
  83:../autoPilot/src/main.c **** #include "stdio.h"
  84:../autoPilot/src/main.c **** 
  85:../autoPilot/src/main.c **** /* Scheduler includes. */
  86:../autoPilot/src/main.c **** #include "FreeRTOSConfig.h"
  87:../autoPilot/src/main.c **** #include "FreeRTOS.h"
  88:../autoPilot/src/main.c **** #include "task.h"
  89:../autoPilot/src/main.c **** #include "queue.h"
  90:../autoPilot/src/main.c **** #include "semphr.h"
  91:../autoPilot/src/main.c **** 
  92:../autoPilot/src/main.c **** #include "hwConfig.h"
  93:../autoPilot/src/main.c **** #include "taskLed.h"
  94:../autoPilot/src/main.c **** 
  95:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
  96:../autoPilot/src/main.c **** 
  97:../autoPilot/src/main.c **** /* The time between cycles of the 'check' functionality (defined within the
  98:../autoPilot/src/main.c **** tick hook. */
  99:../autoPilot/src/main.c **** #define mainCHECK_DELAY						( ( portTickType ) 5000 / portTICK_RATE_MS )
 100:../autoPilot/src/main.c **** 
 101:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
 102:../autoPilot/src/main.c **** 
 103:../autoPilot/src/main.c **** // contains the handles for all tasks
 104:../autoPilot/src/main.c **** // define one more taskHandle than you need, zero the last entry
 105:../autoPilot/src/main.c **** xTaskHandle taskHandles[5];  //TODO: need to know how many there will be
 106:../autoPilot/src/main.c **** 
 107:../autoPilot/src/main.c **** int main( void )
 108:../autoPilot/src/main.c **** {
 4394              		.loc 1 108 0
 4395              		.cfi_startproc
 4396              		@ args = 0, pretend = 0, frame = 0
 4397              		@ frame_needed = 1, uses_anonymous_args = 0
 4398 0000 80B5     		push	{r7, lr}
 4399              	.LCFI0:
 4400              		.cfi_def_cfa_offset 8
 4401 0002 84B0     		sub	sp, sp, #16
 4402              	.LCFI1:
 4403              		.cfi_def_cfa_offset 24
 4404 0004 04AF     		add	r7, sp, #16
 4405              		.cfi_offset 14, -4
 4406              		.cfi_offset 7, -8
 4407              	.LCFI2:
 4408              		.cfi_def_cfa 7, 8
 109:../autoPilot/src/main.c **** 	// configure the system
 110:../autoPilot/src/main.c ****     setSystem();
 4409              		.loc 1 110 0
 4410 0006 FFF7FEFF 		bl	setSystem
 111:../autoPilot/src/main.c **** 
 112:../autoPilot/src/main.c ****     // create the LED task
 113:../autoPilot/src/main.c ****     if(xTaskCreate(vLedTask, (signed portCHAR*) "LED",128,NULL, 1, &taskHandles[0]) != pdPASS)
 4411              		.loc 1 113 0
 4412 000a 0F4B     		ldr	r3, .L3
 4413 000c 4FF00102 		mov	r2, #1
 4414 0010 0092     		str	r2, [sp, #0]
 4415 0012 0E4A     		ldr	r2, .L3+4
 4416 0014 0192     		str	r2, [sp, #4]
 4417 0016 4FF00002 		mov	r2, #0
 4418 001a 0292     		str	r2, [sp, #8]
 4419 001c 4FF00002 		mov	r2, #0
 4420 0020 0392     		str	r2, [sp, #12]
 4421 0022 0B48     		ldr	r0, .L3+8
 4422 0024 1946     		mov	r1, r3
 4423 0026 4FF08002 		mov	r2, #128
 4424 002a 4FF00003 		mov	r3, #0
 4425 002e FFF7FEFF 		bl	xTaskGenericCreate
 114:../autoPilot/src/main.c ****     {
 115:../autoPilot/src/main.c ****     	//TODO: the task was not created, do something
 116:../autoPilot/src/main.c ****     }
 117:../autoPilot/src/main.c **** 
 118:../autoPilot/src/main.c ****     taskHandles[4] = 0; //TODO: will need to change when we know how many tasks there will be
 4426              		.loc 1 118 0
 4427 0032 064B     		ldr	r3, .L3+4
 4428 0034 4FF00002 		mov	r2, #0
 4429 0038 1A61     		str	r2, [r3, #16]
 119:../autoPilot/src/main.c **** 
 120:../autoPilot/src/main.c ****     // enable the interrupts
 121:../autoPilot/src/main.c ****     portENABLE_INTERRUPTS();
 4430              		.loc 1 121 0
 4431              	@ 121 "../autoPilot/src/main.c" 1
 4432 003a 4FF00000 			mov r0, #0					
 4433 003e 80F31188 		msr basepri, r0				
 4434              	
 4435              	@ 0 "" 2
 122:../autoPilot/src/main.c **** 
 123:../autoPilot/src/main.c ****     // start the scheduler
 124:../autoPilot/src/main.c **** 	vTaskStartScheduler();
 4436              		.loc 1 124 0
 4437              		.thumb
 4438 0042 FFF7FEFF 		bl	vTaskStartScheduler
 4439              	.L2:
 125:../autoPilot/src/main.c **** 
 126:../autoPilot/src/main.c ****     // will only get here if there was insufficient memory to create the idle
 127:../autoPilot/src/main.c ****     // task.  The idle task is created within vTaskStartScheduler().
 128:../autoPilot/src/main.c **** 	for( ;; );
 4440              		.loc 1 128 0 discriminator 1
 4441 0046 FEE7     		b	.L2
 4442              	.L4:
 4443              		.align	2
 4444              	.L3:
 4445 0048 00000000 		.word	.LC0
 4446 004c 00000000 		.word	taskHandles
 4447 0050 00000000 		.word	vLedTask
 4448              		.cfi_endproc
 4449              	.LFE29:
 4451              		.align	2
 4452              		.global	vApplicationTickHook
 4453              		.thumb
 4454              		.thumb_func
 4456              	vApplicationTickHook:
 4457              	.LFB30:
 129:../autoPilot/src/main.c **** 
 130:../autoPilot/src/main.c **** 	return 0; // never gets here
 131:../autoPilot/src/main.c **** }
 132:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
 133:../autoPilot/src/main.c **** 
 134:../autoPilot/src/main.c **** void vApplicationTickHook( void )
 135:../autoPilot/src/main.c **** {
 4458              		.loc 1 135 0
 4459              		.cfi_startproc
 4460              		@ args = 0, pretend = 0, frame = 0
 4461              		@ frame_needed = 1, uses_anonymous_args = 0
 4462              		@ link register save eliminated.
 4463 0054 80B4     		push	{r7}
 4464              	.LCFI3:
 4465              		.cfi_def_cfa_offset 4
 4466 0056 00AF     		add	r7, sp, #0
 4467              		.cfi_offset 7, -4
 4468              	.LCFI4:
 4469              		.cfi_def_cfa_register 7
 136:../autoPilot/src/main.c **** static unsigned long ulTicksSinceLastDisplay = 0;
 137:../autoPilot/src/main.c **** 
 138:../autoPilot/src/main.c **** 	// Called from every tick interrupt as described in the comments at the top
 139:../autoPilot/src/main.c **** 	//of this file.
 140:../autoPilot/src/main.c **** 
 141:../autoPilot/src/main.c **** 	//Have enough ticks passed to make it	time to perform our health status
 142:../autoPilot/src/main.c **** 	//check again?
 143:../autoPilot/src/main.c **** /*
 144:../autoPilot/src/main.c **** 	ulTicksSinceLastDisplay++;
 145:../autoPilot/src/main.c **** 	if( ulTicksSinceLastDisplay >= mainCHECK_DELAY )
 146:../autoPilot/src/main.c **** 	{
 147:../autoPilot/src/main.c **** 		// Reset the counter so these checks run again in mainCHECK_DELA  ticks time.
 148:../autoPilot/src/main.c **** 		ulTicksSinceLastDisplay = 0;
 149:../autoPilot/src/main.c **** 
 150:../autoPilot/src/main.c **** 		// Has an error been found in any task?
 151:../autoPilot/src/main.c **** 		if( xAreGenericQueueTasksStillRunning() != pdTRUE )
 152:../autoPilot/src/main.c **** 		{
 153:../autoPilot/src/main.c **** 			pcStatusMessage = "An error has been detected in the Generic Queue test/demo.";
 154:../autoPilot/src/main.c **** 		}
 155:../autoPilot/src/main.c **** 		else if( xAreQueuePeekTasksStillRunning() != pdTRUE )
 156:../autoPilot/src/main.c **** 		{
 157:../autoPilot/src/main.c **** 			pcStatusMessage = "An error has been detected in the Peek Queue test/demo.";
 158:../autoPilot/src/main.c **** 		}
 159:../autoPilot/src/main.c **** 		else if( xAreBlockingQueuesStillRunning() != pdTRUE )
 160:../autoPilot/src/main.c **** 		{
 161:../autoPilot/src/main.c **** 			pcStatusMessage = "An error has been detected in the Block Queue test/demo.";
 162:../autoPilot/src/main.c **** 		}
 163:../autoPilot/src/main.c **** 		else if( xAreBlockTimeTestTasksStillRunning() != pdTRUE )
 164:../autoPilot/src/main.c **** 		{
 165:../autoPilot/src/main.c **** 			pcStatusMessage = "An error has been detected in the Block Time test/demo.";
 166:../autoPilot/src/main.c **** 		}
 167:../autoPilot/src/main.c **** 	    else if( xAreSemaphoreTasksStillRunning() != pdTRUE )
 168:../autoPilot/src/main.c **** 	    {
 169:../autoPilot/src/main.c **** 	        pcStatusMessage = "An error has been detected in the Semaphore test/demo.";
 170:../autoPilot/src/main.c **** 	    }
 171:../autoPilot/src/main.c **** 	    else if( xArePollingQueuesStillRunning() != pdTRUE )
 172:../autoPilot/src/main.c **** 	    {
 173:../autoPilot/src/main.c **** 	        pcStatusMessage = "An error has been detected in the Poll Queue test/demo.";
 174:../autoPilot/src/main.c **** 	    }
 175:../autoPilot/src/main.c **** 	    else if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
 176:../autoPilot/src/main.c **** 	    {
 177:../autoPilot/src/main.c **** 	        pcStatusMessage = "An error has been detected in the Int Math test/demo.";
 178:../autoPilot/src/main.c **** 	    }
 179:../autoPilot/src/main.c **** 	    else if( xAreRecursiveMutexTasksStillRunning() != pdTRUE )
 180:../autoPilot/src/main.c **** 	    {
 181:../autoPilot/src/main.c **** 	    	pcStatusMessage = "An error has been detected in the Mutex test/demo.";
 182:../autoPilot/src/main.c **** 	    }
 183:../autoPilot/src/main.c **** 	}
 184:../autoPilot/src/main.c **** 	*/
 185:../autoPilot/src/main.c **** }
 4470              		.loc 1 185 0
 4471 0058 BD46     		mov	sp, r7
 4472 005a 80BC     		pop	{r7}
 4473 005c 7047     		bx	lr
 4474              		.cfi_endproc
 4475              	.LFE30:
 4477 005e 00BF     		.align	2
 4478              		.global	vApplicationStackOverflowHook
 4479              		.thumb
 4480              		.thumb_func
 4482              	vApplicationStackOverflowHook:
 4483              	.LFB31:
 186:../autoPilot/src/main.c **** 
 187:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
 188:../autoPilot/src/main.c **** 
 189:../autoPilot/src/main.c **** void vApplicationStackOverflowHook( xTaskHandle pxTask, signed char *pcTaskName )
 190:../autoPilot/src/main.c **** {
 4484              		.loc 1 190 0
 4485              		.cfi_startproc
 4486              		@ args = 0, pretend = 0, frame = 8
 4487              		@ frame_needed = 1, uses_anonymous_args = 0
 4488              		@ link register save eliminated.
 4489 0060 80B4     		push	{r7}
 4490              	.LCFI5:
 4491              		.cfi_def_cfa_offset 4
 4492 0062 83B0     		sub	sp, sp, #12
 4493              	.LCFI6:
 4494              		.cfi_def_cfa_offset 16
 4495 0064 00AF     		add	r7, sp, #0
 4496              		.cfi_offset 7, -4
 4497              	.LCFI7:
 4498              		.cfi_def_cfa_register 7
 4499 0066 7860     		str	r0, [r7, #4]
 4500 0068 3960     		str	r1, [r7, #0]
 4501              	.L7:
 191:../autoPilot/src/main.c **** 	/* This function will get called if a task overflows its stack. */
 192:../autoPilot/src/main.c **** 
 193:../autoPilot/src/main.c **** 	( void ) pxTask;
 194:../autoPilot/src/main.c **** 	( void ) pcTaskName;
 195:../autoPilot/src/main.c **** 
 196:../autoPilot/src/main.c **** 	for( ;; );
 4502              		.loc 1 196 0 discriminator 1
 4503 006a FEE7     		b	.L7
 4504              		.cfi_endproc
 4505              	.LFE31:
 4507              		.align	2
 4508              		.global	vConfigureTimerForRunTimeStats
 4509              		.thumb
 4510              		.thumb_func
 4512              	vConfigureTimerForRunTimeStats:
 4513              	.LFB32:
 197:../autoPilot/src/main.c **** }
 198:../autoPilot/src/main.c **** /*-----------------------------------------------------------*/
 199:../autoPilot/src/main.c **** 
 200:../autoPilot/src/main.c **** void vConfigureTimerForRunTimeStats( void )
 201:../autoPilot/src/main.c **** {
 4514              		.loc 1 201 0
 4515              		.cfi_startproc
 4516              		@ args = 0, pretend = 0, frame = 16
 4517              		@ frame_needed = 1, uses_anonymous_args = 0
 4518              		@ link register save eliminated.
 4519 006c 80B4     		push	{r7}
 4520              	.LCFI8:
 4521              		.cfi_def_cfa_offset 4
 4522 006e 85B0     		sub	sp, sp, #20
 4523              	.LCFI9:
 4524              		.cfi_def_cfa_offset 24
 4525 0070 00AF     		add	r7, sp, #0
 4526              		.cfi_offset 7, -4
 4527              	.LCFI10:
 4528              		.cfi_def_cfa_register 7
 202:../autoPilot/src/main.c **** const unsigned long TCR_COUNT_RESET = 2, CTCR_CTM_TIMER = 0x00, TCR_COUNT_ENABLE = 0x01;
 4529              		.loc 1 202 0
 4530 0072 4FF00203 		mov	r3, #2
 4531 0076 FB60     		str	r3, [r7, #12]
 4532 0078 4FF00003 		mov	r3, #0
 4533 007c BB60     		str	r3, [r7, #8]
 4534 007e 4FF00103 		mov	r3, #1
 4535 0082 7B60     		str	r3, [r7, #4]
 203:../autoPilot/src/main.c **** 
 204:../autoPilot/src/main.c **** 	/* This function configures a timer that is used as the time base when
 205:../autoPilot/src/main.c **** 	collecting run time statistical information - basically the percentage
 206:../autoPilot/src/main.c **** 	of CPU time that each task is utilising.  It is called automatically when
 207:../autoPilot/src/main.c **** 	the scheduler is started (assuming configGENERATE_RUN_TIME_STATS is set
 208:../autoPilot/src/main.c **** 	to 1). */
 209:../autoPilot/src/main.c **** 
 210:../autoPilot/src/main.c **** 	/* Power up and feed the timer. */
 211:../autoPilot/src/main.c **** 	LPC_SC->PCONP |= 0x02UL;
 4536              		.loc 1 211 0
 4537 0084 134B     		ldr	r3, .L9
 4538 0086 134A     		ldr	r2, .L9
 4539 0088 D2F8C420 		ldr	r2, [r2, #196]
 4540 008c 42F00202 		orr	r2, r2, #2
 4541 0090 C3F8C420 		str	r2, [r3, #196]
 212:../autoPilot/src/main.c **** 	LPC_SC->PCLKSEL0 = (LPC_SC->PCLKSEL0 & (~(0x3<<2))) | (0x01 << 2);
 4542              		.loc 1 212 0
 4543 0094 0F4B     		ldr	r3, .L9
 4544 0096 0F4A     		ldr	r2, .L9
 4545 0098 D2F8A821 		ldr	r2, [r2, #424]
 4546 009c 22F00C02 		bic	r2, r2, #12
 4547 00a0 42F00402 		orr	r2, r2, #4
 4548 00a4 C3F8A821 		str	r2, [r3, #424]
 213:../autoPilot/src/main.c **** 
 214:../autoPilot/src/main.c **** 	/* Reset Timer 0 */
 215:../autoPilot/src/main.c **** 	LPC_TIM0->TCR = TCR_COUNT_RESET;
 4549              		.loc 1 215 0
 4550 00a8 4FF04023 		mov	r3, #1073758208
 4551 00ac FA68     		ldr	r2, [r7, #12]
 4552 00ae 5A60     		str	r2, [r3, #4]
 216:../autoPilot/src/main.c **** 
 217:../autoPilot/src/main.c **** 	/* Just count up. */
 218:../autoPilot/src/main.c **** 	LPC_TIM0->CTCR = CTCR_CTM_TIMER;
 4553              		.loc 1 218 0
 4554 00b0 4FF04023 		mov	r3, #1073758208
 4555 00b4 BA68     		ldr	r2, [r7, #8]
 4556 00b6 1A67     		str	r2, [r3, #112]
 219:../autoPilot/src/main.c **** 
 220:../autoPilot/src/main.c **** 	/* Prescale to a frequency that is good enough to get a decent resolution,
 221:../autoPilot/src/main.c **** 	but not too fast so as to overflow all the time. */
 222:../autoPilot/src/main.c **** 	LPC_TIM0->PR =  ( configCPU_CLOCK_HZ / 10000UL ) - 1UL;
 4557              		.loc 1 222 0
 4558 00b8 4FF04023 		mov	r3, #1073758208
 4559 00bc 42F2AB62 		movw	r2, #9899
 4560 00c0 DA60     		str	r2, [r3, #12]
 223:../autoPilot/src/main.c **** 
 224:../autoPilot/src/main.c **** 	/* Start the counter. */
 225:../autoPilot/src/main.c **** 	LPC_TIM0->TCR = TCR_COUNT_ENABLE;
 4561              		.loc 1 225 0
 4562 00c2 4FF04023 		mov	r3, #1073758208
 4563 00c6 7A68     		ldr	r2, [r7, #4]
 4564 00c8 5A60     		str	r2, [r3, #4]
 226:../autoPilot/src/main.c **** }
 4565              		.loc 1 226 0
 4566 00ca 07F11407 		add	r7, r7, #20
 4567 00ce BD46     		mov	sp, r7
 4568 00d0 80BC     		pop	{r7}
 4569 00d2 7047     		bx	lr
 4570              	.L10:
 4571              		.align	2
 4572              	.L9:
 4573 00d4 00C00F40 		.word	1074774016
 4574              		.cfi_endproc
 4575              	.LFE32:
 4577              		.bss
 4578              		.align	2
 4579              	ulTicksSinceLastDisplay.6120:
 4580 0000 00000000 		.space	4
 4581              		.text
 4582              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
                            *COM*:00000014 taskHandles
     /tmp/ccYGxz64.s:4383   .rodata:00000000 $d
     /tmp/ccYGxz64.s:4387   .text:00000000 $t
     /tmp/ccYGxz64.s:4392   .text:00000000 main
     /tmp/ccYGxz64.s:4445   .text:00000048 $d
     /tmp/ccYGxz64.s:4451   .text:00000054 $t
     /tmp/ccYGxz64.s:4456   .text:00000054 vApplicationTickHook
     /tmp/ccYGxz64.s:4482   .text:00000060 vApplicationStackOverflowHook
     /tmp/ccYGxz64.s:4512   .text:0000006c vConfigureTimerForRunTimeStats
     /tmp/ccYGxz64.s:4573   .text:000000d4 $d
     /tmp/ccYGxz64.s:4578   .bss:00000000 $d
     /tmp/ccYGxz64.s:4579   .bss:00000000 ulTicksSinceLastDisplay.6120
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
setSystem
xTaskGenericCreate
vTaskStartScheduler
vLedTask
