   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"queue.c"
  23              	.Ltext0:
  24              		.file 1 "../3rdParty/FreeRTOS/queue.c"
 4052              		.align	2
 4053              		.global	xQueueGenericCreate
 4054              		.thumb
 4055              		.thumb_func
 4057              	xQueueGenericCreate:
 4058              	.LFB55:
   1:../3rdParty/FreeRTOS/queue.c **** /*
   2:../3rdParty/FreeRTOS/queue.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../3rdParty/FreeRTOS/queue.c **** 
   4:../3rdParty/FreeRTOS/queue.c **** 
   5:../3rdParty/FreeRTOS/queue.c ****     ***************************************************************************
   6:../3rdParty/FreeRTOS/queue.c ****      *                                                                       *
   7:../3rdParty/FreeRTOS/queue.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../3rdParty/FreeRTOS/queue.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../3rdParty/FreeRTOS/queue.c ****      *    available.                                                         *
  10:../3rdParty/FreeRTOS/queue.c ****      *                                                                       *
  11:../3rdParty/FreeRTOS/queue.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../3rdParty/FreeRTOS/queue.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../3rdParty/FreeRTOS/queue.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../3rdParty/FreeRTOS/queue.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../3rdParty/FreeRTOS/queue.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../3rdParty/FreeRTOS/queue.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../3rdParty/FreeRTOS/queue.c ****      *                                                                       *
  18:../3rdParty/FreeRTOS/queue.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../3rdParty/FreeRTOS/queue.c ****      *                                                                       *
  20:../3rdParty/FreeRTOS/queue.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../3rdParty/FreeRTOS/queue.c ****      *                                                                       *
  22:../3rdParty/FreeRTOS/queue.c ****     ***************************************************************************
  23:../3rdParty/FreeRTOS/queue.c **** 
  24:../3rdParty/FreeRTOS/queue.c **** 
  25:../3rdParty/FreeRTOS/queue.c ****     This file is part of the FreeRTOS distribution.
  26:../3rdParty/FreeRTOS/queue.c **** 
  27:../3rdParty/FreeRTOS/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../3rdParty/FreeRTOS/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../3rdParty/FreeRTOS/queue.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../3rdParty/FreeRTOS/queue.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../3rdParty/FreeRTOS/queue.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../3rdParty/FreeRTOS/queue.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../3rdParty/FreeRTOS/queue.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../3rdParty/FreeRTOS/queue.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../3rdParty/FreeRTOS/queue.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../3rdParty/FreeRTOS/queue.c ****     more details. You should have received a copy of the GNU General Public
  37:../3rdParty/FreeRTOS/queue.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../3rdParty/FreeRTOS/queue.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../3rdParty/FreeRTOS/queue.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../3rdParty/FreeRTOS/queue.c ****     FreeRTOS WEB site.
  41:../3rdParty/FreeRTOS/queue.c **** 
  42:../3rdParty/FreeRTOS/queue.c ****     1 tab == 4 spaces!
  43:../3rdParty/FreeRTOS/queue.c **** 
  44:../3rdParty/FreeRTOS/queue.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../3rdParty/FreeRTOS/queue.c ****     contact details.
  46:../3rdParty/FreeRTOS/queue.c **** 
  47:../3rdParty/FreeRTOS/queue.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../3rdParty/FreeRTOS/queue.c ****     critical systems.
  49:../3rdParty/FreeRTOS/queue.c **** 
  50:../3rdParty/FreeRTOS/queue.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../3rdParty/FreeRTOS/queue.c ****     licensing and training services.
  52:../3rdParty/FreeRTOS/queue.c **** */
  53:../3rdParty/FreeRTOS/queue.c **** 
  54:../3rdParty/FreeRTOS/queue.c **** #include <stdlib.h>
  55:../3rdParty/FreeRTOS/queue.c **** #include <string.h>
  56:../3rdParty/FreeRTOS/queue.c **** 
  57:../3rdParty/FreeRTOS/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  58:../3rdParty/FreeRTOS/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  59:../3rdParty/FreeRTOS/queue.c **** task.h is included from an application file. */
  60:../3rdParty/FreeRTOS/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  61:../3rdParty/FreeRTOS/queue.c **** 
  62:../3rdParty/FreeRTOS/queue.c **** #include "FreeRTOS.h"
  63:../3rdParty/FreeRTOS/queue.c **** #include "task.h"
  64:../3rdParty/FreeRTOS/queue.c **** 
  65:../3rdParty/FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  66:../3rdParty/FreeRTOS/queue.c **** 	#include "croutine.h"
  67:../3rdParty/FreeRTOS/queue.c **** #endif
  68:../3rdParty/FreeRTOS/queue.c **** 
  69:../3rdParty/FreeRTOS/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../3rdParty/FreeRTOS/queue.c **** 
  71:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------
  72:../3rdParty/FreeRTOS/queue.c ****  * PUBLIC LIST API documented in list.h
  73:../3rdParty/FreeRTOS/queue.c ****  *----------------------------------------------------------*/
  74:../3rdParty/FreeRTOS/queue.c **** 
  75:../3rdParty/FreeRTOS/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  76:../3rdParty/FreeRTOS/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  77:../3rdParty/FreeRTOS/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  78:../3rdParty/FreeRTOS/queue.c **** 
  79:../3rdParty/FreeRTOS/queue.c **** #define queueERRONEOUS_UNBLOCK			( -1 )
  80:../3rdParty/FreeRTOS/queue.c **** 
  81:../3rdParty/FreeRTOS/queue.c **** /* For internal use only. */
  82:../3rdParty/FreeRTOS/queue.c **** #define	queueSEND_TO_BACK				( 0 )
  83:../3rdParty/FreeRTOS/queue.c **** #define	queueSEND_TO_FRONT				( 1 )
  84:../3rdParty/FreeRTOS/queue.c **** 
  85:../3rdParty/FreeRTOS/queue.c **** /* Effectively make a union out of the xQUEUE structure. */
  86:../3rdParty/FreeRTOS/queue.c **** #define pxMutexHolder					pcTail
  87:../3rdParty/FreeRTOS/queue.c **** #define uxQueueType						pcHead
  88:../3rdParty/FreeRTOS/queue.c **** #define uxRecursiveCallCount			pcReadFrom
  89:../3rdParty/FreeRTOS/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  90:../3rdParty/FreeRTOS/queue.c **** 
  91:../3rdParty/FreeRTOS/queue.c **** /* Semaphores do not actually store or copy data, so have an items size of
  92:../3rdParty/FreeRTOS/queue.c **** zero. */
  93:../3rdParty/FreeRTOS/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
  94:../3rdParty/FreeRTOS/queue.c **** #define queueDONT_BLOCK					 ( ( portTickType ) 0U )
  95:../3rdParty/FreeRTOS/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
  96:../3rdParty/FreeRTOS/queue.c **** 
  97:../3rdParty/FreeRTOS/queue.c **** /* These definitions *must* match those in queue.h. */
  98:../3rdParty/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_BASE				( 0U )
  99:../3rdParty/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_MUTEX 				( 1U )
 100:../3rdParty/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( 2U )
 101:../3rdParty/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_BINARY_SEMAPHORE	( 3U )
 102:../3rdParty/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_RECURSIVE_MUTEX		( 4U )
 103:../3rdParty/FreeRTOS/queue.c **** 
 104:../3rdParty/FreeRTOS/queue.c **** /*
 105:../3rdParty/FreeRTOS/queue.c ****  * Definition of the queue used by the scheduler.
 106:../3rdParty/FreeRTOS/queue.c ****  * Items are queued by copy, not reference.
 107:../3rdParty/FreeRTOS/queue.c ****  */
 108:../3rdParty/FreeRTOS/queue.c **** typedef struct QueueDefinition
 109:../3rdParty/FreeRTOS/queue.c **** {
 110:../3rdParty/FreeRTOS/queue.c **** 	signed char *pcHead;				/*< Points to the beginning of the queue storage area. */
 111:../3rdParty/FreeRTOS/queue.c **** 	signed char *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more by
 112:../3rdParty/FreeRTOS/queue.c **** 
 113:../3rdParty/FreeRTOS/queue.c **** 	signed char *pcWriteTo;				/*< Points to the free next place in the storage area. */
 114:../3rdParty/FreeRTOS/queue.c **** 	signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
 115:../3rdParty/FreeRTOS/queue.c **** 
 116:../3rdParty/FreeRTOS/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 117:../3rdParty/FreeRTOS/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 118:../3rdParty/FreeRTOS/queue.c **** 
 119:../3rdParty/FreeRTOS/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 120:../3rdParty/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 121:../3rdParty/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 122:../3rdParty/FreeRTOS/queue.c **** 
 123:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xRxLock;			/*< Stores the number of items received from the queue (removed fr
 124:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xTxLock;			/*< Stores the number of items transmitted to the queue (added to 
 125:../3rdParty/FreeRTOS/queue.c **** 	
 126:../3rdParty/FreeRTOS/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:../3rdParty/FreeRTOS/queue.c **** 		unsigned char ucQueueNumber;
 128:../3rdParty/FreeRTOS/queue.c **** 		unsigned char ucQueueType;
 129:../3rdParty/FreeRTOS/queue.c **** 	#endif
 130:../3rdParty/FreeRTOS/queue.c **** 
 131:../3rdParty/FreeRTOS/queue.c **** } xQUEUE;
 132:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 133:../3rdParty/FreeRTOS/queue.c **** 
 134:../3rdParty/FreeRTOS/queue.c **** /*
 135:../3rdParty/FreeRTOS/queue.c ****  * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
 136:../3rdParty/FreeRTOS/queue.c ****  * To keep the definition private the API header file defines it as a
 137:../3rdParty/FreeRTOS/queue.c ****  * pointer to void.
 138:../3rdParty/FreeRTOS/queue.c ****  */
 139:../3rdParty/FreeRTOS/queue.c **** typedef xQUEUE * xQueueHandle;
 140:../3rdParty/FreeRTOS/queue.c **** 
 141:../3rdParty/FreeRTOS/queue.c **** /*
 142:../3rdParty/FreeRTOS/queue.c ****  * Prototypes for public functions are included here so we don't have to
 143:../3rdParty/FreeRTOS/queue.c ****  * include the API header file (as it defines xQueueHandle differently).  These
 144:../3rdParty/FreeRTOS/queue.c ****  * functions are documented in the API header file.
 145:../3rdParty/FreeRTOS/queue.c ****  */
 146:../3rdParty/FreeRTOS/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 147:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 148:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 149:../3rdParty/FreeRTOS/queue.c **** void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 150:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 151:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 152:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 153:../3rdParty/FreeRTOS/queue.c **** xQueueHandle xQueueCreateMutex( unsigned char ucQueueType ) PRIVILEGED_FUNCTION;
 154:../3rdParty/FreeRTOS/queue.c **** xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_
 155:../3rdParty/FreeRTOS/queue.c **** portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_F
 156:../3rdParty/FreeRTOS/queue.c **** portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
 157:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, 
 158:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTick
 159:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 160:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 161:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCT
 162:../3rdParty/FreeRTOS/queue.c **** void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait ) PRIVILEGED_F
 163:../3rdParty/FreeRTOS/queue.c **** unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 164:../3rdParty/FreeRTOS/queue.c **** void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber ) PRIVILEGED_FUNCTION;
 165:../3rdParty/FreeRTOS/queue.c **** unsigned char ucQueueGetQueueType( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 166:../3rdParty/FreeRTOS/queue.c **** 
 167:../3rdParty/FreeRTOS/queue.c **** /*
 168:../3rdParty/FreeRTOS/queue.c ****  * Co-routine queue functions differ from task queue functions.  Co-routines are
 169:../3rdParty/FreeRTOS/queue.c ****  * an optional component.
 170:../3rdParty/FreeRTOS/queue.c ****  */
 171:../3rdParty/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
 172:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed 
 173:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE
 174:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType x
 175:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToW
 176:../3rdParty/FreeRTOS/queue.c **** #endif
 177:../3rdParty/FreeRTOS/queue.c **** 
 178:../3rdParty/FreeRTOS/queue.c **** /*
 179:../3rdParty/FreeRTOS/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 180:../3rdParty/FreeRTOS/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 181:../3rdParty/FreeRTOS/queue.c ****  */
 182:../3rdParty/FreeRTOS/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
 183:../3rdParty/FreeRTOS/queue.c **** 
 184:../3rdParty/FreeRTOS/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 185:../3rdParty/FreeRTOS/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 186:../3rdParty/FreeRTOS/queue.c **** 	more user friendly. */
 187:../3rdParty/FreeRTOS/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 188:../3rdParty/FreeRTOS/queue.c **** 	{
 189:../3rdParty/FreeRTOS/queue.c **** 		signed char *pcQueueName;
 190:../3rdParty/FreeRTOS/queue.c **** 		xQueueHandle xHandle;
 191:../3rdParty/FreeRTOS/queue.c **** 	} xQueueRegistryItem;
 192:../3rdParty/FreeRTOS/queue.c **** 
 193:../3rdParty/FreeRTOS/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 194:../3rdParty/FreeRTOS/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 195:../3rdParty/FreeRTOS/queue.c **** 	array position being vacant. */
 196:../3rdParty/FreeRTOS/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 197:../3rdParty/FreeRTOS/queue.c **** 
 198:../3rdParty/FreeRTOS/queue.c **** 	/* Removes a queue from the registry by simply setting the pcQueueName
 199:../3rdParty/FreeRTOS/queue.c **** 	member to NULL. */
 200:../3rdParty/FreeRTOS/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 201:../3rdParty/FreeRTOS/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
 202:../3rdParty/FreeRTOS/queue.c **** #endif
 203:../3rdParty/FreeRTOS/queue.c **** 
 204:../3rdParty/FreeRTOS/queue.c **** /*
 205:../3rdParty/FreeRTOS/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 206:../3rdParty/FreeRTOS/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 207:../3rdParty/FreeRTOS/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 208:../3rdParty/FreeRTOS/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 209:../3rdParty/FreeRTOS/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 210:../3rdParty/FreeRTOS/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 211:../3rdParty/FreeRTOS/queue.c ****  */
 212:../3rdParty/FreeRTOS/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 213:../3rdParty/FreeRTOS/queue.c **** 
 214:../3rdParty/FreeRTOS/queue.c **** /*
 215:../3rdParty/FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 216:../3rdParty/FreeRTOS/queue.c ****  *
 217:../3rdParty/FreeRTOS/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 218:../3rdParty/FreeRTOS/queue.c ****  */
 219:../3rdParty/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 220:../3rdParty/FreeRTOS/queue.c **** 
 221:../3rdParty/FreeRTOS/queue.c **** /*
 222:../3rdParty/FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 223:../3rdParty/FreeRTOS/queue.c ****  *
 224:../3rdParty/FreeRTOS/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 225:../3rdParty/FreeRTOS/queue.c ****  */
 226:../3rdParty/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 227:../3rdParty/FreeRTOS/queue.c **** 
 228:../3rdParty/FreeRTOS/queue.c **** /*
 229:../3rdParty/FreeRTOS/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 230:../3rdParty/FreeRTOS/queue.c ****  * back of the queue.
 231:../3rdParty/FreeRTOS/queue.c ****  */
 232:../3rdParty/FreeRTOS/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 233:../3rdParty/FreeRTOS/queue.c **** 
 234:../3rdParty/FreeRTOS/queue.c **** /*
 235:../3rdParty/FreeRTOS/queue.c ****  * Copies an item out of a queue.
 236:../3rdParty/FreeRTOS/queue.c ****  */
 237:../3rdParty/FreeRTOS/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTIO
 238:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 239:../3rdParty/FreeRTOS/queue.c **** 
 240:../3rdParty/FreeRTOS/queue.c **** /*
 241:../3rdParty/FreeRTOS/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 242:../3rdParty/FreeRTOS/queue.c ****  * accessing the queue event lists.
 243:../3rdParty/FreeRTOS/queue.c ****  */
 244:../3rdParty/FreeRTOS/queue.c **** #define prvLockQueue( pxQueue )								\
 245:../3rdParty/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();									\
 246:../3rdParty/FreeRTOS/queue.c **** 	{														\
 247:../3rdParty/FreeRTOS/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 248:../3rdParty/FreeRTOS/queue.c **** 		{													\
 249:../3rdParty/FreeRTOS/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 250:../3rdParty/FreeRTOS/queue.c **** 		}													\
 251:../3rdParty/FreeRTOS/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 252:../3rdParty/FreeRTOS/queue.c **** 		{													\
 253:../3rdParty/FreeRTOS/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 254:../3rdParty/FreeRTOS/queue.c **** 		}													\
 255:../3rdParty/FreeRTOS/queue.c **** 	}														\
 256:../3rdParty/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL()
 257:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 258:../3rdParty/FreeRTOS/queue.c **** 
 259:../3rdParty/FreeRTOS/queue.c **** 
 260:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------
 261:../3rdParty/FreeRTOS/queue.c ****  * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 262:../3rdParty/FreeRTOS/queue.c ****  *----------------------------------------------------------*/
 263:../3rdParty/FreeRTOS/queue.c **** 
 264:../3rdParty/FreeRTOS/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 265:../3rdParty/FreeRTOS/queue.c **** {
 4059              		.loc 1 265 0
 4060              		.cfi_startproc
 4061              		@ args = 0, pretend = 0, frame = 32
 4062              		@ frame_needed = 1, uses_anonymous_args = 0
 4063 0000 80B5     		push	{r7, lr}
 4064              	.LCFI0:
 4065              		.cfi_def_cfa_offset 8
 4066 0002 88B0     		sub	sp, sp, #32
 4067              	.LCFI1:
 4068              		.cfi_def_cfa_offset 40
 4069 0004 00AF     		add	r7, sp, #0
 4070              		.cfi_offset 14, -4
 4071              		.cfi_offset 7, -8
 4072              	.LCFI2:
 4073              		.cfi_def_cfa_register 7
 4074 0006 F860     		str	r0, [r7, #12]
 4075 0008 B960     		str	r1, [r7, #8]
 4076 000a 1346     		mov	r3, r2
 4077 000c FB71     		strb	r3, [r7, #7]
 266:../3rdParty/FreeRTOS/queue.c **** xQUEUE *pxNewQueue;
 267:../3rdParty/FreeRTOS/queue.c **** size_t xQueueSizeInBytes;
 268:../3rdParty/FreeRTOS/queue.c **** xQueueHandle xReturn = NULL;
 4078              		.loc 1 268 0
 4079 000e 4FF00003 		mov	r3, #0
 4080 0012 FB61     		str	r3, [r7, #28]
 269:../3rdParty/FreeRTOS/queue.c **** 
 270:../3rdParty/FreeRTOS/queue.c **** 	/* Remove compiler warnings about unused parameters should 
 271:../3rdParty/FreeRTOS/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 272:../3rdParty/FreeRTOS/queue.c **** 	( void ) ucQueueType;
 273:../3rdParty/FreeRTOS/queue.c **** 
 274:../3rdParty/FreeRTOS/queue.c **** 	/* Allocate the new queue structure. */
 275:../3rdParty/FreeRTOS/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 4081              		.loc 1 275 0
 4082 0014 FB68     		ldr	r3, [r7, #12]
 4083 0016 002B     		cmp	r3, #0
 4084 0018 5AD0     		beq	.L2
 276:../3rdParty/FreeRTOS/queue.c **** 	{
 277:../3rdParty/FreeRTOS/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 4085              		.loc 1 277 0
 4086 001a 4FF05000 		mov	r0, #80
 4087 001e FFF7FEFF 		bl	pvPortMalloc
 4088 0022 0346     		mov	r3, r0
 4089 0024 BB61     		str	r3, [r7, #24]
 278:../3rdParty/FreeRTOS/queue.c **** 		if( pxNewQueue != NULL )
 4090              		.loc 1 278 0
 4091 0026 BB69     		ldr	r3, [r7, #24]
 4092 0028 002B     		cmp	r3, #0
 4093 002a 51D0     		beq	.L2
 279:../3rdParty/FreeRTOS/queue.c **** 		{
 280:../3rdParty/FreeRTOS/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 281:../3rdParty/FreeRTOS/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 282:../3rdParty/FreeRTOS/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 4094              		.loc 1 282 0
 4095 002c FB68     		ldr	r3, [r7, #12]
 4096 002e BA68     		ldr	r2, [r7, #8]
 4097 0030 02FB03F3 		mul	r3, r2, r3
 4098 0034 03F10103 		add	r3, r3, #1
 4099 0038 7B61     		str	r3, [r7, #20]
 283:../3rdParty/FreeRTOS/queue.c **** 
 284:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 4100              		.loc 1 284 0
 4101 003a 7869     		ldr	r0, [r7, #20]
 4102 003c FFF7FEFF 		bl	pvPortMalloc
 4103 0040 0346     		mov	r3, r0
 4104 0042 1A46     		mov	r2, r3
 4105 0044 BB69     		ldr	r3, [r7, #24]
 4106 0046 1A60     		str	r2, [r3, #0]
 285:../3rdParty/FreeRTOS/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 4107              		.loc 1 285 0
 4108 0048 BB69     		ldr	r3, [r7, #24]
 4109 004a 1B68     		ldr	r3, [r3, #0]
 4110 004c 002B     		cmp	r3, #0
 4111 004e 3CD0     		beq	.L3
 286:../3rdParty/FreeRTOS/queue.c **** 			{
 287:../3rdParty/FreeRTOS/queue.c **** 				/* Initialise the queue members as described above where the
 288:../3rdParty/FreeRTOS/queue.c **** 				queue type is defined. */
 289:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 4112              		.loc 1 289 0
 4113 0050 BB69     		ldr	r3, [r7, #24]
 4114 0052 1A68     		ldr	r2, [r3, #0]
 4115 0054 FB68     		ldr	r3, [r7, #12]
 4116 0056 B968     		ldr	r1, [r7, #8]
 4117 0058 01FB03F3 		mul	r3, r1, r3
 4118 005c D218     		adds	r2, r2, r3
 4119 005e BB69     		ldr	r3, [r7, #24]
 4120 0060 5A60     		str	r2, [r3, #4]
 290:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 4121              		.loc 1 290 0
 4122 0062 BB69     		ldr	r3, [r7, #24]
 4123 0064 4FF00002 		mov	r2, #0
 4124 0068 9A63     		str	r2, [r3, #56]
 291:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 4125              		.loc 1 291 0
 4126 006a BB69     		ldr	r3, [r7, #24]
 4127 006c 1A68     		ldr	r2, [r3, #0]
 4128 006e BB69     		ldr	r3, [r7, #24]
 4129 0070 9A60     		str	r2, [r3, #8]
 292:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U
 4130              		.loc 1 292 0
 4131 0072 BB69     		ldr	r3, [r7, #24]
 4132 0074 1A68     		ldr	r2, [r3, #0]
 4133 0076 FB68     		ldr	r3, [r7, #12]
 4134 0078 03F1FF33 		add	r3, r3, #-1
 4135 007c B968     		ldr	r1, [r7, #8]
 4136 007e 01FB03F3 		mul	r3, r1, r3
 4137 0082 D218     		adds	r2, r2, r3
 4138 0084 BB69     		ldr	r3, [r7, #24]
 4139 0086 DA60     		str	r2, [r3, #12]
 293:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 4140              		.loc 1 293 0
 4141 0088 BB69     		ldr	r3, [r7, #24]
 4142 008a FA68     		ldr	r2, [r7, #12]
 4143 008c DA63     		str	r2, [r3, #60]
 294:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 4144              		.loc 1 294 0
 4145 008e BB69     		ldr	r3, [r7, #24]
 4146 0090 BA68     		ldr	r2, [r7, #8]
 4147 0092 1A64     		str	r2, [r3, #64]
 295:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 4148              		.loc 1 295 0
 4149 0094 BB69     		ldr	r3, [r7, #24]
 4150 0096 4FF0FF32 		mov	r2, #-1
 4151 009a 5A64     		str	r2, [r3, #68]
 296:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 4152              		.loc 1 296 0
 4153 009c BB69     		ldr	r3, [r7, #24]
 4154 009e 4FF0FF32 		mov	r2, #-1
 4155 00a2 9A64     		str	r2, [r3, #72]
 297:../3rdParty/FreeRTOS/queue.c **** 				#if ( configUSE_TRACE_FACILITY == 1 )
 298:../3rdParty/FreeRTOS/queue.c **** 				{
 299:../3rdParty/FreeRTOS/queue.c **** 					pxNewQueue->ucQueueType = ucQueueType;
 4156              		.loc 1 299 0
 4157 00a4 BB69     		ldr	r3, [r7, #24]
 4158 00a6 FA79     		ldrb	r2, [r7, #7]
 4159 00a8 83F84D20 		strb	r2, [r3, #77]
 300:../3rdParty/FreeRTOS/queue.c **** 				}
 301:../3rdParty/FreeRTOS/queue.c **** 				#endif /* configUSE_TRACE_FACILITY */
 302:../3rdParty/FreeRTOS/queue.c **** 
 303:../3rdParty/FreeRTOS/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 304:../3rdParty/FreeRTOS/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 4160              		.loc 1 304 0
 4161 00ac BB69     		ldr	r3, [r7, #24]
 4162 00ae 03F11003 		add	r3, r3, #16
 4163 00b2 1846     		mov	r0, r3
 4164 00b4 FFF7FEFF 		bl	vListInitialise
 305:../3rdParty/FreeRTOS/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 4165              		.loc 1 305 0
 4166 00b8 BB69     		ldr	r3, [r7, #24]
 4167 00ba 03F12403 		add	r3, r3, #36
 4168 00be 1846     		mov	r0, r3
 4169 00c0 FFF7FEFF 		bl	vListInitialise
 306:../3rdParty/FreeRTOS/queue.c **** 
 307:../3rdParty/FreeRTOS/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 308:../3rdParty/FreeRTOS/queue.c **** 				xReturn = pxNewQueue;
 4170              		.loc 1 308 0
 4171 00c4 BB69     		ldr	r3, [r7, #24]
 4172 00c6 FB61     		str	r3, [r7, #28]
 4173 00c8 02E0     		b	.L2
 4174              	.L3:
 309:../3rdParty/FreeRTOS/queue.c **** 			}
 310:../3rdParty/FreeRTOS/queue.c **** 			else
 311:../3rdParty/FreeRTOS/queue.c **** 			{
 312:../3rdParty/FreeRTOS/queue.c **** 				traceQUEUE_CREATE_FAILED( ucQueueType );
 313:../3rdParty/FreeRTOS/queue.c **** 				vPortFree( pxNewQueue );
 4175              		.loc 1 313 0
 4176 00ca B869     		ldr	r0, [r7, #24]
 4177 00cc FFF7FEFF 		bl	vPortFree
 4178              	.L2:
 314:../3rdParty/FreeRTOS/queue.c **** 			}
 315:../3rdParty/FreeRTOS/queue.c **** 		}
 316:../3rdParty/FreeRTOS/queue.c **** 	}
 317:../3rdParty/FreeRTOS/queue.c **** 
 318:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( xReturn );
 319:../3rdParty/FreeRTOS/queue.c **** 
 320:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 4179              		.loc 1 320 0
 4180 00d0 FB69     		ldr	r3, [r7, #28]
 321:../3rdParty/FreeRTOS/queue.c **** }
 4181              		.loc 1 321 0
 4182 00d2 1846     		mov	r0, r3
 4183 00d4 07F12007 		add	r7, r7, #32
 4184 00d8 BD46     		mov	sp, r7
 4185 00da 80BD     		pop	{r7, pc}
 4186              		.cfi_endproc
 4187              	.LFE55:
 4189              		.align	2
 4190              		.global	xQueueCreateMutex
 4191              		.thumb
 4192              		.thumb_func
 4194              	xQueueCreateMutex:
 4195              	.LFB56:
 322:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 323:../3rdParty/FreeRTOS/queue.c **** 
 324:../3rdParty/FreeRTOS/queue.c **** #if ( configUSE_MUTEXES == 1 )
 325:../3rdParty/FreeRTOS/queue.c **** 
 326:../3rdParty/FreeRTOS/queue.c **** 	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
 327:../3rdParty/FreeRTOS/queue.c **** 	{
 4196              		.loc 1 327 0
 4197              		.cfi_startproc
 4198              		@ args = 0, pretend = 0, frame = 16
 4199              		@ frame_needed = 1, uses_anonymous_args = 0
 4200 00dc 80B5     		push	{r7, lr}
 4201              	.LCFI3:
 4202              		.cfi_def_cfa_offset 8
 4203 00de 84B0     		sub	sp, sp, #16
 4204              	.LCFI4:
 4205              		.cfi_def_cfa_offset 24
 4206 00e0 00AF     		add	r7, sp, #0
 4207              		.cfi_offset 14, -4
 4208              		.cfi_offset 7, -8
 4209              	.LCFI5:
 4210              		.cfi_def_cfa_register 7
 4211 00e2 0346     		mov	r3, r0
 4212 00e4 FB71     		strb	r3, [r7, #7]
 328:../3rdParty/FreeRTOS/queue.c **** 	xQUEUE *pxNewQueue;
 329:../3rdParty/FreeRTOS/queue.c **** 
 330:../3rdParty/FreeRTOS/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 331:../3rdParty/FreeRTOS/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 332:../3rdParty/FreeRTOS/queue.c **** 		( void ) ucQueueType;
 333:../3rdParty/FreeRTOS/queue.c **** 	
 334:../3rdParty/FreeRTOS/queue.c **** 		/* Allocate the new queue structure. */
 335:../3rdParty/FreeRTOS/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 4213              		.loc 1 335 0
 4214 00e6 4FF05000 		mov	r0, #80
 4215 00ea FFF7FEFF 		bl	pvPortMalloc
 4216 00ee 0346     		mov	r3, r0
 4217 00f0 FB60     		str	r3, [r7, #12]
 336:../3rdParty/FreeRTOS/queue.c **** 		if( pxNewQueue != NULL )
 4218              		.loc 1 336 0
 4219 00f2 FB68     		ldr	r3, [r7, #12]
 4220 00f4 002B     		cmp	r3, #0
 4221 00f6 3CD0     		beq	.L5
 337:../3rdParty/FreeRTOS/queue.c **** 		{
 338:../3rdParty/FreeRTOS/queue.c **** 			/* Information required for priority inheritance. */
 339:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 4222              		.loc 1 339 0
 4223 00f8 FB68     		ldr	r3, [r7, #12]
 4224 00fa 4FF00002 		mov	r2, #0
 4225 00fe 5A60     		str	r2, [r3, #4]
 340:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 4226              		.loc 1 340 0
 4227 0100 FB68     		ldr	r3, [r7, #12]
 4228 0102 4FF00002 		mov	r2, #0
 4229 0106 1A60     		str	r2, [r3, #0]
 341:../3rdParty/FreeRTOS/queue.c **** 
 342:../3rdParty/FreeRTOS/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 343:../3rdParty/FreeRTOS/queue.c **** 			of the queue. */
 344:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 4230              		.loc 1 344 0
 4231 0108 FB68     		ldr	r3, [r7, #12]
 4232 010a 4FF00002 		mov	r2, #0
 4233 010e 9A60     		str	r2, [r3, #8]
 345:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->pcReadFrom = NULL;
 4234              		.loc 1 345 0
 4235 0110 FB68     		ldr	r3, [r7, #12]
 4236 0112 4FF00002 		mov	r2, #0
 4237 0116 DA60     		str	r2, [r3, #12]
 346:../3rdParty/FreeRTOS/queue.c **** 
 347:../3rdParty/FreeRTOS/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 348:../3rdParty/FreeRTOS/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 349:../3rdParty/FreeRTOS/queue.c **** 			of the mutex. */
 350:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 4238              		.loc 1 350 0
 4239 0118 FB68     		ldr	r3, [r7, #12]
 4240 011a 4FF00002 		mov	r2, #0
 4241 011e 9A63     		str	r2, [r3, #56]
 351:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 4242              		.loc 1 351 0
 4243 0120 FB68     		ldr	r3, [r7, #12]
 4244 0122 4FF00102 		mov	r2, #1
 4245 0126 DA63     		str	r2, [r3, #60]
 352:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 4246              		.loc 1 352 0
 4247 0128 FB68     		ldr	r3, [r7, #12]
 4248 012a 4FF00002 		mov	r2, #0
 4249 012e 1A64     		str	r2, [r3, #64]
 353:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 4250              		.loc 1 353 0
 4251 0130 FB68     		ldr	r3, [r7, #12]
 4252 0132 4FF0FF32 		mov	r2, #-1
 4253 0136 5A64     		str	r2, [r3, #68]
 354:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 4254              		.loc 1 354 0
 4255 0138 FB68     		ldr	r3, [r7, #12]
 4256 013a 4FF0FF32 		mov	r2, #-1
 4257 013e 9A64     		str	r2, [r3, #72]
 355:../3rdParty/FreeRTOS/queue.c **** 			
 356:../3rdParty/FreeRTOS/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 357:../3rdParty/FreeRTOS/queue.c **** 			{
 358:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 4258              		.loc 1 358 0
 4259 0140 FB68     		ldr	r3, [r7, #12]
 4260 0142 FA79     		ldrb	r2, [r7, #7]
 4261 0144 83F84D20 		strb	r2, [r3, #77]
 359:../3rdParty/FreeRTOS/queue.c **** 			}
 360:../3rdParty/FreeRTOS/queue.c **** 			#endif
 361:../3rdParty/FreeRTOS/queue.c **** 
 362:../3rdParty/FreeRTOS/queue.c **** 			/* Ensure the event queues start with the correct state. */
 363:../3rdParty/FreeRTOS/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 4262              		.loc 1 363 0
 4263 0148 FB68     		ldr	r3, [r7, #12]
 4264 014a 03F11003 		add	r3, r3, #16
 4265 014e 1846     		mov	r0, r3
 4266 0150 FFF7FEFF 		bl	vListInitialise
 364:../3rdParty/FreeRTOS/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 4267              		.loc 1 364 0
 4268 0154 FB68     		ldr	r3, [r7, #12]
 4269 0156 03F12403 		add	r3, r3, #36
 4270 015a 1846     		mov	r0, r3
 4271 015c FFF7FEFF 		bl	vListInitialise
 365:../3rdParty/FreeRTOS/queue.c **** 
 366:../3rdParty/FreeRTOS/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 367:../3rdParty/FreeRTOS/queue.c **** 
 368:../3rdParty/FreeRTOS/queue.c **** 			/* Start with the semaphore in the expected state. */
 369:../3rdParty/FreeRTOS/queue.c **** 			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 4272              		.loc 1 369 0
 4273 0160 F868     		ldr	r0, [r7, #12]
 4274 0162 4FF00001 		mov	r1, #0
 4275 0166 4FF00002 		mov	r2, #0
 4276 016a 4FF00003 		mov	r3, #0
 4277 016e FFF7FEFF 		bl	xQueueGenericSend
 4278              	.L5:
 370:../3rdParty/FreeRTOS/queue.c **** 		}
 371:../3rdParty/FreeRTOS/queue.c **** 		else
 372:../3rdParty/FreeRTOS/queue.c **** 		{
 373:../3rdParty/FreeRTOS/queue.c **** 			traceCREATE_MUTEX_FAILED();
 374:../3rdParty/FreeRTOS/queue.c **** 		}
 375:../3rdParty/FreeRTOS/queue.c **** 
 376:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( pxNewQueue );
 377:../3rdParty/FreeRTOS/queue.c **** 		return pxNewQueue;
 4279              		.loc 1 377 0
 4280 0172 FB68     		ldr	r3, [r7, #12]
 378:../3rdParty/FreeRTOS/queue.c **** 	}
 4281              		.loc 1 378 0
 4282 0174 1846     		mov	r0, r3
 4283 0176 07F11007 		add	r7, r7, #16
 4284 017a BD46     		mov	sp, r7
 4285 017c 80BD     		pop	{r7, pc}
 4286              		.cfi_endproc
 4287              	.LFE56:
 4289 017e 00BF     		.align	2
 4290              		.global	xQueueGiveMutexRecursive
 4291              		.thumb
 4292              		.thumb_func
 4294              	xQueueGiveMutexRecursive:
 4295              	.LFB57:
 379:../3rdParty/FreeRTOS/queue.c **** 
 380:../3rdParty/FreeRTOS/queue.c **** #endif /* configUSE_MUTEXES */
 381:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 382:../3rdParty/FreeRTOS/queue.c **** 
 383:../3rdParty/FreeRTOS/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 384:../3rdParty/FreeRTOS/queue.c **** 
 385:../3rdParty/FreeRTOS/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
 386:../3rdParty/FreeRTOS/queue.c **** 	{
 4296              		.loc 1 386 0
 4297              		.cfi_startproc
 4298              		@ args = 0, pretend = 0, frame = 16
 4299              		@ frame_needed = 1, uses_anonymous_args = 0
 4300 0180 90B5     		push	{r4, r7, lr}
 4301              	.LCFI6:
 4302              		.cfi_def_cfa_offset 12
 4303 0182 85B0     		sub	sp, sp, #20
 4304              	.LCFI7:
 4305              		.cfi_def_cfa_offset 32
 4306 0184 00AF     		add	r7, sp, #0
 4307              		.cfi_offset 14, -4
 4308              		.cfi_offset 7, -8
 4309              		.cfi_offset 4, -12
 4310              	.LCFI8:
 4311              		.cfi_def_cfa_register 7
 4312 0186 7860     		str	r0, [r7, #4]
 387:../3rdParty/FreeRTOS/queue.c **** 	portBASE_TYPE xReturn;
 388:../3rdParty/FreeRTOS/queue.c **** 
 389:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( pxMutex );
 390:../3rdParty/FreeRTOS/queue.c **** 
 391:../3rdParty/FreeRTOS/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 392:../3rdParty/FreeRTOS/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 393:../3rdParty/FreeRTOS/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 394:../3rdParty/FreeRTOS/queue.c **** 		this is the only condition we are interested in it does not matter if
 395:../3rdParty/FreeRTOS/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 396:../3rdParty/FreeRTOS/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 397:../3rdParty/FreeRTOS/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 4313              		.loc 1 397 0
 4314 0188 7B68     		ldr	r3, [r7, #4]
 4315 018a 5C68     		ldr	r4, [r3, #4]
 4316 018c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 4317 0190 0346     		mov	r3, r0
 4318 0192 9C42     		cmp	r4, r3
 4319 0194 16D1     		bne	.L7
 398:../3rdParty/FreeRTOS/queue.c **** 		{
 399:../3rdParty/FreeRTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 400:../3rdParty/FreeRTOS/queue.c **** 
 401:../3rdParty/FreeRTOS/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 402:../3rdParty/FreeRTOS/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 403:../3rdParty/FreeRTOS/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 404:../3rdParty/FreeRTOS/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 405:../3rdParty/FreeRTOS/queue.c **** 			uxRecursiveCallCount member. */
 406:../3rdParty/FreeRTOS/queue.c **** 			( pxMutex->uxRecursiveCallCount )--;
 4320              		.loc 1 406 0
 4321 0196 7B68     		ldr	r3, [r7, #4]
 4322 0198 DB68     		ldr	r3, [r3, #12]
 4323 019a 03F1FF32 		add	r2, r3, #-1
 4324 019e 7B68     		ldr	r3, [r7, #4]
 4325 01a0 DA60     		str	r2, [r3, #12]
 407:../3rdParty/FreeRTOS/queue.c **** 
 408:../3rdParty/FreeRTOS/queue.c **** 			/* Have we unwound the call count? */
 409:../3rdParty/FreeRTOS/queue.c **** 			if( pxMutex->uxRecursiveCallCount == 0 )
 4326              		.loc 1 409 0
 4327 01a2 7B68     		ldr	r3, [r7, #4]
 4328 01a4 DB68     		ldr	r3, [r3, #12]
 4329 01a6 002B     		cmp	r3, #0
 4330 01a8 08D1     		bne	.L8
 410:../3rdParty/FreeRTOS/queue.c **** 			{
 411:../3rdParty/FreeRTOS/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 412:../3rdParty/FreeRTOS/queue.c **** 				task that might be waiting to access the mutex. */
 413:../3rdParty/FreeRTOS/queue.c **** 				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 4331              		.loc 1 413 0
 4332 01aa 7868     		ldr	r0, [r7, #4]
 4333 01ac 4FF00001 		mov	r1, #0
 4334 01b0 4FF00002 		mov	r2, #0
 4335 01b4 4FF00003 		mov	r3, #0
 4336 01b8 FFF7FEFF 		bl	xQueueGenericSend
 4337              	.L8:
 414:../3rdParty/FreeRTOS/queue.c **** 			}
 415:../3rdParty/FreeRTOS/queue.c **** 
 416:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 4338              		.loc 1 416 0
 4339 01bc 4FF00103 		mov	r3, #1
 4340 01c0 FB60     		str	r3, [r7, #12]
 4341 01c2 02E0     		b	.L9
 4342              	.L7:
 417:../3rdParty/FreeRTOS/queue.c **** 		}
 418:../3rdParty/FreeRTOS/queue.c **** 		else
 419:../3rdParty/FreeRTOS/queue.c **** 		{
 420:../3rdParty/FreeRTOS/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 421:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdFAIL;
 4343              		.loc 1 421 0
 4344 01c4 4FF00003 		mov	r3, #0
 4345 01c8 FB60     		str	r3, [r7, #12]
 4346              	.L9:
 422:../3rdParty/FreeRTOS/queue.c **** 
 423:../3rdParty/FreeRTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 424:../3rdParty/FreeRTOS/queue.c **** 		}
 425:../3rdParty/FreeRTOS/queue.c **** 
 426:../3rdParty/FreeRTOS/queue.c **** 		return xReturn;
 4347              		.loc 1 426 0
 4348 01ca FB68     		ldr	r3, [r7, #12]
 427:../3rdParty/FreeRTOS/queue.c **** 	}
 4349              		.loc 1 427 0
 4350 01cc 1846     		mov	r0, r3
 4351 01ce 07F11407 		add	r7, r7, #20
 4352 01d2 BD46     		mov	sp, r7
 4353 01d4 90BD     		pop	{r4, r7, pc}
 4354              		.cfi_endproc
 4355              	.LFE57:
 4357 01d6 00BF     		.align	2
 4358              		.global	xQueueTakeMutexRecursive
 4359              		.thumb
 4360              		.thumb_func
 4362              	xQueueTakeMutexRecursive:
 4363              	.LFB58:
 428:../3rdParty/FreeRTOS/queue.c **** 
 429:../3rdParty/FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 430:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 431:../3rdParty/FreeRTOS/queue.c **** 
 432:../3rdParty/FreeRTOS/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 433:../3rdParty/FreeRTOS/queue.c **** 
 434:../3rdParty/FreeRTOS/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
 435:../3rdParty/FreeRTOS/queue.c **** 	{
 4364              		.loc 1 435 0
 4365              		.cfi_startproc
 4366              		@ args = 0, pretend = 0, frame = 16
 4367              		@ frame_needed = 1, uses_anonymous_args = 0
 4368 01d8 90B5     		push	{r4, r7, lr}
 4369              	.LCFI9:
 4370              		.cfi_def_cfa_offset 12
 4371 01da 85B0     		sub	sp, sp, #20
 4372              	.LCFI10:
 4373              		.cfi_def_cfa_offset 32
 4374 01dc 00AF     		add	r7, sp, #0
 4375              		.cfi_offset 14, -4
 4376              		.cfi_offset 7, -8
 4377              		.cfi_offset 4, -12
 4378              	.LCFI11:
 4379              		.cfi_def_cfa_register 7
 4380 01de 7860     		str	r0, [r7, #4]
 4381 01e0 3960     		str	r1, [r7, #0]
 436:../3rdParty/FreeRTOS/queue.c **** 	portBASE_TYPE xReturn;
 437:../3rdParty/FreeRTOS/queue.c **** 
 438:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( pxMutex );
 439:../3rdParty/FreeRTOS/queue.c **** 
 440:../3rdParty/FreeRTOS/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 441:../3rdParty/FreeRTOS/queue.c **** 		xQueueGiveMutexRecursive(). */
 442:../3rdParty/FreeRTOS/queue.c **** 
 443:../3rdParty/FreeRTOS/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 444:../3rdParty/FreeRTOS/queue.c **** 
 445:../3rdParty/FreeRTOS/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 4382              		.loc 1 445 0
 4383 01e2 7B68     		ldr	r3, [r7, #4]
 4384 01e4 5C68     		ldr	r4, [r3, #4]
 4385 01e6 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 4386 01ea 0346     		mov	r3, r0
 4387 01ec 9C42     		cmp	r4, r3
 4388 01ee 09D1     		bne	.L11
 446:../3rdParty/FreeRTOS/queue.c **** 		{
 447:../3rdParty/FreeRTOS/queue.c **** 			( pxMutex->uxRecursiveCallCount )++;
 4389              		.loc 1 447 0
 4390 01f0 7B68     		ldr	r3, [r7, #4]
 4391 01f2 DB68     		ldr	r3, [r3, #12]
 4392 01f4 03F10102 		add	r2, r3, #1
 4393 01f8 7B68     		ldr	r3, [r7, #4]
 4394 01fa DA60     		str	r2, [r3, #12]
 448:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 4395              		.loc 1 448 0
 4396 01fc 4FF00103 		mov	r3, #1
 4397 0200 FB60     		str	r3, [r7, #12]
 4398 0202 11E0     		b	.L12
 4399              	.L11:
 449:../3rdParty/FreeRTOS/queue.c **** 		}
 450:../3rdParty/FreeRTOS/queue.c **** 		else
 451:../3rdParty/FreeRTOS/queue.c **** 		{
 452:../3rdParty/FreeRTOS/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 4400              		.loc 1 452 0
 4401 0204 7868     		ldr	r0, [r7, #4]
 4402 0206 4FF00001 		mov	r1, #0
 4403 020a 3A68     		ldr	r2, [r7, #0]
 4404 020c 4FF00003 		mov	r3, #0
 4405 0210 FFF7FEFF 		bl	xQueueGenericReceive
 4406 0214 F860     		str	r0, [r7, #12]
 453:../3rdParty/FreeRTOS/queue.c **** 
 454:../3rdParty/FreeRTOS/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 455:../3rdParty/FreeRTOS/queue.c **** 			we may have blocked to reach here. */
 456:../3rdParty/FreeRTOS/queue.c **** 			if( xReturn == pdPASS )
 4407              		.loc 1 456 0
 4408 0216 FB68     		ldr	r3, [r7, #12]
 4409 0218 012B     		cmp	r3, #1
 4410 021a 05D1     		bne	.L12
 457:../3rdParty/FreeRTOS/queue.c **** 			{
 458:../3rdParty/FreeRTOS/queue.c **** 				( pxMutex->uxRecursiveCallCount )++;
 4411              		.loc 1 458 0
 4412 021c 7B68     		ldr	r3, [r7, #4]
 4413 021e DB68     		ldr	r3, [r3, #12]
 4414 0220 03F10102 		add	r2, r3, #1
 4415 0224 7B68     		ldr	r3, [r7, #4]
 4416 0226 DA60     		str	r2, [r3, #12]
 4417              	.L12:
 459:../3rdParty/FreeRTOS/queue.c **** 			}
 460:../3rdParty/FreeRTOS/queue.c **** 			else
 461:../3rdParty/FreeRTOS/queue.c **** 			{
 462:../3rdParty/FreeRTOS/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 463:../3rdParty/FreeRTOS/queue.c **** 			}
 464:../3rdParty/FreeRTOS/queue.c **** 		}
 465:../3rdParty/FreeRTOS/queue.c **** 
 466:../3rdParty/FreeRTOS/queue.c **** 		return xReturn;
 4418              		.loc 1 466 0
 4419 0228 FB68     		ldr	r3, [r7, #12]
 467:../3rdParty/FreeRTOS/queue.c **** 	}
 4420              		.loc 1 467 0
 4421 022a 1846     		mov	r0, r3
 4422 022c 07F11407 		add	r7, r7, #20
 4423 0230 BD46     		mov	sp, r7
 4424 0232 90BD     		pop	{r4, r7, pc}
 4425              		.cfi_endproc
 4426              	.LFE58:
 4428              		.align	2
 4429              		.global	xQueueGenericSend
 4430              		.thumb
 4431              		.thumb_func
 4433              	xQueueGenericSend:
 4434              	.LFB59:
 468:../3rdParty/FreeRTOS/queue.c **** 
 469:../3rdParty/FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 470:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 471:../3rdParty/FreeRTOS/queue.c **** 
 472:../3rdParty/FreeRTOS/queue.c **** #if configUSE_COUNTING_SEMAPHORES == 1
 473:../3rdParty/FreeRTOS/queue.c **** 
 474:../3rdParty/FreeRTOS/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 475:../3rdParty/FreeRTOS/queue.c **** 	{
 476:../3rdParty/FreeRTOS/queue.c **** 	xQueueHandle pxHandle;
 477:../3rdParty/FreeRTOS/queue.c **** 
 478:../3rdParty/FreeRTOS/queue.c **** 		pxHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITE
 479:../3rdParty/FreeRTOS/queue.c **** 
 480:../3rdParty/FreeRTOS/queue.c **** 		if( pxHandle != NULL )
 481:../3rdParty/FreeRTOS/queue.c **** 		{
 482:../3rdParty/FreeRTOS/queue.c **** 			pxHandle->uxMessagesWaiting = uxInitialCount;
 483:../3rdParty/FreeRTOS/queue.c **** 
 484:../3rdParty/FreeRTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 485:../3rdParty/FreeRTOS/queue.c **** 		}
 486:../3rdParty/FreeRTOS/queue.c **** 		else
 487:../3rdParty/FreeRTOS/queue.c **** 		{
 488:../3rdParty/FreeRTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 489:../3rdParty/FreeRTOS/queue.c **** 		}
 490:../3rdParty/FreeRTOS/queue.c **** 
 491:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( pxHandle );
 492:../3rdParty/FreeRTOS/queue.c **** 		return pxHandle;
 493:../3rdParty/FreeRTOS/queue.c **** 	}
 494:../3rdParty/FreeRTOS/queue.c **** 
 495:../3rdParty/FreeRTOS/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 496:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 497:../3rdParty/FreeRTOS/queue.c **** 
 498:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, por
 499:../3rdParty/FreeRTOS/queue.c **** {
 4435              		.loc 1 499 0
 4436              		.cfi_startproc
 4437              		@ args = 0, pretend = 0, frame = 32
 4438              		@ frame_needed = 1, uses_anonymous_args = 0
 4439 0234 80B5     		push	{r7, lr}
 4440              	.LCFI12:
 4441              		.cfi_def_cfa_offset 8
 4442 0236 88B0     		sub	sp, sp, #32
 4443              	.LCFI13:
 4444              		.cfi_def_cfa_offset 40
 4445 0238 00AF     		add	r7, sp, #0
 4446              		.cfi_offset 14, -4
 4447              		.cfi_offset 7, -8
 4448              	.LCFI14:
 4449              		.cfi_def_cfa_register 7
 4450 023a F860     		str	r0, [r7, #12]
 4451 023c B960     		str	r1, [r7, #8]
 4452 023e 7A60     		str	r2, [r7, #4]
 4453 0240 3B60     		str	r3, [r7, #0]
 500:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 4454              		.loc 1 500 0
 4455 0242 4FF00003 		mov	r3, #0
 4456 0246 FB61     		str	r3, [r7, #28]
 4457 0248 00E0     		b	.L24
 4458              	.L25:
 501:../3rdParty/FreeRTOS/queue.c **** xTimeOutType xTimeOut;
 502:../3rdParty/FreeRTOS/queue.c **** 
 503:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 504:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 505:../3rdParty/FreeRTOS/queue.c **** 
 506:../3rdParty/FreeRTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 507:../3rdParty/FreeRTOS/queue.c **** 	statements within the function itself.  This is done in the interest
 508:../3rdParty/FreeRTOS/queue.c **** 	of execution time efficiency. */
 509:../3rdParty/FreeRTOS/queue.c **** 	for( ;; )
 510:../3rdParty/FreeRTOS/queue.c **** 	{
 511:../3rdParty/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 512:../3rdParty/FreeRTOS/queue.c **** 		{
 513:../3rdParty/FreeRTOS/queue.c **** 			/* Is there room on the queue now?  To be running we must be
 514:../3rdParty/FreeRTOS/queue.c **** 			the highest priority task wanting to access the queue. */
 515:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 516:../3rdParty/FreeRTOS/queue.c **** 			{
 517:../3rdParty/FreeRTOS/queue.c **** 				traceQUEUE_SEND( pxQueue );
 518:../3rdParty/FreeRTOS/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 519:../3rdParty/FreeRTOS/queue.c **** 
 520:../3rdParty/FreeRTOS/queue.c **** 				/* If there was a task waiting for data to arrive on the
 521:../3rdParty/FreeRTOS/queue.c **** 				queue then unblock it now. */
 522:../3rdParty/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 523:../3rdParty/FreeRTOS/queue.c **** 				{
 524:../3rdParty/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 525:../3rdParty/FreeRTOS/queue.c **** 					{
 526:../3rdParty/FreeRTOS/queue.c **** 						/* The unblocked task has a priority higher than
 527:../3rdParty/FreeRTOS/queue.c **** 						our own so yield immediately.  Yes it is ok to do
 528:../3rdParty/FreeRTOS/queue.c **** 						this from within the critical section - the kernel
 529:../3rdParty/FreeRTOS/queue.c **** 						takes care of that. */
 530:../3rdParty/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 531:../3rdParty/FreeRTOS/queue.c **** 					}
 532:../3rdParty/FreeRTOS/queue.c **** 				}
 533:../3rdParty/FreeRTOS/queue.c **** 
 534:../3rdParty/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 535:../3rdParty/FreeRTOS/queue.c **** 
 536:../3rdParty/FreeRTOS/queue.c **** 				/* Return to the original privilege level before exiting the
 537:../3rdParty/FreeRTOS/queue.c **** 				function. */
 538:../3rdParty/FreeRTOS/queue.c **** 				return pdPASS;
 539:../3rdParty/FreeRTOS/queue.c **** 			}
 540:../3rdParty/FreeRTOS/queue.c **** 			else
 541:../3rdParty/FreeRTOS/queue.c **** 			{
 542:../3rdParty/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 543:../3rdParty/FreeRTOS/queue.c **** 				{
 544:../3rdParty/FreeRTOS/queue.c **** 					/* The queue was full and no block time is specified (or
 545:../3rdParty/FreeRTOS/queue.c **** 					the block time has expired) so leave now. */
 546:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 547:../3rdParty/FreeRTOS/queue.c **** 
 548:../3rdParty/FreeRTOS/queue.c **** 					/* Return to the original privilege level before exiting
 549:../3rdParty/FreeRTOS/queue.c **** 					the function. */
 550:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 551:../3rdParty/FreeRTOS/queue.c **** 					return errQUEUE_FULL;
 552:../3rdParty/FreeRTOS/queue.c **** 				}
 553:../3rdParty/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 554:../3rdParty/FreeRTOS/queue.c **** 				{
 555:../3rdParty/FreeRTOS/queue.c **** 					/* The queue was full and a block time was specified so
 556:../3rdParty/FreeRTOS/queue.c **** 					configure the timeout structure. */
 557:../3rdParty/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 558:../3rdParty/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 559:../3rdParty/FreeRTOS/queue.c **** 				}
 560:../3rdParty/FreeRTOS/queue.c **** 			}
 561:../3rdParty/FreeRTOS/queue.c **** 		}
 562:../3rdParty/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 563:../3rdParty/FreeRTOS/queue.c **** 
 564:../3rdParty/FreeRTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 565:../3rdParty/FreeRTOS/queue.c **** 		now the critical section has been exited. */
 566:../3rdParty/FreeRTOS/queue.c **** 
 567:../3rdParty/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 568:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 569:../3rdParty/FreeRTOS/queue.c **** 
 570:../3rdParty/FreeRTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 571:../3rdParty/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 572:../3rdParty/FreeRTOS/queue.c **** 		{
 573:../3rdParty/FreeRTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 574:../3rdParty/FreeRTOS/queue.c **** 			{
 575:../3rdParty/FreeRTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 576:../3rdParty/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 577:../3rdParty/FreeRTOS/queue.c **** 
 578:../3rdParty/FreeRTOS/queue.c **** 				/* Unlocking the queue means queue events can effect the
 579:../3rdParty/FreeRTOS/queue.c **** 				event list.  It is possible	that interrupts occurring now
 580:../3rdParty/FreeRTOS/queue.c **** 				remove this task from the event	list again - but as the
 581:../3rdParty/FreeRTOS/queue.c **** 				scheduler is suspended the task will go onto the pending
 582:../3rdParty/FreeRTOS/queue.c **** 				ready last instead of the actual ready list. */
 583:../3rdParty/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 584:../3rdParty/FreeRTOS/queue.c **** 
 585:../3rdParty/FreeRTOS/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 586:../3rdParty/FreeRTOS/queue.c **** 				ready list into the ready list - so it is feasible that this
 587:../3rdParty/FreeRTOS/queue.c **** 				task is already in a ready list before it yields - in which
 588:../3rdParty/FreeRTOS/queue.c **** 				case the yield will not cause a context switch unless there
 589:../3rdParty/FreeRTOS/queue.c **** 				is also a higher priority task in the pending ready list. */
 590:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 591:../3rdParty/FreeRTOS/queue.c **** 				{
 592:../3rdParty/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
 593:../3rdParty/FreeRTOS/queue.c **** 				}
 594:../3rdParty/FreeRTOS/queue.c **** 			}
 595:../3rdParty/FreeRTOS/queue.c **** 			else
 596:../3rdParty/FreeRTOS/queue.c **** 			{
 597:../3rdParty/FreeRTOS/queue.c **** 				/* Try again. */
 598:../3rdParty/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 599:../3rdParty/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
 600:../3rdParty/FreeRTOS/queue.c **** 			}
 601:../3rdParty/FreeRTOS/queue.c **** 		}
 602:../3rdParty/FreeRTOS/queue.c **** 		else
 603:../3rdParty/FreeRTOS/queue.c **** 		{
 604:../3rdParty/FreeRTOS/queue.c **** 			/* The timeout has expired. */
 605:../3rdParty/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 606:../3rdParty/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
 607:../3rdParty/FreeRTOS/queue.c **** 
 608:../3rdParty/FreeRTOS/queue.c **** 			/* Return to the original privilege level before exiting the
 609:../3rdParty/FreeRTOS/queue.c **** 			function. */
 610:../3rdParty/FreeRTOS/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 611:../3rdParty/FreeRTOS/queue.c **** 			return errQUEUE_FULL;
 612:../3rdParty/FreeRTOS/queue.c **** 		}
 613:../3rdParty/FreeRTOS/queue.c **** 	}
 4459              		.loc 1 613 0
 4460 024a 00BF     		nop
 4461              	.L24:
 511:../3rdParty/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 4462              		.loc 1 511 0
 4463 024c FFF7FEFF 		bl	vPortEnterCritical
 515:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 4464              		.loc 1 515 0
 4465 0250 FB68     		ldr	r3, [r7, #12]
 4466 0252 9A6B     		ldr	r2, [r3, #56]
 4467 0254 FB68     		ldr	r3, [r7, #12]
 4468 0256 DB6B     		ldr	r3, [r3, #60]
 4469 0258 9A42     		cmp	r2, r3
 4470 025a 18D2     		bcs	.L14
 518:../3rdParty/FreeRTOS/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 4471              		.loc 1 518 0
 4472 025c F868     		ldr	r0, [r7, #12]
 4473 025e B968     		ldr	r1, [r7, #8]
 4474 0260 3A68     		ldr	r2, [r7, #0]
 4475 0262 00F02DFA 		bl	prvCopyDataToQueue
 522:../3rdParty/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4476              		.loc 1 522 0
 4477 0266 FB68     		ldr	r3, [r7, #12]
 4478 0268 5B6A     		ldr	r3, [r3, #36]
 4479 026a 002B     		cmp	r3, #0
 4480 026c 0AD0     		beq	.L15
 524:../3rdParty/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 4481              		.loc 1 524 0
 4482 026e FB68     		ldr	r3, [r7, #12]
 4483 0270 03F12403 		add	r3, r3, #36
 4484 0274 1846     		mov	r0, r3
 4485 0276 FFF7FEFF 		bl	xTaskRemoveFromEventList
 4486 027a 0346     		mov	r3, r0
 4487 027c 012B     		cmp	r3, #1
 4488 027e 01D1     		bne	.L15
 530:../3rdParty/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 4489              		.loc 1 530 0
 4490 0280 FFF7FEFF 		bl	vPortYieldFromISR
 4491              	.L15:
 534:../3rdParty/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 4492              		.loc 1 534 0
 4493 0284 FFF7FEFF 		bl	vPortExitCritical
 538:../3rdParty/FreeRTOS/queue.c **** 				return pdPASS;
 4494              		.loc 1 538 0
 4495 0288 4FF00103 		mov	r3, #1
 4496 028c 5DE0     		b	.L16
 4497              	.L14:
 542:../3rdParty/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 4498              		.loc 1 542 0
 4499 028e 7B68     		ldr	r3, [r7, #4]
 4500 0290 002B     		cmp	r3, #0
 4501 0292 04D1     		bne	.L17
 546:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 4502              		.loc 1 546 0
 4503 0294 FFF7FEFF 		bl	vPortExitCritical
 551:../3rdParty/FreeRTOS/queue.c **** 					return errQUEUE_FULL;
 4504              		.loc 1 551 0
 4505 0298 4FF00003 		mov	r3, #0
 4506 029c 55E0     		b	.L16
 4507              	.L17:
 553:../3rdParty/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 4508              		.loc 1 553 0
 4509 029e FB69     		ldr	r3, [r7, #28]
 4510 02a0 002B     		cmp	r3, #0
 4511 02a2 07D1     		bne	.L18
 557:../3rdParty/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 4512              		.loc 1 557 0
 4513 02a4 07F11403 		add	r3, r7, #20
 4514 02a8 1846     		mov	r0, r3
 4515 02aa FFF7FEFF 		bl	vTaskSetTimeOutState
 558:../3rdParty/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 4516              		.loc 1 558 0
 4517 02ae 4FF00103 		mov	r3, #1
 4518 02b2 FB61     		str	r3, [r7, #28]
 4519              	.L18:
 562:../3rdParty/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 4520              		.loc 1 562 0
 4521 02b4 FFF7FEFF 		bl	vPortExitCritical
 567:../3rdParty/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 4522              		.loc 1 567 0
 4523 02b8 FFF7FEFF 		bl	vTaskSuspendAll
 568:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4524              		.loc 1 568 0
 4525 02bc FFF7FEFF 		bl	vPortEnterCritical
 4526 02c0 FB68     		ldr	r3, [r7, #12]
 4527 02c2 5B6C     		ldr	r3, [r3, #68]
 4528 02c4 B3F1FF3F 		cmp	r3, #-1
 4529 02c8 03D1     		bne	.L19
 568:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4530              		.loc 1 568 0 is_stmt 0 discriminator 1
 4531 02ca FB68     		ldr	r3, [r7, #12]
 4532 02cc 4FF00002 		mov	r2, #0
 4533 02d0 5A64     		str	r2, [r3, #68]
 4534              	.L19:
 568:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4535              		.loc 1 568 0 discriminator 2
 4536 02d2 FB68     		ldr	r3, [r7, #12]
 4537 02d4 9B6C     		ldr	r3, [r3, #72]
 4538 02d6 B3F1FF3F 		cmp	r3, #-1
 4539 02da 03D1     		bne	.L20
 568:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4540              		.loc 1 568 0 discriminator 3
 4541 02dc FB68     		ldr	r3, [r7, #12]
 4542 02de 4FF00002 		mov	r2, #0
 4543 02e2 9A64     		str	r2, [r3, #72]
 4544              	.L20:
 568:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4545              		.loc 1 568 0 discriminator 4
 4546 02e4 FFF7FEFF 		bl	vPortExitCritical
 571:../3rdParty/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4547              		.loc 1 571 0 is_stmt 1 discriminator 4
 4548 02e8 07F11402 		add	r2, r7, #20
 4549 02ec 07F10403 		add	r3, r7, #4
 4550 02f0 1046     		mov	r0, r2
 4551 02f2 1946     		mov	r1, r3
 4552 02f4 FFF7FEFF 		bl	xTaskCheckForTimeOut
 4553 02f8 0346     		mov	r3, r0
 4554 02fa 002B     		cmp	r3, #0
 4555 02fc 1ED1     		bne	.L21
 573:../3rdParty/FreeRTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 4556              		.loc 1 573 0
 4557 02fe F868     		ldr	r0, [r7, #12]
 4558 0300 00F0E0FA 		bl	prvIsQueueFull
 4559 0304 0346     		mov	r3, r0
 4560 0306 002B     		cmp	r3, #0
 4561 0308 12D0     		beq	.L22
 576:../3rdParty/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 4562              		.loc 1 576 0
 4563 030a FB68     		ldr	r3, [r7, #12]
 4564 030c 03F11002 		add	r2, r3, #16
 4565 0310 7B68     		ldr	r3, [r7, #4]
 4566 0312 1046     		mov	r0, r2
 4567 0314 1946     		mov	r1, r3
 4568 0316 FFF7FEFF 		bl	vTaskPlaceOnEventList
 583:../3rdParty/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 4569              		.loc 1 583 0
 4570 031a F868     		ldr	r0, [r7, #12]
 4571 031c 00F05AFA 		bl	prvUnlockQueue
 590:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 4572              		.loc 1 590 0
 4573 0320 FFF7FEFF 		bl	xTaskResumeAll
 4574 0324 0346     		mov	r3, r0
 4575 0326 002B     		cmp	r3, #0
 4576 0328 8FD1     		bne	.L25
 592:../3rdParty/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
 4577              		.loc 1 592 0
 4578 032a FFF7FEFF 		bl	vPortYieldFromISR
 4579              		.loc 1 613 0
 4580 032e 8DE7     		b	.L24
 4581              	.L22:
 598:../3rdParty/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 4582              		.loc 1 598 0
 4583 0330 F868     		ldr	r0, [r7, #12]
 4584 0332 00F04FFA 		bl	prvUnlockQueue
 599:../3rdParty/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
 4585              		.loc 1 599 0
 4586 0336 FFF7FEFF 		bl	xTaskResumeAll
 4587              		.loc 1 613 0
 4588 033a 87E7     		b	.L24
 4589              	.L21:
 605:../3rdParty/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 4590              		.loc 1 605 0
 4591 033c F868     		ldr	r0, [r7, #12]
 4592 033e 00F049FA 		bl	prvUnlockQueue
 606:../3rdParty/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
 4593              		.loc 1 606 0
 4594 0342 FFF7FEFF 		bl	xTaskResumeAll
 611:../3rdParty/FreeRTOS/queue.c **** 			return errQUEUE_FULL;
 4595              		.loc 1 611 0
 4596 0346 4FF00003 		mov	r3, #0
 4597              	.L16:
 614:../3rdParty/FreeRTOS/queue.c **** }
 4598              		.loc 1 614 0
 4599 034a 1846     		mov	r0, r3
 4600 034c 07F12007 		add	r7, r7, #32
 4601 0350 BD46     		mov	sp, r7
 4602 0352 80BD     		pop	{r7, pc}
 4603              		.cfi_endproc
 4604              	.LFE59:
 4606              		.align	2
 4607              		.global	xQueueGenericSendFromISR
 4608              		.thumb
 4609              		.thumb_func
 4611              	xQueueGenericSendFromISR:
 4612              	.LFB60:
 615:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 616:../3rdParty/FreeRTOS/queue.c **** 
 617:../3rdParty/FreeRTOS/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 618:../3rdParty/FreeRTOS/queue.c **** 
 619:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue,
 620:../3rdParty/FreeRTOS/queue.c **** 	{
 621:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 622:../3rdParty/FreeRTOS/queue.c **** 	xTimeOutType xTimeOut;
 623:../3rdParty/FreeRTOS/queue.c **** 
 624:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( pxQueue );
 625:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE )
 626:../3rdParty/FreeRTOS/queue.c **** 
 627:../3rdParty/FreeRTOS/queue.c **** 		for( ;; )
 628:../3rdParty/FreeRTOS/queue.c **** 		{
 629:../3rdParty/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 630:../3rdParty/FreeRTOS/queue.c **** 			{
 631:../3rdParty/FreeRTOS/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 632:../3rdParty/FreeRTOS/queue.c **** 				the highest priority task wanting to access the queue. */
 633:../3rdParty/FreeRTOS/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 634:../3rdParty/FreeRTOS/queue.c **** 				{
 635:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_SEND( pxQueue );
 636:../3rdParty/FreeRTOS/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 637:../3rdParty/FreeRTOS/queue.c **** 
 638:../3rdParty/FreeRTOS/queue.c **** 					/* If there was a task waiting for data to arrive on the
 639:../3rdParty/FreeRTOS/queue.c **** 					queue then unblock it now. */
 640:../3rdParty/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 641:../3rdParty/FreeRTOS/queue.c **** 					{
 642:../3rdParty/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 643:../3rdParty/FreeRTOS/queue.c **** 						{
 644:../3rdParty/FreeRTOS/queue.c **** 							/* The unblocked task has a priority higher than
 645:../3rdParty/FreeRTOS/queue.c **** 							our own so yield immediately. */
 646:../3rdParty/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 647:../3rdParty/FreeRTOS/queue.c **** 						}
 648:../3rdParty/FreeRTOS/queue.c **** 					}
 649:../3rdParty/FreeRTOS/queue.c **** 
 650:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 651:../3rdParty/FreeRTOS/queue.c **** 					return pdPASS;
 652:../3rdParty/FreeRTOS/queue.c **** 				}
 653:../3rdParty/FreeRTOS/queue.c **** 				else
 654:../3rdParty/FreeRTOS/queue.c **** 				{
 655:../3rdParty/FreeRTOS/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 656:../3rdParty/FreeRTOS/queue.c **** 					{
 657:../3rdParty/FreeRTOS/queue.c **** 						taskEXIT_CRITICAL();
 658:../3rdParty/FreeRTOS/queue.c **** 						return errQUEUE_FULL;
 659:../3rdParty/FreeRTOS/queue.c **** 					}
 660:../3rdParty/FreeRTOS/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 661:../3rdParty/FreeRTOS/queue.c **** 					{
 662:../3rdParty/FreeRTOS/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 663:../3rdParty/FreeRTOS/queue.c **** 						xEntryTimeSet = pdTRUE;
 664:../3rdParty/FreeRTOS/queue.c **** 					}
 665:../3rdParty/FreeRTOS/queue.c **** 				}
 666:../3rdParty/FreeRTOS/queue.c **** 			}
 667:../3rdParty/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 668:../3rdParty/FreeRTOS/queue.c **** 
 669:../3rdParty/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 670:../3rdParty/FreeRTOS/queue.c **** 			{
 671:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 672:../3rdParty/FreeRTOS/queue.c **** 				{
 673:../3rdParty/FreeRTOS/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 674:../3rdParty/FreeRTOS/queue.c **** 					{
 675:../3rdParty/FreeRTOS/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 676:../3rdParty/FreeRTOS/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 677:../3rdParty/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 678:../3rdParty/FreeRTOS/queue.c **** 					}
 679:../3rdParty/FreeRTOS/queue.c **** 				}
 680:../3rdParty/FreeRTOS/queue.c **** 				else
 681:../3rdParty/FreeRTOS/queue.c **** 				{
 682:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 683:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 684:../3rdParty/FreeRTOS/queue.c **** 					return errQUEUE_FULL;
 685:../3rdParty/FreeRTOS/queue.c **** 				}
 686:../3rdParty/FreeRTOS/queue.c **** 			}
 687:../3rdParty/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 688:../3rdParty/FreeRTOS/queue.c **** 		}
 689:../3rdParty/FreeRTOS/queue.c **** 	}
 690:../3rdParty/FreeRTOS/queue.c **** 
 691:../3rdParty/FreeRTOS/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 692:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 693:../3rdParty/FreeRTOS/queue.c **** 
 694:../3rdParty/FreeRTOS/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 695:../3rdParty/FreeRTOS/queue.c **** 
 696:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTic
 697:../3rdParty/FreeRTOS/queue.c **** 	{
 698:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 699:../3rdParty/FreeRTOS/queue.c **** 	xTimeOutType xTimeOut;
 700:../3rdParty/FreeRTOS/queue.c **** 	signed char *pcOriginalReadPosition;
 701:../3rdParty/FreeRTOS/queue.c **** 
 702:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( pxQueue );
 703:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U )
 704:../3rdParty/FreeRTOS/queue.c **** 
 705:../3rdParty/FreeRTOS/queue.c **** 		for( ;; )
 706:../3rdParty/FreeRTOS/queue.c **** 		{
 707:../3rdParty/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 708:../3rdParty/FreeRTOS/queue.c **** 			{
 709:../3rdParty/FreeRTOS/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 710:../3rdParty/FreeRTOS/queue.c **** 				{
 711:../3rdParty/FreeRTOS/queue.c **** 					/* Remember our read position in case we are just peeking. */
 712:../3rdParty/FreeRTOS/queue.c **** 					pcOriginalReadPosition = pxQueue->pcReadFrom;
 713:../3rdParty/FreeRTOS/queue.c **** 
 714:../3rdParty/FreeRTOS/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 715:../3rdParty/FreeRTOS/queue.c **** 
 716:../3rdParty/FreeRTOS/queue.c **** 					if( xJustPeeking == pdFALSE )
 717:../3rdParty/FreeRTOS/queue.c **** 					{
 718:../3rdParty/FreeRTOS/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 719:../3rdParty/FreeRTOS/queue.c **** 
 720:../3rdParty/FreeRTOS/queue.c **** 						/* We are actually removing data. */
 721:../3rdParty/FreeRTOS/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 722:../3rdParty/FreeRTOS/queue.c **** 
 723:../3rdParty/FreeRTOS/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 724:../3rdParty/FreeRTOS/queue.c **** 						{
 725:../3rdParty/FreeRTOS/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 726:../3rdParty/FreeRTOS/queue.c **** 							{
 727:../3rdParty/FreeRTOS/queue.c **** 								/* Record the information required to implement
 728:../3rdParty/FreeRTOS/queue.c **** 								priority inheritance should it become necessary. */
 729:../3rdParty/FreeRTOS/queue.c **** 								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 730:../3rdParty/FreeRTOS/queue.c **** 							}
 731:../3rdParty/FreeRTOS/queue.c **** 						}
 732:../3rdParty/FreeRTOS/queue.c **** 						#endif
 733:../3rdParty/FreeRTOS/queue.c **** 
 734:../3rdParty/FreeRTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 735:../3rdParty/FreeRTOS/queue.c **** 						{
 736:../3rdParty/FreeRTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 737:../3rdParty/FreeRTOS/queue.c **** 							{
 738:../3rdParty/FreeRTOS/queue.c **** 								portYIELD_WITHIN_API();
 739:../3rdParty/FreeRTOS/queue.c **** 							}
 740:../3rdParty/FreeRTOS/queue.c **** 						}
 741:../3rdParty/FreeRTOS/queue.c **** 					}
 742:../3rdParty/FreeRTOS/queue.c **** 					else
 743:../3rdParty/FreeRTOS/queue.c **** 					{
 744:../3rdParty/FreeRTOS/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 745:../3rdParty/FreeRTOS/queue.c **** 
 746:../3rdParty/FreeRTOS/queue.c **** 						/* We are not removing the data, so reset our read
 747:../3rdParty/FreeRTOS/queue.c **** 						pointer. */
 748:../3rdParty/FreeRTOS/queue.c **** 						pxQueue->pcReadFrom = pcOriginalReadPosition;
 749:../3rdParty/FreeRTOS/queue.c **** 
 750:../3rdParty/FreeRTOS/queue.c **** 						/* The data is being left in the queue, so see if there are
 751:../3rdParty/FreeRTOS/queue.c **** 						any other tasks waiting for the data. */
 752:../3rdParty/FreeRTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 753:../3rdParty/FreeRTOS/queue.c **** 						{
 754:../3rdParty/FreeRTOS/queue.c **** 							/* Tasks that are removed from the event list will get added to
 755:../3rdParty/FreeRTOS/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 756:../3rdParty/FreeRTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 757:../3rdParty/FreeRTOS/queue.c **** 							{
 758:../3rdParty/FreeRTOS/queue.c **** 								/* The task waiting has a higher priority than this task. */
 759:../3rdParty/FreeRTOS/queue.c **** 								portYIELD_WITHIN_API();
 760:../3rdParty/FreeRTOS/queue.c **** 							}
 761:../3rdParty/FreeRTOS/queue.c **** 						}
 762:../3rdParty/FreeRTOS/queue.c **** 
 763:../3rdParty/FreeRTOS/queue.c **** 					}
 764:../3rdParty/FreeRTOS/queue.c **** 
 765:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 766:../3rdParty/FreeRTOS/queue.c **** 					return pdPASS;
 767:../3rdParty/FreeRTOS/queue.c **** 				}
 768:../3rdParty/FreeRTOS/queue.c **** 				else
 769:../3rdParty/FreeRTOS/queue.c **** 				{
 770:../3rdParty/FreeRTOS/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 771:../3rdParty/FreeRTOS/queue.c **** 					{
 772:../3rdParty/FreeRTOS/queue.c **** 						taskEXIT_CRITICAL();
 773:../3rdParty/FreeRTOS/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 774:../3rdParty/FreeRTOS/queue.c **** 						return errQUEUE_EMPTY;
 775:../3rdParty/FreeRTOS/queue.c **** 					}
 776:../3rdParty/FreeRTOS/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 777:../3rdParty/FreeRTOS/queue.c **** 					{
 778:../3rdParty/FreeRTOS/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 779:../3rdParty/FreeRTOS/queue.c **** 						xEntryTimeSet = pdTRUE;
 780:../3rdParty/FreeRTOS/queue.c **** 					}
 781:../3rdParty/FreeRTOS/queue.c **** 				}
 782:../3rdParty/FreeRTOS/queue.c **** 			}
 783:../3rdParty/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 784:../3rdParty/FreeRTOS/queue.c **** 
 785:../3rdParty/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 786:../3rdParty/FreeRTOS/queue.c **** 			{
 787:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 788:../3rdParty/FreeRTOS/queue.c **** 				{
 789:../3rdParty/FreeRTOS/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 790:../3rdParty/FreeRTOS/queue.c **** 					{
 791:../3rdParty/FreeRTOS/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 792:../3rdParty/FreeRTOS/queue.c **** 
 793:../3rdParty/FreeRTOS/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 794:../3rdParty/FreeRTOS/queue.c **** 						{
 795:../3rdParty/FreeRTOS/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 796:../3rdParty/FreeRTOS/queue.c **** 							{
 797:../3rdParty/FreeRTOS/queue.c **** 								portENTER_CRITICAL();
 798:../3rdParty/FreeRTOS/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 799:../3rdParty/FreeRTOS/queue.c **** 								portEXIT_CRITICAL();
 800:../3rdParty/FreeRTOS/queue.c **** 							}
 801:../3rdParty/FreeRTOS/queue.c **** 						}
 802:../3rdParty/FreeRTOS/queue.c **** 						#endif
 803:../3rdParty/FreeRTOS/queue.c **** 
 804:../3rdParty/FreeRTOS/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 805:../3rdParty/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 806:../3rdParty/FreeRTOS/queue.c **** 					}
 807:../3rdParty/FreeRTOS/queue.c **** 				}
 808:../3rdParty/FreeRTOS/queue.c **** 				else
 809:../3rdParty/FreeRTOS/queue.c **** 				{
 810:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 811:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 812:../3rdParty/FreeRTOS/queue.c **** 					return errQUEUE_EMPTY;
 813:../3rdParty/FreeRTOS/queue.c **** 				}
 814:../3rdParty/FreeRTOS/queue.c **** 			}
 815:../3rdParty/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 816:../3rdParty/FreeRTOS/queue.c **** 		}
 817:../3rdParty/FreeRTOS/queue.c **** 	}
 818:../3rdParty/FreeRTOS/queue.c **** 
 819:../3rdParty/FreeRTOS/queue.c **** 
 820:../3rdParty/FreeRTOS/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 821:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 822:../3rdParty/FreeRTOS/queue.c **** 
 823:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 824:../3rdParty/FreeRTOS/queue.c **** {
 4613              		.loc 1 824 0
 4614              		.cfi_startproc
 4615              		@ args = 0, pretend = 0, frame = 24
 4616              		@ frame_needed = 1, uses_anonymous_args = 0
 4617 0354 80B5     		push	{r7, lr}
 4618              	.LCFI15:
 4619              		.cfi_def_cfa_offset 8
 4620 0356 86B0     		sub	sp, sp, #24
 4621              	.LCFI16:
 4622              		.cfi_def_cfa_offset 32
 4623 0358 00AF     		add	r7, sp, #0
 4624              		.cfi_offset 14, -4
 4625              		.cfi_offset 7, -8
 4626              	.LCFI17:
 4627              		.cfi_def_cfa_register 7
 4628 035a F860     		str	r0, [r7, #12]
 4629 035c B960     		str	r1, [r7, #8]
 4630 035e 7A60     		str	r2, [r7, #4]
 4631 0360 3B60     		str	r3, [r7, #0]
 825:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
 826:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 827:../3rdParty/FreeRTOS/queue.c **** 
 828:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 829:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxHigherPriorityTaskWoken );
 830:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 831:../3rdParty/FreeRTOS/queue.c **** 
 832:../3rdParty/FreeRTOS/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 833:../3rdParty/FreeRTOS/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 834:../3rdParty/FreeRTOS/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 835:../3rdParty/FreeRTOS/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 836:../3rdParty/FreeRTOS/queue.c **** 	by this	post). */
 837:../3rdParty/FreeRTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4632              		.loc 1 837 0
 4633 0362 4FF00003 		mov	r3, #0
 4634 0366 3B61     		str	r3, [r7, #16]
 4635              	@ 837 "../3rdParty/FreeRTOS/queue.c" 1
 4636 0368 4FF02800 			mov r0, #40								
 4637 036c 80F31188 		msr basepri, r0							
 4638              	
 4639              	@ 0 "" 2
 838:../3rdParty/FreeRTOS/queue.c **** 	{
 839:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 4640              		.loc 1 839 0
 4641              		.thumb
 4642 0370 FB68     		ldr	r3, [r7, #12]
 4643 0372 9A6B     		ldr	r2, [r3, #56]
 4644 0374 FB68     		ldr	r3, [r7, #12]
 4645 0376 DB6B     		ldr	r3, [r3, #60]
 4646 0378 9A42     		cmp	r2, r3
 4647 037a 25D2     		bcs	.L27
 840:../3rdParty/FreeRTOS/queue.c **** 		{
 841:../3rdParty/FreeRTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 842:../3rdParty/FreeRTOS/queue.c **** 
 843:../3rdParty/FreeRTOS/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 4648              		.loc 1 843 0
 4649 037c F868     		ldr	r0, [r7, #12]
 4650 037e B968     		ldr	r1, [r7, #8]
 4651 0380 3A68     		ldr	r2, [r7, #0]
 4652 0382 00F09DF9 		bl	prvCopyDataToQueue
 844:../3rdParty/FreeRTOS/queue.c **** 
 845:../3rdParty/FreeRTOS/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 846:../3rdParty/FreeRTOS/queue.c **** 			be done when the queue is unlocked later. */
 847:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 4653              		.loc 1 847 0
 4654 0386 FB68     		ldr	r3, [r7, #12]
 4655 0388 9B6C     		ldr	r3, [r3, #72]
 4656 038a B3F1FF3F 		cmp	r3, #-1
 4657 038e 11D1     		bne	.L28
 848:../3rdParty/FreeRTOS/queue.c **** 			{
 849:../3rdParty/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4658              		.loc 1 849 0
 4659 0390 FB68     		ldr	r3, [r7, #12]
 4660 0392 5B6A     		ldr	r3, [r3, #36]
 4661 0394 002B     		cmp	r3, #0
 4662 0396 13D0     		beq	.L29
 850:../3rdParty/FreeRTOS/queue.c **** 				{
 851:../3rdParty/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4663              		.loc 1 851 0
 4664 0398 FB68     		ldr	r3, [r7, #12]
 4665 039a 03F12403 		add	r3, r3, #36
 4666 039e 1846     		mov	r0, r3
 4667 03a0 FFF7FEFF 		bl	xTaskRemoveFromEventList
 4668 03a4 0346     		mov	r3, r0
 4669 03a6 002B     		cmp	r3, #0
 4670 03a8 0AD0     		beq	.L29
 852:../3rdParty/FreeRTOS/queue.c **** 					{
 853:../3rdParty/FreeRTOS/queue.c **** 						/* The task waiting has a higher priority so record that a
 854:../3rdParty/FreeRTOS/queue.c **** 						context	switch is required. */
 855:../3rdParty/FreeRTOS/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 4671              		.loc 1 855 0
 4672 03aa 7B68     		ldr	r3, [r7, #4]
 4673 03ac 4FF00102 		mov	r2, #1
 4674 03b0 1A60     		str	r2, [r3, #0]
 4675 03b2 05E0     		b	.L29
 4676              	.L28:
 856:../3rdParty/FreeRTOS/queue.c **** 					}
 857:../3rdParty/FreeRTOS/queue.c **** 				}
 858:../3rdParty/FreeRTOS/queue.c **** 			}
 859:../3rdParty/FreeRTOS/queue.c **** 			else
 860:../3rdParty/FreeRTOS/queue.c **** 			{
 861:../3rdParty/FreeRTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
 862:../3rdParty/FreeRTOS/queue.c **** 				knows that data was posted while it was locked. */
 863:../3rdParty/FreeRTOS/queue.c **** 				++( pxQueue->xTxLock );
 4677              		.loc 1 863 0
 4678 03b4 FB68     		ldr	r3, [r7, #12]
 4679 03b6 9B6C     		ldr	r3, [r3, #72]
 4680 03b8 03F10102 		add	r2, r3, #1
 4681 03bc FB68     		ldr	r3, [r7, #12]
 4682 03be 9A64     		str	r2, [r3, #72]
 4683              	.L29:
 864:../3rdParty/FreeRTOS/queue.c **** 			}
 865:../3rdParty/FreeRTOS/queue.c **** 
 866:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 4684              		.loc 1 866 0
 4685 03c0 4FF00103 		mov	r3, #1
 4686 03c4 7B61     		str	r3, [r7, #20]
 4687 03c6 02E0     		b	.L30
 4688              	.L27:
 867:../3rdParty/FreeRTOS/queue.c **** 		}
 868:../3rdParty/FreeRTOS/queue.c **** 		else
 869:../3rdParty/FreeRTOS/queue.c **** 		{
 870:../3rdParty/FreeRTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 871:../3rdParty/FreeRTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 4689              		.loc 1 871 0
 4690 03c8 4FF00003 		mov	r3, #0
 4691 03cc 7B61     		str	r3, [r7, #20]
 4692              	.L30:
 872:../3rdParty/FreeRTOS/queue.c **** 		}
 873:../3rdParty/FreeRTOS/queue.c **** 	}
 874:../3rdParty/FreeRTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 4693              		.loc 1 874 0
 4694              	@ 874 "../3rdParty/FreeRTOS/queue.c" 1
 4695 03ce 4FF00000 			mov r0, #0					
 4696 03d2 80F31188 		msr basepri, r0				
 4697              	
 4698              	@ 0 "" 2
 875:../3rdParty/FreeRTOS/queue.c **** 
 876:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 4699              		.loc 1 876 0
 4700              		.thumb
 4701 03d6 7B69     		ldr	r3, [r7, #20]
 877:../3rdParty/FreeRTOS/queue.c **** }
 4702              		.loc 1 877 0
 4703 03d8 1846     		mov	r0, r3
 4704 03da 07F11807 		add	r7, r7, #24
 4705 03de BD46     		mov	sp, r7
 4706 03e0 80BD     		pop	{r7, pc}
 4707              		.cfi_endproc
 4708              	.LFE60:
 4710 03e2 00BF     		.align	2
 4711              		.global	xQueueGenericReceive
 4712              		.thumb
 4713              		.thumb_func
 4715              	xQueueGenericReceive:
 4716              	.LFB61:
 878:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 879:../3rdParty/FreeRTOS/queue.c **** 
 880:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 881:../3rdParty/FreeRTOS/queue.c **** {
 4717              		.loc 1 881 0
 4718              		.cfi_startproc
 4719              		@ args = 0, pretend = 0, frame = 32
 4720              		@ frame_needed = 1, uses_anonymous_args = 0
 4721 03e4 80B5     		push	{r7, lr}
 4722              	.LCFI18:
 4723              		.cfi_def_cfa_offset 8
 4724 03e6 88B0     		sub	sp, sp, #32
 4725              	.LCFI19:
 4726              		.cfi_def_cfa_offset 40
 4727 03e8 00AF     		add	r7, sp, #0
 4728              		.cfi_offset 14, -4
 4729              		.cfi_offset 7, -8
 4730              	.LCFI20:
 4731              		.cfi_def_cfa_register 7
 4732 03ea F860     		str	r0, [r7, #12]
 4733 03ec B960     		str	r1, [r7, #8]
 4734 03ee 7A60     		str	r2, [r7, #4]
 4735 03f0 3B60     		str	r3, [r7, #0]
 882:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 4736              		.loc 1 882 0
 4737 03f2 4FF00003 		mov	r3, #0
 4738 03f6 FB61     		str	r3, [r7, #28]
 4739 03f8 00E0     		b	.L45
 4740              	.L46:
 883:../3rdParty/FreeRTOS/queue.c **** xTimeOutType xTimeOut;
 884:../3rdParty/FreeRTOS/queue.c **** signed char *pcOriginalReadPosition;
 885:../3rdParty/FreeRTOS/queue.c **** 
 886:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 887:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 888:../3rdParty/FreeRTOS/queue.c **** 
 889:../3rdParty/FreeRTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 890:../3rdParty/FreeRTOS/queue.c **** 	statements within the function itself.  This is done in the interest
 891:../3rdParty/FreeRTOS/queue.c **** 	of execution time efficiency. */
 892:../3rdParty/FreeRTOS/queue.c **** 
 893:../3rdParty/FreeRTOS/queue.c **** 	for( ;; )
 894:../3rdParty/FreeRTOS/queue.c **** 	{
 895:../3rdParty/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 896:../3rdParty/FreeRTOS/queue.c **** 		{
 897:../3rdParty/FreeRTOS/queue.c **** 			/* Is there data in the queue now?  To be running we must be
 898:../3rdParty/FreeRTOS/queue.c **** 			the highest priority task wanting to access the queue. */
 899:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 900:../3rdParty/FreeRTOS/queue.c **** 			{
 901:../3rdParty/FreeRTOS/queue.c **** 				/* Remember our read position in case we are just peeking. */
 902:../3rdParty/FreeRTOS/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 903:../3rdParty/FreeRTOS/queue.c **** 
 904:../3rdParty/FreeRTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 905:../3rdParty/FreeRTOS/queue.c **** 
 906:../3rdParty/FreeRTOS/queue.c **** 				if( xJustPeeking == pdFALSE )
 907:../3rdParty/FreeRTOS/queue.c **** 				{
 908:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
 909:../3rdParty/FreeRTOS/queue.c **** 
 910:../3rdParty/FreeRTOS/queue.c **** 					/* We are actually removing data. */
 911:../3rdParty/FreeRTOS/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 912:../3rdParty/FreeRTOS/queue.c **** 
 913:../3rdParty/FreeRTOS/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
 914:../3rdParty/FreeRTOS/queue.c **** 					{
 915:../3rdParty/FreeRTOS/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 916:../3rdParty/FreeRTOS/queue.c **** 						{
 917:../3rdParty/FreeRTOS/queue.c **** 							/* Record the information required to implement
 918:../3rdParty/FreeRTOS/queue.c **** 							priority inheritance should it become necessary. */
 919:../3rdParty/FreeRTOS/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 920:../3rdParty/FreeRTOS/queue.c **** 						}
 921:../3rdParty/FreeRTOS/queue.c **** 					}
 922:../3rdParty/FreeRTOS/queue.c **** 					#endif
 923:../3rdParty/FreeRTOS/queue.c **** 
 924:../3rdParty/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 925:../3rdParty/FreeRTOS/queue.c **** 					{
 926:../3rdParty/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 927:../3rdParty/FreeRTOS/queue.c **** 						{
 928:../3rdParty/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 929:../3rdParty/FreeRTOS/queue.c **** 						}
 930:../3rdParty/FreeRTOS/queue.c **** 					}
 931:../3rdParty/FreeRTOS/queue.c **** 				}
 932:../3rdParty/FreeRTOS/queue.c **** 				else
 933:../3rdParty/FreeRTOS/queue.c **** 				{
 934:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_PEEK( pxQueue );
 935:../3rdParty/FreeRTOS/queue.c **** 
 936:../3rdParty/FreeRTOS/queue.c **** 					/* We are not removing the data, so reset our read
 937:../3rdParty/FreeRTOS/queue.c **** 					pointer. */
 938:../3rdParty/FreeRTOS/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 939:../3rdParty/FreeRTOS/queue.c **** 
 940:../3rdParty/FreeRTOS/queue.c **** 					/* The data is being left in the queue, so see if there are
 941:../3rdParty/FreeRTOS/queue.c **** 					any other tasks waiting for the data. */
 942:../3rdParty/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 943:../3rdParty/FreeRTOS/queue.c **** 					{
 944:../3rdParty/FreeRTOS/queue.c **** 						/* Tasks that are removed from the event list will get added to
 945:../3rdParty/FreeRTOS/queue.c **** 						the pending ready list as the scheduler is still suspended. */
 946:../3rdParty/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 947:../3rdParty/FreeRTOS/queue.c **** 						{
 948:../3rdParty/FreeRTOS/queue.c **** 							/* The task waiting has a higher priority than this task. */
 949:../3rdParty/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 950:../3rdParty/FreeRTOS/queue.c **** 						}
 951:../3rdParty/FreeRTOS/queue.c **** 					}
 952:../3rdParty/FreeRTOS/queue.c **** 
 953:../3rdParty/FreeRTOS/queue.c **** 				}
 954:../3rdParty/FreeRTOS/queue.c **** 
 955:../3rdParty/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 956:../3rdParty/FreeRTOS/queue.c **** 				return pdPASS;
 957:../3rdParty/FreeRTOS/queue.c **** 			}
 958:../3rdParty/FreeRTOS/queue.c **** 			else
 959:../3rdParty/FreeRTOS/queue.c **** 			{
 960:../3rdParty/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 961:../3rdParty/FreeRTOS/queue.c **** 				{
 962:../3rdParty/FreeRTOS/queue.c **** 					/* The queue was empty and no block time is specified (or
 963:../3rdParty/FreeRTOS/queue.c **** 					the block time has expired) so leave now. */
 964:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 965:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 966:../3rdParty/FreeRTOS/queue.c **** 					return errQUEUE_EMPTY;
 967:../3rdParty/FreeRTOS/queue.c **** 				}
 968:../3rdParty/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 969:../3rdParty/FreeRTOS/queue.c **** 				{
 970:../3rdParty/FreeRTOS/queue.c **** 					/* The queue was empty and a block time was specified so
 971:../3rdParty/FreeRTOS/queue.c **** 					configure the timeout structure. */
 972:../3rdParty/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 973:../3rdParty/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 974:../3rdParty/FreeRTOS/queue.c **** 				}
 975:../3rdParty/FreeRTOS/queue.c **** 			}
 976:../3rdParty/FreeRTOS/queue.c **** 		}
 977:../3rdParty/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 978:../3rdParty/FreeRTOS/queue.c **** 
 979:../3rdParty/FreeRTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 980:../3rdParty/FreeRTOS/queue.c **** 		now the critical section has been exited. */
 981:../3rdParty/FreeRTOS/queue.c **** 
 982:../3rdParty/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 983:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 984:../3rdParty/FreeRTOS/queue.c **** 
 985:../3rdParty/FreeRTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 986:../3rdParty/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 987:../3rdParty/FreeRTOS/queue.c **** 		{
 988:../3rdParty/FreeRTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 989:../3rdParty/FreeRTOS/queue.c **** 			{
 990:../3rdParty/FreeRTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 991:../3rdParty/FreeRTOS/queue.c **** 
 992:../3rdParty/FreeRTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
 993:../3rdParty/FreeRTOS/queue.c **** 				{
 994:../3rdParty/FreeRTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 995:../3rdParty/FreeRTOS/queue.c **** 					{
 996:../3rdParty/FreeRTOS/queue.c **** 						portENTER_CRITICAL();
 997:../3rdParty/FreeRTOS/queue.c **** 						{
 998:../3rdParty/FreeRTOS/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 999:../3rdParty/FreeRTOS/queue.c **** 						}
1000:../3rdParty/FreeRTOS/queue.c **** 						portEXIT_CRITICAL();
1001:../3rdParty/FreeRTOS/queue.c **** 					}
1002:../3rdParty/FreeRTOS/queue.c **** 				}
1003:../3rdParty/FreeRTOS/queue.c **** 				#endif
1004:../3rdParty/FreeRTOS/queue.c **** 
1005:../3rdParty/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1006:../3rdParty/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
1007:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1008:../3rdParty/FreeRTOS/queue.c **** 				{
1009:../3rdParty/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
1010:../3rdParty/FreeRTOS/queue.c **** 				}
1011:../3rdParty/FreeRTOS/queue.c **** 			}
1012:../3rdParty/FreeRTOS/queue.c **** 			else
1013:../3rdParty/FreeRTOS/queue.c **** 			{
1014:../3rdParty/FreeRTOS/queue.c **** 				/* Try again. */
1015:../3rdParty/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
1016:../3rdParty/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
1017:../3rdParty/FreeRTOS/queue.c **** 			}
1018:../3rdParty/FreeRTOS/queue.c **** 		}
1019:../3rdParty/FreeRTOS/queue.c **** 		else
1020:../3rdParty/FreeRTOS/queue.c **** 		{
1021:../3rdParty/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
1022:../3rdParty/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
1023:../3rdParty/FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1024:../3rdParty/FreeRTOS/queue.c **** 			return errQUEUE_EMPTY;
1025:../3rdParty/FreeRTOS/queue.c **** 		}
1026:../3rdParty/FreeRTOS/queue.c **** 	}
 4741              		.loc 1 1026 0
 4742 03fa 00BF     		nop
 4743              	.L45:
 895:../3rdParty/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 4744              		.loc 1 895 0
 4745 03fc FFF7FEFF 		bl	vPortEnterCritical
 899:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 4746              		.loc 1 899 0
 4747 0400 FB68     		ldr	r3, [r7, #12]
 4748 0402 9B6B     		ldr	r3, [r3, #56]
 4749 0404 002B     		cmp	r3, #0
 4750 0406 40D0     		beq	.L32
 902:../3rdParty/FreeRTOS/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 4751              		.loc 1 902 0
 4752 0408 FB68     		ldr	r3, [r7, #12]
 4753 040a DB68     		ldr	r3, [r3, #12]
 4754 040c BB61     		str	r3, [r7, #24]
 904:../3rdParty/FreeRTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 4755              		.loc 1 904 0
 4756 040e F868     		ldr	r0, [r7, #12]
 4757 0410 B968     		ldr	r1, [r7, #8]
 4758 0412 00F0B7F9 		bl	prvCopyDataFromQueue
 906:../3rdParty/FreeRTOS/queue.c **** 				if( xJustPeeking == pdFALSE )
 4759              		.loc 1 906 0
 4760 0416 3B68     		ldr	r3, [r7, #0]
 4761 0418 002B     		cmp	r3, #0
 4762 041a 1FD1     		bne	.L33
 911:../3rdParty/FreeRTOS/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 4763              		.loc 1 911 0
 4764 041c FB68     		ldr	r3, [r7, #12]
 4765 041e 9B6B     		ldr	r3, [r3, #56]
 4766 0420 03F1FF32 		add	r2, r3, #-1
 4767 0424 FB68     		ldr	r3, [r7, #12]
 4768 0426 9A63     		str	r2, [r3, #56]
 915:../3rdParty/FreeRTOS/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4769              		.loc 1 915 0
 4770 0428 FB68     		ldr	r3, [r7, #12]
 4771 042a 1B68     		ldr	r3, [r3, #0]
 4772 042c 002B     		cmp	r3, #0
 4773 042e 05D1     		bne	.L34
 919:../3rdParty/FreeRTOS/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 4774              		.loc 1 919 0
 4775 0430 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 4776 0434 0346     		mov	r3, r0
 4777 0436 1A46     		mov	r2, r3
 4778 0438 FB68     		ldr	r3, [r7, #12]
 4779 043a 5A60     		str	r2, [r3, #4]
 4780              	.L34:
 924:../3rdParty/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4781              		.loc 1 924 0
 4782 043c FB68     		ldr	r3, [r7, #12]
 4783 043e 1B69     		ldr	r3, [r3, #16]
 4784 0440 002B     		cmp	r3, #0
 4785 0442 1DD0     		beq	.L35
 926:../3rdParty/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 4786              		.loc 1 926 0
 4787 0444 FB68     		ldr	r3, [r7, #12]
 4788 0446 03F11003 		add	r3, r3, #16
 4789 044a 1846     		mov	r0, r3
 4790 044c FFF7FEFF 		bl	xTaskRemoveFromEventList
 4791 0450 0346     		mov	r3, r0
 4792 0452 012B     		cmp	r3, #1
 4793 0454 14D1     		bne	.L35
 928:../3rdParty/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 4794              		.loc 1 928 0
 4795 0456 FFF7FEFF 		bl	vPortYieldFromISR
 4796 045a 11E0     		b	.L35
 4797              	.L33:
 938:../3rdParty/FreeRTOS/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 4798              		.loc 1 938 0
 4799 045c FB68     		ldr	r3, [r7, #12]
 4800 045e BA69     		ldr	r2, [r7, #24]
 4801 0460 DA60     		str	r2, [r3, #12]
 942:../3rdParty/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4802              		.loc 1 942 0
 4803 0462 FB68     		ldr	r3, [r7, #12]
 4804 0464 5B6A     		ldr	r3, [r3, #36]
 4805 0466 002B     		cmp	r3, #0
 4806 0468 0AD0     		beq	.L35
 946:../3rdParty/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4807              		.loc 1 946 0
 4808 046a FB68     		ldr	r3, [r7, #12]
 4809 046c 03F12403 		add	r3, r3, #36
 4810 0470 1846     		mov	r0, r3
 4811 0472 FFF7FEFF 		bl	xTaskRemoveFromEventList
 4812 0476 0346     		mov	r3, r0
 4813 0478 002B     		cmp	r3, #0
 4814 047a 01D0     		beq	.L35
 949:../3rdParty/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 4815              		.loc 1 949 0
 4816 047c FFF7FEFF 		bl	vPortYieldFromISR
 4817              	.L35:
 955:../3rdParty/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 4818              		.loc 1 955 0
 4819 0480 FFF7FEFF 		bl	vPortExitCritical
 956:../3rdParty/FreeRTOS/queue.c **** 				return pdPASS;
 4820              		.loc 1 956 0
 4821 0484 4FF00103 		mov	r3, #1
 4822 0488 6BE0     		b	.L36
 4823              	.L32:
 960:../3rdParty/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 4824              		.loc 1 960 0
 4825 048a 7B68     		ldr	r3, [r7, #4]
 4826 048c 002B     		cmp	r3, #0
 4827 048e 04D1     		bne	.L37
 964:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 4828              		.loc 1 964 0
 4829 0490 FFF7FEFF 		bl	vPortExitCritical
 966:../3rdParty/FreeRTOS/queue.c **** 					return errQUEUE_EMPTY;
 4830              		.loc 1 966 0
 4831 0494 4FF00003 		mov	r3, #0
 4832 0498 63E0     		b	.L36
 4833              	.L37:
 968:../3rdParty/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 4834              		.loc 1 968 0
 4835 049a FB69     		ldr	r3, [r7, #28]
 4836 049c 002B     		cmp	r3, #0
 4837 049e 07D1     		bne	.L38
 972:../3rdParty/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 4838              		.loc 1 972 0
 4839 04a0 07F11003 		add	r3, r7, #16
 4840 04a4 1846     		mov	r0, r3
 4841 04a6 FFF7FEFF 		bl	vTaskSetTimeOutState
 973:../3rdParty/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 4842              		.loc 1 973 0
 4843 04aa 4FF00103 		mov	r3, #1
 4844 04ae FB61     		str	r3, [r7, #28]
 4845              	.L38:
 977:../3rdParty/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 4846              		.loc 1 977 0
 4847 04b0 FFF7FEFF 		bl	vPortExitCritical
 982:../3rdParty/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 4848              		.loc 1 982 0
 4849 04b4 FFF7FEFF 		bl	vTaskSuspendAll
 983:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4850              		.loc 1 983 0
 4851 04b8 FFF7FEFF 		bl	vPortEnterCritical
 4852 04bc FB68     		ldr	r3, [r7, #12]
 4853 04be 5B6C     		ldr	r3, [r3, #68]
 4854 04c0 B3F1FF3F 		cmp	r3, #-1
 4855 04c4 03D1     		bne	.L39
 983:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4856              		.loc 1 983 0 is_stmt 0 discriminator 1
 4857 04c6 FB68     		ldr	r3, [r7, #12]
 4858 04c8 4FF00002 		mov	r2, #0
 4859 04cc 5A64     		str	r2, [r3, #68]
 4860              	.L39:
 983:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4861              		.loc 1 983 0 discriminator 2
 4862 04ce FB68     		ldr	r3, [r7, #12]
 4863 04d0 9B6C     		ldr	r3, [r3, #72]
 4864 04d2 B3F1FF3F 		cmp	r3, #-1
 4865 04d6 03D1     		bne	.L40
 983:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4866              		.loc 1 983 0 discriminator 3
 4867 04d8 FB68     		ldr	r3, [r7, #12]
 4868 04da 4FF00002 		mov	r2, #0
 4869 04de 9A64     		str	r2, [r3, #72]
 4870              	.L40:
 983:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4871              		.loc 1 983 0 discriminator 4
 4872 04e0 FFF7FEFF 		bl	vPortExitCritical
 986:../3rdParty/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4873              		.loc 1 986 0 is_stmt 1 discriminator 4
 4874 04e4 07F11002 		add	r2, r7, #16
 4875 04e8 07F10403 		add	r3, r7, #4
 4876 04ec 1046     		mov	r0, r2
 4877 04ee 1946     		mov	r1, r3
 4878 04f0 FFF7FEFF 		bl	xTaskCheckForTimeOut
 4879 04f4 0346     		mov	r3, r0
 4880 04f6 002B     		cmp	r3, #0
 4881 04f8 2CD1     		bne	.L41
 988:../3rdParty/FreeRTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4882              		.loc 1 988 0
 4883 04fa F868     		ldr	r0, [r7, #12]
 4884 04fc 00F0BAF9 		bl	prvIsQueueEmpty
 4885 0500 0346     		mov	r3, r0
 4886 0502 002B     		cmp	r3, #0
 4887 0504 20D0     		beq	.L42
 994:../3rdParty/FreeRTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4888              		.loc 1 994 0
 4889 0506 FB68     		ldr	r3, [r7, #12]
 4890 0508 1B68     		ldr	r3, [r3, #0]
 4891 050a 002B     		cmp	r3, #0
 4892 050c 08D1     		bne	.L43
 996:../3rdParty/FreeRTOS/queue.c **** 						portENTER_CRITICAL();
 4893              		.loc 1 996 0
 4894 050e FFF7FEFF 		bl	vPortEnterCritical
 998:../3rdParty/FreeRTOS/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 4895              		.loc 1 998 0
 4896 0512 FB68     		ldr	r3, [r7, #12]
 4897 0514 5B68     		ldr	r3, [r3, #4]
 4898 0516 1846     		mov	r0, r3
 4899 0518 FFF7FEFF 		bl	vTaskPriorityInherit
1000:../3rdParty/FreeRTOS/queue.c **** 						portEXIT_CRITICAL();
 4900              		.loc 1 1000 0
 4901 051c FFF7FEFF 		bl	vPortExitCritical
 4902              	.L43:
1005:../3rdParty/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 4903              		.loc 1 1005 0
 4904 0520 FB68     		ldr	r3, [r7, #12]
 4905 0522 03F12402 		add	r2, r3, #36
 4906 0526 7B68     		ldr	r3, [r7, #4]
 4907 0528 1046     		mov	r0, r2
 4908 052a 1946     		mov	r1, r3
 4909 052c FFF7FEFF 		bl	vTaskPlaceOnEventList
1006:../3rdParty/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 4910              		.loc 1 1006 0
 4911 0530 F868     		ldr	r0, [r7, #12]
 4912 0532 00F04FF9 		bl	prvUnlockQueue
1007:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 4913              		.loc 1 1007 0
 4914 0536 FFF7FEFF 		bl	xTaskResumeAll
 4915 053a 0346     		mov	r3, r0
 4916 053c 002B     		cmp	r3, #0
 4917 053e 7FF45CAF 		bne	.L46
1009:../3rdParty/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
 4918              		.loc 1 1009 0
 4919 0542 FFF7FEFF 		bl	vPortYieldFromISR
 4920              		.loc 1 1026 0
 4921 0546 59E7     		b	.L45
 4922              	.L42:
1015:../3rdParty/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 4923              		.loc 1 1015 0
 4924 0548 F868     		ldr	r0, [r7, #12]
 4925 054a 00F043F9 		bl	prvUnlockQueue
1016:../3rdParty/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
 4926              		.loc 1 1016 0
 4927 054e FFF7FEFF 		bl	xTaskResumeAll
 4928              		.loc 1 1026 0
 4929 0552 53E7     		b	.L45
 4930              	.L41:
1021:../3rdParty/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 4931              		.loc 1 1021 0
 4932 0554 F868     		ldr	r0, [r7, #12]
 4933 0556 00F03DF9 		bl	prvUnlockQueue
1022:../3rdParty/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
 4934              		.loc 1 1022 0
 4935 055a FFF7FEFF 		bl	xTaskResumeAll
1024:../3rdParty/FreeRTOS/queue.c **** 			return errQUEUE_EMPTY;
 4936              		.loc 1 1024 0
 4937 055e 4FF00003 		mov	r3, #0
 4938              	.L36:
1027:../3rdParty/FreeRTOS/queue.c **** }
 4939              		.loc 1 1027 0
 4940 0562 1846     		mov	r0, r3
 4941 0564 07F12007 		add	r7, r7, #32
 4942 0568 BD46     		mov	sp, r7
 4943 056a 80BD     		pop	{r7, pc}
 4944              		.cfi_endproc
 4945              	.LFE61:
 4947              		.align	2
 4948              		.global	xQueueReceiveFromISR
 4949              		.thumb
 4950              		.thumb_func
 4952              	xQueueReceiveFromISR:
 4953              	.LFB62:
1028:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1029:../3rdParty/FreeRTOS/queue.c **** 
1030:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
1031:../3rdParty/FreeRTOS/queue.c **** {
 4954              		.loc 1 1031 0
 4955              		.cfi_startproc
 4956              		@ args = 0, pretend = 0, frame = 24
 4957              		@ frame_needed = 1, uses_anonymous_args = 0
 4958 056c 80B5     		push	{r7, lr}
 4959              	.LCFI21:
 4960              		.cfi_def_cfa_offset 8
 4961 056e 86B0     		sub	sp, sp, #24
 4962              	.LCFI22:
 4963              		.cfi_def_cfa_offset 32
 4964 0570 00AF     		add	r7, sp, #0
 4965              		.cfi_offset 14, -4
 4966              		.cfi_offset 7, -8
 4967              	.LCFI23:
 4968              		.cfi_def_cfa_register 7
 4969 0572 F860     		str	r0, [r7, #12]
 4970 0574 B960     		str	r1, [r7, #8]
 4971 0576 7A60     		str	r2, [r7, #4]
1032:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1033:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1034:../3rdParty/FreeRTOS/queue.c **** 
1035:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1036:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxTaskWoken );
1037:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
1038:../3rdParty/FreeRTOS/queue.c **** 
1039:../3rdParty/FreeRTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4972              		.loc 1 1039 0
 4973 0578 4FF00003 		mov	r3, #0
 4974 057c 3B61     		str	r3, [r7, #16]
 4975              	@ 1039 "../3rdParty/FreeRTOS/queue.c" 1
 4976 057e 4FF02800 			mov r0, #40								
 4977 0582 80F31188 		msr basepri, r0							
 4978              	
 4979              	@ 0 "" 2
1040:../3rdParty/FreeRTOS/queue.c **** 	{
1041:../3rdParty/FreeRTOS/queue.c **** 		/* We cannot block from an ISR, so check there is data available. */
1042:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 4980              		.loc 1 1042 0
 4981              		.thumb
 4982 0586 FB68     		ldr	r3, [r7, #12]
 4983 0588 9B6B     		ldr	r3, [r3, #56]
 4984 058a 002B     		cmp	r3, #0
 4985 058c 2AD0     		beq	.L48
1043:../3rdParty/FreeRTOS/queue.c **** 		{
1044:../3rdParty/FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1045:../3rdParty/FreeRTOS/queue.c **** 
1046:../3rdParty/FreeRTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 4986              		.loc 1 1046 0
 4987 058e F868     		ldr	r0, [r7, #12]
 4988 0590 B968     		ldr	r1, [r7, #8]
 4989 0592 00F0F7F8 		bl	prvCopyDataFromQueue
1047:../3rdParty/FreeRTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 4990              		.loc 1 1047 0
 4991 0596 FB68     		ldr	r3, [r7, #12]
 4992 0598 9B6B     		ldr	r3, [r3, #56]
 4993 059a 03F1FF32 		add	r2, r3, #-1
 4994 059e FB68     		ldr	r3, [r7, #12]
 4995 05a0 9A63     		str	r2, [r3, #56]
1048:../3rdParty/FreeRTOS/queue.c **** 
1049:../3rdParty/FreeRTOS/queue.c **** 			/* If the queue is locked we will not modify the event list.  Instead
1050:../3rdParty/FreeRTOS/queue.c **** 			we update the lock count so the task that unlocks the queue will know
1051:../3rdParty/FreeRTOS/queue.c **** 			that an ISR has removed data while the queue was locked. */
1052:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 4996              		.loc 1 1052 0
 4997 05a2 FB68     		ldr	r3, [r7, #12]
 4998 05a4 5B6C     		ldr	r3, [r3, #68]
 4999 05a6 B3F1FF3F 		cmp	r3, #-1
 5000 05aa 11D1     		bne	.L49
1053:../3rdParty/FreeRTOS/queue.c **** 			{
1054:../3rdParty/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 5001              		.loc 1 1054 0
 5002 05ac FB68     		ldr	r3, [r7, #12]
 5003 05ae 1B69     		ldr	r3, [r3, #16]
 5004 05b0 002B     		cmp	r3, #0
 5005 05b2 13D0     		beq	.L50
1055:../3rdParty/FreeRTOS/queue.c **** 				{
1056:../3rdParty/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 5006              		.loc 1 1056 0
 5007 05b4 FB68     		ldr	r3, [r7, #12]
 5008 05b6 03F11003 		add	r3, r3, #16
 5009 05ba 1846     		mov	r0, r3
 5010 05bc FFF7FEFF 		bl	xTaskRemoveFromEventList
 5011 05c0 0346     		mov	r3, r0
 5012 05c2 002B     		cmp	r3, #0
 5013 05c4 0AD0     		beq	.L50
1057:../3rdParty/FreeRTOS/queue.c **** 					{
1058:../3rdParty/FreeRTOS/queue.c **** 						/* The task waiting has a higher priority than us so
1059:../3rdParty/FreeRTOS/queue.c **** 						force a context switch. */
1060:../3rdParty/FreeRTOS/queue.c **** 						*pxTaskWoken = pdTRUE;
 5014              		.loc 1 1060 0
 5015 05c6 7B68     		ldr	r3, [r7, #4]
 5016 05c8 4FF00102 		mov	r2, #1
 5017 05cc 1A60     		str	r2, [r3, #0]
 5018 05ce 05E0     		b	.L50
 5019              	.L49:
1061:../3rdParty/FreeRTOS/queue.c **** 					}
1062:../3rdParty/FreeRTOS/queue.c **** 				}
1063:../3rdParty/FreeRTOS/queue.c **** 			}
1064:../3rdParty/FreeRTOS/queue.c **** 			else
1065:../3rdParty/FreeRTOS/queue.c **** 			{
1066:../3rdParty/FreeRTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1067:../3rdParty/FreeRTOS/queue.c **** 				knows that data was removed while it was locked. */
1068:../3rdParty/FreeRTOS/queue.c **** 				++( pxQueue->xRxLock );
 5020              		.loc 1 1068 0
 5021 05d0 FB68     		ldr	r3, [r7, #12]
 5022 05d2 5B6C     		ldr	r3, [r3, #68]
 5023 05d4 03F10102 		add	r2, r3, #1
 5024 05d8 FB68     		ldr	r3, [r7, #12]
 5025 05da 5A64     		str	r2, [r3, #68]
 5026              	.L50:
1069:../3rdParty/FreeRTOS/queue.c **** 			}
1070:../3rdParty/FreeRTOS/queue.c **** 
1071:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 5027              		.loc 1 1071 0
 5028 05dc 4FF00103 		mov	r3, #1
 5029 05e0 7B61     		str	r3, [r7, #20]
 5030 05e2 02E0     		b	.L51
 5031              	.L48:
1072:../3rdParty/FreeRTOS/queue.c **** 		}
1073:../3rdParty/FreeRTOS/queue.c **** 		else
1074:../3rdParty/FreeRTOS/queue.c **** 		{
1075:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdFAIL;
 5032              		.loc 1 1075 0
 5033 05e4 4FF00003 		mov	r3, #0
 5034 05e8 7B61     		str	r3, [r7, #20]
 5035              	.L51:
1076:../3rdParty/FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1077:../3rdParty/FreeRTOS/queue.c **** 		}
1078:../3rdParty/FreeRTOS/queue.c **** 	}
1079:../3rdParty/FreeRTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 5036              		.loc 1 1079 0
 5037              	@ 1079 "../3rdParty/FreeRTOS/queue.c" 1
 5038 05ea 4FF00000 			mov r0, #0					
 5039 05ee 80F31188 		msr basepri, r0				
 5040              	
 5041              	@ 0 "" 2
1080:../3rdParty/FreeRTOS/queue.c **** 
1081:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 5042              		.loc 1 1081 0
 5043              		.thumb
 5044 05f2 7B69     		ldr	r3, [r7, #20]
1082:../3rdParty/FreeRTOS/queue.c **** }
 5045              		.loc 1 1082 0
 5046 05f4 1846     		mov	r0, r3
 5047 05f6 07F11807 		add	r7, r7, #24
 5048 05fa BD46     		mov	sp, r7
 5049 05fc 80BD     		pop	{r7, pc}
 5050              		.cfi_endproc
 5051              	.LFE62:
 5053 05fe 00BF     		.align	2
 5054              		.global	uxQueueMessagesWaiting
 5055              		.thumb
 5056              		.thumb_func
 5058              	uxQueueMessagesWaiting:
 5059              	.LFB63:
1083:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1084:../3rdParty/FreeRTOS/queue.c **** 
1085:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
1086:../3rdParty/FreeRTOS/queue.c **** {
 5060              		.loc 1 1086 0
 5061              		.cfi_startproc
 5062              		@ args = 0, pretend = 0, frame = 16
 5063              		@ frame_needed = 1, uses_anonymous_args = 0
 5064 0600 80B5     		push	{r7, lr}
 5065              	.LCFI24:
 5066              		.cfi_def_cfa_offset 8
 5067 0602 84B0     		sub	sp, sp, #16
 5068              	.LCFI25:
 5069              		.cfi_def_cfa_offset 24
 5070 0604 00AF     		add	r7, sp, #0
 5071              		.cfi_offset 14, -4
 5072              		.cfi_offset 7, -8
 5073              	.LCFI26:
 5074              		.cfi_def_cfa_register 7
 5075 0606 7860     		str	r0, [r7, #4]
1087:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxReturn;
1088:../3rdParty/FreeRTOS/queue.c **** 
1089:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1090:../3rdParty/FreeRTOS/queue.c **** 
1091:../3rdParty/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 5076              		.loc 1 1091 0
 5077 0608 FFF7FEFF 		bl	vPortEnterCritical
1092:../3rdParty/FreeRTOS/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
 5078              		.loc 1 1092 0
 5079 060c 7B68     		ldr	r3, [r7, #4]
 5080 060e 9B6B     		ldr	r3, [r3, #56]
 5081 0610 FB60     		str	r3, [r7, #12]
1093:../3rdParty/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 5082              		.loc 1 1093 0
 5083 0612 FFF7FEFF 		bl	vPortExitCritical
1094:../3rdParty/FreeRTOS/queue.c **** 
1095:../3rdParty/FreeRTOS/queue.c **** 	return uxReturn;
 5084              		.loc 1 1095 0
 5085 0616 FB68     		ldr	r3, [r7, #12]
1096:../3rdParty/FreeRTOS/queue.c **** }
 5086              		.loc 1 1096 0
 5087 0618 1846     		mov	r0, r3
 5088 061a 07F11007 		add	r7, r7, #16
 5089 061e BD46     		mov	sp, r7
 5090 0620 80BD     		pop	{r7, pc}
 5091              		.cfi_endproc
 5092              	.LFE63:
 5094 0622 00BF     		.align	2
 5095              		.global	uxQueueMessagesWaitingFromISR
 5096              		.thumb
 5097              		.thumb_func
 5099              	uxQueueMessagesWaitingFromISR:
 5100              	.LFB64:
1097:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1098:../3rdParty/FreeRTOS/queue.c **** 
1099:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
1100:../3rdParty/FreeRTOS/queue.c **** {
 5101              		.loc 1 1100 0
 5102              		.cfi_startproc
 5103              		@ args = 0, pretend = 0, frame = 16
 5104              		@ frame_needed = 1, uses_anonymous_args = 0
 5105              		@ link register save eliminated.
 5106 0624 80B4     		push	{r7}
 5107              	.LCFI27:
 5108              		.cfi_def_cfa_offset 4
 5109 0626 85B0     		sub	sp, sp, #20
 5110              	.LCFI28:
 5111              		.cfi_def_cfa_offset 24
 5112 0628 00AF     		add	r7, sp, #0
 5113              		.cfi_offset 7, -4
 5114              	.LCFI29:
 5115              		.cfi_def_cfa_register 7
 5116 062a 7860     		str	r0, [r7, #4]
1101:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxReturn;
1102:../3rdParty/FreeRTOS/queue.c **** 
1103:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1104:../3rdParty/FreeRTOS/queue.c **** 
1105:../3rdParty/FreeRTOS/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 5117              		.loc 1 1105 0
 5118 062c 7B68     		ldr	r3, [r7, #4]
 5119 062e 9B6B     		ldr	r3, [r3, #56]
 5120 0630 FB60     		str	r3, [r7, #12]
1106:../3rdParty/FreeRTOS/queue.c **** 
1107:../3rdParty/FreeRTOS/queue.c **** 	return uxReturn;
 5121              		.loc 1 1107 0
 5122 0632 FB68     		ldr	r3, [r7, #12]
1108:../3rdParty/FreeRTOS/queue.c **** }
 5123              		.loc 1 1108 0
 5124 0634 1846     		mov	r0, r3
 5125 0636 07F11407 		add	r7, r7, #20
 5126 063a BD46     		mov	sp, r7
 5127 063c 80BC     		pop	{r7}
 5128 063e 7047     		bx	lr
 5129              		.cfi_endproc
 5130              	.LFE64:
 5132              		.align	2
 5133              		.global	vQueueDelete
 5134              		.thumb
 5135              		.thumb_func
 5137              	vQueueDelete:
 5138              	.LFB65:
1109:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1110:../3rdParty/FreeRTOS/queue.c **** 
1111:../3rdParty/FreeRTOS/queue.c **** void vQueueDelete( xQueueHandle pxQueue )
1112:../3rdParty/FreeRTOS/queue.c **** {
 5139              		.loc 1 1112 0
 5140              		.cfi_startproc
 5141              		@ args = 0, pretend = 0, frame = 8
 5142              		@ frame_needed = 1, uses_anonymous_args = 0
 5143 0640 80B5     		push	{r7, lr}
 5144              	.LCFI30:
 5145              		.cfi_def_cfa_offset 8
 5146 0642 82B0     		sub	sp, sp, #8
 5147              	.LCFI31:
 5148              		.cfi_def_cfa_offset 16
 5149 0644 00AF     		add	r7, sp, #0
 5150              		.cfi_offset 14, -4
 5151              		.cfi_offset 7, -8
 5152              	.LCFI32:
 5153              		.cfi_def_cfa_register 7
 5154 0646 7860     		str	r0, [r7, #4]
1113:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1114:../3rdParty/FreeRTOS/queue.c **** 
1115:../3rdParty/FreeRTOS/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1116:../3rdParty/FreeRTOS/queue.c **** 	vQueueUnregisterQueue( pxQueue );
 5155              		.loc 1 1116 0
 5156 0648 7868     		ldr	r0, [r7, #4]
 5157 064a 00F091F9 		bl	vQueueUnregisterQueue
1117:../3rdParty/FreeRTOS/queue.c **** 	vPortFree( pxQueue->pcHead );
 5158              		.loc 1 1117 0
 5159 064e 7B68     		ldr	r3, [r7, #4]
 5160 0650 1B68     		ldr	r3, [r3, #0]
 5161 0652 1846     		mov	r0, r3
 5162 0654 FFF7FEFF 		bl	vPortFree
1118:../3rdParty/FreeRTOS/queue.c **** 	vPortFree( pxQueue );
 5163              		.loc 1 1118 0
 5164 0658 7868     		ldr	r0, [r7, #4]
 5165 065a FFF7FEFF 		bl	vPortFree
1119:../3rdParty/FreeRTOS/queue.c **** }
 5166              		.loc 1 1119 0
 5167 065e 07F10807 		add	r7, r7, #8
 5168 0662 BD46     		mov	sp, r7
 5169 0664 80BD     		pop	{r7, pc}
 5170              		.cfi_endproc
 5171              	.LFE65:
 5173 0666 00BF     		.align	2
 5174              		.global	ucQueueGetQueueNumber
 5175              		.thumb
 5176              		.thumb_func
 5178              	ucQueueGetQueueNumber:
 5179              	.LFB66:
1120:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1121:../3rdParty/FreeRTOS/queue.c **** 
1122:../3rdParty/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1123:../3rdParty/FreeRTOS/queue.c **** 
1124:../3rdParty/FreeRTOS/queue.c **** 	unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue )
1125:../3rdParty/FreeRTOS/queue.c **** 	{
 5180              		.loc 1 1125 0
 5181              		.cfi_startproc
 5182              		@ args = 0, pretend = 0, frame = 8
 5183              		@ frame_needed = 1, uses_anonymous_args = 0
 5184              		@ link register save eliminated.
 5185 0668 80B4     		push	{r7}
 5186              	.LCFI33:
 5187              		.cfi_def_cfa_offset 4
 5188 066a 83B0     		sub	sp, sp, #12
 5189              	.LCFI34:
 5190              		.cfi_def_cfa_offset 16
 5191 066c 00AF     		add	r7, sp, #0
 5192              		.cfi_offset 7, -4
 5193              	.LCFI35:
 5194              		.cfi_def_cfa_register 7
 5195 066e 7860     		str	r0, [r7, #4]
1126:../3rdParty/FreeRTOS/queue.c **** 		return pxQueue->ucQueueNumber;
 5196              		.loc 1 1126 0
 5197 0670 7B68     		ldr	r3, [r7, #4]
 5198 0672 93F84C30 		ldrb	r3, [r3, #76]	@ zero_extendqisi2
1127:../3rdParty/FreeRTOS/queue.c **** 	}
 5199              		.loc 1 1127 0
 5200 0676 1846     		mov	r0, r3
 5201 0678 07F10C07 		add	r7, r7, #12
 5202 067c BD46     		mov	sp, r7
 5203 067e 80BC     		pop	{r7}
 5204 0680 7047     		bx	lr
 5205              		.cfi_endproc
 5206              	.LFE66:
 5208 0682 00BF     		.align	2
 5209              		.global	vQueueSetQueueNumber
 5210              		.thumb
 5211              		.thumb_func
 5213              	vQueueSetQueueNumber:
 5214              	.LFB67:
1128:../3rdParty/FreeRTOS/queue.c **** 
1129:../3rdParty/FreeRTOS/queue.c **** #endif
1130:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1131:../3rdParty/FreeRTOS/queue.c **** 
1132:../3rdParty/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1133:../3rdParty/FreeRTOS/queue.c **** 
1134:../3rdParty/FreeRTOS/queue.c **** 	void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber )
1135:../3rdParty/FreeRTOS/queue.c **** 	{
 5215              		.loc 1 1135 0
 5216              		.cfi_startproc
 5217              		@ args = 0, pretend = 0, frame = 8
 5218              		@ frame_needed = 1, uses_anonymous_args = 0
 5219              		@ link register save eliminated.
 5220 0684 80B4     		push	{r7}
 5221              	.LCFI36:
 5222              		.cfi_def_cfa_offset 4
 5223 0686 83B0     		sub	sp, sp, #12
 5224              	.LCFI37:
 5225              		.cfi_def_cfa_offset 16
 5226 0688 00AF     		add	r7, sp, #0
 5227              		.cfi_offset 7, -4
 5228              	.LCFI38:
 5229              		.cfi_def_cfa_register 7
 5230 068a 7860     		str	r0, [r7, #4]
 5231 068c 0B46     		mov	r3, r1
 5232 068e FB70     		strb	r3, [r7, #3]
1136:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->ucQueueNumber = ucQueueNumber;
 5233              		.loc 1 1136 0
 5234 0690 7B68     		ldr	r3, [r7, #4]
 5235 0692 FA78     		ldrb	r2, [r7, #3]
 5236 0694 83F84C20 		strb	r2, [r3, #76]
1137:../3rdParty/FreeRTOS/queue.c **** 	}
 5237              		.loc 1 1137 0
 5238 0698 07F10C07 		add	r7, r7, #12
 5239 069c BD46     		mov	sp, r7
 5240 069e 80BC     		pop	{r7}
 5241 06a0 7047     		bx	lr
 5242              		.cfi_endproc
 5243              	.LFE67:
 5245 06a2 00BF     		.align	2
 5246              		.global	ucQueueGetQueueType
 5247              		.thumb
 5248              		.thumb_func
 5250              	ucQueueGetQueueType:
 5251              	.LFB68:
1138:../3rdParty/FreeRTOS/queue.c **** 
1139:../3rdParty/FreeRTOS/queue.c **** #endif
1140:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1141:../3rdParty/FreeRTOS/queue.c **** 
1142:../3rdParty/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1143:../3rdParty/FreeRTOS/queue.c **** 
1144:../3rdParty/FreeRTOS/queue.c **** 	unsigned char ucQueueGetQueueType( xQueueHandle pxQueue )
1145:../3rdParty/FreeRTOS/queue.c **** 	{
 5252              		.loc 1 1145 0
 5253              		.cfi_startproc
 5254              		@ args = 0, pretend = 0, frame = 8
 5255              		@ frame_needed = 1, uses_anonymous_args = 0
 5256              		@ link register save eliminated.
 5257 06a4 80B4     		push	{r7}
 5258              	.LCFI39:
 5259              		.cfi_def_cfa_offset 4
 5260 06a6 83B0     		sub	sp, sp, #12
 5261              	.LCFI40:
 5262              		.cfi_def_cfa_offset 16
 5263 06a8 00AF     		add	r7, sp, #0
 5264              		.cfi_offset 7, -4
 5265              	.LCFI41:
 5266              		.cfi_def_cfa_register 7
 5267 06aa 7860     		str	r0, [r7, #4]
1146:../3rdParty/FreeRTOS/queue.c **** 		return pxQueue->ucQueueType;
 5268              		.loc 1 1146 0
 5269 06ac 7B68     		ldr	r3, [r7, #4]
 5270 06ae 93F84D30 		ldrb	r3, [r3, #77]	@ zero_extendqisi2
1147:../3rdParty/FreeRTOS/queue.c **** 	}
 5271              		.loc 1 1147 0
 5272 06b2 1846     		mov	r0, r3
 5273 06b4 07F10C07 		add	r7, r7, #12
 5274 06b8 BD46     		mov	sp, r7
 5275 06ba 80BC     		pop	{r7}
 5276 06bc 7047     		bx	lr
 5277              		.cfi_endproc
 5278              	.LFE68:
 5280 06be 00BF     		.align	2
 5281              		.thumb
 5282              		.thumb_func
 5284              	prvCopyDataToQueue:
 5285              	.LFB69:
1148:../3rdParty/FreeRTOS/queue.c **** 
1149:../3rdParty/FreeRTOS/queue.c **** #endif
1150:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1151:../3rdParty/FreeRTOS/queue.c **** 
1152:../3rdParty/FreeRTOS/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1153:../3rdParty/FreeRTOS/queue.c **** {
 5286              		.loc 1 1153 0
 5287              		.cfi_startproc
 5288              		@ args = 0, pretend = 0, frame = 16
 5289              		@ frame_needed = 1, uses_anonymous_args = 0
 5290 06c0 80B5     		push	{r7, lr}
 5291              	.LCFI42:
 5292              		.cfi_def_cfa_offset 8
 5293 06c2 84B0     		sub	sp, sp, #16
 5294              	.LCFI43:
 5295              		.cfi_def_cfa_offset 24
 5296 06c4 00AF     		add	r7, sp, #0
 5297              		.cfi_offset 14, -4
 5298              		.cfi_offset 7, -8
 5299              	.LCFI44:
 5300              		.cfi_def_cfa_register 7
 5301 06c6 F860     		str	r0, [r7, #12]
 5302 06c8 B960     		str	r1, [r7, #8]
 5303 06ca 7A60     		str	r2, [r7, #4]
1154:../3rdParty/FreeRTOS/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 5304              		.loc 1 1154 0
 5305 06cc FB68     		ldr	r3, [r7, #12]
 5306 06ce 1B6C     		ldr	r3, [r3, #64]
 5307 06d0 002B     		cmp	r3, #0
 5308 06d2 0DD1     		bne	.L59
1155:../3rdParty/FreeRTOS/queue.c **** 	{
1156:../3rdParty/FreeRTOS/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1157:../3rdParty/FreeRTOS/queue.c **** 		{
1158:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 5309              		.loc 1 1158 0
 5310 06d4 FB68     		ldr	r3, [r7, #12]
 5311 06d6 1B68     		ldr	r3, [r3, #0]
 5312 06d8 002B     		cmp	r3, #0
 5313 06da 48D1     		bne	.L60
1159:../3rdParty/FreeRTOS/queue.c **** 			{
1160:../3rdParty/FreeRTOS/queue.c **** 				/* The mutex is no longer being held. */
1161:../3rdParty/FreeRTOS/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 5314              		.loc 1 1161 0
 5315 06dc FB68     		ldr	r3, [r7, #12]
 5316 06de 5B68     		ldr	r3, [r3, #4]
 5317 06e0 1846     		mov	r0, r3
 5318 06e2 FFF7FEFF 		bl	vTaskPriorityDisinherit
1162:../3rdParty/FreeRTOS/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 5319              		.loc 1 1162 0
 5320 06e6 FB68     		ldr	r3, [r7, #12]
 5321 06e8 4FF00002 		mov	r2, #0
 5322 06ec 5A60     		str	r2, [r3, #4]
 5323 06ee 3EE0     		b	.L60
 5324              	.L59:
1163:../3rdParty/FreeRTOS/queue.c **** 			}
1164:../3rdParty/FreeRTOS/queue.c **** 		}
1165:../3rdParty/FreeRTOS/queue.c **** 		#endif
1166:../3rdParty/FreeRTOS/queue.c **** 	}
1167:../3rdParty/FreeRTOS/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 5325              		.loc 1 1167 0
 5326 06f0 7B68     		ldr	r3, [r7, #4]
 5327 06f2 002B     		cmp	r3, #0
 5328 06f4 1AD1     		bne	.L61
1168:../3rdParty/FreeRTOS/queue.c **** 	{
1169:../3rdParty/FreeRTOS/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 5329              		.loc 1 1169 0
 5330 06f6 FB68     		ldr	r3, [r7, #12]
 5331 06f8 9A68     		ldr	r2, [r3, #8]
 5332 06fa FB68     		ldr	r3, [r7, #12]
 5333 06fc 1B6C     		ldr	r3, [r3, #64]
 5334 06fe 1046     		mov	r0, r2
 5335 0700 B968     		ldr	r1, [r7, #8]
 5336 0702 1A46     		mov	r2, r3
 5337 0704 FFF7FEFF 		bl	memcpy
1170:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 5338              		.loc 1 1170 0
 5339 0708 FB68     		ldr	r3, [r7, #12]
 5340 070a 9A68     		ldr	r2, [r3, #8]
 5341 070c FB68     		ldr	r3, [r7, #12]
 5342 070e 1B6C     		ldr	r3, [r3, #64]
 5343 0710 D218     		adds	r2, r2, r3
 5344 0712 FB68     		ldr	r3, [r7, #12]
 5345 0714 9A60     		str	r2, [r3, #8]
1171:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 5346              		.loc 1 1171 0
 5347 0716 FB68     		ldr	r3, [r7, #12]
 5348 0718 9A68     		ldr	r2, [r3, #8]
 5349 071a FB68     		ldr	r3, [r7, #12]
 5350 071c 5B68     		ldr	r3, [r3, #4]
 5351 071e 9A42     		cmp	r2, r3
 5352 0720 25D3     		bcc	.L60
1172:../3rdParty/FreeRTOS/queue.c **** 		{
1173:../3rdParty/FreeRTOS/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 5353              		.loc 1 1173 0
 5354 0722 FB68     		ldr	r3, [r7, #12]
 5355 0724 1A68     		ldr	r2, [r3, #0]
 5356 0726 FB68     		ldr	r3, [r7, #12]
 5357 0728 9A60     		str	r2, [r3, #8]
 5358 072a 20E0     		b	.L60
 5359              	.L61:
1174:../3rdParty/FreeRTOS/queue.c **** 		}
1175:../3rdParty/FreeRTOS/queue.c **** 	}
1176:../3rdParty/FreeRTOS/queue.c **** 	else
1177:../3rdParty/FreeRTOS/queue.c **** 	{
1178:../3rdParty/FreeRTOS/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 5360              		.loc 1 1178 0
 5361 072c FB68     		ldr	r3, [r7, #12]
 5362 072e DA68     		ldr	r2, [r3, #12]
 5363 0730 FB68     		ldr	r3, [r7, #12]
 5364 0732 1B6C     		ldr	r3, [r3, #64]
 5365 0734 1046     		mov	r0, r2
 5366 0736 B968     		ldr	r1, [r7, #8]
 5367 0738 1A46     		mov	r2, r3
 5368 073a FFF7FEFF 		bl	memcpy
1179:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 5369              		.loc 1 1179 0
 5370 073e FB68     		ldr	r3, [r7, #12]
 5371 0740 DA68     		ldr	r2, [r3, #12]
 5372 0742 FB68     		ldr	r3, [r7, #12]
 5373 0744 1B6C     		ldr	r3, [r3, #64]
 5374 0746 C3F10003 		rsb	r3, r3, #0
 5375 074a D218     		adds	r2, r2, r3
 5376 074c FB68     		ldr	r3, [r7, #12]
 5377 074e DA60     		str	r2, [r3, #12]
1180:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 5378              		.loc 1 1180 0
 5379 0750 FB68     		ldr	r3, [r7, #12]
 5380 0752 DA68     		ldr	r2, [r3, #12]
 5381 0754 FB68     		ldr	r3, [r7, #12]
 5382 0756 1B68     		ldr	r3, [r3, #0]
 5383 0758 9A42     		cmp	r2, r3
 5384 075a 08D2     		bcs	.L60
1181:../3rdParty/FreeRTOS/queue.c **** 		{
1182:../3rdParty/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 5385              		.loc 1 1182 0
 5386 075c FB68     		ldr	r3, [r7, #12]
 5387 075e 5A68     		ldr	r2, [r3, #4]
 5388 0760 FB68     		ldr	r3, [r7, #12]
 5389 0762 1B6C     		ldr	r3, [r3, #64]
 5390 0764 C3F10003 		rsb	r3, r3, #0
 5391 0768 D218     		adds	r2, r2, r3
 5392 076a FB68     		ldr	r3, [r7, #12]
 5393 076c DA60     		str	r2, [r3, #12]
 5394              	.L60:
1183:../3rdParty/FreeRTOS/queue.c **** 		}
1184:../3rdParty/FreeRTOS/queue.c **** 	}
1185:../3rdParty/FreeRTOS/queue.c **** 
1186:../3rdParty/FreeRTOS/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 5395              		.loc 1 1186 0
 5396 076e FB68     		ldr	r3, [r7, #12]
 5397 0770 9B6B     		ldr	r3, [r3, #56]
 5398 0772 03F10102 		add	r2, r3, #1
 5399 0776 FB68     		ldr	r3, [r7, #12]
 5400 0778 9A63     		str	r2, [r3, #56]
1187:../3rdParty/FreeRTOS/queue.c **** }
 5401              		.loc 1 1187 0
 5402 077a 07F11007 		add	r7, r7, #16
 5403 077e BD46     		mov	sp, r7
 5404 0780 80BD     		pop	{r7, pc}
 5405              		.cfi_endproc
 5406              	.LFE69:
 5408 0782 00BF     		.align	2
 5409              		.thumb
 5410              		.thumb_func
 5412              	prvCopyDataFromQueue:
 5413              	.LFB70:
1188:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1189:../3rdParty/FreeRTOS/queue.c **** 
1190:../3rdParty/FreeRTOS/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1191:../3rdParty/FreeRTOS/queue.c **** {
 5414              		.loc 1 1191 0
 5415              		.cfi_startproc
 5416              		@ args = 0, pretend = 0, frame = 8
 5417              		@ frame_needed = 1, uses_anonymous_args = 0
 5418 0784 80B5     		push	{r7, lr}
 5419              	.LCFI45:
 5420              		.cfi_def_cfa_offset 8
 5421 0786 82B0     		sub	sp, sp, #8
 5422              	.LCFI46:
 5423              		.cfi_def_cfa_offset 16
 5424 0788 00AF     		add	r7, sp, #0
 5425              		.cfi_offset 14, -4
 5426              		.cfi_offset 7, -8
 5427              	.LCFI47:
 5428              		.cfi_def_cfa_register 7
 5429 078a 7860     		str	r0, [r7, #4]
 5430 078c 3960     		str	r1, [r7, #0]
1192:../3rdParty/FreeRTOS/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 5431              		.loc 1 1192 0
 5432 078e 7B68     		ldr	r3, [r7, #4]
 5433 0790 1B68     		ldr	r3, [r3, #0]
 5434 0792 002B     		cmp	r3, #0
 5435 0794 19D0     		beq	.L62
1193:../3rdParty/FreeRTOS/queue.c **** 	{
1194:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 5436              		.loc 1 1194 0
 5437 0796 7B68     		ldr	r3, [r7, #4]
 5438 0798 DA68     		ldr	r2, [r3, #12]
 5439 079a 7B68     		ldr	r3, [r7, #4]
 5440 079c 1B6C     		ldr	r3, [r3, #64]
 5441 079e D218     		adds	r2, r2, r3
 5442 07a0 7B68     		ldr	r3, [r7, #4]
 5443 07a2 DA60     		str	r2, [r3, #12]
1195:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 5444              		.loc 1 1195 0
 5445 07a4 7B68     		ldr	r3, [r7, #4]
 5446 07a6 DA68     		ldr	r2, [r3, #12]
 5447 07a8 7B68     		ldr	r3, [r7, #4]
 5448 07aa 5B68     		ldr	r3, [r3, #4]
 5449 07ac 9A42     		cmp	r2, r3
 5450 07ae 03D3     		bcc	.L64
1196:../3rdParty/FreeRTOS/queue.c **** 		{
1197:../3rdParty/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 5451              		.loc 1 1197 0
 5452 07b0 7B68     		ldr	r3, [r7, #4]
 5453 07b2 1A68     		ldr	r2, [r3, #0]
 5454 07b4 7B68     		ldr	r3, [r7, #4]
 5455 07b6 DA60     		str	r2, [r3, #12]
 5456              	.L64:
1198:../3rdParty/FreeRTOS/queue.c **** 		}
1199:../3rdParty/FreeRTOS/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 5457              		.loc 1 1199 0
 5458 07b8 7B68     		ldr	r3, [r7, #4]
 5459 07ba DA68     		ldr	r2, [r3, #12]
 5460 07bc 7B68     		ldr	r3, [r7, #4]
 5461 07be 1B6C     		ldr	r3, [r3, #64]
 5462 07c0 3868     		ldr	r0, [r7, #0]
 5463 07c2 1146     		mov	r1, r2
 5464 07c4 1A46     		mov	r2, r3
 5465 07c6 FFF7FEFF 		bl	memcpy
 5466              	.L62:
1200:../3rdParty/FreeRTOS/queue.c **** 	}
1201:../3rdParty/FreeRTOS/queue.c **** }
 5467              		.loc 1 1201 0
 5468 07ca 07F10807 		add	r7, r7, #8
 5469 07ce BD46     		mov	sp, r7
 5470 07d0 80BD     		pop	{r7, pc}
 5471              		.cfi_endproc
 5472              	.LFE70:
 5474 07d2 00BF     		.align	2
 5475              		.thumb
 5476              		.thumb_func
 5478              	prvUnlockQueue:
 5479              	.LFB71:
1202:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1203:../3rdParty/FreeRTOS/queue.c **** 
1204:../3rdParty/FreeRTOS/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue )
1205:../3rdParty/FreeRTOS/queue.c **** {
 5480              		.loc 1 1205 0
 5481              		.cfi_startproc
 5482              		@ args = 0, pretend = 0, frame = 8
 5483              		@ frame_needed = 1, uses_anonymous_args = 0
 5484 07d4 80B5     		push	{r7, lr}
 5485              	.LCFI48:
 5486              		.cfi_def_cfa_offset 8
 5487 07d6 82B0     		sub	sp, sp, #8
 5488              	.LCFI49:
 5489              		.cfi_def_cfa_offset 16
 5490 07d8 00AF     		add	r7, sp, #0
 5491              		.cfi_offset 14, -4
 5492              		.cfi_offset 7, -8
 5493              	.LCFI50:
 5494              		.cfi_def_cfa_register 7
 5495 07da 7860     		str	r0, [r7, #4]
1206:../3rdParty/FreeRTOS/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1207:../3rdParty/FreeRTOS/queue.c **** 
1208:../3rdParty/FreeRTOS/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1209:../3rdParty/FreeRTOS/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1210:../3rdParty/FreeRTOS/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1211:../3rdParty/FreeRTOS/queue.c **** 	updated. */
1212:../3rdParty/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 5496              		.loc 1 1212 0
 5497 07dc FFF7FEFF 		bl	vPortEnterCritical
1213:../3rdParty/FreeRTOS/queue.c **** 	{
1214:../3rdParty/FreeRTOS/queue.c **** 		/* See if data was added to the queue while it was locked. */
1215:../3rdParty/FreeRTOS/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 5498              		.loc 1 1215 0
 5499 07e0 14E0     		b	.L66
 5500              	.L70:
1216:../3rdParty/FreeRTOS/queue.c **** 		{
1217:../3rdParty/FreeRTOS/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1218:../3rdParty/FreeRTOS/queue.c **** 			blocked waiting for data to become available? */
1219:../3rdParty/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 5501              		.loc 1 1219 0
 5502 07e2 7B68     		ldr	r3, [r7, #4]
 5503 07e4 5B6A     		ldr	r3, [r3, #36]
 5504 07e6 002B     		cmp	r3, #0
 5505 07e8 15D0     		beq	.L76
1220:../3rdParty/FreeRTOS/queue.c **** 			{
1221:../3rdParty/FreeRTOS/queue.c **** 				/* Tasks that are removed from the event list will get added to
1222:../3rdParty/FreeRTOS/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1223:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 5506              		.loc 1 1223 0
 5507 07ea 7B68     		ldr	r3, [r7, #4]
 5508 07ec 03F12403 		add	r3, r3, #36
 5509 07f0 1846     		mov	r0, r3
 5510 07f2 FFF7FEFF 		bl	xTaskRemoveFromEventList
 5511 07f6 0346     		mov	r3, r0
 5512 07f8 002B     		cmp	r3, #0
 5513 07fa 01D0     		beq	.L68
1224:../3rdParty/FreeRTOS/queue.c **** 				{
1225:../3rdParty/FreeRTOS/queue.c **** 					/* The task waiting has a higher priority so record that a
1226:../3rdParty/FreeRTOS/queue.c **** 					context	switch is required. */
1227:../3rdParty/FreeRTOS/queue.c **** 					vTaskMissedYield();
 5514              		.loc 1 1227 0
 5515 07fc FFF7FEFF 		bl	vTaskMissedYield
 5516              	.L68:
1228:../3rdParty/FreeRTOS/queue.c **** 				}
1229:../3rdParty/FreeRTOS/queue.c **** 
1230:../3rdParty/FreeRTOS/queue.c **** 				--( pxQueue->xTxLock );
 5517              		.loc 1 1230 0
 5518 0800 7B68     		ldr	r3, [r7, #4]
 5519 0802 9B6C     		ldr	r3, [r3, #72]
 5520 0804 03F1FF32 		add	r2, r3, #-1
 5521 0808 7B68     		ldr	r3, [r7, #4]
 5522 080a 9A64     		str	r2, [r3, #72]
 5523              	.L66:
1215:../3rdParty/FreeRTOS/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 5524              		.loc 1 1215 0 discriminator 1
 5525 080c 7B68     		ldr	r3, [r7, #4]
 5526 080e 9B6C     		ldr	r3, [r3, #72]
 5527 0810 002B     		cmp	r3, #0
 5528 0812 E6DC     		bgt	.L70
 5529 0814 00E0     		b	.L69
 5530              	.L76:
1231:../3rdParty/FreeRTOS/queue.c **** 			}
1232:../3rdParty/FreeRTOS/queue.c **** 			else
1233:../3rdParty/FreeRTOS/queue.c **** 			{
1234:../3rdParty/FreeRTOS/queue.c **** 				break;
 5531              		.loc 1 1234 0
 5532 0816 00BF     		nop
 5533              	.L69:
1235:../3rdParty/FreeRTOS/queue.c **** 			}
1236:../3rdParty/FreeRTOS/queue.c **** 		}
1237:../3rdParty/FreeRTOS/queue.c **** 
1238:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 5534              		.loc 1 1238 0
 5535 0818 7B68     		ldr	r3, [r7, #4]
 5536 081a 4FF0FF32 		mov	r2, #-1
 5537 081e 9A64     		str	r2, [r3, #72]
1239:../3rdParty/FreeRTOS/queue.c **** 	}
1240:../3rdParty/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 5538              		.loc 1 1240 0
 5539 0820 FFF7FEFF 		bl	vPortExitCritical
1241:../3rdParty/FreeRTOS/queue.c **** 
1242:../3rdParty/FreeRTOS/queue.c **** 	/* Do the same for the Rx lock. */
1243:../3rdParty/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 5540              		.loc 1 1243 0
 5541 0824 FFF7FEFF 		bl	vPortEnterCritical
1244:../3rdParty/FreeRTOS/queue.c **** 	{
1245:../3rdParty/FreeRTOS/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 5542              		.loc 1 1245 0
 5543 0828 14E0     		b	.L71
 5544              	.L75:
1246:../3rdParty/FreeRTOS/queue.c **** 		{
1247:../3rdParty/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 5545              		.loc 1 1247 0
 5546 082a 7B68     		ldr	r3, [r7, #4]
 5547 082c 1B69     		ldr	r3, [r3, #16]
 5548 082e 002B     		cmp	r3, #0
 5549 0830 15D0     		beq	.L77
1248:../3rdParty/FreeRTOS/queue.c **** 			{
1249:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 5550              		.loc 1 1249 0
 5551 0832 7B68     		ldr	r3, [r7, #4]
 5552 0834 03F11003 		add	r3, r3, #16
 5553 0838 1846     		mov	r0, r3
 5554 083a FFF7FEFF 		bl	xTaskRemoveFromEventList
 5555 083e 0346     		mov	r3, r0
 5556 0840 002B     		cmp	r3, #0
 5557 0842 01D0     		beq	.L73
1250:../3rdParty/FreeRTOS/queue.c **** 				{
1251:../3rdParty/FreeRTOS/queue.c **** 					vTaskMissedYield();
 5558              		.loc 1 1251 0
 5559 0844 FFF7FEFF 		bl	vTaskMissedYield
 5560              	.L73:
1252:../3rdParty/FreeRTOS/queue.c **** 				}
1253:../3rdParty/FreeRTOS/queue.c **** 
1254:../3rdParty/FreeRTOS/queue.c **** 				--( pxQueue->xRxLock );
 5561              		.loc 1 1254 0
 5562 0848 7B68     		ldr	r3, [r7, #4]
 5563 084a 5B6C     		ldr	r3, [r3, #68]
 5564 084c 03F1FF32 		add	r2, r3, #-1
 5565 0850 7B68     		ldr	r3, [r7, #4]
 5566 0852 5A64     		str	r2, [r3, #68]
 5567              	.L71:
1245:../3rdParty/FreeRTOS/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 5568              		.loc 1 1245 0 discriminator 1
 5569 0854 7B68     		ldr	r3, [r7, #4]
 5570 0856 5B6C     		ldr	r3, [r3, #68]
 5571 0858 002B     		cmp	r3, #0
 5572 085a E6DC     		bgt	.L75
 5573 085c 00E0     		b	.L74
 5574              	.L77:
1255:../3rdParty/FreeRTOS/queue.c **** 			}
1256:../3rdParty/FreeRTOS/queue.c **** 			else
1257:../3rdParty/FreeRTOS/queue.c **** 			{
1258:../3rdParty/FreeRTOS/queue.c **** 				break;
 5575              		.loc 1 1258 0
 5576 085e 00BF     		nop
 5577              	.L74:
1259:../3rdParty/FreeRTOS/queue.c **** 			}
1260:../3rdParty/FreeRTOS/queue.c **** 		}
1261:../3rdParty/FreeRTOS/queue.c **** 
1262:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 5578              		.loc 1 1262 0
 5579 0860 7B68     		ldr	r3, [r7, #4]
 5580 0862 4FF0FF32 		mov	r2, #-1
 5581 0866 5A64     		str	r2, [r3, #68]
1263:../3rdParty/FreeRTOS/queue.c **** 	}
1264:../3rdParty/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 5582              		.loc 1 1264 0
 5583 0868 FFF7FEFF 		bl	vPortExitCritical
1265:../3rdParty/FreeRTOS/queue.c **** }
 5584              		.loc 1 1265 0
 5585 086c 07F10807 		add	r7, r7, #8
 5586 0870 BD46     		mov	sp, r7
 5587 0872 80BD     		pop	{r7, pc}
 5588              		.cfi_endproc
 5589              	.LFE71:
 5591              		.align	2
 5592              		.thumb
 5593              		.thumb_func
 5595              	prvIsQueueEmpty:
 5596              	.LFB72:
1266:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1267:../3rdParty/FreeRTOS/queue.c **** 
1268:../3rdParty/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
1269:../3rdParty/FreeRTOS/queue.c **** {
 5597              		.loc 1 1269 0
 5598              		.cfi_startproc
 5599              		@ args = 0, pretend = 0, frame = 16
 5600              		@ frame_needed = 1, uses_anonymous_args = 0
 5601 0874 80B5     		push	{r7, lr}
 5602              	.LCFI51:
 5603              		.cfi_def_cfa_offset 8
 5604 0876 84B0     		sub	sp, sp, #16
 5605              	.LCFI52:
 5606              		.cfi_def_cfa_offset 24
 5607 0878 00AF     		add	r7, sp, #0
 5608              		.cfi_offset 14, -4
 5609              		.cfi_offset 7, -8
 5610              	.LCFI53:
 5611              		.cfi_def_cfa_register 7
 5612 087a 7860     		str	r0, [r7, #4]
1270:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1271:../3rdParty/FreeRTOS/queue.c **** 
1272:../3rdParty/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 5613              		.loc 1 1272 0
 5614 087c FFF7FEFF 		bl	vPortEnterCritical
1273:../3rdParty/FreeRTOS/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 5615              		.loc 1 1273 0
 5616 0880 7B68     		ldr	r3, [r7, #4]
 5617 0882 9B6B     		ldr	r3, [r3, #56]
 5618 0884 002B     		cmp	r3, #0
 5619 0886 14BF     		ite	ne
 5620 0888 0023     		movne	r3, #0
 5621 088a 0123     		moveq	r3, #1
 5622 088c FB60     		str	r3, [r7, #12]
1274:../3rdParty/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 5623              		.loc 1 1274 0
 5624 088e FFF7FEFF 		bl	vPortExitCritical
1275:../3rdParty/FreeRTOS/queue.c **** 
1276:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 5625              		.loc 1 1276 0
 5626 0892 FB68     		ldr	r3, [r7, #12]
1277:../3rdParty/FreeRTOS/queue.c **** }
 5627              		.loc 1 1277 0
 5628 0894 1846     		mov	r0, r3
 5629 0896 07F11007 		add	r7, r7, #16
 5630 089a BD46     		mov	sp, r7
 5631 089c 80BD     		pop	{r7, pc}
 5632              		.cfi_endproc
 5633              	.LFE72:
 5635 089e 00BF     		.align	2
 5636              		.global	xQueueIsQueueEmptyFromISR
 5637              		.thumb
 5638              		.thumb_func
 5640              	xQueueIsQueueEmptyFromISR:
 5641              	.LFB73:
1278:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1279:../3rdParty/FreeRTOS/queue.c **** 
1280:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
1281:../3rdParty/FreeRTOS/queue.c **** {
 5642              		.loc 1 1281 0
 5643              		.cfi_startproc
 5644              		@ args = 0, pretend = 0, frame = 16
 5645              		@ frame_needed = 1, uses_anonymous_args = 0
 5646              		@ link register save eliminated.
 5647 08a0 80B4     		push	{r7}
 5648              	.LCFI54:
 5649              		.cfi_def_cfa_offset 4
 5650 08a2 85B0     		sub	sp, sp, #20
 5651              	.LCFI55:
 5652              		.cfi_def_cfa_offset 24
 5653 08a4 00AF     		add	r7, sp, #0
 5654              		.cfi_offset 7, -4
 5655              	.LCFI56:
 5656              		.cfi_def_cfa_register 7
 5657 08a6 7860     		str	r0, [r7, #4]
1282:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1283:../3rdParty/FreeRTOS/queue.c **** 
1284:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1285:../3rdParty/FreeRTOS/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 5658              		.loc 1 1285 0
 5659 08a8 7B68     		ldr	r3, [r7, #4]
 5660 08aa 9B6B     		ldr	r3, [r3, #56]
 5661 08ac 002B     		cmp	r3, #0
 5662 08ae 14BF     		ite	ne
 5663 08b0 0023     		movne	r3, #0
 5664 08b2 0123     		moveq	r3, #1
 5665 08b4 FB60     		str	r3, [r7, #12]
1286:../3rdParty/FreeRTOS/queue.c **** 
1287:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 5666              		.loc 1 1287 0
 5667 08b6 FB68     		ldr	r3, [r7, #12]
1288:../3rdParty/FreeRTOS/queue.c **** }
 5668              		.loc 1 1288 0
 5669 08b8 1846     		mov	r0, r3
 5670 08ba 07F11407 		add	r7, r7, #20
 5671 08be BD46     		mov	sp, r7
 5672 08c0 80BC     		pop	{r7}
 5673 08c2 7047     		bx	lr
 5674              		.cfi_endproc
 5675              	.LFE73:
 5677              		.align	2
 5678              		.thumb
 5679              		.thumb_func
 5681              	prvIsQueueFull:
 5682              	.LFB74:
1289:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1290:../3rdParty/FreeRTOS/queue.c **** 
1291:../3rdParty/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
1292:../3rdParty/FreeRTOS/queue.c **** {
 5683              		.loc 1 1292 0
 5684              		.cfi_startproc
 5685              		@ args = 0, pretend = 0, frame = 16
 5686              		@ frame_needed = 1, uses_anonymous_args = 0
 5687 08c4 80B5     		push	{r7, lr}
 5688              	.LCFI57:
 5689              		.cfi_def_cfa_offset 8
 5690 08c6 84B0     		sub	sp, sp, #16
 5691              	.LCFI58:
 5692              		.cfi_def_cfa_offset 24
 5693 08c8 00AF     		add	r7, sp, #0
 5694              		.cfi_offset 14, -4
 5695              		.cfi_offset 7, -8
 5696              	.LCFI59:
 5697              		.cfi_def_cfa_register 7
 5698 08ca 7860     		str	r0, [r7, #4]
1293:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1294:../3rdParty/FreeRTOS/queue.c **** 
1295:../3rdParty/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 5699              		.loc 1 1295 0
 5700 08cc FFF7FEFF 		bl	vPortEnterCritical
1296:../3rdParty/FreeRTOS/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 5701              		.loc 1 1296 0
 5702 08d0 7B68     		ldr	r3, [r7, #4]
 5703 08d2 9A6B     		ldr	r2, [r3, #56]
 5704 08d4 7B68     		ldr	r3, [r7, #4]
 5705 08d6 DB6B     		ldr	r3, [r3, #60]
 5706 08d8 9A42     		cmp	r2, r3
 5707 08da 14BF     		ite	ne
 5708 08dc 0023     		movne	r3, #0
 5709 08de 0123     		moveq	r3, #1
 5710 08e0 FB60     		str	r3, [r7, #12]
1297:../3rdParty/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 5711              		.loc 1 1297 0
 5712 08e2 FFF7FEFF 		bl	vPortExitCritical
1298:../3rdParty/FreeRTOS/queue.c **** 
1299:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 5713              		.loc 1 1299 0
 5714 08e6 FB68     		ldr	r3, [r7, #12]
1300:../3rdParty/FreeRTOS/queue.c **** }
 5715              		.loc 1 1300 0
 5716 08e8 1846     		mov	r0, r3
 5717 08ea 07F11007 		add	r7, r7, #16
 5718 08ee BD46     		mov	sp, r7
 5719 08f0 80BD     		pop	{r7, pc}
 5720              		.cfi_endproc
 5721              	.LFE74:
 5723 08f2 00BF     		.align	2
 5724              		.global	xQueueIsQueueFullFromISR
 5725              		.thumb
 5726              		.thumb_func
 5728              	xQueueIsQueueFullFromISR:
 5729              	.LFB75:
1301:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1302:../3rdParty/FreeRTOS/queue.c **** 
1303:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
1304:../3rdParty/FreeRTOS/queue.c **** {
 5730              		.loc 1 1304 0
 5731              		.cfi_startproc
 5732              		@ args = 0, pretend = 0, frame = 16
 5733              		@ frame_needed = 1, uses_anonymous_args = 0
 5734              		@ link register save eliminated.
 5735 08f4 80B4     		push	{r7}
 5736              	.LCFI60:
 5737              		.cfi_def_cfa_offset 4
 5738 08f6 85B0     		sub	sp, sp, #20
 5739              	.LCFI61:
 5740              		.cfi_def_cfa_offset 24
 5741 08f8 00AF     		add	r7, sp, #0
 5742              		.cfi_offset 7, -4
 5743              	.LCFI62:
 5744              		.cfi_def_cfa_register 7
 5745 08fa 7860     		str	r0, [r7, #4]
1305:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1306:../3rdParty/FreeRTOS/queue.c **** 
1307:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1308:../3rdParty/FreeRTOS/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 5746              		.loc 1 1308 0
 5747 08fc 7B68     		ldr	r3, [r7, #4]
 5748 08fe 9A6B     		ldr	r2, [r3, #56]
 5749 0900 7B68     		ldr	r3, [r7, #4]
 5750 0902 DB6B     		ldr	r3, [r3, #60]
 5751 0904 9A42     		cmp	r2, r3
 5752 0906 14BF     		ite	ne
 5753 0908 0023     		movne	r3, #0
 5754 090a 0123     		moveq	r3, #1
 5755 090c FB60     		str	r3, [r7, #12]
1309:../3rdParty/FreeRTOS/queue.c **** 
1310:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 5756              		.loc 1 1310 0
 5757 090e FB68     		ldr	r3, [r7, #12]
1311:../3rdParty/FreeRTOS/queue.c **** }
 5758              		.loc 1 1311 0
 5759 0910 1846     		mov	r0, r3
 5760 0912 07F11407 		add	r7, r7, #20
 5761 0916 BD46     		mov	sp, r7
 5762 0918 80BC     		pop	{r7}
 5763 091a 7047     		bx	lr
 5764              		.cfi_endproc
 5765              	.LFE75:
 5767              		.align	2
 5768              		.global	vQueueAddToRegistry
 5769              		.thumb
 5770              		.thumb_func
 5772              	vQueueAddToRegistry:
 5773              	.LFB76:
1312:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1313:../3rdParty/FreeRTOS/queue.c **** 
1314:../3rdParty/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1315:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xT
1316:../3rdParty/FreeRTOS/queue.c **** {
1317:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1318:../3rdParty/FreeRTOS/queue.c **** 
1319:../3rdParty/FreeRTOS/queue.c **** 	/* If the queue is already full we may have to block.  A critical section
1320:../3rdParty/FreeRTOS/queue.c **** 	is required to prevent an interrupt removing something from the queue
1321:../3rdParty/FreeRTOS/queue.c **** 	between the check to see if the queue is full and blocking on the queue. */
1322:../3rdParty/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1323:../3rdParty/FreeRTOS/queue.c **** 	{
1324:../3rdParty/FreeRTOS/queue.c **** 		if( prvIsQueueFull( pxQueue ) != pdFALSE )
1325:../3rdParty/FreeRTOS/queue.c **** 		{
1326:../3rdParty/FreeRTOS/queue.c **** 			/* The queue is full - do we want to block or just leave without
1327:../3rdParty/FreeRTOS/queue.c **** 			posting? */
1328:../3rdParty/FreeRTOS/queue.c **** 			if( xTicksToWait > ( portTickType ) 0 )
1329:../3rdParty/FreeRTOS/queue.c **** 			{
1330:../3rdParty/FreeRTOS/queue.c **** 				/* As this is called from a coroutine we cannot block directly, but
1331:../3rdParty/FreeRTOS/queue.c **** 				return indicating that we need to block. */
1332:../3rdParty/FreeRTOS/queue.c **** 				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1333:../3rdParty/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1334:../3rdParty/FreeRTOS/queue.c **** 				return errQUEUE_BLOCKED;
1335:../3rdParty/FreeRTOS/queue.c **** 			}
1336:../3rdParty/FreeRTOS/queue.c **** 			else
1337:../3rdParty/FreeRTOS/queue.c **** 			{
1338:../3rdParty/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1339:../3rdParty/FreeRTOS/queue.c **** 				return errQUEUE_FULL;
1340:../3rdParty/FreeRTOS/queue.c **** 			}
1341:../3rdParty/FreeRTOS/queue.c **** 		}
1342:../3rdParty/FreeRTOS/queue.c **** 	}
1343:../3rdParty/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1344:../3rdParty/FreeRTOS/queue.c **** 
1345:../3rdParty/FreeRTOS/queue.c **** 	portNOP();
1346:../3rdParty/FreeRTOS/queue.c **** 
1347:../3rdParty/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1348:../3rdParty/FreeRTOS/queue.c **** 	{
1349:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1350:../3rdParty/FreeRTOS/queue.c **** 		{
1351:../3rdParty/FreeRTOS/queue.c **** 			/* There is room in the queue, copy the data into the queue. */
1352:../3rdParty/FreeRTOS/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1353:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdPASS;
1354:../3rdParty/FreeRTOS/queue.c **** 
1355:../3rdParty/FreeRTOS/queue.c **** 			/* Were any co-routines waiting for data to become available? */
1356:../3rdParty/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1357:../3rdParty/FreeRTOS/queue.c **** 			{
1358:../3rdParty/FreeRTOS/queue.c **** 				/* In this instance the co-routine could be placed directly
1359:../3rdParty/FreeRTOS/queue.c **** 				into the ready list as we are within a critical section.
1360:../3rdParty/FreeRTOS/queue.c **** 				Instead the same pending ready list mechanism is used as if
1361:../3rdParty/FreeRTOS/queue.c **** 				the event were caused from within an interrupt. */
1362:../3rdParty/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1363:../3rdParty/FreeRTOS/queue.c **** 				{
1364:../3rdParty/FreeRTOS/queue.c **** 					/* The co-routine waiting has a higher priority so record
1365:../3rdParty/FreeRTOS/queue.c **** 					that a yield might be appropriate. */
1366:../3rdParty/FreeRTOS/queue.c **** 					xReturn = errQUEUE_YIELD;
1367:../3rdParty/FreeRTOS/queue.c **** 				}
1368:../3rdParty/FreeRTOS/queue.c **** 			}
1369:../3rdParty/FreeRTOS/queue.c **** 		}
1370:../3rdParty/FreeRTOS/queue.c **** 		else
1371:../3rdParty/FreeRTOS/queue.c **** 		{
1372:../3rdParty/FreeRTOS/queue.c **** 			xReturn = errQUEUE_FULL;
1373:../3rdParty/FreeRTOS/queue.c **** 		}
1374:../3rdParty/FreeRTOS/queue.c **** 	}
1375:../3rdParty/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1376:../3rdParty/FreeRTOS/queue.c **** 
1377:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
1378:../3rdParty/FreeRTOS/queue.c **** }
1379:../3rdParty/FreeRTOS/queue.c **** #endif
1380:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1381:../3rdParty/FreeRTOS/queue.c **** 
1382:../3rdParty/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1383:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWa
1384:../3rdParty/FreeRTOS/queue.c **** {
1385:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1386:../3rdParty/FreeRTOS/queue.c **** 
1387:../3rdParty/FreeRTOS/queue.c **** 	/* If the queue is already empty we may have to block.  A critical section
1388:../3rdParty/FreeRTOS/queue.c **** 	is required to prevent an interrupt adding something to the queue
1389:../3rdParty/FreeRTOS/queue.c **** 	between the check to see if the queue is empty and blocking on the queue. */
1390:../3rdParty/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1391:../3rdParty/FreeRTOS/queue.c **** 	{
1392:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
1393:../3rdParty/FreeRTOS/queue.c **** 		{
1394:../3rdParty/FreeRTOS/queue.c **** 			/* There are no messages in the queue, do we want to block or just
1395:../3rdParty/FreeRTOS/queue.c **** 			leave with nothing? */
1396:../3rdParty/FreeRTOS/queue.c **** 			if( xTicksToWait > ( portTickType ) 0 )
1397:../3rdParty/FreeRTOS/queue.c **** 			{
1398:../3rdParty/FreeRTOS/queue.c **** 				/* As this is a co-routine we cannot block directly, but return
1399:../3rdParty/FreeRTOS/queue.c **** 				indicating that we need to block. */
1400:../3rdParty/FreeRTOS/queue.c **** 				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
1401:../3rdParty/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1402:../3rdParty/FreeRTOS/queue.c **** 				return errQUEUE_BLOCKED;
1403:../3rdParty/FreeRTOS/queue.c **** 			}
1404:../3rdParty/FreeRTOS/queue.c **** 			else
1405:../3rdParty/FreeRTOS/queue.c **** 			{
1406:../3rdParty/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1407:../3rdParty/FreeRTOS/queue.c **** 				return errQUEUE_FULL;
1408:../3rdParty/FreeRTOS/queue.c **** 			}
1409:../3rdParty/FreeRTOS/queue.c **** 		}
1410:../3rdParty/FreeRTOS/queue.c **** 	}
1411:../3rdParty/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1412:../3rdParty/FreeRTOS/queue.c **** 
1413:../3rdParty/FreeRTOS/queue.c **** 	portNOP();
1414:../3rdParty/FreeRTOS/queue.c **** 
1415:../3rdParty/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1416:../3rdParty/FreeRTOS/queue.c **** 	{
1417:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1418:../3rdParty/FreeRTOS/queue.c **** 		{
1419:../3rdParty/FreeRTOS/queue.c **** 			/* Data is available from the queue. */
1420:../3rdParty/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom += pxQueue->uxItemSize;
1421:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1422:../3rdParty/FreeRTOS/queue.c **** 			{
1423:../3rdParty/FreeRTOS/queue.c **** 				pxQueue->pcReadFrom = pxQueue->pcHead;
1424:../3rdParty/FreeRTOS/queue.c **** 			}
1425:../3rdParty/FreeRTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1426:../3rdParty/FreeRTOS/queue.c **** 			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1427:../3rdParty/FreeRTOS/queue.c **** 
1428:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdPASS;
1429:../3rdParty/FreeRTOS/queue.c **** 
1430:../3rdParty/FreeRTOS/queue.c **** 			/* Were any co-routines waiting for space to become available? */
1431:../3rdParty/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1432:../3rdParty/FreeRTOS/queue.c **** 			{
1433:../3rdParty/FreeRTOS/queue.c **** 				/* In this instance the co-routine could be placed directly
1434:../3rdParty/FreeRTOS/queue.c **** 				into the ready list as we are within a critical section.
1435:../3rdParty/FreeRTOS/queue.c **** 				Instead the same pending ready list mechanism is used as if
1436:../3rdParty/FreeRTOS/queue.c **** 				the event were caused from within an interrupt. */
1437:../3rdParty/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1438:../3rdParty/FreeRTOS/queue.c **** 				{
1439:../3rdParty/FreeRTOS/queue.c **** 					xReturn = errQUEUE_YIELD;
1440:../3rdParty/FreeRTOS/queue.c **** 				}
1441:../3rdParty/FreeRTOS/queue.c **** 			}
1442:../3rdParty/FreeRTOS/queue.c **** 		}
1443:../3rdParty/FreeRTOS/queue.c **** 		else
1444:../3rdParty/FreeRTOS/queue.c **** 		{
1445:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdFAIL;
1446:../3rdParty/FreeRTOS/queue.c **** 		}
1447:../3rdParty/FreeRTOS/queue.c **** 	}
1448:../3rdParty/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1449:../3rdParty/FreeRTOS/queue.c **** 
1450:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
1451:../3rdParty/FreeRTOS/queue.c **** }
1452:../3rdParty/FreeRTOS/queue.c **** #endif
1453:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1454:../3rdParty/FreeRTOS/queue.c **** 
1455:../3rdParty/FreeRTOS/queue.c **** 
1456:../3rdParty/FreeRTOS/queue.c **** 
1457:../3rdParty/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1458:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed p
1459:../3rdParty/FreeRTOS/queue.c **** {
1460:../3rdParty/FreeRTOS/queue.c **** 	/* Cannot block within an ISR so if there is no space on the queue then
1461:../3rdParty/FreeRTOS/queue.c **** 	exit without doing anything. */
1462:../3rdParty/FreeRTOS/queue.c **** 	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1463:../3rdParty/FreeRTOS/queue.c **** 	{
1464:../3rdParty/FreeRTOS/queue.c **** 		prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1465:../3rdParty/FreeRTOS/queue.c **** 
1466:../3rdParty/FreeRTOS/queue.c **** 		/* We only want to wake one co-routine per ISR, so check that a
1467:../3rdParty/FreeRTOS/queue.c **** 		co-routine has not already been woken. */
1468:../3rdParty/FreeRTOS/queue.c **** 		if( xCoRoutinePreviouslyWoken == pdFALSE )
1469:../3rdParty/FreeRTOS/queue.c **** 		{
1470:../3rdParty/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1471:../3rdParty/FreeRTOS/queue.c **** 			{
1472:../3rdParty/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1473:../3rdParty/FreeRTOS/queue.c **** 				{
1474:../3rdParty/FreeRTOS/queue.c **** 					return pdTRUE;
1475:../3rdParty/FreeRTOS/queue.c **** 				}
1476:../3rdParty/FreeRTOS/queue.c **** 			}
1477:../3rdParty/FreeRTOS/queue.c **** 		}
1478:../3rdParty/FreeRTOS/queue.c **** 	}
1479:../3rdParty/FreeRTOS/queue.c **** 
1480:../3rdParty/FreeRTOS/queue.c **** 	return xCoRoutinePreviouslyWoken;
1481:../3rdParty/FreeRTOS/queue.c **** }
1482:../3rdParty/FreeRTOS/queue.c **** #endif
1483:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1484:../3rdParty/FreeRTOS/queue.c **** 
1485:../3rdParty/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1486:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_
1487:../3rdParty/FreeRTOS/queue.c **** {
1488:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1489:../3rdParty/FreeRTOS/queue.c **** 
1490:../3rdParty/FreeRTOS/queue.c **** 	/* We cannot block from an ISR, so check there is data available. If
1491:../3rdParty/FreeRTOS/queue.c **** 	not then just leave without doing anything. */
1492:../3rdParty/FreeRTOS/queue.c **** 	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1493:../3rdParty/FreeRTOS/queue.c **** 	{
1494:../3rdParty/FreeRTOS/queue.c **** 		/* Copy the data from the queue. */
1495:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
1496:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1497:../3rdParty/FreeRTOS/queue.c **** 		{
1498:../3rdParty/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
1499:../3rdParty/FreeRTOS/queue.c **** 		}
1500:../3rdParty/FreeRTOS/queue.c **** 		--( pxQueue->uxMessagesWaiting );
1501:../3rdParty/FreeRTOS/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1502:../3rdParty/FreeRTOS/queue.c **** 
1503:../3rdParty/FreeRTOS/queue.c **** 		if( ( *pxCoRoutineWoken ) == pdFALSE )
1504:../3rdParty/FreeRTOS/queue.c **** 		{
1505:../3rdParty/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1506:../3rdParty/FreeRTOS/queue.c **** 			{
1507:../3rdParty/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1508:../3rdParty/FreeRTOS/queue.c **** 				{
1509:../3rdParty/FreeRTOS/queue.c **** 					*pxCoRoutineWoken = pdTRUE;
1510:../3rdParty/FreeRTOS/queue.c **** 				}
1511:../3rdParty/FreeRTOS/queue.c **** 			}
1512:../3rdParty/FreeRTOS/queue.c **** 		}
1513:../3rdParty/FreeRTOS/queue.c **** 
1514:../3rdParty/FreeRTOS/queue.c **** 		xReturn = pdPASS;
1515:../3rdParty/FreeRTOS/queue.c **** 	}
1516:../3rdParty/FreeRTOS/queue.c **** 	else
1517:../3rdParty/FreeRTOS/queue.c **** 	{
1518:../3rdParty/FreeRTOS/queue.c **** 		xReturn = pdFAIL;
1519:../3rdParty/FreeRTOS/queue.c **** 	}
1520:../3rdParty/FreeRTOS/queue.c **** 
1521:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
1522:../3rdParty/FreeRTOS/queue.c **** }
1523:../3rdParty/FreeRTOS/queue.c **** #endif
1524:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1525:../3rdParty/FreeRTOS/queue.c **** 
1526:../3rdParty/FreeRTOS/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
1527:../3rdParty/FreeRTOS/queue.c **** 
1528:../3rdParty/FreeRTOS/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
1529:../3rdParty/FreeRTOS/queue.c **** 	{
 5774              		.loc 1 1529 0
 5775              		.cfi_startproc
 5776              		@ args = 0, pretend = 0, frame = 16
 5777              		@ frame_needed = 1, uses_anonymous_args = 0
 5778              		@ link register save eliminated.
 5779 091c 80B4     		push	{r7}
 5780              	.LCFI63:
 5781              		.cfi_def_cfa_offset 4
 5782 091e 85B0     		sub	sp, sp, #20
 5783              	.LCFI64:
 5784              		.cfi_def_cfa_offset 24
 5785 0920 00AF     		add	r7, sp, #0
 5786              		.cfi_offset 7, -4
 5787              	.LCFI65:
 5788              		.cfi_def_cfa_register 7
 5789 0922 7860     		str	r0, [r7, #4]
 5790 0924 3960     		str	r1, [r7, #0]
1530:../3rdParty/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE ux;
1531:../3rdParty/FreeRTOS/queue.c **** 
1532:../3rdParty/FreeRTOS/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
1533:../3rdParty/FreeRTOS/queue.c **** 		a free slot. */
1534:../3rdParty/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5791              		.loc 1 1534 0
 5792 0926 4FF00003 		mov	r3, #0
 5793 092a FB60     		str	r3, [r7, #12]
 5794 092c 16E0     		b	.L83
 5795              	.L86:
1535:../3rdParty/FreeRTOS/queue.c **** 		{
1536:../3rdParty/FreeRTOS/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 5796              		.loc 1 1536 0
 5797 092e 0F4B     		ldr	r3, .L87
 5798 0930 FA68     		ldr	r2, [r7, #12]
 5799 0932 53F83230 		ldr	r3, [r3, r2, lsl #3]
 5800 0936 002B     		cmp	r3, #0
 5801 0938 0CD1     		bne	.L84
1537:../3rdParty/FreeRTOS/queue.c **** 			{
1538:../3rdParty/FreeRTOS/queue.c **** 				/* Store the information on this queue. */
1539:../3rdParty/FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 5802              		.loc 1 1539 0
 5803 093a 0C4B     		ldr	r3, .L87
 5804 093c FA68     		ldr	r2, [r7, #12]
 5805 093e 3968     		ldr	r1, [r7, #0]
 5806 0940 43F83210 		str	r1, [r3, r2, lsl #3]
1540:../3rdParty/FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 5807              		.loc 1 1540 0
 5808 0944 094A     		ldr	r2, .L87
 5809 0946 FB68     		ldr	r3, [r7, #12]
 5810 0948 4FEAC303 		lsl	r3, r3, #3
 5811 094c D318     		adds	r3, r2, r3
 5812 094e 7A68     		ldr	r2, [r7, #4]
 5813 0950 5A60     		str	r2, [r3, #4]
1541:../3rdParty/FreeRTOS/queue.c **** 				break;
 5814              		.loc 1 1541 0
 5815 0952 06E0     		b	.L82
 5816              	.L84:
1534:../3rdParty/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5817              		.loc 1 1534 0
 5818 0954 FB68     		ldr	r3, [r7, #12]
 5819 0956 03F10103 		add	r3, r3, #1
 5820 095a FB60     		str	r3, [r7, #12]
 5821              	.L83:
1534:../3rdParty/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5822              		.loc 1 1534 0 is_stmt 0 discriminator 1
 5823 095c FB68     		ldr	r3, [r7, #12]
 5824 095e 092B     		cmp	r3, #9
 5825 0960 E5D9     		bls	.L86
 5826              	.L82:
1542:../3rdParty/FreeRTOS/queue.c **** 			}
1543:../3rdParty/FreeRTOS/queue.c **** 		}
1544:../3rdParty/FreeRTOS/queue.c **** 	}
 5827              		.loc 1 1544 0 is_stmt 1
 5828 0962 07F11407 		add	r7, r7, #20
 5829 0966 BD46     		mov	sp, r7
 5830 0968 80BC     		pop	{r7}
 5831 096a 7047     		bx	lr
 5832              	.L88:
 5833              		.align	2
 5834              	.L87:
 5835 096c 00000000 		.word	xQueueRegistry
 5836              		.cfi_endproc
 5837              	.LFE76:
 5839              		.align	2
 5840              		.thumb
 5841              		.thumb_func
 5843              	vQueueUnregisterQueue:
 5844              	.LFB77:
1545:../3rdParty/FreeRTOS/queue.c **** 
1546:../3rdParty/FreeRTOS/queue.c **** #endif
1547:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1548:../3rdParty/FreeRTOS/queue.c **** 
1549:../3rdParty/FreeRTOS/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
1550:../3rdParty/FreeRTOS/queue.c **** 
1551:../3rdParty/FreeRTOS/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue )
1552:../3rdParty/FreeRTOS/queue.c **** 	{
 5845              		.loc 1 1552 0
 5846              		.cfi_startproc
 5847              		@ args = 0, pretend = 0, frame = 16
 5848              		@ frame_needed = 1, uses_anonymous_args = 0
 5849              		@ link register save eliminated.
 5850 0970 80B4     		push	{r7}
 5851              	.LCFI66:
 5852              		.cfi_def_cfa_offset 4
 5853 0972 85B0     		sub	sp, sp, #20
 5854              	.LCFI67:
 5855              		.cfi_def_cfa_offset 24
 5856 0974 00AF     		add	r7, sp, #0
 5857              		.cfi_offset 7, -4
 5858              	.LCFI68:
 5859              		.cfi_def_cfa_register 7
 5860 0976 7860     		str	r0, [r7, #4]
1553:../3rdParty/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE ux;
1554:../3rdParty/FreeRTOS/queue.c **** 
1555:../3rdParty/FreeRTOS/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
1556:../3rdParty/FreeRTOS/queue.c **** 		registry. */
1557:../3rdParty/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5861              		.loc 1 1557 0
 5862 0978 4FF00003 		mov	r3, #0
 5863 097c FB60     		str	r3, [r7, #12]
 5864 097e 13E0     		b	.L90
 5865              	.L93:
1558:../3rdParty/FreeRTOS/queue.c **** 		{
1559:../3rdParty/FreeRTOS/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 5866              		.loc 1 1559 0
 5867 0980 0D4A     		ldr	r2, .L94
 5868 0982 FB68     		ldr	r3, [r7, #12]
 5869 0984 4FEAC303 		lsl	r3, r3, #3
 5870 0988 D318     		adds	r3, r2, r3
 5871 098a 5A68     		ldr	r2, [r3, #4]
 5872 098c 7B68     		ldr	r3, [r7, #4]
 5873 098e 9A42     		cmp	r2, r3
 5874 0990 06D1     		bne	.L91
1560:../3rdParty/FreeRTOS/queue.c **** 			{
1561:../3rdParty/FreeRTOS/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
1562:../3rdParty/FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 5875              		.loc 1 1562 0
 5876 0992 094B     		ldr	r3, .L94
 5877 0994 FA68     		ldr	r2, [r7, #12]
 5878 0996 4FF00001 		mov	r1, #0
 5879 099a 43F83210 		str	r1, [r3, r2, lsl #3]
1563:../3rdParty/FreeRTOS/queue.c **** 				break;
 5880              		.loc 1 1563 0
 5881 099e 06E0     		b	.L89
 5882              	.L91:
1557:../3rdParty/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5883              		.loc 1 1557 0
 5884 09a0 FB68     		ldr	r3, [r7, #12]
 5885 09a2 03F10103 		add	r3, r3, #1
 5886 09a6 FB60     		str	r3, [r7, #12]
 5887              	.L90:
1557:../3rdParty/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5888              		.loc 1 1557 0 is_stmt 0 discriminator 1
 5889 09a8 FB68     		ldr	r3, [r7, #12]
 5890 09aa 092B     		cmp	r3, #9
 5891 09ac E8D9     		bls	.L93
 5892              	.L89:
1564:../3rdParty/FreeRTOS/queue.c **** 			}
1565:../3rdParty/FreeRTOS/queue.c **** 		}
1566:../3rdParty/FreeRTOS/queue.c **** 
1567:../3rdParty/FreeRTOS/queue.c **** 	}
 5893              		.loc 1 1567 0 is_stmt 1
 5894 09ae 07F11407 		add	r7, r7, #20
 5895 09b2 BD46     		mov	sp, r7
 5896 09b4 80BC     		pop	{r7}
 5897 09b6 7047     		bx	lr
 5898              	.L95:
 5899              		.align	2
 5900              	.L94:
 5901 09b8 00000000 		.word	xQueueRegistry
 5902              		.cfi_endproc
 5903              	.LFE77:
 5905              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
                            *COM*:00000050 xQueueRegistry
     /tmp/ccJ44cRO.s:4052   .text:00000000 $t
     /tmp/ccJ44cRO.s:4057   .text:00000000 xQueueGenericCreate
     /tmp/ccJ44cRO.s:4194   .text:000000dc xQueueCreateMutex
     /tmp/ccJ44cRO.s:4433   .text:00000234 xQueueGenericSend
     /tmp/ccJ44cRO.s:4294   .text:00000180 xQueueGiveMutexRecursive
     /tmp/ccJ44cRO.s:4362   .text:000001d8 xQueueTakeMutexRecursive
     /tmp/ccJ44cRO.s:4715   .text:000003e4 xQueueGenericReceive
     /tmp/ccJ44cRO.s:5284   .text:000006c0 prvCopyDataToQueue
     /tmp/ccJ44cRO.s:5681   .text:000008c4 prvIsQueueFull
     /tmp/ccJ44cRO.s:5478   .text:000007d4 prvUnlockQueue
     /tmp/ccJ44cRO.s:4611   .text:00000354 xQueueGenericSendFromISR
     /tmp/ccJ44cRO.s:5412   .text:00000784 prvCopyDataFromQueue
     /tmp/ccJ44cRO.s:5595   .text:00000874 prvIsQueueEmpty
     /tmp/ccJ44cRO.s:4952   .text:0000056c xQueueReceiveFromISR
     /tmp/ccJ44cRO.s:5058   .text:00000600 uxQueueMessagesWaiting
     /tmp/ccJ44cRO.s:5099   .text:00000624 uxQueueMessagesWaitingFromISR
     /tmp/ccJ44cRO.s:5137   .text:00000640 vQueueDelete
     /tmp/ccJ44cRO.s:5843   .text:00000970 vQueueUnregisterQueue
     /tmp/ccJ44cRO.s:5178   .text:00000668 ucQueueGetQueueNumber
     /tmp/ccJ44cRO.s:5213   .text:00000684 vQueueSetQueueNumber
     /tmp/ccJ44cRO.s:5250   .text:000006a4 ucQueueGetQueueType
     /tmp/ccJ44cRO.s:5640   .text:000008a0 xQueueIsQueueEmptyFromISR
     /tmp/ccJ44cRO.s:5728   .text:000008f4 xQueueIsQueueFullFromISR
     /tmp/ccJ44cRO.s:5772   .text:0000091c vQueueAddToRegistry
     /tmp/ccJ44cRO.s:5835   .text:0000096c $d
     /tmp/ccJ44cRO.s:5839   .text:00000970 $t
     /tmp/ccJ44cRO.s:5901   .text:000009b8 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pvPortMalloc
vListInitialise
vPortFree
xTaskGetCurrentTaskHandle
vPortEnterCritical
xTaskRemoveFromEventList
vPortYieldFromISR
vPortExitCritical
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vTaskPriorityInherit
vTaskPriorityDisinherit
memcpy
vTaskMissedYield
