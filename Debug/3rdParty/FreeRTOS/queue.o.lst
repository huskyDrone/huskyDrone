   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"queue.c"
  23              	.Ltext0:
  24              		.file 1 "../3rdParty/FreeRTOS/queue.c"
 3403              		.align	2
 3404              		.global	xQueueGenericCreate
 3405              		.thumb
 3406              		.thumb_func
 3408              	xQueueGenericCreate:
 3409              	.LFB55:
   1:../3rdParty/FreeRTOS/queue.c **** /*
   2:../3rdParty/FreeRTOS/queue.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../3rdParty/FreeRTOS/queue.c **** 
   4:../3rdParty/FreeRTOS/queue.c **** 
   5:../3rdParty/FreeRTOS/queue.c ****     ***************************************************************************
   6:../3rdParty/FreeRTOS/queue.c ****      *                                                                       *
   7:../3rdParty/FreeRTOS/queue.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../3rdParty/FreeRTOS/queue.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../3rdParty/FreeRTOS/queue.c ****      *    available.                                                         *
  10:../3rdParty/FreeRTOS/queue.c ****      *                                                                       *
  11:../3rdParty/FreeRTOS/queue.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../3rdParty/FreeRTOS/queue.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../3rdParty/FreeRTOS/queue.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../3rdParty/FreeRTOS/queue.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../3rdParty/FreeRTOS/queue.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../3rdParty/FreeRTOS/queue.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../3rdParty/FreeRTOS/queue.c ****      *                                                                       *
  18:../3rdParty/FreeRTOS/queue.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../3rdParty/FreeRTOS/queue.c ****      *                                                                       *
  20:../3rdParty/FreeRTOS/queue.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../3rdParty/FreeRTOS/queue.c ****      *                                                                       *
  22:../3rdParty/FreeRTOS/queue.c ****     ***************************************************************************
  23:../3rdParty/FreeRTOS/queue.c **** 
  24:../3rdParty/FreeRTOS/queue.c **** 
  25:../3rdParty/FreeRTOS/queue.c ****     This file is part of the FreeRTOS distribution.
  26:../3rdParty/FreeRTOS/queue.c **** 
  27:../3rdParty/FreeRTOS/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../3rdParty/FreeRTOS/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../3rdParty/FreeRTOS/queue.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../3rdParty/FreeRTOS/queue.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../3rdParty/FreeRTOS/queue.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../3rdParty/FreeRTOS/queue.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../3rdParty/FreeRTOS/queue.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../3rdParty/FreeRTOS/queue.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../3rdParty/FreeRTOS/queue.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../3rdParty/FreeRTOS/queue.c ****     more details. You should have received a copy of the GNU General Public
  37:../3rdParty/FreeRTOS/queue.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../3rdParty/FreeRTOS/queue.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../3rdParty/FreeRTOS/queue.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../3rdParty/FreeRTOS/queue.c ****     FreeRTOS WEB site.
  41:../3rdParty/FreeRTOS/queue.c **** 
  42:../3rdParty/FreeRTOS/queue.c ****     1 tab == 4 spaces!
  43:../3rdParty/FreeRTOS/queue.c **** 
  44:../3rdParty/FreeRTOS/queue.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../3rdParty/FreeRTOS/queue.c ****     contact details.
  46:../3rdParty/FreeRTOS/queue.c **** 
  47:../3rdParty/FreeRTOS/queue.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../3rdParty/FreeRTOS/queue.c ****     critical systems.
  49:../3rdParty/FreeRTOS/queue.c **** 
  50:../3rdParty/FreeRTOS/queue.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../3rdParty/FreeRTOS/queue.c ****     licensing and training services.
  52:../3rdParty/FreeRTOS/queue.c **** */
  53:../3rdParty/FreeRTOS/queue.c **** 
  54:../3rdParty/FreeRTOS/queue.c **** #include <stdlib.h>
  55:../3rdParty/FreeRTOS/queue.c **** #include <string.h>
  56:../3rdParty/FreeRTOS/queue.c **** 
  57:../3rdParty/FreeRTOS/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  58:../3rdParty/FreeRTOS/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  59:../3rdParty/FreeRTOS/queue.c **** task.h is included from an application file. */
  60:../3rdParty/FreeRTOS/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  61:../3rdParty/FreeRTOS/queue.c **** 
  62:../3rdParty/FreeRTOS/queue.c **** #include "FreeRTOS.h"
  63:../3rdParty/FreeRTOS/queue.c **** #include "task.h"
  64:../3rdParty/FreeRTOS/queue.c **** 
  65:../3rdParty/FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  66:../3rdParty/FreeRTOS/queue.c **** 	#include "croutine.h"
  67:../3rdParty/FreeRTOS/queue.c **** #endif
  68:../3rdParty/FreeRTOS/queue.c **** 
  69:../3rdParty/FreeRTOS/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../3rdParty/FreeRTOS/queue.c **** 
  71:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------
  72:../3rdParty/FreeRTOS/queue.c ****  * PUBLIC LIST API documented in list.h
  73:../3rdParty/FreeRTOS/queue.c ****  *----------------------------------------------------------*/
  74:../3rdParty/FreeRTOS/queue.c **** 
  75:../3rdParty/FreeRTOS/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  76:../3rdParty/FreeRTOS/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  77:../3rdParty/FreeRTOS/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  78:../3rdParty/FreeRTOS/queue.c **** 
  79:../3rdParty/FreeRTOS/queue.c **** #define queueERRONEOUS_UNBLOCK			( -1 )
  80:../3rdParty/FreeRTOS/queue.c **** 
  81:../3rdParty/FreeRTOS/queue.c **** /* For internal use only. */
  82:../3rdParty/FreeRTOS/queue.c **** #define	queueSEND_TO_BACK				( 0 )
  83:../3rdParty/FreeRTOS/queue.c **** #define	queueSEND_TO_FRONT				( 1 )
  84:../3rdParty/FreeRTOS/queue.c **** 
  85:../3rdParty/FreeRTOS/queue.c **** /* Effectively make a union out of the xQUEUE structure. */
  86:../3rdParty/FreeRTOS/queue.c **** #define pxMutexHolder					pcTail
  87:../3rdParty/FreeRTOS/queue.c **** #define uxQueueType						pcHead
  88:../3rdParty/FreeRTOS/queue.c **** #define uxRecursiveCallCount			pcReadFrom
  89:../3rdParty/FreeRTOS/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  90:../3rdParty/FreeRTOS/queue.c **** 
  91:../3rdParty/FreeRTOS/queue.c **** /* Semaphores do not actually store or copy data, so have an items size of
  92:../3rdParty/FreeRTOS/queue.c **** zero. */
  93:../3rdParty/FreeRTOS/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
  94:../3rdParty/FreeRTOS/queue.c **** #define queueDONT_BLOCK					 ( ( portTickType ) 0U )
  95:../3rdParty/FreeRTOS/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
  96:../3rdParty/FreeRTOS/queue.c **** 
  97:../3rdParty/FreeRTOS/queue.c **** /* These definitions *must* match those in queue.h. */
  98:../3rdParty/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_BASE				( 0U )
  99:../3rdParty/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_MUTEX 				( 1U )
 100:../3rdParty/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( 2U )
 101:../3rdParty/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_BINARY_SEMAPHORE	( 3U )
 102:../3rdParty/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_RECURSIVE_MUTEX		( 4U )
 103:../3rdParty/FreeRTOS/queue.c **** 
 104:../3rdParty/FreeRTOS/queue.c **** /*
 105:../3rdParty/FreeRTOS/queue.c ****  * Definition of the queue used by the scheduler.
 106:../3rdParty/FreeRTOS/queue.c ****  * Items are queued by copy, not reference.
 107:../3rdParty/FreeRTOS/queue.c ****  */
 108:../3rdParty/FreeRTOS/queue.c **** typedef struct QueueDefinition
 109:../3rdParty/FreeRTOS/queue.c **** {
 110:../3rdParty/FreeRTOS/queue.c **** 	signed char *pcHead;				/*< Points to the beginning of the queue storage area. */
 111:../3rdParty/FreeRTOS/queue.c **** 	signed char *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more by
 112:../3rdParty/FreeRTOS/queue.c **** 
 113:../3rdParty/FreeRTOS/queue.c **** 	signed char *pcWriteTo;				/*< Points to the free next place in the storage area. */
 114:../3rdParty/FreeRTOS/queue.c **** 	signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
 115:../3rdParty/FreeRTOS/queue.c **** 
 116:../3rdParty/FreeRTOS/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 117:../3rdParty/FreeRTOS/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 118:../3rdParty/FreeRTOS/queue.c **** 
 119:../3rdParty/FreeRTOS/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 120:../3rdParty/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 121:../3rdParty/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 122:../3rdParty/FreeRTOS/queue.c **** 
 123:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xRxLock;			/*< Stores the number of items received from the queue (removed fr
 124:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xTxLock;			/*< Stores the number of items transmitted to the queue (added to 
 125:../3rdParty/FreeRTOS/queue.c **** 	
 126:../3rdParty/FreeRTOS/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:../3rdParty/FreeRTOS/queue.c **** 		unsigned char ucQueueNumber;
 128:../3rdParty/FreeRTOS/queue.c **** 		unsigned char ucQueueType;
 129:../3rdParty/FreeRTOS/queue.c **** 	#endif
 130:../3rdParty/FreeRTOS/queue.c **** 
 131:../3rdParty/FreeRTOS/queue.c **** } xQUEUE;
 132:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 133:../3rdParty/FreeRTOS/queue.c **** 
 134:../3rdParty/FreeRTOS/queue.c **** /*
 135:../3rdParty/FreeRTOS/queue.c ****  * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
 136:../3rdParty/FreeRTOS/queue.c ****  * To keep the definition private the API header file defines it as a
 137:../3rdParty/FreeRTOS/queue.c ****  * pointer to void.
 138:../3rdParty/FreeRTOS/queue.c ****  */
 139:../3rdParty/FreeRTOS/queue.c **** typedef xQUEUE * xQueueHandle;
 140:../3rdParty/FreeRTOS/queue.c **** 
 141:../3rdParty/FreeRTOS/queue.c **** /*
 142:../3rdParty/FreeRTOS/queue.c ****  * Prototypes for public functions are included here so we don't have to
 143:../3rdParty/FreeRTOS/queue.c ****  * include the API header file (as it defines xQueueHandle differently).  These
 144:../3rdParty/FreeRTOS/queue.c ****  * functions are documented in the API header file.
 145:../3rdParty/FreeRTOS/queue.c ****  */
 146:../3rdParty/FreeRTOS/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 147:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 148:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 149:../3rdParty/FreeRTOS/queue.c **** void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 150:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 151:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 152:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 153:../3rdParty/FreeRTOS/queue.c **** xQueueHandle xQueueCreateMutex( unsigned char ucQueueType ) PRIVILEGED_FUNCTION;
 154:../3rdParty/FreeRTOS/queue.c **** xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_
 155:../3rdParty/FreeRTOS/queue.c **** portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_F
 156:../3rdParty/FreeRTOS/queue.c **** portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
 157:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, 
 158:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTick
 159:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 160:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 161:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCT
 162:../3rdParty/FreeRTOS/queue.c **** void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait ) PRIVILEGED_F
 163:../3rdParty/FreeRTOS/queue.c **** unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 164:../3rdParty/FreeRTOS/queue.c **** void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber ) PRIVILEGED_FUNCTION;
 165:../3rdParty/FreeRTOS/queue.c **** unsigned char ucQueueGetQueueType( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 166:../3rdParty/FreeRTOS/queue.c **** 
 167:../3rdParty/FreeRTOS/queue.c **** /*
 168:../3rdParty/FreeRTOS/queue.c ****  * Co-routine queue functions differ from task queue functions.  Co-routines are
 169:../3rdParty/FreeRTOS/queue.c ****  * an optional component.
 170:../3rdParty/FreeRTOS/queue.c ****  */
 171:../3rdParty/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
 172:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed 
 173:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE
 174:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType x
 175:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToW
 176:../3rdParty/FreeRTOS/queue.c **** #endif
 177:../3rdParty/FreeRTOS/queue.c **** 
 178:../3rdParty/FreeRTOS/queue.c **** /*
 179:../3rdParty/FreeRTOS/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 180:../3rdParty/FreeRTOS/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 181:../3rdParty/FreeRTOS/queue.c ****  */
 182:../3rdParty/FreeRTOS/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
 183:../3rdParty/FreeRTOS/queue.c **** 
 184:../3rdParty/FreeRTOS/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 185:../3rdParty/FreeRTOS/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 186:../3rdParty/FreeRTOS/queue.c **** 	more user friendly. */
 187:../3rdParty/FreeRTOS/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 188:../3rdParty/FreeRTOS/queue.c **** 	{
 189:../3rdParty/FreeRTOS/queue.c **** 		signed char *pcQueueName;
 190:../3rdParty/FreeRTOS/queue.c **** 		xQueueHandle xHandle;
 191:../3rdParty/FreeRTOS/queue.c **** 	} xQueueRegistryItem;
 192:../3rdParty/FreeRTOS/queue.c **** 
 193:../3rdParty/FreeRTOS/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 194:../3rdParty/FreeRTOS/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 195:../3rdParty/FreeRTOS/queue.c **** 	array position being vacant. */
 196:../3rdParty/FreeRTOS/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 197:../3rdParty/FreeRTOS/queue.c **** 
 198:../3rdParty/FreeRTOS/queue.c **** 	/* Removes a queue from the registry by simply setting the pcQueueName
 199:../3rdParty/FreeRTOS/queue.c **** 	member to NULL. */
 200:../3rdParty/FreeRTOS/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 201:../3rdParty/FreeRTOS/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
 202:../3rdParty/FreeRTOS/queue.c **** #endif
 203:../3rdParty/FreeRTOS/queue.c **** 
 204:../3rdParty/FreeRTOS/queue.c **** /*
 205:../3rdParty/FreeRTOS/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 206:../3rdParty/FreeRTOS/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 207:../3rdParty/FreeRTOS/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 208:../3rdParty/FreeRTOS/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 209:../3rdParty/FreeRTOS/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 210:../3rdParty/FreeRTOS/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 211:../3rdParty/FreeRTOS/queue.c ****  */
 212:../3rdParty/FreeRTOS/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 213:../3rdParty/FreeRTOS/queue.c **** 
 214:../3rdParty/FreeRTOS/queue.c **** /*
 215:../3rdParty/FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 216:../3rdParty/FreeRTOS/queue.c ****  *
 217:../3rdParty/FreeRTOS/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 218:../3rdParty/FreeRTOS/queue.c ****  */
 219:../3rdParty/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 220:../3rdParty/FreeRTOS/queue.c **** 
 221:../3rdParty/FreeRTOS/queue.c **** /*
 222:../3rdParty/FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 223:../3rdParty/FreeRTOS/queue.c ****  *
 224:../3rdParty/FreeRTOS/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 225:../3rdParty/FreeRTOS/queue.c ****  */
 226:../3rdParty/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 227:../3rdParty/FreeRTOS/queue.c **** 
 228:../3rdParty/FreeRTOS/queue.c **** /*
 229:../3rdParty/FreeRTOS/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 230:../3rdParty/FreeRTOS/queue.c ****  * back of the queue.
 231:../3rdParty/FreeRTOS/queue.c ****  */
 232:../3rdParty/FreeRTOS/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 233:../3rdParty/FreeRTOS/queue.c **** 
 234:../3rdParty/FreeRTOS/queue.c **** /*
 235:../3rdParty/FreeRTOS/queue.c ****  * Copies an item out of a queue.
 236:../3rdParty/FreeRTOS/queue.c ****  */
 237:../3rdParty/FreeRTOS/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTIO
 238:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 239:../3rdParty/FreeRTOS/queue.c **** 
 240:../3rdParty/FreeRTOS/queue.c **** /*
 241:../3rdParty/FreeRTOS/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 242:../3rdParty/FreeRTOS/queue.c ****  * accessing the queue event lists.
 243:../3rdParty/FreeRTOS/queue.c ****  */
 244:../3rdParty/FreeRTOS/queue.c **** #define prvLockQueue( pxQueue )								\
 245:../3rdParty/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();									\
 246:../3rdParty/FreeRTOS/queue.c **** 	{														\
 247:../3rdParty/FreeRTOS/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 248:../3rdParty/FreeRTOS/queue.c **** 		{													\
 249:../3rdParty/FreeRTOS/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 250:../3rdParty/FreeRTOS/queue.c **** 		}													\
 251:../3rdParty/FreeRTOS/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 252:../3rdParty/FreeRTOS/queue.c **** 		{													\
 253:../3rdParty/FreeRTOS/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 254:../3rdParty/FreeRTOS/queue.c **** 		}													\
 255:../3rdParty/FreeRTOS/queue.c **** 	}														\
 256:../3rdParty/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL()
 257:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 258:../3rdParty/FreeRTOS/queue.c **** 
 259:../3rdParty/FreeRTOS/queue.c **** 
 260:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------
 261:../3rdParty/FreeRTOS/queue.c ****  * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 262:../3rdParty/FreeRTOS/queue.c ****  *----------------------------------------------------------*/
 263:../3rdParty/FreeRTOS/queue.c **** 
 264:../3rdParty/FreeRTOS/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 265:../3rdParty/FreeRTOS/queue.c **** {
 3410              		.loc 1 265 0
 3411              		@ args = 0, pretend = 0, frame = 32
 3412              		@ frame_needed = 1, uses_anonymous_args = 0
 3413 0000 80B5     		push	{r7, lr}
 3414              	.LCFI0:
 3415 0002 88B0     		sub	sp, sp, #32
 3416              	.LCFI1:
 3417 0004 00AF     		add	r7, sp, #0
 3418              	.LCFI2:
 3419 0006 F860     		str	r0, [r7, #12]
 3420 0008 B960     		str	r1, [r7, #8]
 3421 000a 1346     		mov	r3, r2
 3422 000c FB71     		strb	r3, [r7, #7]
 266:../3rdParty/FreeRTOS/queue.c **** xQUEUE *pxNewQueue;
 267:../3rdParty/FreeRTOS/queue.c **** size_t xQueueSizeInBytes;
 268:../3rdParty/FreeRTOS/queue.c **** xQueueHandle xReturn = NULL;
 3423              		.loc 1 268 0
 3424 000e 4FF00003 		mov	r3, #0
 3425 0012 FB61     		str	r3, [r7, #28]
 269:../3rdParty/FreeRTOS/queue.c **** 
 270:../3rdParty/FreeRTOS/queue.c **** 	/* Remove compiler warnings about unused parameters should 
 271:../3rdParty/FreeRTOS/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 272:../3rdParty/FreeRTOS/queue.c **** 	( void ) ucQueueType;
 273:../3rdParty/FreeRTOS/queue.c **** 
 274:../3rdParty/FreeRTOS/queue.c **** 	/* Allocate the new queue structure. */
 275:../3rdParty/FreeRTOS/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 3426              		.loc 1 275 0
 3427 0014 FB68     		ldr	r3, [r7, #12]
 3428 0016 002B     		cmp	r3, #0
 3429 0018 5AD0     		beq	.L2
 276:../3rdParty/FreeRTOS/queue.c **** 	{
 277:../3rdParty/FreeRTOS/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 3430              		.loc 1 277 0
 3431 001a 4FF05000 		mov	r0, #80
 3432 001e FFF7FEFF 		bl	pvPortMalloc
 3433 0022 0346     		mov	r3, r0
 3434 0024 7B61     		str	r3, [r7, #20]
 278:../3rdParty/FreeRTOS/queue.c **** 		if( pxNewQueue != NULL )
 3435              		.loc 1 278 0
 3436 0026 7B69     		ldr	r3, [r7, #20]
 3437 0028 002B     		cmp	r3, #0
 3438 002a 51D0     		beq	.L2
 279:../3rdParty/FreeRTOS/queue.c **** 		{
 280:../3rdParty/FreeRTOS/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 281:../3rdParty/FreeRTOS/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 282:../3rdParty/FreeRTOS/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 3439              		.loc 1 282 0
 3440 002c FB68     		ldr	r3, [r7, #12]
 3441 002e BA68     		ldr	r2, [r7, #8]
 3442 0030 02FB03F3 		mul	r3, r2, r3
 3443 0034 03F10103 		add	r3, r3, #1
 3444 0038 BB61     		str	r3, [r7, #24]
 283:../3rdParty/FreeRTOS/queue.c **** 
 284:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 3445              		.loc 1 284 0
 3446 003a B869     		ldr	r0, [r7, #24]
 3447 003c FFF7FEFF 		bl	pvPortMalloc
 3448 0040 0346     		mov	r3, r0
 3449 0042 1A46     		mov	r2, r3
 3450 0044 7B69     		ldr	r3, [r7, #20]
 3451 0046 1A60     		str	r2, [r3, #0]
 285:../3rdParty/FreeRTOS/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 3452              		.loc 1 285 0
 3453 0048 7B69     		ldr	r3, [r7, #20]
 3454 004a 1B68     		ldr	r3, [r3, #0]
 3455 004c 002B     		cmp	r3, #0
 3456 004e 3CD0     		beq	.L3
 286:../3rdParty/FreeRTOS/queue.c **** 			{
 287:../3rdParty/FreeRTOS/queue.c **** 				/* Initialise the queue members as described above where the
 288:../3rdParty/FreeRTOS/queue.c **** 				queue type is defined. */
 289:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 3457              		.loc 1 289 0
 3458 0050 7B69     		ldr	r3, [r7, #20]
 3459 0052 1A68     		ldr	r2, [r3, #0]
 3460 0054 FB68     		ldr	r3, [r7, #12]
 3461 0056 B968     		ldr	r1, [r7, #8]
 3462 0058 01FB03F3 		mul	r3, r1, r3
 3463 005c 1A44     		add	r2, r2, r3
 3464 005e 7B69     		ldr	r3, [r7, #20]
 3465 0060 5A60     		str	r2, [r3, #4]
 290:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 3466              		.loc 1 290 0
 3467 0062 7B69     		ldr	r3, [r7, #20]
 3468 0064 4FF00002 		mov	r2, #0
 3469 0068 9A63     		str	r2, [r3, #56]
 291:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 3470              		.loc 1 291 0
 3471 006a 7B69     		ldr	r3, [r7, #20]
 3472 006c 1A68     		ldr	r2, [r3, #0]
 3473 006e 7B69     		ldr	r3, [r7, #20]
 3474 0070 9A60     		str	r2, [r3, #8]
 292:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U
 3475              		.loc 1 292 0
 3476 0072 7B69     		ldr	r3, [r7, #20]
 3477 0074 1A68     		ldr	r2, [r3, #0]
 3478 0076 FB68     		ldr	r3, [r7, #12]
 3479 0078 03F1FF33 		add	r3, r3, #-1
 3480 007c B968     		ldr	r1, [r7, #8]
 3481 007e 01FB03F3 		mul	r3, r1, r3
 3482 0082 1A44     		add	r2, r2, r3
 3483 0084 7B69     		ldr	r3, [r7, #20]
 3484 0086 DA60     		str	r2, [r3, #12]
 293:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 3485              		.loc 1 293 0
 3486 0088 7B69     		ldr	r3, [r7, #20]
 3487 008a FA68     		ldr	r2, [r7, #12]
 3488 008c DA63     		str	r2, [r3, #60]
 294:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 3489              		.loc 1 294 0
 3490 008e 7B69     		ldr	r3, [r7, #20]
 3491 0090 BA68     		ldr	r2, [r7, #8]
 3492 0092 1A64     		str	r2, [r3, #64]
 295:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 3493              		.loc 1 295 0
 3494 0094 7B69     		ldr	r3, [r7, #20]
 3495 0096 4FF0FF32 		mov	r2, #-1
 3496 009a 5A64     		str	r2, [r3, #68]
 296:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 3497              		.loc 1 296 0
 3498 009c 7B69     		ldr	r3, [r7, #20]
 3499 009e 4FF0FF32 		mov	r2, #-1
 3500 00a2 9A64     		str	r2, [r3, #72]
 297:../3rdParty/FreeRTOS/queue.c **** 				#if ( configUSE_TRACE_FACILITY == 1 )
 298:../3rdParty/FreeRTOS/queue.c **** 				{
 299:../3rdParty/FreeRTOS/queue.c **** 					pxNewQueue->ucQueueType = ucQueueType;
 3501              		.loc 1 299 0
 3502 00a4 7B69     		ldr	r3, [r7, #20]
 3503 00a6 FA79     		ldrb	r2, [r7, #7]
 3504 00a8 83F84D20 		strb	r2, [r3, #77]
 300:../3rdParty/FreeRTOS/queue.c **** 				}
 301:../3rdParty/FreeRTOS/queue.c **** 				#endif /* configUSE_TRACE_FACILITY */
 302:../3rdParty/FreeRTOS/queue.c **** 
 303:../3rdParty/FreeRTOS/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 304:../3rdParty/FreeRTOS/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 3505              		.loc 1 304 0
 3506 00ac 7B69     		ldr	r3, [r7, #20]
 3507 00ae 03F11003 		add	r3, r3, #16
 3508 00b2 1846     		mov	r0, r3
 3509 00b4 FFF7FEFF 		bl	vListInitialise
 305:../3rdParty/FreeRTOS/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 3510              		.loc 1 305 0
 3511 00b8 7B69     		ldr	r3, [r7, #20]
 3512 00ba 03F12403 		add	r3, r3, #36
 3513 00be 1846     		mov	r0, r3
 3514 00c0 FFF7FEFF 		bl	vListInitialise
 306:../3rdParty/FreeRTOS/queue.c **** 
 307:../3rdParty/FreeRTOS/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 308:../3rdParty/FreeRTOS/queue.c **** 				xReturn = pxNewQueue;
 3515              		.loc 1 308 0
 3516 00c4 7B69     		ldr	r3, [r7, #20]
 3517 00c6 FB61     		str	r3, [r7, #28]
 3518 00c8 02E0     		b	.L2
 3519              	.L3:
 309:../3rdParty/FreeRTOS/queue.c **** 			}
 310:../3rdParty/FreeRTOS/queue.c **** 			else
 311:../3rdParty/FreeRTOS/queue.c **** 			{
 312:../3rdParty/FreeRTOS/queue.c **** 				traceQUEUE_CREATE_FAILED( ucQueueType );
 313:../3rdParty/FreeRTOS/queue.c **** 				vPortFree( pxNewQueue );
 3520              		.loc 1 313 0
 3521 00ca 7869     		ldr	r0, [r7, #20]
 3522 00cc FFF7FEFF 		bl	vPortFree
 3523              	.L2:
 314:../3rdParty/FreeRTOS/queue.c **** 			}
 315:../3rdParty/FreeRTOS/queue.c **** 		}
 316:../3rdParty/FreeRTOS/queue.c **** 	}
 317:../3rdParty/FreeRTOS/queue.c **** 
 318:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( xReturn );
 319:../3rdParty/FreeRTOS/queue.c **** 
 320:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 3524              		.loc 1 320 0
 3525 00d0 FB69     		ldr	r3, [r7, #28]
 321:../3rdParty/FreeRTOS/queue.c **** }
 3526              		.loc 1 321 0
 3527 00d2 1846     		mov	r0, r3
 3528 00d4 07F12007 		add	r7, r7, #32
 3529 00d8 BD46     		mov	sp, r7
 3530 00da 80BD     		pop	{r7, pc}
 3531              	.LFE55:
 3533              		.align	2
 3534              		.global	xQueueCreateMutex
 3535              		.thumb
 3536              		.thumb_func
 3538              	xQueueCreateMutex:
 3539              	.LFB56:
 322:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 323:../3rdParty/FreeRTOS/queue.c **** 
 324:../3rdParty/FreeRTOS/queue.c **** #if ( configUSE_MUTEXES == 1 )
 325:../3rdParty/FreeRTOS/queue.c **** 
 326:../3rdParty/FreeRTOS/queue.c **** 	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
 327:../3rdParty/FreeRTOS/queue.c **** 	{
 3540              		.loc 1 327 0
 3541              		@ args = 0, pretend = 0, frame = 16
 3542              		@ frame_needed = 1, uses_anonymous_args = 0
 3543 00dc 80B5     		push	{r7, lr}
 3544              	.LCFI3:
 3545 00de 84B0     		sub	sp, sp, #16
 3546              	.LCFI4:
 3547 00e0 00AF     		add	r7, sp, #0
 3548              	.LCFI5:
 3549 00e2 0346     		mov	r3, r0
 3550 00e4 FB71     		strb	r3, [r7, #7]
 328:../3rdParty/FreeRTOS/queue.c **** 	xQUEUE *pxNewQueue;
 329:../3rdParty/FreeRTOS/queue.c **** 
 330:../3rdParty/FreeRTOS/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 331:../3rdParty/FreeRTOS/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 332:../3rdParty/FreeRTOS/queue.c **** 		( void ) ucQueueType;
 333:../3rdParty/FreeRTOS/queue.c **** 	
 334:../3rdParty/FreeRTOS/queue.c **** 		/* Allocate the new queue structure. */
 335:../3rdParty/FreeRTOS/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 3551              		.loc 1 335 0
 3552 00e6 4FF05000 		mov	r0, #80
 3553 00ea FFF7FEFF 		bl	pvPortMalloc
 3554 00ee 0346     		mov	r3, r0
 3555 00f0 FB60     		str	r3, [r7, #12]
 336:../3rdParty/FreeRTOS/queue.c **** 		if( pxNewQueue != NULL )
 3556              		.loc 1 336 0
 3557 00f2 FB68     		ldr	r3, [r7, #12]
 3558 00f4 002B     		cmp	r3, #0
 3559 00f6 3CD0     		beq	.L6
 337:../3rdParty/FreeRTOS/queue.c **** 		{
 338:../3rdParty/FreeRTOS/queue.c **** 			/* Information required for priority inheritance. */
 339:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 3560              		.loc 1 339 0
 3561 00f8 FB68     		ldr	r3, [r7, #12]
 3562 00fa 4FF00002 		mov	r2, #0
 3563 00fe 5A60     		str	r2, [r3, #4]
 340:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 3564              		.loc 1 340 0
 3565 0100 FB68     		ldr	r3, [r7, #12]
 3566 0102 4FF00002 		mov	r2, #0
 3567 0106 1A60     		str	r2, [r3, #0]
 341:../3rdParty/FreeRTOS/queue.c **** 
 342:../3rdParty/FreeRTOS/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 343:../3rdParty/FreeRTOS/queue.c **** 			of the queue. */
 344:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 3568              		.loc 1 344 0
 3569 0108 FB68     		ldr	r3, [r7, #12]
 3570 010a 4FF00002 		mov	r2, #0
 3571 010e 9A60     		str	r2, [r3, #8]
 345:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->pcReadFrom = NULL;
 3572              		.loc 1 345 0
 3573 0110 FB68     		ldr	r3, [r7, #12]
 3574 0112 4FF00002 		mov	r2, #0
 3575 0116 DA60     		str	r2, [r3, #12]
 346:../3rdParty/FreeRTOS/queue.c **** 
 347:../3rdParty/FreeRTOS/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 348:../3rdParty/FreeRTOS/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 349:../3rdParty/FreeRTOS/queue.c **** 			of the mutex. */
 350:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 3576              		.loc 1 350 0
 3577 0118 FB68     		ldr	r3, [r7, #12]
 3578 011a 4FF00002 		mov	r2, #0
 3579 011e 9A63     		str	r2, [r3, #56]
 351:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 3580              		.loc 1 351 0
 3581 0120 FB68     		ldr	r3, [r7, #12]
 3582 0122 4FF00102 		mov	r2, #1
 3583 0126 DA63     		str	r2, [r3, #60]
 352:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 3584              		.loc 1 352 0
 3585 0128 FB68     		ldr	r3, [r7, #12]
 3586 012a 4FF00002 		mov	r2, #0
 3587 012e 1A64     		str	r2, [r3, #64]
 353:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 3588              		.loc 1 353 0
 3589 0130 FB68     		ldr	r3, [r7, #12]
 3590 0132 4FF0FF32 		mov	r2, #-1
 3591 0136 5A64     		str	r2, [r3, #68]
 354:../3rdParty/FreeRTOS/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 3592              		.loc 1 354 0
 3593 0138 FB68     		ldr	r3, [r7, #12]
 3594 013a 4FF0FF32 		mov	r2, #-1
 3595 013e 9A64     		str	r2, [r3, #72]
 355:../3rdParty/FreeRTOS/queue.c **** 			
 356:../3rdParty/FreeRTOS/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 357:../3rdParty/FreeRTOS/queue.c **** 			{
 358:../3rdParty/FreeRTOS/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 3596              		.loc 1 358 0
 3597 0140 FB68     		ldr	r3, [r7, #12]
 3598 0142 FA79     		ldrb	r2, [r7, #7]
 3599 0144 83F84D20 		strb	r2, [r3, #77]
 359:../3rdParty/FreeRTOS/queue.c **** 			}
 360:../3rdParty/FreeRTOS/queue.c **** 			#endif
 361:../3rdParty/FreeRTOS/queue.c **** 
 362:../3rdParty/FreeRTOS/queue.c **** 			/* Ensure the event queues start with the correct state. */
 363:../3rdParty/FreeRTOS/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 3600              		.loc 1 363 0
 3601 0148 FB68     		ldr	r3, [r7, #12]
 3602 014a 03F11003 		add	r3, r3, #16
 3603 014e 1846     		mov	r0, r3
 3604 0150 FFF7FEFF 		bl	vListInitialise
 364:../3rdParty/FreeRTOS/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 3605              		.loc 1 364 0
 3606 0154 FB68     		ldr	r3, [r7, #12]
 3607 0156 03F12403 		add	r3, r3, #36
 3608 015a 1846     		mov	r0, r3
 3609 015c FFF7FEFF 		bl	vListInitialise
 365:../3rdParty/FreeRTOS/queue.c **** 
 366:../3rdParty/FreeRTOS/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 367:../3rdParty/FreeRTOS/queue.c **** 
 368:../3rdParty/FreeRTOS/queue.c **** 			/* Start with the semaphore in the expected state. */
 369:../3rdParty/FreeRTOS/queue.c **** 			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 3610              		.loc 1 369 0
 3611 0160 F868     		ldr	r0, [r7, #12]
 3612 0162 4FF00001 		mov	r1, #0
 3613 0166 4FF00002 		mov	r2, #0
 3614 016a 4FF00003 		mov	r3, #0
 3615 016e FFF7FEFF 		bl	xQueueGenericSend
 3616              	.L6:
 370:../3rdParty/FreeRTOS/queue.c **** 		}
 371:../3rdParty/FreeRTOS/queue.c **** 		else
 372:../3rdParty/FreeRTOS/queue.c **** 		{
 373:../3rdParty/FreeRTOS/queue.c **** 			traceCREATE_MUTEX_FAILED();
 374:../3rdParty/FreeRTOS/queue.c **** 		}
 375:../3rdParty/FreeRTOS/queue.c **** 
 376:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( pxNewQueue );
 377:../3rdParty/FreeRTOS/queue.c **** 		return pxNewQueue;
 3617              		.loc 1 377 0
 3618 0172 FB68     		ldr	r3, [r7, #12]
 378:../3rdParty/FreeRTOS/queue.c **** 	}
 3619              		.loc 1 378 0
 3620 0174 1846     		mov	r0, r3
 3621 0176 07F11007 		add	r7, r7, #16
 3622 017a BD46     		mov	sp, r7
 3623 017c 80BD     		pop	{r7, pc}
 3624              	.LFE56:
 3626 017e 00BF     		.align	2
 3627              		.global	xQueueGiveMutexRecursive
 3628              		.thumb
 3629              		.thumb_func
 3631              	xQueueGiveMutexRecursive:
 3632              	.LFB57:
 379:../3rdParty/FreeRTOS/queue.c **** 
 380:../3rdParty/FreeRTOS/queue.c **** #endif /* configUSE_MUTEXES */
 381:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 382:../3rdParty/FreeRTOS/queue.c **** 
 383:../3rdParty/FreeRTOS/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 384:../3rdParty/FreeRTOS/queue.c **** 
 385:../3rdParty/FreeRTOS/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
 386:../3rdParty/FreeRTOS/queue.c **** 	{
 3633              		.loc 1 386 0
 3634              		@ args = 0, pretend = 0, frame = 16
 3635              		@ frame_needed = 1, uses_anonymous_args = 0
 3636 0180 90B5     		push	{r4, r7, lr}
 3637              	.LCFI6:
 3638 0182 85B0     		sub	sp, sp, #20
 3639              	.LCFI7:
 3640 0184 00AF     		add	r7, sp, #0
 3641              	.LCFI8:
 3642 0186 7860     		str	r0, [r7, #4]
 387:../3rdParty/FreeRTOS/queue.c **** 	portBASE_TYPE xReturn;
 388:../3rdParty/FreeRTOS/queue.c **** 
 389:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( pxMutex );
 390:../3rdParty/FreeRTOS/queue.c **** 
 391:../3rdParty/FreeRTOS/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 392:../3rdParty/FreeRTOS/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 393:../3rdParty/FreeRTOS/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 394:../3rdParty/FreeRTOS/queue.c **** 		this is the only condition we are interested in it does not matter if
 395:../3rdParty/FreeRTOS/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 396:../3rdParty/FreeRTOS/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 397:../3rdParty/FreeRTOS/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 3643              		.loc 1 397 0
 3644 0188 7B68     		ldr	r3, [r7, #4]
 3645 018a 5C68     		ldr	r4, [r3, #4]
 3646 018c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 3647 0190 0346     		mov	r3, r0
 3648 0192 9C42     		cmp	r4, r3
 3649 0194 16D1     		bne	.L9
 398:../3rdParty/FreeRTOS/queue.c **** 		{
 399:../3rdParty/FreeRTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 400:../3rdParty/FreeRTOS/queue.c **** 
 401:../3rdParty/FreeRTOS/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 402:../3rdParty/FreeRTOS/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 403:../3rdParty/FreeRTOS/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 404:../3rdParty/FreeRTOS/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 405:../3rdParty/FreeRTOS/queue.c **** 			uxRecursiveCallCount member. */
 406:../3rdParty/FreeRTOS/queue.c **** 			( pxMutex->uxRecursiveCallCount )--;
 3650              		.loc 1 406 0
 3651 0196 7B68     		ldr	r3, [r7, #4]
 3652 0198 DB68     		ldr	r3, [r3, #12]
 3653 019a 03F1FF32 		add	r2, r3, #-1
 3654 019e 7B68     		ldr	r3, [r7, #4]
 3655 01a0 DA60     		str	r2, [r3, #12]
 407:../3rdParty/FreeRTOS/queue.c **** 
 408:../3rdParty/FreeRTOS/queue.c **** 			/* Have we unwound the call count? */
 409:../3rdParty/FreeRTOS/queue.c **** 			if( pxMutex->uxRecursiveCallCount == 0 )
 3656              		.loc 1 409 0
 3657 01a2 7B68     		ldr	r3, [r7, #4]
 3658 01a4 DB68     		ldr	r3, [r3, #12]
 3659 01a6 002B     		cmp	r3, #0
 3660 01a8 08D1     		bne	.L10
 410:../3rdParty/FreeRTOS/queue.c **** 			{
 411:../3rdParty/FreeRTOS/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 412:../3rdParty/FreeRTOS/queue.c **** 				task that might be waiting to access the mutex. */
 413:../3rdParty/FreeRTOS/queue.c **** 				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 3661              		.loc 1 413 0
 3662 01aa 7868     		ldr	r0, [r7, #4]
 3663 01ac 4FF00001 		mov	r1, #0
 3664 01b0 4FF00002 		mov	r2, #0
 3665 01b4 4FF00003 		mov	r3, #0
 3666 01b8 FFF7FEFF 		bl	xQueueGenericSend
 3667              	.L10:
 414:../3rdParty/FreeRTOS/queue.c **** 			}
 415:../3rdParty/FreeRTOS/queue.c **** 
 416:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 3668              		.loc 1 416 0
 3669 01bc 4FF00103 		mov	r3, #1
 3670 01c0 FB60     		str	r3, [r7, #12]
 3671 01c2 02E0     		b	.L11
 3672              	.L9:
 417:../3rdParty/FreeRTOS/queue.c **** 		}
 418:../3rdParty/FreeRTOS/queue.c **** 		else
 419:../3rdParty/FreeRTOS/queue.c **** 		{
 420:../3rdParty/FreeRTOS/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 421:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdFAIL;
 3673              		.loc 1 421 0
 3674 01c4 4FF00003 		mov	r3, #0
 3675 01c8 FB60     		str	r3, [r7, #12]
 3676              	.L11:
 422:../3rdParty/FreeRTOS/queue.c **** 
 423:../3rdParty/FreeRTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 424:../3rdParty/FreeRTOS/queue.c **** 		}
 425:../3rdParty/FreeRTOS/queue.c **** 
 426:../3rdParty/FreeRTOS/queue.c **** 		return xReturn;
 3677              		.loc 1 426 0
 3678 01ca FB68     		ldr	r3, [r7, #12]
 427:../3rdParty/FreeRTOS/queue.c **** 	}
 3679              		.loc 1 427 0
 3680 01cc 1846     		mov	r0, r3
 3681 01ce 07F11407 		add	r7, r7, #20
 3682 01d2 BD46     		mov	sp, r7
 3683 01d4 90BD     		pop	{r4, r7, pc}
 3684              	.LFE57:
 3686 01d6 00BF     		.align	2
 3687              		.global	xQueueTakeMutexRecursive
 3688              		.thumb
 3689              		.thumb_func
 3691              	xQueueTakeMutexRecursive:
 3692              	.LFB58:
 428:../3rdParty/FreeRTOS/queue.c **** 
 429:../3rdParty/FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 430:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 431:../3rdParty/FreeRTOS/queue.c **** 
 432:../3rdParty/FreeRTOS/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 433:../3rdParty/FreeRTOS/queue.c **** 
 434:../3rdParty/FreeRTOS/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
 435:../3rdParty/FreeRTOS/queue.c **** 	{
 3693              		.loc 1 435 0
 3694              		@ args = 0, pretend = 0, frame = 16
 3695              		@ frame_needed = 1, uses_anonymous_args = 0
 3696 01d8 90B5     		push	{r4, r7, lr}
 3697              	.LCFI9:
 3698 01da 85B0     		sub	sp, sp, #20
 3699              	.LCFI10:
 3700 01dc 00AF     		add	r7, sp, #0
 3701              	.LCFI11:
 3702 01de 7860     		str	r0, [r7, #4]
 3703 01e0 3960     		str	r1, [r7, #0]
 436:../3rdParty/FreeRTOS/queue.c **** 	portBASE_TYPE xReturn;
 437:../3rdParty/FreeRTOS/queue.c **** 
 438:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( pxMutex );
 439:../3rdParty/FreeRTOS/queue.c **** 
 440:../3rdParty/FreeRTOS/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 441:../3rdParty/FreeRTOS/queue.c **** 		xQueueGiveMutexRecursive(). */
 442:../3rdParty/FreeRTOS/queue.c **** 
 443:../3rdParty/FreeRTOS/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 444:../3rdParty/FreeRTOS/queue.c **** 
 445:../3rdParty/FreeRTOS/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 3704              		.loc 1 445 0
 3705 01e2 7B68     		ldr	r3, [r7, #4]
 3706 01e4 5C68     		ldr	r4, [r3, #4]
 3707 01e6 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 3708 01ea 0346     		mov	r3, r0
 3709 01ec 9C42     		cmp	r4, r3
 3710 01ee 09D1     		bne	.L14
 446:../3rdParty/FreeRTOS/queue.c **** 		{
 447:../3rdParty/FreeRTOS/queue.c **** 			( pxMutex->uxRecursiveCallCount )++;
 3711              		.loc 1 447 0
 3712 01f0 7B68     		ldr	r3, [r7, #4]
 3713 01f2 DB68     		ldr	r3, [r3, #12]
 3714 01f4 03F10102 		add	r2, r3, #1
 3715 01f8 7B68     		ldr	r3, [r7, #4]
 3716 01fa DA60     		str	r2, [r3, #12]
 448:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 3717              		.loc 1 448 0
 3718 01fc 4FF00103 		mov	r3, #1
 3719 0200 FB60     		str	r3, [r7, #12]
 3720 0202 12E0     		b	.L15
 3721              	.L14:
 449:../3rdParty/FreeRTOS/queue.c **** 		}
 450:../3rdParty/FreeRTOS/queue.c **** 		else
 451:../3rdParty/FreeRTOS/queue.c **** 		{
 452:../3rdParty/FreeRTOS/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 3722              		.loc 1 452 0
 3723 0204 7868     		ldr	r0, [r7, #4]
 3724 0206 4FF00001 		mov	r1, #0
 3725 020a 3A68     		ldr	r2, [r7, #0]
 3726 020c 4FF00003 		mov	r3, #0
 3727 0210 FFF7FEFF 		bl	xQueueGenericReceive
 3728 0214 0346     		mov	r3, r0
 3729 0216 FB60     		str	r3, [r7, #12]
 453:../3rdParty/FreeRTOS/queue.c **** 
 454:../3rdParty/FreeRTOS/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 455:../3rdParty/FreeRTOS/queue.c **** 			we may have blocked to reach here. */
 456:../3rdParty/FreeRTOS/queue.c **** 			if( xReturn == pdPASS )
 3730              		.loc 1 456 0
 3731 0218 FB68     		ldr	r3, [r7, #12]
 3732 021a 012B     		cmp	r3, #1
 3733 021c 05D1     		bne	.L15
 457:../3rdParty/FreeRTOS/queue.c **** 			{
 458:../3rdParty/FreeRTOS/queue.c **** 				( pxMutex->uxRecursiveCallCount )++;
 3734              		.loc 1 458 0
 3735 021e 7B68     		ldr	r3, [r7, #4]
 3736 0220 DB68     		ldr	r3, [r3, #12]
 3737 0222 03F10102 		add	r2, r3, #1
 3738 0226 7B68     		ldr	r3, [r7, #4]
 3739 0228 DA60     		str	r2, [r3, #12]
 3740              	.L15:
 459:../3rdParty/FreeRTOS/queue.c **** 			}
 460:../3rdParty/FreeRTOS/queue.c **** 			else
 461:../3rdParty/FreeRTOS/queue.c **** 			{
 462:../3rdParty/FreeRTOS/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 463:../3rdParty/FreeRTOS/queue.c **** 			}
 464:../3rdParty/FreeRTOS/queue.c **** 		}
 465:../3rdParty/FreeRTOS/queue.c **** 
 466:../3rdParty/FreeRTOS/queue.c **** 		return xReturn;
 3741              		.loc 1 466 0
 3742 022a FB68     		ldr	r3, [r7, #12]
 467:../3rdParty/FreeRTOS/queue.c **** 	}
 3743              		.loc 1 467 0
 3744 022c 1846     		mov	r0, r3
 3745 022e 07F11407 		add	r7, r7, #20
 3746 0232 BD46     		mov	sp, r7
 3747 0234 90BD     		pop	{r4, r7, pc}
 3748              	.LFE58:
 3750 0236 00BF     		.align	2
 3751              		.global	xQueueGenericSend
 3752              		.thumb
 3753              		.thumb_func
 3755              	xQueueGenericSend:
 3756              	.LFB59:
 468:../3rdParty/FreeRTOS/queue.c **** 
 469:../3rdParty/FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 470:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 471:../3rdParty/FreeRTOS/queue.c **** 
 472:../3rdParty/FreeRTOS/queue.c **** #if configUSE_COUNTING_SEMAPHORES == 1
 473:../3rdParty/FreeRTOS/queue.c **** 
 474:../3rdParty/FreeRTOS/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 475:../3rdParty/FreeRTOS/queue.c **** 	{
 476:../3rdParty/FreeRTOS/queue.c **** 	xQueueHandle pxHandle;
 477:../3rdParty/FreeRTOS/queue.c **** 
 478:../3rdParty/FreeRTOS/queue.c **** 		pxHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITE
 479:../3rdParty/FreeRTOS/queue.c **** 
 480:../3rdParty/FreeRTOS/queue.c **** 		if( pxHandle != NULL )
 481:../3rdParty/FreeRTOS/queue.c **** 		{
 482:../3rdParty/FreeRTOS/queue.c **** 			pxHandle->uxMessagesWaiting = uxInitialCount;
 483:../3rdParty/FreeRTOS/queue.c **** 
 484:../3rdParty/FreeRTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 485:../3rdParty/FreeRTOS/queue.c **** 		}
 486:../3rdParty/FreeRTOS/queue.c **** 		else
 487:../3rdParty/FreeRTOS/queue.c **** 		{
 488:../3rdParty/FreeRTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 489:../3rdParty/FreeRTOS/queue.c **** 		}
 490:../3rdParty/FreeRTOS/queue.c **** 
 491:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( pxHandle );
 492:../3rdParty/FreeRTOS/queue.c **** 		return pxHandle;
 493:../3rdParty/FreeRTOS/queue.c **** 	}
 494:../3rdParty/FreeRTOS/queue.c **** 
 495:../3rdParty/FreeRTOS/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 496:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 497:../3rdParty/FreeRTOS/queue.c **** 
 498:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, por
 499:../3rdParty/FreeRTOS/queue.c **** {
 3757              		.loc 1 499 0
 3758              		@ args = 0, pretend = 0, frame = 32
 3759              		@ frame_needed = 1, uses_anonymous_args = 0
 3760 0238 80B5     		push	{r7, lr}
 3761              	.LCFI12:
 3762 023a 88B0     		sub	sp, sp, #32
 3763              	.LCFI13:
 3764 023c 00AF     		add	r7, sp, #0
 3765              	.LCFI14:
 3766 023e F860     		str	r0, [r7, #12]
 3767 0240 B960     		str	r1, [r7, #8]
 3768 0242 7A60     		str	r2, [r7, #4]
 3769 0244 3B60     		str	r3, [r7, #0]
 500:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 3770              		.loc 1 500 0
 3771 0246 4FF00003 		mov	r3, #0
 3772 024a FB61     		str	r3, [r7, #28]
 3773 024c 00E0     		b	.L29
 3774              	.L31:
 501:../3rdParty/FreeRTOS/queue.c **** xTimeOutType xTimeOut;
 502:../3rdParty/FreeRTOS/queue.c **** 
 503:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 504:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 505:../3rdParty/FreeRTOS/queue.c **** 
 506:../3rdParty/FreeRTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 507:../3rdParty/FreeRTOS/queue.c **** 	statements within the function itself.  This is done in the interest
 508:../3rdParty/FreeRTOS/queue.c **** 	of execution time efficiency. */
 509:../3rdParty/FreeRTOS/queue.c **** 	for( ;; )
 510:../3rdParty/FreeRTOS/queue.c **** 	{
 511:../3rdParty/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 512:../3rdParty/FreeRTOS/queue.c **** 		{
 513:../3rdParty/FreeRTOS/queue.c **** 			/* Is there room on the queue now?  To be running we must be
 514:../3rdParty/FreeRTOS/queue.c **** 			the highest priority task wanting to access the queue. */
 515:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 516:../3rdParty/FreeRTOS/queue.c **** 			{
 517:../3rdParty/FreeRTOS/queue.c **** 				traceQUEUE_SEND( pxQueue );
 518:../3rdParty/FreeRTOS/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 519:../3rdParty/FreeRTOS/queue.c **** 
 520:../3rdParty/FreeRTOS/queue.c **** 				/* If there was a task waiting for data to arrive on the
 521:../3rdParty/FreeRTOS/queue.c **** 				queue then unblock it now. */
 522:../3rdParty/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 523:../3rdParty/FreeRTOS/queue.c **** 				{
 524:../3rdParty/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 525:../3rdParty/FreeRTOS/queue.c **** 					{
 526:../3rdParty/FreeRTOS/queue.c **** 						/* The unblocked task has a priority higher than
 527:../3rdParty/FreeRTOS/queue.c **** 						our own so yield immediately.  Yes it is ok to do
 528:../3rdParty/FreeRTOS/queue.c **** 						this from within the critical section - the kernel
 529:../3rdParty/FreeRTOS/queue.c **** 						takes care of that. */
 530:../3rdParty/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 531:../3rdParty/FreeRTOS/queue.c **** 					}
 532:../3rdParty/FreeRTOS/queue.c **** 				}
 533:../3rdParty/FreeRTOS/queue.c **** 
 534:../3rdParty/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 535:../3rdParty/FreeRTOS/queue.c **** 
 536:../3rdParty/FreeRTOS/queue.c **** 				/* Return to the original privilege level before exiting the
 537:../3rdParty/FreeRTOS/queue.c **** 				function. */
 538:../3rdParty/FreeRTOS/queue.c **** 				return pdPASS;
 539:../3rdParty/FreeRTOS/queue.c **** 			}
 540:../3rdParty/FreeRTOS/queue.c **** 			else
 541:../3rdParty/FreeRTOS/queue.c **** 			{
 542:../3rdParty/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 543:../3rdParty/FreeRTOS/queue.c **** 				{
 544:../3rdParty/FreeRTOS/queue.c **** 					/* The queue was full and no block time is specified (or
 545:../3rdParty/FreeRTOS/queue.c **** 					the block time has expired) so leave now. */
 546:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 547:../3rdParty/FreeRTOS/queue.c **** 
 548:../3rdParty/FreeRTOS/queue.c **** 					/* Return to the original privilege level before exiting
 549:../3rdParty/FreeRTOS/queue.c **** 					the function. */
 550:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 551:../3rdParty/FreeRTOS/queue.c **** 					return errQUEUE_FULL;
 552:../3rdParty/FreeRTOS/queue.c **** 				}
 553:../3rdParty/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 554:../3rdParty/FreeRTOS/queue.c **** 				{
 555:../3rdParty/FreeRTOS/queue.c **** 					/* The queue was full and a block time was specified so
 556:../3rdParty/FreeRTOS/queue.c **** 					configure the timeout structure. */
 557:../3rdParty/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 558:../3rdParty/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 559:../3rdParty/FreeRTOS/queue.c **** 				}
 560:../3rdParty/FreeRTOS/queue.c **** 			}
 561:../3rdParty/FreeRTOS/queue.c **** 		}
 562:../3rdParty/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 563:../3rdParty/FreeRTOS/queue.c **** 
 564:../3rdParty/FreeRTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 565:../3rdParty/FreeRTOS/queue.c **** 		now the critical section has been exited. */
 566:../3rdParty/FreeRTOS/queue.c **** 
 567:../3rdParty/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 568:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 569:../3rdParty/FreeRTOS/queue.c **** 
 570:../3rdParty/FreeRTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 571:../3rdParty/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 572:../3rdParty/FreeRTOS/queue.c **** 		{
 573:../3rdParty/FreeRTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 574:../3rdParty/FreeRTOS/queue.c **** 			{
 575:../3rdParty/FreeRTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 576:../3rdParty/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 577:../3rdParty/FreeRTOS/queue.c **** 
 578:../3rdParty/FreeRTOS/queue.c **** 				/* Unlocking the queue means queue events can effect the
 579:../3rdParty/FreeRTOS/queue.c **** 				event list.  It is possible	that interrupts occurring now
 580:../3rdParty/FreeRTOS/queue.c **** 				remove this task from the event	list again - but as the
 581:../3rdParty/FreeRTOS/queue.c **** 				scheduler is suspended the task will go onto the pending
 582:../3rdParty/FreeRTOS/queue.c **** 				ready last instead of the actual ready list. */
 583:../3rdParty/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 584:../3rdParty/FreeRTOS/queue.c **** 
 585:../3rdParty/FreeRTOS/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 586:../3rdParty/FreeRTOS/queue.c **** 				ready list into the ready list - so it is feasible that this
 587:../3rdParty/FreeRTOS/queue.c **** 				task is already in a ready list before it yields - in which
 588:../3rdParty/FreeRTOS/queue.c **** 				case the yield will not cause a context switch unless there
 589:../3rdParty/FreeRTOS/queue.c **** 				is also a higher priority task in the pending ready list. */
 590:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 591:../3rdParty/FreeRTOS/queue.c **** 				{
 592:../3rdParty/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
 593:../3rdParty/FreeRTOS/queue.c **** 				}
 594:../3rdParty/FreeRTOS/queue.c **** 			}
 595:../3rdParty/FreeRTOS/queue.c **** 			else
 596:../3rdParty/FreeRTOS/queue.c **** 			{
 597:../3rdParty/FreeRTOS/queue.c **** 				/* Try again. */
 598:../3rdParty/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 599:../3rdParty/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
 600:../3rdParty/FreeRTOS/queue.c **** 			}
 601:../3rdParty/FreeRTOS/queue.c **** 		}
 602:../3rdParty/FreeRTOS/queue.c **** 		else
 603:../3rdParty/FreeRTOS/queue.c **** 		{
 604:../3rdParty/FreeRTOS/queue.c **** 			/* The timeout has expired. */
 605:../3rdParty/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 606:../3rdParty/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
 607:../3rdParty/FreeRTOS/queue.c **** 
 608:../3rdParty/FreeRTOS/queue.c **** 			/* Return to the original privilege level before exiting the
 609:../3rdParty/FreeRTOS/queue.c **** 			function. */
 610:../3rdParty/FreeRTOS/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 611:../3rdParty/FreeRTOS/queue.c **** 			return errQUEUE_FULL;
 612:../3rdParty/FreeRTOS/queue.c **** 		}
 613:../3rdParty/FreeRTOS/queue.c **** 	}
 3775              		.loc 1 613 0
 3776 024e 00BF     		nop
 3777              	.L29:
 3778              		.loc 1 511 0
 3779 0250 FFF7FEFF 		bl	vPortEnterCritical
 3780              		.loc 1 515 0
 3781 0254 FB68     		ldr	r3, [r7, #12]
 3782 0256 9A6B     		ldr	r2, [r3, #56]
 3783 0258 FB68     		ldr	r3, [r7, #12]
 3784 025a DB6B     		ldr	r3, [r3, #60]
 3785 025c 9A42     		cmp	r2, r3
 3786 025e 18D2     		bcs	.L18
 3787              		.loc 1 518 0
 3788 0260 F868     		ldr	r0, [r7, #12]
 3789 0262 B968     		ldr	r1, [r7, #8]
 3790 0264 3A68     		ldr	r2, [r7, #0]
 3791 0266 00F039FA 		bl	prvCopyDataToQueue
 3792              		.loc 1 522 0
 3793 026a FB68     		ldr	r3, [r7, #12]
 3794 026c 5B6A     		ldr	r3, [r3, #36]
 3795 026e 002B     		cmp	r3, #0
 3796 0270 0AD0     		beq	.L19
 3797              		.loc 1 524 0
 3798 0272 FB68     		ldr	r3, [r7, #12]
 3799 0274 03F12403 		add	r3, r3, #36
 3800 0278 1846     		mov	r0, r3
 3801 027a FFF7FEFF 		bl	xTaskRemoveFromEventList
 3802 027e 0346     		mov	r3, r0
 3803 0280 012B     		cmp	r3, #1
 3804 0282 01D1     		bne	.L19
 3805              		.loc 1 530 0
 3806 0284 FFF7FEFF 		bl	vPortYieldFromISR
 3807              	.L19:
 3808              		.loc 1 534 0
 3809 0288 FFF7FEFF 		bl	vPortExitCritical
 3810              		.loc 1 538 0
 3811 028c 4FF00103 		mov	r3, #1
 3812 0290 5DE0     		b	.L20
 3813              	.L18:
 3814              		.loc 1 542 0
 3815 0292 7B68     		ldr	r3, [r7, #4]
 3816 0294 002B     		cmp	r3, #0
 3817 0296 04D1     		bne	.L21
 3818              		.loc 1 546 0
 3819 0298 FFF7FEFF 		bl	vPortExitCritical
 3820              		.loc 1 551 0
 3821 029c 4FF00003 		mov	r3, #0
 3822 02a0 55E0     		b	.L20
 3823              	.L21:
 3824              		.loc 1 553 0
 3825 02a2 FB69     		ldr	r3, [r7, #28]
 3826 02a4 002B     		cmp	r3, #0
 3827 02a6 07D1     		bne	.L22
 3828              		.loc 1 557 0
 3829 02a8 07F11403 		add	r3, r7, #20
 3830 02ac 1846     		mov	r0, r3
 3831 02ae FFF7FEFF 		bl	vTaskSetTimeOutState
 3832              		.loc 1 558 0
 3833 02b2 4FF00103 		mov	r3, #1
 3834 02b6 FB61     		str	r3, [r7, #28]
 3835              	.L22:
 3836              		.loc 1 562 0
 3837 02b8 FFF7FEFF 		bl	vPortExitCritical
 3838              		.loc 1 567 0
 3839 02bc FFF7FEFF 		bl	vTaskSuspendAll
 3840              		.loc 1 568 0
 3841 02c0 FFF7FEFF 		bl	vPortEnterCritical
 3842 02c4 FB68     		ldr	r3, [r7, #12]
 3843 02c6 5B6C     		ldr	r3, [r3, #68]
 3844 02c8 B3F1FF3F 		cmp	r3, #-1
 3845 02cc 03D1     		bne	.L23
 3846 02ce FB68     		ldr	r3, [r7, #12]
 3847 02d0 4FF00002 		mov	r2, #0
 3848 02d4 5A64     		str	r2, [r3, #68]
 3849              	.L23:
 3850 02d6 FB68     		ldr	r3, [r7, #12]
 3851 02d8 9B6C     		ldr	r3, [r3, #72]
 3852 02da B3F1FF3F 		cmp	r3, #-1
 3853 02de 03D1     		bne	.L24
 3854 02e0 FB68     		ldr	r3, [r7, #12]
 3855 02e2 4FF00002 		mov	r2, #0
 3856 02e6 9A64     		str	r2, [r3, #72]
 3857              	.L24:
 3858 02e8 FFF7FEFF 		bl	vPortExitCritical
 3859              		.loc 1 571 0
 3860 02ec 07F11402 		add	r2, r7, #20
 3861 02f0 07F10403 		add	r3, r7, #4
 3862 02f4 1046     		mov	r0, r2
 3863 02f6 1946     		mov	r1, r3
 3864 02f8 FFF7FEFF 		bl	xTaskCheckForTimeOut
 3865 02fc 0346     		mov	r3, r0
 3866 02fe 002B     		cmp	r3, #0
 3867 0300 1ED1     		bne	.L25
 3868              		.loc 1 573 0
 3869 0302 F868     		ldr	r0, [r7, #12]
 3870 0304 00F0F0FA 		bl	prvIsQueueFull
 3871 0308 0346     		mov	r3, r0
 3872 030a 002B     		cmp	r3, #0
 3873 030c 12D0     		beq	.L26
 3874              		.loc 1 576 0
 3875 030e FB68     		ldr	r3, [r7, #12]
 3876 0310 03F11002 		add	r2, r3, #16
 3877 0314 7B68     		ldr	r3, [r7, #4]
 3878 0316 1046     		mov	r0, r2
 3879 0318 1946     		mov	r1, r3
 3880 031a FFF7FEFF 		bl	vTaskPlaceOnEventList
 3881              		.loc 1 583 0
 3882 031e F868     		ldr	r0, [r7, #12]
 3883 0320 00F06AFA 		bl	prvUnlockQueue
 3884              		.loc 1 590 0
 3885 0324 FFF7FEFF 		bl	xTaskResumeAll
 3886 0328 0346     		mov	r3, r0
 3887 032a 002B     		cmp	r3, #0
 3888 032c 8FD1     		bne	.L31
 3889              		.loc 1 592 0
 3890 032e FFF7FEFF 		bl	vPortYieldFromISR
 3891              		.loc 1 613 0
 3892 0332 8DE7     		b	.L29
 3893              	.L26:
 3894              		.loc 1 598 0
 3895 0334 F868     		ldr	r0, [r7, #12]
 3896 0336 00F05FFA 		bl	prvUnlockQueue
 3897              		.loc 1 599 0
 3898 033a FFF7FEFF 		bl	xTaskResumeAll
 3899              		.loc 1 613 0
 3900 033e 87E7     		b	.L29
 3901              	.L25:
 3902              		.loc 1 605 0
 3903 0340 F868     		ldr	r0, [r7, #12]
 3904 0342 00F059FA 		bl	prvUnlockQueue
 3905              		.loc 1 606 0
 3906 0346 FFF7FEFF 		bl	xTaskResumeAll
 3907              		.loc 1 611 0
 3908 034a 4FF00003 		mov	r3, #0
 3909              	.L20:
 614:../3rdParty/FreeRTOS/queue.c **** }
 3910              		.loc 1 614 0
 3911 034e 1846     		mov	r0, r3
 3912 0350 07F12007 		add	r7, r7, #32
 3913 0354 BD46     		mov	sp, r7
 3914 0356 80BD     		pop	{r7, pc}
 3915              	.LFE59:
 3917              		.align	2
 3918              		.global	xQueueGenericSendFromISR
 3919              		.thumb
 3920              		.thumb_func
 3922              	xQueueGenericSendFromISR:
 3923              	.LFB60:
 615:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 616:../3rdParty/FreeRTOS/queue.c **** 
 617:../3rdParty/FreeRTOS/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 618:../3rdParty/FreeRTOS/queue.c **** 
 619:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue,
 620:../3rdParty/FreeRTOS/queue.c **** 	{
 621:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 622:../3rdParty/FreeRTOS/queue.c **** 	xTimeOutType xTimeOut;
 623:../3rdParty/FreeRTOS/queue.c **** 
 624:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( pxQueue );
 625:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE )
 626:../3rdParty/FreeRTOS/queue.c **** 
 627:../3rdParty/FreeRTOS/queue.c **** 		for( ;; )
 628:../3rdParty/FreeRTOS/queue.c **** 		{
 629:../3rdParty/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 630:../3rdParty/FreeRTOS/queue.c **** 			{
 631:../3rdParty/FreeRTOS/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 632:../3rdParty/FreeRTOS/queue.c **** 				the highest priority task wanting to access the queue. */
 633:../3rdParty/FreeRTOS/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 634:../3rdParty/FreeRTOS/queue.c **** 				{
 635:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_SEND( pxQueue );
 636:../3rdParty/FreeRTOS/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 637:../3rdParty/FreeRTOS/queue.c **** 
 638:../3rdParty/FreeRTOS/queue.c **** 					/* If there was a task waiting for data to arrive on the
 639:../3rdParty/FreeRTOS/queue.c **** 					queue then unblock it now. */
 640:../3rdParty/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 641:../3rdParty/FreeRTOS/queue.c **** 					{
 642:../3rdParty/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 643:../3rdParty/FreeRTOS/queue.c **** 						{
 644:../3rdParty/FreeRTOS/queue.c **** 							/* The unblocked task has a priority higher than
 645:../3rdParty/FreeRTOS/queue.c **** 							our own so yield immediately. */
 646:../3rdParty/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 647:../3rdParty/FreeRTOS/queue.c **** 						}
 648:../3rdParty/FreeRTOS/queue.c **** 					}
 649:../3rdParty/FreeRTOS/queue.c **** 
 650:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 651:../3rdParty/FreeRTOS/queue.c **** 					return pdPASS;
 652:../3rdParty/FreeRTOS/queue.c **** 				}
 653:../3rdParty/FreeRTOS/queue.c **** 				else
 654:../3rdParty/FreeRTOS/queue.c **** 				{
 655:../3rdParty/FreeRTOS/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 656:../3rdParty/FreeRTOS/queue.c **** 					{
 657:../3rdParty/FreeRTOS/queue.c **** 						taskEXIT_CRITICAL();
 658:../3rdParty/FreeRTOS/queue.c **** 						return errQUEUE_FULL;
 659:../3rdParty/FreeRTOS/queue.c **** 					}
 660:../3rdParty/FreeRTOS/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 661:../3rdParty/FreeRTOS/queue.c **** 					{
 662:../3rdParty/FreeRTOS/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 663:../3rdParty/FreeRTOS/queue.c **** 						xEntryTimeSet = pdTRUE;
 664:../3rdParty/FreeRTOS/queue.c **** 					}
 665:../3rdParty/FreeRTOS/queue.c **** 				}
 666:../3rdParty/FreeRTOS/queue.c **** 			}
 667:../3rdParty/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 668:../3rdParty/FreeRTOS/queue.c **** 
 669:../3rdParty/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 670:../3rdParty/FreeRTOS/queue.c **** 			{
 671:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 672:../3rdParty/FreeRTOS/queue.c **** 				{
 673:../3rdParty/FreeRTOS/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 674:../3rdParty/FreeRTOS/queue.c **** 					{
 675:../3rdParty/FreeRTOS/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 676:../3rdParty/FreeRTOS/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 677:../3rdParty/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 678:../3rdParty/FreeRTOS/queue.c **** 					}
 679:../3rdParty/FreeRTOS/queue.c **** 				}
 680:../3rdParty/FreeRTOS/queue.c **** 				else
 681:../3rdParty/FreeRTOS/queue.c **** 				{
 682:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 683:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 684:../3rdParty/FreeRTOS/queue.c **** 					return errQUEUE_FULL;
 685:../3rdParty/FreeRTOS/queue.c **** 				}
 686:../3rdParty/FreeRTOS/queue.c **** 			}
 687:../3rdParty/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 688:../3rdParty/FreeRTOS/queue.c **** 		}
 689:../3rdParty/FreeRTOS/queue.c **** 	}
 690:../3rdParty/FreeRTOS/queue.c **** 
 691:../3rdParty/FreeRTOS/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 692:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 693:../3rdParty/FreeRTOS/queue.c **** 
 694:../3rdParty/FreeRTOS/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 695:../3rdParty/FreeRTOS/queue.c **** 
 696:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTic
 697:../3rdParty/FreeRTOS/queue.c **** 	{
 698:../3rdParty/FreeRTOS/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 699:../3rdParty/FreeRTOS/queue.c **** 	xTimeOutType xTimeOut;
 700:../3rdParty/FreeRTOS/queue.c **** 	signed char *pcOriginalReadPosition;
 701:../3rdParty/FreeRTOS/queue.c **** 
 702:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( pxQueue );
 703:../3rdParty/FreeRTOS/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U )
 704:../3rdParty/FreeRTOS/queue.c **** 
 705:../3rdParty/FreeRTOS/queue.c **** 		for( ;; )
 706:../3rdParty/FreeRTOS/queue.c **** 		{
 707:../3rdParty/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 708:../3rdParty/FreeRTOS/queue.c **** 			{
 709:../3rdParty/FreeRTOS/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 710:../3rdParty/FreeRTOS/queue.c **** 				{
 711:../3rdParty/FreeRTOS/queue.c **** 					/* Remember our read position in case we are just peeking. */
 712:../3rdParty/FreeRTOS/queue.c **** 					pcOriginalReadPosition = pxQueue->pcReadFrom;
 713:../3rdParty/FreeRTOS/queue.c **** 
 714:../3rdParty/FreeRTOS/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 715:../3rdParty/FreeRTOS/queue.c **** 
 716:../3rdParty/FreeRTOS/queue.c **** 					if( xJustPeeking == pdFALSE )
 717:../3rdParty/FreeRTOS/queue.c **** 					{
 718:../3rdParty/FreeRTOS/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 719:../3rdParty/FreeRTOS/queue.c **** 
 720:../3rdParty/FreeRTOS/queue.c **** 						/* We are actually removing data. */
 721:../3rdParty/FreeRTOS/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 722:../3rdParty/FreeRTOS/queue.c **** 
 723:../3rdParty/FreeRTOS/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 724:../3rdParty/FreeRTOS/queue.c **** 						{
 725:../3rdParty/FreeRTOS/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 726:../3rdParty/FreeRTOS/queue.c **** 							{
 727:../3rdParty/FreeRTOS/queue.c **** 								/* Record the information required to implement
 728:../3rdParty/FreeRTOS/queue.c **** 								priority inheritance should it become necessary. */
 729:../3rdParty/FreeRTOS/queue.c **** 								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 730:../3rdParty/FreeRTOS/queue.c **** 							}
 731:../3rdParty/FreeRTOS/queue.c **** 						}
 732:../3rdParty/FreeRTOS/queue.c **** 						#endif
 733:../3rdParty/FreeRTOS/queue.c **** 
 734:../3rdParty/FreeRTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 735:../3rdParty/FreeRTOS/queue.c **** 						{
 736:../3rdParty/FreeRTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 737:../3rdParty/FreeRTOS/queue.c **** 							{
 738:../3rdParty/FreeRTOS/queue.c **** 								portYIELD_WITHIN_API();
 739:../3rdParty/FreeRTOS/queue.c **** 							}
 740:../3rdParty/FreeRTOS/queue.c **** 						}
 741:../3rdParty/FreeRTOS/queue.c **** 					}
 742:../3rdParty/FreeRTOS/queue.c **** 					else
 743:../3rdParty/FreeRTOS/queue.c **** 					{
 744:../3rdParty/FreeRTOS/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 745:../3rdParty/FreeRTOS/queue.c **** 
 746:../3rdParty/FreeRTOS/queue.c **** 						/* We are not removing the data, so reset our read
 747:../3rdParty/FreeRTOS/queue.c **** 						pointer. */
 748:../3rdParty/FreeRTOS/queue.c **** 						pxQueue->pcReadFrom = pcOriginalReadPosition;
 749:../3rdParty/FreeRTOS/queue.c **** 
 750:../3rdParty/FreeRTOS/queue.c **** 						/* The data is being left in the queue, so see if there are
 751:../3rdParty/FreeRTOS/queue.c **** 						any other tasks waiting for the data. */
 752:../3rdParty/FreeRTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 753:../3rdParty/FreeRTOS/queue.c **** 						{
 754:../3rdParty/FreeRTOS/queue.c **** 							/* Tasks that are removed from the event list will get added to
 755:../3rdParty/FreeRTOS/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 756:../3rdParty/FreeRTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 757:../3rdParty/FreeRTOS/queue.c **** 							{
 758:../3rdParty/FreeRTOS/queue.c **** 								/* The task waiting has a higher priority than this task. */
 759:../3rdParty/FreeRTOS/queue.c **** 								portYIELD_WITHIN_API();
 760:../3rdParty/FreeRTOS/queue.c **** 							}
 761:../3rdParty/FreeRTOS/queue.c **** 						}
 762:../3rdParty/FreeRTOS/queue.c **** 
 763:../3rdParty/FreeRTOS/queue.c **** 					}
 764:../3rdParty/FreeRTOS/queue.c **** 
 765:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 766:../3rdParty/FreeRTOS/queue.c **** 					return pdPASS;
 767:../3rdParty/FreeRTOS/queue.c **** 				}
 768:../3rdParty/FreeRTOS/queue.c **** 				else
 769:../3rdParty/FreeRTOS/queue.c **** 				{
 770:../3rdParty/FreeRTOS/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 771:../3rdParty/FreeRTOS/queue.c **** 					{
 772:../3rdParty/FreeRTOS/queue.c **** 						taskEXIT_CRITICAL();
 773:../3rdParty/FreeRTOS/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 774:../3rdParty/FreeRTOS/queue.c **** 						return errQUEUE_EMPTY;
 775:../3rdParty/FreeRTOS/queue.c **** 					}
 776:../3rdParty/FreeRTOS/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 777:../3rdParty/FreeRTOS/queue.c **** 					{
 778:../3rdParty/FreeRTOS/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 779:../3rdParty/FreeRTOS/queue.c **** 						xEntryTimeSet = pdTRUE;
 780:../3rdParty/FreeRTOS/queue.c **** 					}
 781:../3rdParty/FreeRTOS/queue.c **** 				}
 782:../3rdParty/FreeRTOS/queue.c **** 			}
 783:../3rdParty/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 784:../3rdParty/FreeRTOS/queue.c **** 
 785:../3rdParty/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 786:../3rdParty/FreeRTOS/queue.c **** 			{
 787:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 788:../3rdParty/FreeRTOS/queue.c **** 				{
 789:../3rdParty/FreeRTOS/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 790:../3rdParty/FreeRTOS/queue.c **** 					{
 791:../3rdParty/FreeRTOS/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 792:../3rdParty/FreeRTOS/queue.c **** 
 793:../3rdParty/FreeRTOS/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 794:../3rdParty/FreeRTOS/queue.c **** 						{
 795:../3rdParty/FreeRTOS/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 796:../3rdParty/FreeRTOS/queue.c **** 							{
 797:../3rdParty/FreeRTOS/queue.c **** 								portENTER_CRITICAL();
 798:../3rdParty/FreeRTOS/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 799:../3rdParty/FreeRTOS/queue.c **** 								portEXIT_CRITICAL();
 800:../3rdParty/FreeRTOS/queue.c **** 							}
 801:../3rdParty/FreeRTOS/queue.c **** 						}
 802:../3rdParty/FreeRTOS/queue.c **** 						#endif
 803:../3rdParty/FreeRTOS/queue.c **** 
 804:../3rdParty/FreeRTOS/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 805:../3rdParty/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 806:../3rdParty/FreeRTOS/queue.c **** 					}
 807:../3rdParty/FreeRTOS/queue.c **** 				}
 808:../3rdParty/FreeRTOS/queue.c **** 				else
 809:../3rdParty/FreeRTOS/queue.c **** 				{
 810:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 811:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 812:../3rdParty/FreeRTOS/queue.c **** 					return errQUEUE_EMPTY;
 813:../3rdParty/FreeRTOS/queue.c **** 				}
 814:../3rdParty/FreeRTOS/queue.c **** 			}
 815:../3rdParty/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 816:../3rdParty/FreeRTOS/queue.c **** 		}
 817:../3rdParty/FreeRTOS/queue.c **** 	}
 818:../3rdParty/FreeRTOS/queue.c **** 
 819:../3rdParty/FreeRTOS/queue.c **** 
 820:../3rdParty/FreeRTOS/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 821:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 822:../3rdParty/FreeRTOS/queue.c **** 
 823:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 824:../3rdParty/FreeRTOS/queue.c **** {
 3924              		.loc 1 824 0
 3925              		@ args = 0, pretend = 0, frame = 24
 3926              		@ frame_needed = 1, uses_anonymous_args = 0
 3927 0358 80B5     		push	{r7, lr}
 3928              	.LCFI15:
 3929 035a 86B0     		sub	sp, sp, #24
 3930              	.LCFI16:
 3931 035c 00AF     		add	r7, sp, #0
 3932              	.LCFI17:
 3933 035e F860     		str	r0, [r7, #12]
 3934 0360 B960     		str	r1, [r7, #8]
 3935 0362 7A60     		str	r2, [r7, #4]
 3936 0364 3B60     		str	r3, [r7, #0]
 825:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
 826:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 827:../3rdParty/FreeRTOS/queue.c **** 
 828:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 829:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxHigherPriorityTaskWoken );
 830:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 831:../3rdParty/FreeRTOS/queue.c **** 
 832:../3rdParty/FreeRTOS/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 833:../3rdParty/FreeRTOS/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 834:../3rdParty/FreeRTOS/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 835:../3rdParty/FreeRTOS/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 836:../3rdParty/FreeRTOS/queue.c **** 	by this	post). */
 837:../3rdParty/FreeRTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 3937              		.loc 1 837 0
 3938 0366 4FF00003 		mov	r3, #0
 3939 036a 7B61     		str	r3, [r7, #20]
 3940              	@ 837 "../3rdParty/FreeRTOS/queue.c" 1
 3941 036c 4FF02800 			mov r0, #40								
 3942 0370 80F31188 		msr basepri, r0							
 3943              	
 3944              	@ 0 "" 2
 838:../3rdParty/FreeRTOS/queue.c **** 	{
 839:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 3945              		.loc 1 839 0
 3946              		.thumb
 3947 0374 FB68     		ldr	r3, [r7, #12]
 3948 0376 9A6B     		ldr	r2, [r3, #56]
 3949 0378 FB68     		ldr	r3, [r7, #12]
 3950 037a DB6B     		ldr	r3, [r3, #60]
 3951 037c 9A42     		cmp	r2, r3
 3952 037e 29D2     		bcs	.L33
 840:../3rdParty/FreeRTOS/queue.c **** 		{
 841:../3rdParty/FreeRTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 842:../3rdParty/FreeRTOS/queue.c **** 
 843:../3rdParty/FreeRTOS/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 3953              		.loc 1 843 0
 3954 0380 F868     		ldr	r0, [r7, #12]
 3955 0382 B968     		ldr	r1, [r7, #8]
 3956 0384 3A68     		ldr	r2, [r7, #0]
 3957 0386 00F0A9F9 		bl	prvCopyDataToQueue
 844:../3rdParty/FreeRTOS/queue.c **** 
 845:../3rdParty/FreeRTOS/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 846:../3rdParty/FreeRTOS/queue.c **** 			be done when the queue is unlocked later. */
 847:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 3958              		.loc 1 847 0
 3959 038a FB68     		ldr	r3, [r7, #12]
 3960 038c 9B6C     		ldr	r3, [r3, #72]
 3961 038e B3F1FF3F 		cmp	r3, #-1
 3962 0392 11D1     		bne	.L34
 848:../3rdParty/FreeRTOS/queue.c **** 			{
 849:../3rdParty/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 3963              		.loc 1 849 0
 3964 0394 FB68     		ldr	r3, [r7, #12]
 3965 0396 5B6A     		ldr	r3, [r3, #36]
 3966 0398 002B     		cmp	r3, #0
 3967 039a 14D0     		beq	.L39
 850:../3rdParty/FreeRTOS/queue.c **** 				{
 851:../3rdParty/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 3968              		.loc 1 851 0
 3969 039c FB68     		ldr	r3, [r7, #12]
 3970 039e 03F12403 		add	r3, r3, #36
 3971 03a2 1846     		mov	r0, r3
 3972 03a4 FFF7FEFF 		bl	xTaskRemoveFromEventList
 3973 03a8 0346     		mov	r3, r0
 3974 03aa 002B     		cmp	r3, #0
 3975 03ac 0DD0     		beq	.L40
 852:../3rdParty/FreeRTOS/queue.c **** 					{
 853:../3rdParty/FreeRTOS/queue.c **** 						/* The task waiting has a higher priority so record that a
 854:../3rdParty/FreeRTOS/queue.c **** 						context	switch is required. */
 855:../3rdParty/FreeRTOS/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 3976              		.loc 1 855 0
 3977 03ae 7B68     		ldr	r3, [r7, #4]
 3978 03b0 4FF00102 		mov	r2, #1
 3979 03b4 1A60     		str	r2, [r3, #0]
 3980 03b6 09E0     		b	.L36
 3981              	.L34:
 856:../3rdParty/FreeRTOS/queue.c **** 					}
 857:../3rdParty/FreeRTOS/queue.c **** 				}
 858:../3rdParty/FreeRTOS/queue.c **** 			}
 859:../3rdParty/FreeRTOS/queue.c **** 			else
 860:../3rdParty/FreeRTOS/queue.c **** 			{
 861:../3rdParty/FreeRTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
 862:../3rdParty/FreeRTOS/queue.c **** 				knows that data was posted while it was locked. */
 863:../3rdParty/FreeRTOS/queue.c **** 				++( pxQueue->xTxLock );
 3982              		.loc 1 863 0
 3983 03b8 FB68     		ldr	r3, [r7, #12]
 3984 03ba 9B6C     		ldr	r3, [r3, #72]
 3985 03bc 03F10102 		add	r2, r3, #1
 3986 03c0 FB68     		ldr	r3, [r7, #12]
 3987 03c2 9A64     		str	r2, [r3, #72]
 3988 03c4 02E0     		b	.L36
 3989              	.L39:
 3990              		.loc 1 855 0
 3991 03c6 00BF     		nop
 3992 03c8 00E0     		b	.L36
 3993              	.L40:
 3994 03ca 00BF     		nop
 3995              	.L36:
 864:../3rdParty/FreeRTOS/queue.c **** 			}
 865:../3rdParty/FreeRTOS/queue.c **** 
 866:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 3996              		.loc 1 866 0
 3997 03cc 4FF00103 		mov	r3, #1
 3998 03d0 3B61     		str	r3, [r7, #16]
 3999 03d2 02E0     		b	.L37
 4000              	.L33:
 867:../3rdParty/FreeRTOS/queue.c **** 		}
 868:../3rdParty/FreeRTOS/queue.c **** 		else
 869:../3rdParty/FreeRTOS/queue.c **** 		{
 870:../3rdParty/FreeRTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 871:../3rdParty/FreeRTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 4001              		.loc 1 871 0
 4002 03d4 4FF00003 		mov	r3, #0
 4003 03d8 3B61     		str	r3, [r7, #16]
 4004              	.L37:
 872:../3rdParty/FreeRTOS/queue.c **** 		}
 873:../3rdParty/FreeRTOS/queue.c **** 	}
 874:../3rdParty/FreeRTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 4005              		.loc 1 874 0
 4006              	@ 874 "../3rdParty/FreeRTOS/queue.c" 1
 4007 03da 4FF00000 			mov r0, #0					
 4008 03de 80F31188 		msr basepri, r0				
 4009              	
 4010              	@ 0 "" 2
 875:../3rdParty/FreeRTOS/queue.c **** 
 876:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 4011              		.loc 1 876 0
 4012              		.thumb
 4013 03e2 3B69     		ldr	r3, [r7, #16]
 877:../3rdParty/FreeRTOS/queue.c **** }
 4014              		.loc 1 877 0
 4015 03e4 1846     		mov	r0, r3
 4016 03e6 07F11807 		add	r7, r7, #24
 4017 03ea BD46     		mov	sp, r7
 4018 03ec 80BD     		pop	{r7, pc}
 4019              	.LFE60:
 4021 03ee 00BF     		.align	2
 4022              		.global	xQueueGenericReceive
 4023              		.thumb
 4024              		.thumb_func
 4026              	xQueueGenericReceive:
 4027              	.LFB61:
 878:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 879:../3rdParty/FreeRTOS/queue.c **** 
 880:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 881:../3rdParty/FreeRTOS/queue.c **** {
 4028              		.loc 1 881 0
 4029              		@ args = 0, pretend = 0, frame = 32
 4030              		@ frame_needed = 1, uses_anonymous_args = 0
 4031 03f0 80B5     		push	{r7, lr}
 4032              	.LCFI18:
 4033 03f2 88B0     		sub	sp, sp, #32
 4034              	.LCFI19:
 4035 03f4 00AF     		add	r7, sp, #0
 4036              	.LCFI20:
 4037 03f6 F860     		str	r0, [r7, #12]
 4038 03f8 B960     		str	r1, [r7, #8]
 4039 03fa 7A60     		str	r2, [r7, #4]
 4040 03fc 3B60     		str	r3, [r7, #0]
 882:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 4041              		.loc 1 882 0
 4042 03fe 4FF00003 		mov	r3, #0
 4043 0402 BB61     		str	r3, [r7, #24]
 4044 0404 00E0     		b	.L57
 4045              	.L61:
 883:../3rdParty/FreeRTOS/queue.c **** xTimeOutType xTimeOut;
 884:../3rdParty/FreeRTOS/queue.c **** signed char *pcOriginalReadPosition;
 885:../3rdParty/FreeRTOS/queue.c **** 
 886:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 887:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 888:../3rdParty/FreeRTOS/queue.c **** 
 889:../3rdParty/FreeRTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 890:../3rdParty/FreeRTOS/queue.c **** 	statements within the function itself.  This is done in the interest
 891:../3rdParty/FreeRTOS/queue.c **** 	of execution time efficiency. */
 892:../3rdParty/FreeRTOS/queue.c **** 
 893:../3rdParty/FreeRTOS/queue.c **** 	for( ;; )
 894:../3rdParty/FreeRTOS/queue.c **** 	{
 895:../3rdParty/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 896:../3rdParty/FreeRTOS/queue.c **** 		{
 897:../3rdParty/FreeRTOS/queue.c **** 			/* Is there data in the queue now?  To be running we must be
 898:../3rdParty/FreeRTOS/queue.c **** 			the highest priority task wanting to access the queue. */
 899:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 900:../3rdParty/FreeRTOS/queue.c **** 			{
 901:../3rdParty/FreeRTOS/queue.c **** 				/* Remember our read position in case we are just peeking. */
 902:../3rdParty/FreeRTOS/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 903:../3rdParty/FreeRTOS/queue.c **** 
 904:../3rdParty/FreeRTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 905:../3rdParty/FreeRTOS/queue.c **** 
 906:../3rdParty/FreeRTOS/queue.c **** 				if( xJustPeeking == pdFALSE )
 907:../3rdParty/FreeRTOS/queue.c **** 				{
 908:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
 909:../3rdParty/FreeRTOS/queue.c **** 
 910:../3rdParty/FreeRTOS/queue.c **** 					/* We are actually removing data. */
 911:../3rdParty/FreeRTOS/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 912:../3rdParty/FreeRTOS/queue.c **** 
 913:../3rdParty/FreeRTOS/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
 914:../3rdParty/FreeRTOS/queue.c **** 					{
 915:../3rdParty/FreeRTOS/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 916:../3rdParty/FreeRTOS/queue.c **** 						{
 917:../3rdParty/FreeRTOS/queue.c **** 							/* Record the information required to implement
 918:../3rdParty/FreeRTOS/queue.c **** 							priority inheritance should it become necessary. */
 919:../3rdParty/FreeRTOS/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 920:../3rdParty/FreeRTOS/queue.c **** 						}
 921:../3rdParty/FreeRTOS/queue.c **** 					}
 922:../3rdParty/FreeRTOS/queue.c **** 					#endif
 923:../3rdParty/FreeRTOS/queue.c **** 
 924:../3rdParty/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 925:../3rdParty/FreeRTOS/queue.c **** 					{
 926:../3rdParty/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 927:../3rdParty/FreeRTOS/queue.c **** 						{
 928:../3rdParty/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 929:../3rdParty/FreeRTOS/queue.c **** 						}
 930:../3rdParty/FreeRTOS/queue.c **** 					}
 931:../3rdParty/FreeRTOS/queue.c **** 				}
 932:../3rdParty/FreeRTOS/queue.c **** 				else
 933:../3rdParty/FreeRTOS/queue.c **** 				{
 934:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_PEEK( pxQueue );
 935:../3rdParty/FreeRTOS/queue.c **** 
 936:../3rdParty/FreeRTOS/queue.c **** 					/* We are not removing the data, so reset our read
 937:../3rdParty/FreeRTOS/queue.c **** 					pointer. */
 938:../3rdParty/FreeRTOS/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 939:../3rdParty/FreeRTOS/queue.c **** 
 940:../3rdParty/FreeRTOS/queue.c **** 					/* The data is being left in the queue, so see if there are
 941:../3rdParty/FreeRTOS/queue.c **** 					any other tasks waiting for the data. */
 942:../3rdParty/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 943:../3rdParty/FreeRTOS/queue.c **** 					{
 944:../3rdParty/FreeRTOS/queue.c **** 						/* Tasks that are removed from the event list will get added to
 945:../3rdParty/FreeRTOS/queue.c **** 						the pending ready list as the scheduler is still suspended. */
 946:../3rdParty/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 947:../3rdParty/FreeRTOS/queue.c **** 						{
 948:../3rdParty/FreeRTOS/queue.c **** 							/* The task waiting has a higher priority than this task. */
 949:../3rdParty/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 950:../3rdParty/FreeRTOS/queue.c **** 						}
 951:../3rdParty/FreeRTOS/queue.c **** 					}
 952:../3rdParty/FreeRTOS/queue.c **** 
 953:../3rdParty/FreeRTOS/queue.c **** 				}
 954:../3rdParty/FreeRTOS/queue.c **** 
 955:../3rdParty/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 956:../3rdParty/FreeRTOS/queue.c **** 				return pdPASS;
 957:../3rdParty/FreeRTOS/queue.c **** 			}
 958:../3rdParty/FreeRTOS/queue.c **** 			else
 959:../3rdParty/FreeRTOS/queue.c **** 			{
 960:../3rdParty/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 961:../3rdParty/FreeRTOS/queue.c **** 				{
 962:../3rdParty/FreeRTOS/queue.c **** 					/* The queue was empty and no block time is specified (or
 963:../3rdParty/FreeRTOS/queue.c **** 					the block time has expired) so leave now. */
 964:../3rdParty/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 965:../3rdParty/FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 966:../3rdParty/FreeRTOS/queue.c **** 					return errQUEUE_EMPTY;
 967:../3rdParty/FreeRTOS/queue.c **** 				}
 968:../3rdParty/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 969:../3rdParty/FreeRTOS/queue.c **** 				{
 970:../3rdParty/FreeRTOS/queue.c **** 					/* The queue was empty and a block time was specified so
 971:../3rdParty/FreeRTOS/queue.c **** 					configure the timeout structure. */
 972:../3rdParty/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 973:../3rdParty/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 974:../3rdParty/FreeRTOS/queue.c **** 				}
 975:../3rdParty/FreeRTOS/queue.c **** 			}
 976:../3rdParty/FreeRTOS/queue.c **** 		}
 977:../3rdParty/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 978:../3rdParty/FreeRTOS/queue.c **** 
 979:../3rdParty/FreeRTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 980:../3rdParty/FreeRTOS/queue.c **** 		now the critical section has been exited. */
 981:../3rdParty/FreeRTOS/queue.c **** 
 982:../3rdParty/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 983:../3rdParty/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 984:../3rdParty/FreeRTOS/queue.c **** 
 985:../3rdParty/FreeRTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 986:../3rdParty/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 987:../3rdParty/FreeRTOS/queue.c **** 		{
 988:../3rdParty/FreeRTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 989:../3rdParty/FreeRTOS/queue.c **** 			{
 990:../3rdParty/FreeRTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 991:../3rdParty/FreeRTOS/queue.c **** 
 992:../3rdParty/FreeRTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
 993:../3rdParty/FreeRTOS/queue.c **** 				{
 994:../3rdParty/FreeRTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 995:../3rdParty/FreeRTOS/queue.c **** 					{
 996:../3rdParty/FreeRTOS/queue.c **** 						portENTER_CRITICAL();
 997:../3rdParty/FreeRTOS/queue.c **** 						{
 998:../3rdParty/FreeRTOS/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 999:../3rdParty/FreeRTOS/queue.c **** 						}
1000:../3rdParty/FreeRTOS/queue.c **** 						portEXIT_CRITICAL();
1001:../3rdParty/FreeRTOS/queue.c **** 					}
1002:../3rdParty/FreeRTOS/queue.c **** 				}
1003:../3rdParty/FreeRTOS/queue.c **** 				#endif
1004:../3rdParty/FreeRTOS/queue.c **** 
1005:../3rdParty/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1006:../3rdParty/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
1007:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1008:../3rdParty/FreeRTOS/queue.c **** 				{
1009:../3rdParty/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
1010:../3rdParty/FreeRTOS/queue.c **** 				}
1011:../3rdParty/FreeRTOS/queue.c **** 			}
1012:../3rdParty/FreeRTOS/queue.c **** 			else
1013:../3rdParty/FreeRTOS/queue.c **** 			{
1014:../3rdParty/FreeRTOS/queue.c **** 				/* Try again. */
1015:../3rdParty/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
1016:../3rdParty/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
1017:../3rdParty/FreeRTOS/queue.c **** 			}
1018:../3rdParty/FreeRTOS/queue.c **** 		}
1019:../3rdParty/FreeRTOS/queue.c **** 		else
1020:../3rdParty/FreeRTOS/queue.c **** 		{
1021:../3rdParty/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
1022:../3rdParty/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
1023:../3rdParty/FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1024:../3rdParty/FreeRTOS/queue.c **** 			return errQUEUE_EMPTY;
1025:../3rdParty/FreeRTOS/queue.c **** 		}
1026:../3rdParty/FreeRTOS/queue.c **** 	}
 4046              		.loc 1 1026 0
 4047 0406 00BF     		nop
 4048              	.L57:
 4049              		.loc 1 895 0
 4050 0408 FFF7FEFF 		bl	vPortEnterCritical
 4051              		.loc 1 899 0
 4052 040c FB68     		ldr	r3, [r7, #12]
 4053 040e 9B6B     		ldr	r3, [r3, #56]
 4054 0410 002B     		cmp	r3, #0
 4055 0412 44D0     		beq	.L42
 4056              		.loc 1 902 0
 4057 0414 FB68     		ldr	r3, [r7, #12]
 4058 0416 DB68     		ldr	r3, [r3, #12]
 4059 0418 FB61     		str	r3, [r7, #28]
 4060              		.loc 1 904 0
 4061 041a F868     		ldr	r0, [r7, #12]
 4062 041c B968     		ldr	r1, [r7, #8]
 4063 041e 00F0C3F9 		bl	prvCopyDataFromQueue
 4064              		.loc 1 906 0
 4065 0422 3B68     		ldr	r3, [r7, #0]
 4066 0424 002B     		cmp	r3, #0
 4067 0426 1FD1     		bne	.L43
 4068              		.loc 1 911 0
 4069 0428 FB68     		ldr	r3, [r7, #12]
 4070 042a 9B6B     		ldr	r3, [r3, #56]
 4071 042c 03F1FF32 		add	r2, r3, #-1
 4072 0430 FB68     		ldr	r3, [r7, #12]
 4073 0432 9A63     		str	r2, [r3, #56]
 4074              		.loc 1 915 0
 4075 0434 FB68     		ldr	r3, [r7, #12]
 4076 0436 1B68     		ldr	r3, [r3, #0]
 4077 0438 002B     		cmp	r3, #0
 4078 043a 05D1     		bne	.L44
 4079              		.loc 1 919 0
 4080 043c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 4081 0440 0346     		mov	r3, r0
 4082 0442 1A46     		mov	r2, r3
 4083 0444 FB68     		ldr	r3, [r7, #12]
 4084 0446 5A60     		str	r2, [r3, #4]
 4085              	.L44:
 4086              		.loc 1 924 0
 4087 0448 FB68     		ldr	r3, [r7, #12]
 4088 044a 1B69     		ldr	r3, [r3, #16]
 4089 044c 002B     		cmp	r3, #0
 4090 044e 1ED0     		beq	.L59
 4091              		.loc 1 926 0
 4092 0450 FB68     		ldr	r3, [r7, #12]
 4093 0452 03F11003 		add	r3, r3, #16
 4094 0456 1846     		mov	r0, r3
 4095 0458 FFF7FEFF 		bl	xTaskRemoveFromEventList
 4096 045c 0346     		mov	r3, r0
 4097 045e 012B     		cmp	r3, #1
 4098 0460 17D1     		bne	.L60
 4099              		.loc 1 928 0
 4100 0462 FFF7FEFF 		bl	vPortYieldFromISR
 4101 0466 15E0     		b	.L46
 4102              	.L43:
 4103              		.loc 1 938 0
 4104 0468 FB68     		ldr	r3, [r7, #12]
 4105 046a FA69     		ldr	r2, [r7, #28]
 4106 046c DA60     		str	r2, [r3, #12]
 4107              		.loc 1 942 0
 4108 046e FB68     		ldr	r3, [r7, #12]
 4109 0470 5B6A     		ldr	r3, [r3, #36]
 4110 0472 002B     		cmp	r3, #0
 4111 0474 0ED0     		beq	.L46
 4112              		.loc 1 946 0
 4113 0476 FB68     		ldr	r3, [r7, #12]
 4114 0478 03F12403 		add	r3, r3, #36
 4115 047c 1846     		mov	r0, r3
 4116 047e FFF7FEFF 		bl	xTaskRemoveFromEventList
 4117 0482 0346     		mov	r3, r0
 4118 0484 002B     		cmp	r3, #0
 4119 0486 05D0     		beq	.L46
 4120              		.loc 1 949 0
 4121 0488 FFF7FEFF 		bl	vPortYieldFromISR
 4122 048c 02E0     		b	.L46
 4123              	.L59:
 4124              		.loc 1 928 0
 4125 048e 00BF     		nop
 4126 0490 00E0     		b	.L46
 4127              	.L60:
 4128 0492 00BF     		nop
 4129              	.L46:
 4130              		.loc 1 955 0
 4131 0494 FFF7FEFF 		bl	vPortExitCritical
 4132              		.loc 1 956 0
 4133 0498 4FF00103 		mov	r3, #1
 4134 049c 6BE0     		b	.L47
 4135              	.L42:
 4136              		.loc 1 960 0
 4137 049e 7B68     		ldr	r3, [r7, #4]
 4138 04a0 002B     		cmp	r3, #0
 4139 04a2 04D1     		bne	.L48
 4140              		.loc 1 964 0
 4141 04a4 FFF7FEFF 		bl	vPortExitCritical
 4142              		.loc 1 966 0
 4143 04a8 4FF00003 		mov	r3, #0
 4144 04ac 63E0     		b	.L47
 4145              	.L48:
 4146              		.loc 1 968 0
 4147 04ae BB69     		ldr	r3, [r7, #24]
 4148 04b0 002B     		cmp	r3, #0
 4149 04b2 07D1     		bne	.L49
 4150              		.loc 1 972 0
 4151 04b4 07F11003 		add	r3, r7, #16
 4152 04b8 1846     		mov	r0, r3
 4153 04ba FFF7FEFF 		bl	vTaskSetTimeOutState
 4154              		.loc 1 973 0
 4155 04be 4FF00103 		mov	r3, #1
 4156 04c2 BB61     		str	r3, [r7, #24]
 4157              	.L49:
 4158              		.loc 1 977 0
 4159 04c4 FFF7FEFF 		bl	vPortExitCritical
 4160              		.loc 1 982 0
 4161 04c8 FFF7FEFF 		bl	vTaskSuspendAll
 4162              		.loc 1 983 0
 4163 04cc FFF7FEFF 		bl	vPortEnterCritical
 4164 04d0 FB68     		ldr	r3, [r7, #12]
 4165 04d2 5B6C     		ldr	r3, [r3, #68]
 4166 04d4 B3F1FF3F 		cmp	r3, #-1
 4167 04d8 03D1     		bne	.L50
 4168 04da FB68     		ldr	r3, [r7, #12]
 4169 04dc 4FF00002 		mov	r2, #0
 4170 04e0 5A64     		str	r2, [r3, #68]
 4171              	.L50:
 4172 04e2 FB68     		ldr	r3, [r7, #12]
 4173 04e4 9B6C     		ldr	r3, [r3, #72]
 4174 04e6 B3F1FF3F 		cmp	r3, #-1
 4175 04ea 03D1     		bne	.L51
 4176 04ec FB68     		ldr	r3, [r7, #12]
 4177 04ee 4FF00002 		mov	r2, #0
 4178 04f2 9A64     		str	r2, [r3, #72]
 4179              	.L51:
 4180 04f4 FFF7FEFF 		bl	vPortExitCritical
 4181              		.loc 1 986 0
 4182 04f8 07F11002 		add	r2, r7, #16
 4183 04fc 07F10403 		add	r3, r7, #4
 4184 0500 1046     		mov	r0, r2
 4185 0502 1946     		mov	r1, r3
 4186 0504 FFF7FEFF 		bl	xTaskCheckForTimeOut
 4187 0508 0346     		mov	r3, r0
 4188 050a 002B     		cmp	r3, #0
 4189 050c 2CD1     		bne	.L52
 4190              		.loc 1 988 0
 4191 050e F868     		ldr	r0, [r7, #12]
 4192 0510 00F0C2F9 		bl	prvIsQueueEmpty
 4193 0514 0346     		mov	r3, r0
 4194 0516 002B     		cmp	r3, #0
 4195 0518 20D0     		beq	.L53
 4196              		.loc 1 994 0
 4197 051a FB68     		ldr	r3, [r7, #12]
 4198 051c 1B68     		ldr	r3, [r3, #0]
 4199 051e 002B     		cmp	r3, #0
 4200 0520 08D1     		bne	.L54
 4201              		.loc 1 996 0
 4202 0522 FFF7FEFF 		bl	vPortEnterCritical
 4203              		.loc 1 998 0
 4204 0526 FB68     		ldr	r3, [r7, #12]
 4205 0528 5B68     		ldr	r3, [r3, #4]
 4206 052a 1846     		mov	r0, r3
 4207 052c FFF7FEFF 		bl	vTaskPriorityInherit
 4208              		.loc 1 1000 0
 4209 0530 FFF7FEFF 		bl	vPortExitCritical
 4210              	.L54:
 4211              		.loc 1 1005 0
 4212 0534 FB68     		ldr	r3, [r7, #12]
 4213 0536 03F12402 		add	r2, r3, #36
 4214 053a 7B68     		ldr	r3, [r7, #4]
 4215 053c 1046     		mov	r0, r2
 4216 053e 1946     		mov	r1, r3
 4217 0540 FFF7FEFF 		bl	vTaskPlaceOnEventList
 4218              		.loc 1 1006 0
 4219 0544 F868     		ldr	r0, [r7, #12]
 4220 0546 00F057F9 		bl	prvUnlockQueue
 4221              		.loc 1 1007 0
 4222 054a FFF7FEFF 		bl	xTaskResumeAll
 4223 054e 0346     		mov	r3, r0
 4224 0550 002B     		cmp	r3, #0
 4225 0552 7FF458AF 		bne	.L61
 4226              		.loc 1 1009 0
 4227 0556 FFF7FEFF 		bl	vPortYieldFromISR
 4228              		.loc 1 1026 0
 4229 055a 55E7     		b	.L57
 4230              	.L53:
 4231              		.loc 1 1015 0
 4232 055c F868     		ldr	r0, [r7, #12]
 4233 055e 00F04BF9 		bl	prvUnlockQueue
 4234              		.loc 1 1016 0
 4235 0562 FFF7FEFF 		bl	xTaskResumeAll
 4236              		.loc 1 1026 0
 4237 0566 4FE7     		b	.L57
 4238              	.L52:
 4239              		.loc 1 1021 0
 4240 0568 F868     		ldr	r0, [r7, #12]
 4241 056a 00F045F9 		bl	prvUnlockQueue
 4242              		.loc 1 1022 0
 4243 056e FFF7FEFF 		bl	xTaskResumeAll
 4244              		.loc 1 1024 0
 4245 0572 4FF00003 		mov	r3, #0
 4246              	.L47:
1027:../3rdParty/FreeRTOS/queue.c **** }
 4247              		.loc 1 1027 0
 4248 0576 1846     		mov	r0, r3
 4249 0578 07F12007 		add	r7, r7, #32
 4250 057c BD46     		mov	sp, r7
 4251 057e 80BD     		pop	{r7, pc}
 4252              	.LFE61:
 4254              		.align	2
 4255              		.global	xQueueReceiveFromISR
 4256              		.thumb
 4257              		.thumb_func
 4259              	xQueueReceiveFromISR:
 4260              	.LFB62:
1028:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1029:../3rdParty/FreeRTOS/queue.c **** 
1030:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
1031:../3rdParty/FreeRTOS/queue.c **** {
 4261              		.loc 1 1031 0
 4262              		@ args = 0, pretend = 0, frame = 24
 4263              		@ frame_needed = 1, uses_anonymous_args = 0
 4264 0580 80B5     		push	{r7, lr}
 4265              	.LCFI21:
 4266 0582 86B0     		sub	sp, sp, #24
 4267              	.LCFI22:
 4268 0584 00AF     		add	r7, sp, #0
 4269              	.LCFI23:
 4270 0586 F860     		str	r0, [r7, #12]
 4271 0588 B960     		str	r1, [r7, #8]
 4272 058a 7A60     		str	r2, [r7, #4]
1032:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1033:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1034:../3rdParty/FreeRTOS/queue.c **** 
1035:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1036:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxTaskWoken );
1037:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
1038:../3rdParty/FreeRTOS/queue.c **** 
1039:../3rdParty/FreeRTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4273              		.loc 1 1039 0
 4274 058c 4FF00003 		mov	r3, #0
 4275 0590 7B61     		str	r3, [r7, #20]
 4276              	@ 1039 "../3rdParty/FreeRTOS/queue.c" 1
 4277 0592 4FF02800 			mov r0, #40								
 4278 0596 80F31188 		msr basepri, r0							
 4279              	
 4280              	@ 0 "" 2
1040:../3rdParty/FreeRTOS/queue.c **** 	{
1041:../3rdParty/FreeRTOS/queue.c **** 		/* We cannot block from an ISR, so check there is data available. */
1042:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 4281              		.loc 1 1042 0
 4282              		.thumb
 4283 059a FB68     		ldr	r3, [r7, #12]
 4284 059c 9B6B     		ldr	r3, [r3, #56]
 4285 059e 002B     		cmp	r3, #0
 4286 05a0 2ED0     		beq	.L63
1043:../3rdParty/FreeRTOS/queue.c **** 		{
1044:../3rdParty/FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1045:../3rdParty/FreeRTOS/queue.c **** 
1046:../3rdParty/FreeRTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 4287              		.loc 1 1046 0
 4288 05a2 F868     		ldr	r0, [r7, #12]
 4289 05a4 B968     		ldr	r1, [r7, #8]
 4290 05a6 00F0FFF8 		bl	prvCopyDataFromQueue
1047:../3rdParty/FreeRTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 4291              		.loc 1 1047 0
 4292 05aa FB68     		ldr	r3, [r7, #12]
 4293 05ac 9B6B     		ldr	r3, [r3, #56]
 4294 05ae 03F1FF32 		add	r2, r3, #-1
 4295 05b2 FB68     		ldr	r3, [r7, #12]
 4296 05b4 9A63     		str	r2, [r3, #56]
1048:../3rdParty/FreeRTOS/queue.c **** 
1049:../3rdParty/FreeRTOS/queue.c **** 			/* If the queue is locked we will not modify the event list.  Instead
1050:../3rdParty/FreeRTOS/queue.c **** 			we update the lock count so the task that unlocks the queue will know
1051:../3rdParty/FreeRTOS/queue.c **** 			that an ISR has removed data while the queue was locked. */
1052:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 4297              		.loc 1 1052 0
 4298 05b6 FB68     		ldr	r3, [r7, #12]
 4299 05b8 5B6C     		ldr	r3, [r3, #68]
 4300 05ba B3F1FF3F 		cmp	r3, #-1
 4301 05be 11D1     		bne	.L64
1053:../3rdParty/FreeRTOS/queue.c **** 			{
1054:../3rdParty/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4302              		.loc 1 1054 0
 4303 05c0 FB68     		ldr	r3, [r7, #12]
 4304 05c2 1B69     		ldr	r3, [r3, #16]
 4305 05c4 002B     		cmp	r3, #0
 4306 05c6 14D0     		beq	.L69
1055:../3rdParty/FreeRTOS/queue.c **** 				{
1056:../3rdParty/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4307              		.loc 1 1056 0
 4308 05c8 FB68     		ldr	r3, [r7, #12]
 4309 05ca 03F11003 		add	r3, r3, #16
 4310 05ce 1846     		mov	r0, r3
 4311 05d0 FFF7FEFF 		bl	xTaskRemoveFromEventList
 4312 05d4 0346     		mov	r3, r0
 4313 05d6 002B     		cmp	r3, #0
 4314 05d8 0DD0     		beq	.L70
1057:../3rdParty/FreeRTOS/queue.c **** 					{
1058:../3rdParty/FreeRTOS/queue.c **** 						/* The task waiting has a higher priority than us so
1059:../3rdParty/FreeRTOS/queue.c **** 						force a context switch. */
1060:../3rdParty/FreeRTOS/queue.c **** 						*pxTaskWoken = pdTRUE;
 4315              		.loc 1 1060 0
 4316 05da 7B68     		ldr	r3, [r7, #4]
 4317 05dc 4FF00102 		mov	r2, #1
 4318 05e0 1A60     		str	r2, [r3, #0]
 4319 05e2 09E0     		b	.L66
 4320              	.L64:
1061:../3rdParty/FreeRTOS/queue.c **** 					}
1062:../3rdParty/FreeRTOS/queue.c **** 				}
1063:../3rdParty/FreeRTOS/queue.c **** 			}
1064:../3rdParty/FreeRTOS/queue.c **** 			else
1065:../3rdParty/FreeRTOS/queue.c **** 			{
1066:../3rdParty/FreeRTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1067:../3rdParty/FreeRTOS/queue.c **** 				knows that data was removed while it was locked. */
1068:../3rdParty/FreeRTOS/queue.c **** 				++( pxQueue->xRxLock );
 4321              		.loc 1 1068 0
 4322 05e4 FB68     		ldr	r3, [r7, #12]
 4323 05e6 5B6C     		ldr	r3, [r3, #68]
 4324 05e8 03F10102 		add	r2, r3, #1
 4325 05ec FB68     		ldr	r3, [r7, #12]
 4326 05ee 5A64     		str	r2, [r3, #68]
 4327 05f0 02E0     		b	.L66
 4328              	.L69:
 4329              		.loc 1 1060 0
 4330 05f2 00BF     		nop
 4331 05f4 00E0     		b	.L66
 4332              	.L70:
 4333 05f6 00BF     		nop
 4334              	.L66:
1069:../3rdParty/FreeRTOS/queue.c **** 			}
1070:../3rdParty/FreeRTOS/queue.c **** 
1071:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 4335              		.loc 1 1071 0
 4336 05f8 4FF00103 		mov	r3, #1
 4337 05fc 3B61     		str	r3, [r7, #16]
 4338 05fe 02E0     		b	.L67
 4339              	.L63:
1072:../3rdParty/FreeRTOS/queue.c **** 		}
1073:../3rdParty/FreeRTOS/queue.c **** 		else
1074:../3rdParty/FreeRTOS/queue.c **** 		{
1075:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdFAIL;
 4340              		.loc 1 1075 0
 4341 0600 4FF00003 		mov	r3, #0
 4342 0604 3B61     		str	r3, [r7, #16]
 4343              	.L67:
1076:../3rdParty/FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1077:../3rdParty/FreeRTOS/queue.c **** 		}
1078:../3rdParty/FreeRTOS/queue.c **** 	}
1079:../3rdParty/FreeRTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 4344              		.loc 1 1079 0
 4345              	@ 1079 "../3rdParty/FreeRTOS/queue.c" 1
 4346 0606 4FF00000 			mov r0, #0					
 4347 060a 80F31188 		msr basepri, r0				
 4348              	
 4349              	@ 0 "" 2
1080:../3rdParty/FreeRTOS/queue.c **** 
1081:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 4350              		.loc 1 1081 0
 4351              		.thumb
 4352 060e 3B69     		ldr	r3, [r7, #16]
1082:../3rdParty/FreeRTOS/queue.c **** }
 4353              		.loc 1 1082 0
 4354 0610 1846     		mov	r0, r3
 4355 0612 07F11807 		add	r7, r7, #24
 4356 0616 BD46     		mov	sp, r7
 4357 0618 80BD     		pop	{r7, pc}
 4358              	.LFE62:
 4360 061a 00BF     		.align	2
 4361              		.global	uxQueueMessagesWaiting
 4362              		.thumb
 4363              		.thumb_func
 4365              	uxQueueMessagesWaiting:
 4366              	.LFB63:
1083:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1084:../3rdParty/FreeRTOS/queue.c **** 
1085:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
1086:../3rdParty/FreeRTOS/queue.c **** {
 4367              		.loc 1 1086 0
 4368              		@ args = 0, pretend = 0, frame = 16
 4369              		@ frame_needed = 1, uses_anonymous_args = 0
 4370 061c 80B5     		push	{r7, lr}
 4371              	.LCFI24:
 4372 061e 84B0     		sub	sp, sp, #16
 4373              	.LCFI25:
 4374 0620 00AF     		add	r7, sp, #0
 4375              	.LCFI26:
 4376 0622 7860     		str	r0, [r7, #4]
1087:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxReturn;
1088:../3rdParty/FreeRTOS/queue.c **** 
1089:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1090:../3rdParty/FreeRTOS/queue.c **** 
1091:../3rdParty/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 4377              		.loc 1 1091 0
 4378 0624 FFF7FEFF 		bl	vPortEnterCritical
1092:../3rdParty/FreeRTOS/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
 4379              		.loc 1 1092 0
 4380 0628 7B68     		ldr	r3, [r7, #4]
 4381 062a 9B6B     		ldr	r3, [r3, #56]
 4382 062c FB60     		str	r3, [r7, #12]
1093:../3rdParty/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 4383              		.loc 1 1093 0
 4384 062e FFF7FEFF 		bl	vPortExitCritical
1094:../3rdParty/FreeRTOS/queue.c **** 
1095:../3rdParty/FreeRTOS/queue.c **** 	return uxReturn;
 4385              		.loc 1 1095 0
 4386 0632 FB68     		ldr	r3, [r7, #12]
1096:../3rdParty/FreeRTOS/queue.c **** }
 4387              		.loc 1 1096 0
 4388 0634 1846     		mov	r0, r3
 4389 0636 07F11007 		add	r7, r7, #16
 4390 063a BD46     		mov	sp, r7
 4391 063c 80BD     		pop	{r7, pc}
 4392              	.LFE63:
 4394 063e 00BF     		.align	2
 4395              		.global	uxQueueMessagesWaitingFromISR
 4396              		.thumb
 4397              		.thumb_func
 4399              	uxQueueMessagesWaitingFromISR:
 4400              	.LFB64:
1097:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1098:../3rdParty/FreeRTOS/queue.c **** 
1099:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
1100:../3rdParty/FreeRTOS/queue.c **** {
 4401              		.loc 1 1100 0
 4402              		@ args = 0, pretend = 0, frame = 16
 4403              		@ frame_needed = 1, uses_anonymous_args = 0
 4404              		@ link register save eliminated.
 4405 0640 80B4     		push	{r7}
 4406              	.LCFI27:
 4407 0642 85B0     		sub	sp, sp, #20
 4408              	.LCFI28:
 4409 0644 00AF     		add	r7, sp, #0
 4410              	.LCFI29:
 4411 0646 7860     		str	r0, [r7, #4]
1101:../3rdParty/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxReturn;
1102:../3rdParty/FreeRTOS/queue.c **** 
1103:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1104:../3rdParty/FreeRTOS/queue.c **** 
1105:../3rdParty/FreeRTOS/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 4412              		.loc 1 1105 0
 4413 0648 7B68     		ldr	r3, [r7, #4]
 4414 064a 9B6B     		ldr	r3, [r3, #56]
 4415 064c FB60     		str	r3, [r7, #12]
1106:../3rdParty/FreeRTOS/queue.c **** 
1107:../3rdParty/FreeRTOS/queue.c **** 	return uxReturn;
 4416              		.loc 1 1107 0
 4417 064e FB68     		ldr	r3, [r7, #12]
1108:../3rdParty/FreeRTOS/queue.c **** }
 4418              		.loc 1 1108 0
 4419 0650 1846     		mov	r0, r3
 4420 0652 07F11407 		add	r7, r7, #20
 4421 0656 BD46     		mov	sp, r7
 4422 0658 80BC     		pop	{r7}
 4423 065a 7047     		bx	lr
 4424              	.LFE64:
 4426              		.align	2
 4427              		.global	vQueueDelete
 4428              		.thumb
 4429              		.thumb_func
 4431              	vQueueDelete:
 4432              	.LFB65:
1109:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1110:../3rdParty/FreeRTOS/queue.c **** 
1111:../3rdParty/FreeRTOS/queue.c **** void vQueueDelete( xQueueHandle pxQueue )
1112:../3rdParty/FreeRTOS/queue.c **** {
 4433              		.loc 1 1112 0
 4434              		@ args = 0, pretend = 0, frame = 8
 4435              		@ frame_needed = 1, uses_anonymous_args = 0
 4436 065c 80B5     		push	{r7, lr}
 4437              	.LCFI30:
 4438 065e 82B0     		sub	sp, sp, #8
 4439              	.LCFI31:
 4440 0660 00AF     		add	r7, sp, #0
 4441              	.LCFI32:
 4442 0662 7860     		str	r0, [r7, #4]
1113:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1114:../3rdParty/FreeRTOS/queue.c **** 
1115:../3rdParty/FreeRTOS/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1116:../3rdParty/FreeRTOS/queue.c **** 	vQueueUnregisterQueue( pxQueue );
 4443              		.loc 1 1116 0
 4444 0664 7868     		ldr	r0, [r7, #4]
 4445 0666 00F09DF9 		bl	vQueueUnregisterQueue
1117:../3rdParty/FreeRTOS/queue.c **** 	vPortFree( pxQueue->pcHead );
 4446              		.loc 1 1117 0
 4447 066a 7B68     		ldr	r3, [r7, #4]
 4448 066c 1B68     		ldr	r3, [r3, #0]
 4449 066e 1846     		mov	r0, r3
 4450 0670 FFF7FEFF 		bl	vPortFree
1118:../3rdParty/FreeRTOS/queue.c **** 	vPortFree( pxQueue );
 4451              		.loc 1 1118 0
 4452 0674 7868     		ldr	r0, [r7, #4]
 4453 0676 FFF7FEFF 		bl	vPortFree
1119:../3rdParty/FreeRTOS/queue.c **** }
 4454              		.loc 1 1119 0
 4455 067a 07F10807 		add	r7, r7, #8
 4456 067e BD46     		mov	sp, r7
 4457 0680 80BD     		pop	{r7, pc}
 4458              	.LFE65:
 4460 0682 00BF     		.align	2
 4461              		.global	ucQueueGetQueueNumber
 4462              		.thumb
 4463              		.thumb_func
 4465              	ucQueueGetQueueNumber:
 4466              	.LFB66:
1120:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1121:../3rdParty/FreeRTOS/queue.c **** 
1122:../3rdParty/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1123:../3rdParty/FreeRTOS/queue.c **** 
1124:../3rdParty/FreeRTOS/queue.c **** 	unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue )
1125:../3rdParty/FreeRTOS/queue.c **** 	{
 4467              		.loc 1 1125 0
 4468              		@ args = 0, pretend = 0, frame = 8
 4469              		@ frame_needed = 1, uses_anonymous_args = 0
 4470              		@ link register save eliminated.
 4471 0684 80B4     		push	{r7}
 4472              	.LCFI33:
 4473 0686 83B0     		sub	sp, sp, #12
 4474              	.LCFI34:
 4475 0688 00AF     		add	r7, sp, #0
 4476              	.LCFI35:
 4477 068a 7860     		str	r0, [r7, #4]
1126:../3rdParty/FreeRTOS/queue.c **** 		return pxQueue->ucQueueNumber;
 4478              		.loc 1 1126 0
 4479 068c 7B68     		ldr	r3, [r7, #4]
 4480 068e 93F84C30 		ldrb	r3, [r3, #76]	@ zero_extendqisi2
1127:../3rdParty/FreeRTOS/queue.c **** 	}
 4481              		.loc 1 1127 0
 4482 0692 1846     		mov	r0, r3
 4483 0694 07F10C07 		add	r7, r7, #12
 4484 0698 BD46     		mov	sp, r7
 4485 069a 80BC     		pop	{r7}
 4486 069c 7047     		bx	lr
 4487              	.LFE66:
 4489 069e 00BF     		.align	2
 4490              		.global	vQueueSetQueueNumber
 4491              		.thumb
 4492              		.thumb_func
 4494              	vQueueSetQueueNumber:
 4495              	.LFB67:
1128:../3rdParty/FreeRTOS/queue.c **** 
1129:../3rdParty/FreeRTOS/queue.c **** #endif
1130:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1131:../3rdParty/FreeRTOS/queue.c **** 
1132:../3rdParty/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1133:../3rdParty/FreeRTOS/queue.c **** 
1134:../3rdParty/FreeRTOS/queue.c **** 	void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber )
1135:../3rdParty/FreeRTOS/queue.c **** 	{
 4496              		.loc 1 1135 0
 4497              		@ args = 0, pretend = 0, frame = 8
 4498              		@ frame_needed = 1, uses_anonymous_args = 0
 4499              		@ link register save eliminated.
 4500 06a0 80B4     		push	{r7}
 4501              	.LCFI36:
 4502 06a2 83B0     		sub	sp, sp, #12
 4503              	.LCFI37:
 4504 06a4 00AF     		add	r7, sp, #0
 4505              	.LCFI38:
 4506 06a6 7860     		str	r0, [r7, #4]
 4507 06a8 0B46     		mov	r3, r1
 4508 06aa FB70     		strb	r3, [r7, #3]
1136:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->ucQueueNumber = ucQueueNumber;
 4509              		.loc 1 1136 0
 4510 06ac 7B68     		ldr	r3, [r7, #4]
 4511 06ae FA78     		ldrb	r2, [r7, #3]
 4512 06b0 83F84C20 		strb	r2, [r3, #76]
1137:../3rdParty/FreeRTOS/queue.c **** 	}
 4513              		.loc 1 1137 0
 4514 06b4 07F10C07 		add	r7, r7, #12
 4515 06b8 BD46     		mov	sp, r7
 4516 06ba 80BC     		pop	{r7}
 4517 06bc 7047     		bx	lr
 4518              	.LFE67:
 4520 06be 00BF     		.align	2
 4521              		.global	ucQueueGetQueueType
 4522              		.thumb
 4523              		.thumb_func
 4525              	ucQueueGetQueueType:
 4526              	.LFB68:
1138:../3rdParty/FreeRTOS/queue.c **** 
1139:../3rdParty/FreeRTOS/queue.c **** #endif
1140:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1141:../3rdParty/FreeRTOS/queue.c **** 
1142:../3rdParty/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1143:../3rdParty/FreeRTOS/queue.c **** 
1144:../3rdParty/FreeRTOS/queue.c **** 	unsigned char ucQueueGetQueueType( xQueueHandle pxQueue )
1145:../3rdParty/FreeRTOS/queue.c **** 	{
 4527              		.loc 1 1145 0
 4528              		@ args = 0, pretend = 0, frame = 8
 4529              		@ frame_needed = 1, uses_anonymous_args = 0
 4530              		@ link register save eliminated.
 4531 06c0 80B4     		push	{r7}
 4532              	.LCFI39:
 4533 06c2 83B0     		sub	sp, sp, #12
 4534              	.LCFI40:
 4535 06c4 00AF     		add	r7, sp, #0
 4536              	.LCFI41:
 4537 06c6 7860     		str	r0, [r7, #4]
1146:../3rdParty/FreeRTOS/queue.c **** 		return pxQueue->ucQueueType;
 4538              		.loc 1 1146 0
 4539 06c8 7B68     		ldr	r3, [r7, #4]
 4540 06ca 93F84D30 		ldrb	r3, [r3, #77]	@ zero_extendqisi2
1147:../3rdParty/FreeRTOS/queue.c **** 	}
 4541              		.loc 1 1147 0
 4542 06ce 1846     		mov	r0, r3
 4543 06d0 07F10C07 		add	r7, r7, #12
 4544 06d4 BD46     		mov	sp, r7
 4545 06d6 80BC     		pop	{r7}
 4546 06d8 7047     		bx	lr
 4547              	.LFE68:
 4549 06da 00BF     		.align	2
 4550              		.thumb
 4551              		.thumb_func
 4553              	prvCopyDataToQueue:
 4554              	.LFB69:
1148:../3rdParty/FreeRTOS/queue.c **** 
1149:../3rdParty/FreeRTOS/queue.c **** #endif
1150:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1151:../3rdParty/FreeRTOS/queue.c **** 
1152:../3rdParty/FreeRTOS/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1153:../3rdParty/FreeRTOS/queue.c **** {
 4555              		.loc 1 1153 0
 4556              		@ args = 0, pretend = 0, frame = 16
 4557              		@ frame_needed = 1, uses_anonymous_args = 0
 4558 06dc 80B5     		push	{r7, lr}
 4559              	.LCFI42:
 4560 06de 84B0     		sub	sp, sp, #16
 4561              	.LCFI43:
 4562 06e0 00AF     		add	r7, sp, #0
 4563              	.LCFI44:
 4564 06e2 F860     		str	r0, [r7, #12]
 4565 06e4 B960     		str	r1, [r7, #8]
 4566 06e6 7A60     		str	r2, [r7, #4]
1154:../3rdParty/FreeRTOS/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 4567              		.loc 1 1154 0
 4568 06e8 FB68     		ldr	r3, [r7, #12]
 4569 06ea 1B6C     		ldr	r3, [r3, #64]
 4570 06ec 002B     		cmp	r3, #0
 4571 06ee 0DD1     		bne	.L84
1155:../3rdParty/FreeRTOS/queue.c **** 	{
1156:../3rdParty/FreeRTOS/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1157:../3rdParty/FreeRTOS/queue.c **** 		{
1158:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4572              		.loc 1 1158 0
 4573 06f0 FB68     		ldr	r3, [r7, #12]
 4574 06f2 1B68     		ldr	r3, [r3, #0]
 4575 06f4 002B     		cmp	r3, #0
 4576 06f6 49D1     		bne	.L90
1159:../3rdParty/FreeRTOS/queue.c **** 			{
1160:../3rdParty/FreeRTOS/queue.c **** 				/* The mutex is no longer being held. */
1161:../3rdParty/FreeRTOS/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 4577              		.loc 1 1161 0
 4578 06f8 FB68     		ldr	r3, [r7, #12]
 4579 06fa 5B68     		ldr	r3, [r3, #4]
 4580 06fc 1846     		mov	r0, r3
 4581 06fe FFF7FEFF 		bl	vTaskPriorityDisinherit
1162:../3rdParty/FreeRTOS/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 4582              		.loc 1 1162 0
 4583 0702 FB68     		ldr	r3, [r7, #12]
 4584 0704 4FF00002 		mov	r2, #0
 4585 0708 5A60     		str	r2, [r3, #4]
 4586 070a 42E0     		b	.L86
 4587              	.L84:
1163:../3rdParty/FreeRTOS/queue.c **** 			}
1164:../3rdParty/FreeRTOS/queue.c **** 		}
1165:../3rdParty/FreeRTOS/queue.c **** 		#endif
1166:../3rdParty/FreeRTOS/queue.c **** 	}
1167:../3rdParty/FreeRTOS/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 4588              		.loc 1 1167 0
 4589 070c 7B68     		ldr	r3, [r7, #4]
 4590 070e 002B     		cmp	r3, #0
 4591 0710 1AD1     		bne	.L87
1168:../3rdParty/FreeRTOS/queue.c **** 	{
1169:../3rdParty/FreeRTOS/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 4592              		.loc 1 1169 0
 4593 0712 FB68     		ldr	r3, [r7, #12]
 4594 0714 9A68     		ldr	r2, [r3, #8]
 4595 0716 FB68     		ldr	r3, [r7, #12]
 4596 0718 1B6C     		ldr	r3, [r3, #64]
 4597 071a 1046     		mov	r0, r2
 4598 071c B968     		ldr	r1, [r7, #8]
 4599 071e 1A46     		mov	r2, r3
 4600 0720 FFF7FEFF 		bl	memcpy
1170:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 4601              		.loc 1 1170 0
 4602 0724 FB68     		ldr	r3, [r7, #12]
 4603 0726 9A68     		ldr	r2, [r3, #8]
 4604 0728 FB68     		ldr	r3, [r7, #12]
 4605 072a 1B6C     		ldr	r3, [r3, #64]
 4606 072c 1A44     		add	r2, r2, r3
 4607 072e FB68     		ldr	r3, [r7, #12]
 4608 0730 9A60     		str	r2, [r3, #8]
1171:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 4609              		.loc 1 1171 0
 4610 0732 FB68     		ldr	r3, [r7, #12]
 4611 0734 9A68     		ldr	r2, [r3, #8]
 4612 0736 FB68     		ldr	r3, [r7, #12]
 4613 0738 5B68     		ldr	r3, [r3, #4]
 4614 073a 9A42     		cmp	r2, r3
 4615 073c 28D3     		bcc	.L91
1172:../3rdParty/FreeRTOS/queue.c **** 		{
1173:../3rdParty/FreeRTOS/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 4616              		.loc 1 1173 0
 4617 073e FB68     		ldr	r3, [r7, #12]
 4618 0740 1A68     		ldr	r2, [r3, #0]
 4619 0742 FB68     		ldr	r3, [r7, #12]
 4620 0744 9A60     		str	r2, [r3, #8]
 4621 0746 24E0     		b	.L86
 4622              	.L87:
1174:../3rdParty/FreeRTOS/queue.c **** 		}
1175:../3rdParty/FreeRTOS/queue.c **** 	}
1176:../3rdParty/FreeRTOS/queue.c **** 	else
1177:../3rdParty/FreeRTOS/queue.c **** 	{
1178:../3rdParty/FreeRTOS/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 4623              		.loc 1 1178 0
 4624 0748 FB68     		ldr	r3, [r7, #12]
 4625 074a DA68     		ldr	r2, [r3, #12]
 4626 074c FB68     		ldr	r3, [r7, #12]
 4627 074e 1B6C     		ldr	r3, [r3, #64]
 4628 0750 1046     		mov	r0, r2
 4629 0752 B968     		ldr	r1, [r7, #8]
 4630 0754 1A46     		mov	r2, r3
 4631 0756 FFF7FEFF 		bl	memcpy
1179:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 4632              		.loc 1 1179 0
 4633 075a FB68     		ldr	r3, [r7, #12]
 4634 075c DA68     		ldr	r2, [r3, #12]
 4635 075e FB68     		ldr	r3, [r7, #12]
 4636 0760 1B6C     		ldr	r3, [r3, #64]
 4637 0762 C3F10003 		rsb	r3, r3, #0
 4638 0766 1A44     		add	r2, r2, r3
 4639 0768 FB68     		ldr	r3, [r7, #12]
 4640 076a DA60     		str	r2, [r3, #12]
1180:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 4641              		.loc 1 1180 0
 4642 076c FB68     		ldr	r3, [r7, #12]
 4643 076e DA68     		ldr	r2, [r3, #12]
 4644 0770 FB68     		ldr	r3, [r7, #12]
 4645 0772 1B68     		ldr	r3, [r3, #0]
 4646 0774 9A42     		cmp	r2, r3
 4647 0776 0CD2     		bcs	.L86
1181:../3rdParty/FreeRTOS/queue.c **** 		{
1182:../3rdParty/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 4648              		.loc 1 1182 0
 4649 0778 FB68     		ldr	r3, [r7, #12]
 4650 077a 5A68     		ldr	r2, [r3, #4]
 4651 077c FB68     		ldr	r3, [r7, #12]
 4652 077e 1B6C     		ldr	r3, [r3, #64]
 4653 0780 C3F10003 		rsb	r3, r3, #0
 4654 0784 1A44     		add	r2, r2, r3
 4655 0786 FB68     		ldr	r3, [r7, #12]
 4656 0788 DA60     		str	r2, [r3, #12]
 4657 078a 02E0     		b	.L86
 4658              	.L90:
 4659              		.loc 1 1162 0
 4660 078c 00BF     		nop
 4661 078e 00E0     		b	.L86
 4662              	.L91:
 4663              		.loc 1 1173 0
 4664 0790 00BF     		nop
 4665              	.L86:
1183:../3rdParty/FreeRTOS/queue.c **** 		}
1184:../3rdParty/FreeRTOS/queue.c **** 	}
1185:../3rdParty/FreeRTOS/queue.c **** 
1186:../3rdParty/FreeRTOS/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 4666              		.loc 1 1186 0
 4667 0792 FB68     		ldr	r3, [r7, #12]
 4668 0794 9B6B     		ldr	r3, [r3, #56]
 4669 0796 03F10102 		add	r2, r3, #1
 4670 079a FB68     		ldr	r3, [r7, #12]
 4671 079c 9A63     		str	r2, [r3, #56]
1187:../3rdParty/FreeRTOS/queue.c **** }
 4672              		.loc 1 1187 0
 4673 079e 07F11007 		add	r7, r7, #16
 4674 07a2 BD46     		mov	sp, r7
 4675 07a4 80BD     		pop	{r7, pc}
 4676              	.LFE69:
 4678 07a6 00BF     		.align	2
 4679              		.thumb
 4680              		.thumb_func
 4682              	prvCopyDataFromQueue:
 4683              	.LFB70:
1188:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1189:../3rdParty/FreeRTOS/queue.c **** 
1190:../3rdParty/FreeRTOS/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1191:../3rdParty/FreeRTOS/queue.c **** {
 4684              		.loc 1 1191 0
 4685              		@ args = 0, pretend = 0, frame = 8
 4686              		@ frame_needed = 1, uses_anonymous_args = 0
 4687 07a8 80B5     		push	{r7, lr}
 4688              	.LCFI45:
 4689 07aa 82B0     		sub	sp, sp, #8
 4690              	.LCFI46:
 4691 07ac 00AF     		add	r7, sp, #0
 4692              	.LCFI47:
 4693 07ae 7860     		str	r0, [r7, #4]
 4694 07b0 3960     		str	r1, [r7, #0]
1192:../3rdParty/FreeRTOS/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 4695              		.loc 1 1192 0
 4696 07b2 7B68     		ldr	r3, [r7, #4]
 4697 07b4 1B68     		ldr	r3, [r3, #0]
 4698 07b6 002B     		cmp	r3, #0
 4699 07b8 19D0     		beq	.L95
1193:../3rdParty/FreeRTOS/queue.c **** 	{
1194:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 4700              		.loc 1 1194 0
 4701 07ba 7B68     		ldr	r3, [r7, #4]
 4702 07bc DA68     		ldr	r2, [r3, #12]
 4703 07be 7B68     		ldr	r3, [r7, #4]
 4704 07c0 1B6C     		ldr	r3, [r3, #64]
 4705 07c2 1A44     		add	r2, r2, r3
 4706 07c4 7B68     		ldr	r3, [r7, #4]
 4707 07c6 DA60     		str	r2, [r3, #12]
1195:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 4708              		.loc 1 1195 0
 4709 07c8 7B68     		ldr	r3, [r7, #4]
 4710 07ca DA68     		ldr	r2, [r3, #12]
 4711 07cc 7B68     		ldr	r3, [r7, #4]
 4712 07ce 5B68     		ldr	r3, [r3, #4]
 4713 07d0 9A42     		cmp	r2, r3
 4714 07d2 03D3     		bcc	.L94
1196:../3rdParty/FreeRTOS/queue.c **** 		{
1197:../3rdParty/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 4715              		.loc 1 1197 0
 4716 07d4 7B68     		ldr	r3, [r7, #4]
 4717 07d6 1A68     		ldr	r2, [r3, #0]
 4718 07d8 7B68     		ldr	r3, [r7, #4]
 4719 07da DA60     		str	r2, [r3, #12]
 4720              	.L94:
1198:../3rdParty/FreeRTOS/queue.c **** 		}
1199:../3rdParty/FreeRTOS/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 4721              		.loc 1 1199 0
 4722 07dc 7B68     		ldr	r3, [r7, #4]
 4723 07de DA68     		ldr	r2, [r3, #12]
 4724 07e0 7B68     		ldr	r3, [r7, #4]
 4725 07e2 1B6C     		ldr	r3, [r3, #64]
 4726 07e4 3868     		ldr	r0, [r7, #0]
 4727 07e6 1146     		mov	r1, r2
 4728 07e8 1A46     		mov	r2, r3
 4729 07ea FFF7FEFF 		bl	memcpy
 4730              	.L95:
1200:../3rdParty/FreeRTOS/queue.c **** 	}
1201:../3rdParty/FreeRTOS/queue.c **** }
 4731              		.loc 1 1201 0
 4732 07ee 07F10807 		add	r7, r7, #8
 4733 07f2 BD46     		mov	sp, r7
 4734 07f4 80BD     		pop	{r7, pc}
 4735              	.LFE70:
 4737 07f6 00BF     		.align	2
 4738              		.thumb
 4739              		.thumb_func
 4741              	prvUnlockQueue:
 4742              	.LFB71:
1202:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1203:../3rdParty/FreeRTOS/queue.c **** 
1204:../3rdParty/FreeRTOS/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue )
1205:../3rdParty/FreeRTOS/queue.c **** {
 4743              		.loc 1 1205 0
 4744              		@ args = 0, pretend = 0, frame = 8
 4745              		@ frame_needed = 1, uses_anonymous_args = 0
 4746 07f8 80B5     		push	{r7, lr}
 4747              	.LCFI48:
 4748 07fa 82B0     		sub	sp, sp, #8
 4749              	.LCFI49:
 4750 07fc 00AF     		add	r7, sp, #0
 4751              	.LCFI50:
 4752 07fe 7860     		str	r0, [r7, #4]
1206:../3rdParty/FreeRTOS/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1207:../3rdParty/FreeRTOS/queue.c **** 
1208:../3rdParty/FreeRTOS/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1209:../3rdParty/FreeRTOS/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1210:../3rdParty/FreeRTOS/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1211:../3rdParty/FreeRTOS/queue.c **** 	updated. */
1212:../3rdParty/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 4753              		.loc 1 1212 0
 4754 0800 FFF7FEFF 		bl	vPortEnterCritical
1213:../3rdParty/FreeRTOS/queue.c **** 	{
1214:../3rdParty/FreeRTOS/queue.c **** 		/* See if data was added to the queue while it was locked. */
1215:../3rdParty/FreeRTOS/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 4755              		.loc 1 1215 0
 4756 0804 14E0     		b	.L97
 4757              	.L101:
1216:../3rdParty/FreeRTOS/queue.c **** 		{
1217:../3rdParty/FreeRTOS/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1218:../3rdParty/FreeRTOS/queue.c **** 			blocked waiting for data to become available? */
1219:../3rdParty/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4758              		.loc 1 1219 0
 4759 0806 7B68     		ldr	r3, [r7, #4]
 4760 0808 5B6A     		ldr	r3, [r3, #36]
 4761 080a 002B     		cmp	r3, #0
 4762 080c 15D0     		beq	.L108
1220:../3rdParty/FreeRTOS/queue.c **** 			{
1221:../3rdParty/FreeRTOS/queue.c **** 				/* Tasks that are removed from the event list will get added to
1222:../3rdParty/FreeRTOS/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1223:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4763              		.loc 1 1223 0
 4764 080e 7B68     		ldr	r3, [r7, #4]
 4765 0810 03F12403 		add	r3, r3, #36
 4766 0814 1846     		mov	r0, r3
 4767 0816 FFF7FEFF 		bl	xTaskRemoveFromEventList
 4768 081a 0346     		mov	r3, r0
 4769 081c 002B     		cmp	r3, #0
 4770 081e 01D0     		beq	.L99
1224:../3rdParty/FreeRTOS/queue.c **** 				{
1225:../3rdParty/FreeRTOS/queue.c **** 					/* The task waiting has a higher priority so record that a
1226:../3rdParty/FreeRTOS/queue.c **** 					context	switch is required. */
1227:../3rdParty/FreeRTOS/queue.c **** 					vTaskMissedYield();
 4771              		.loc 1 1227 0
 4772 0820 FFF7FEFF 		bl	vTaskMissedYield
 4773              	.L99:
1228:../3rdParty/FreeRTOS/queue.c **** 				}
1229:../3rdParty/FreeRTOS/queue.c **** 
1230:../3rdParty/FreeRTOS/queue.c **** 				--( pxQueue->xTxLock );
 4774              		.loc 1 1230 0
 4775 0824 7B68     		ldr	r3, [r7, #4]
 4776 0826 9B6C     		ldr	r3, [r3, #72]
 4777 0828 03F1FF32 		add	r2, r3, #-1
 4778 082c 7B68     		ldr	r3, [r7, #4]
 4779 082e 9A64     		str	r2, [r3, #72]
 4780              	.L97:
 4781              		.loc 1 1215 0
 4782 0830 7B68     		ldr	r3, [r7, #4]
 4783 0832 9B6C     		ldr	r3, [r3, #72]
 4784 0834 002B     		cmp	r3, #0
 4785 0836 E6DC     		bgt	.L101
 4786 0838 00E0     		b	.L100
 4787              	.L108:
1231:../3rdParty/FreeRTOS/queue.c **** 			}
1232:../3rdParty/FreeRTOS/queue.c **** 			else
1233:../3rdParty/FreeRTOS/queue.c **** 			{
1234:../3rdParty/FreeRTOS/queue.c **** 				break;
 4788              		.loc 1 1234 0
 4789 083a 00BF     		nop
 4790              	.L100:
1235:../3rdParty/FreeRTOS/queue.c **** 			}
1236:../3rdParty/FreeRTOS/queue.c **** 		}
1237:../3rdParty/FreeRTOS/queue.c **** 
1238:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 4791              		.loc 1 1238 0
 4792 083c 7B68     		ldr	r3, [r7, #4]
 4793 083e 4FF0FF32 		mov	r2, #-1
 4794 0842 9A64     		str	r2, [r3, #72]
1239:../3rdParty/FreeRTOS/queue.c **** 	}
1240:../3rdParty/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 4795              		.loc 1 1240 0
 4796 0844 FFF7FEFF 		bl	vPortExitCritical
1241:../3rdParty/FreeRTOS/queue.c **** 
1242:../3rdParty/FreeRTOS/queue.c **** 	/* Do the same for the Rx lock. */
1243:../3rdParty/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 4797              		.loc 1 1243 0
 4798 0848 FFF7FEFF 		bl	vPortEnterCritical
1244:../3rdParty/FreeRTOS/queue.c **** 	{
1245:../3rdParty/FreeRTOS/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 4799              		.loc 1 1245 0
 4800 084c 14E0     		b	.L102
 4801              	.L106:
1246:../3rdParty/FreeRTOS/queue.c **** 		{
1247:../3rdParty/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4802              		.loc 1 1247 0
 4803 084e 7B68     		ldr	r3, [r7, #4]
 4804 0850 1B69     		ldr	r3, [r3, #16]
 4805 0852 002B     		cmp	r3, #0
 4806 0854 15D0     		beq	.L109
1248:../3rdParty/FreeRTOS/queue.c **** 			{
1249:../3rdParty/FreeRTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4807              		.loc 1 1249 0
 4808 0856 7B68     		ldr	r3, [r7, #4]
 4809 0858 03F11003 		add	r3, r3, #16
 4810 085c 1846     		mov	r0, r3
 4811 085e FFF7FEFF 		bl	xTaskRemoveFromEventList
 4812 0862 0346     		mov	r3, r0
 4813 0864 002B     		cmp	r3, #0
 4814 0866 01D0     		beq	.L104
1250:../3rdParty/FreeRTOS/queue.c **** 				{
1251:../3rdParty/FreeRTOS/queue.c **** 					vTaskMissedYield();
 4815              		.loc 1 1251 0
 4816 0868 FFF7FEFF 		bl	vTaskMissedYield
 4817              	.L104:
1252:../3rdParty/FreeRTOS/queue.c **** 				}
1253:../3rdParty/FreeRTOS/queue.c **** 
1254:../3rdParty/FreeRTOS/queue.c **** 				--( pxQueue->xRxLock );
 4818              		.loc 1 1254 0
 4819 086c 7B68     		ldr	r3, [r7, #4]
 4820 086e 5B6C     		ldr	r3, [r3, #68]
 4821 0870 03F1FF32 		add	r2, r3, #-1
 4822 0874 7B68     		ldr	r3, [r7, #4]
 4823 0876 5A64     		str	r2, [r3, #68]
 4824              	.L102:
 4825              		.loc 1 1245 0
 4826 0878 7B68     		ldr	r3, [r7, #4]
 4827 087a 5B6C     		ldr	r3, [r3, #68]
 4828 087c 002B     		cmp	r3, #0
 4829 087e E6DC     		bgt	.L106
 4830 0880 00E0     		b	.L105
 4831              	.L109:
1255:../3rdParty/FreeRTOS/queue.c **** 			}
1256:../3rdParty/FreeRTOS/queue.c **** 			else
1257:../3rdParty/FreeRTOS/queue.c **** 			{
1258:../3rdParty/FreeRTOS/queue.c **** 				break;
 4832              		.loc 1 1258 0
 4833 0882 00BF     		nop
 4834              	.L105:
1259:../3rdParty/FreeRTOS/queue.c **** 			}
1260:../3rdParty/FreeRTOS/queue.c **** 		}
1261:../3rdParty/FreeRTOS/queue.c **** 
1262:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 4835              		.loc 1 1262 0
 4836 0884 7B68     		ldr	r3, [r7, #4]
 4837 0886 4FF0FF32 		mov	r2, #-1
 4838 088a 5A64     		str	r2, [r3, #68]
1263:../3rdParty/FreeRTOS/queue.c **** 	}
1264:../3rdParty/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 4839              		.loc 1 1264 0
 4840 088c FFF7FEFF 		bl	vPortExitCritical
1265:../3rdParty/FreeRTOS/queue.c **** }
 4841              		.loc 1 1265 0
 4842 0890 07F10807 		add	r7, r7, #8
 4843 0894 BD46     		mov	sp, r7
 4844 0896 80BD     		pop	{r7, pc}
 4845              	.LFE71:
 4847              		.align	2
 4848              		.thumb
 4849              		.thumb_func
 4851              	prvIsQueueEmpty:
 4852              	.LFB72:
1266:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1267:../3rdParty/FreeRTOS/queue.c **** 
1268:../3rdParty/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
1269:../3rdParty/FreeRTOS/queue.c **** {
 4853              		.loc 1 1269 0
 4854              		@ args = 0, pretend = 0, frame = 16
 4855              		@ frame_needed = 1, uses_anonymous_args = 0
 4856 0898 80B5     		push	{r7, lr}
 4857              	.LCFI51:
 4858 089a 84B0     		sub	sp, sp, #16
 4859              	.LCFI52:
 4860 089c 00AF     		add	r7, sp, #0
 4861              	.LCFI53:
 4862 089e 7860     		str	r0, [r7, #4]
1270:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1271:../3rdParty/FreeRTOS/queue.c **** 
1272:../3rdParty/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 4863              		.loc 1 1272 0
 4864 08a0 FFF7FEFF 		bl	vPortEnterCritical
1273:../3rdParty/FreeRTOS/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 4865              		.loc 1 1273 0
 4866 08a4 7B68     		ldr	r3, [r7, #4]
 4867 08a6 9B6B     		ldr	r3, [r3, #56]
 4868 08a8 002B     		cmp	r3, #0
 4869 08aa 14BF     		ite	ne
 4870 08ac 0023     		movne	r3, #0
 4871 08ae 0123     		moveq	r3, #1
 4872 08b0 FB60     		str	r3, [r7, #12]
1274:../3rdParty/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 4873              		.loc 1 1274 0
 4874 08b2 FFF7FEFF 		bl	vPortExitCritical
1275:../3rdParty/FreeRTOS/queue.c **** 
1276:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 4875              		.loc 1 1276 0
 4876 08b6 FB68     		ldr	r3, [r7, #12]
1277:../3rdParty/FreeRTOS/queue.c **** }
 4877              		.loc 1 1277 0
 4878 08b8 1846     		mov	r0, r3
 4879 08ba 07F11007 		add	r7, r7, #16
 4880 08be BD46     		mov	sp, r7
 4881 08c0 80BD     		pop	{r7, pc}
 4882              	.LFE72:
 4884 08c2 00BF     		.align	2
 4885              		.global	xQueueIsQueueEmptyFromISR
 4886              		.thumb
 4887              		.thumb_func
 4889              	xQueueIsQueueEmptyFromISR:
 4890              	.LFB73:
1278:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1279:../3rdParty/FreeRTOS/queue.c **** 
1280:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
1281:../3rdParty/FreeRTOS/queue.c **** {
 4891              		.loc 1 1281 0
 4892              		@ args = 0, pretend = 0, frame = 16
 4893              		@ frame_needed = 1, uses_anonymous_args = 0
 4894              		@ link register save eliminated.
 4895 08c4 80B4     		push	{r7}
 4896              	.LCFI54:
 4897 08c6 85B0     		sub	sp, sp, #20
 4898              	.LCFI55:
 4899 08c8 00AF     		add	r7, sp, #0
 4900              	.LCFI56:
 4901 08ca 7860     		str	r0, [r7, #4]
1282:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1283:../3rdParty/FreeRTOS/queue.c **** 
1284:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1285:../3rdParty/FreeRTOS/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 4902              		.loc 1 1285 0
 4903 08cc 7B68     		ldr	r3, [r7, #4]
 4904 08ce 9B6B     		ldr	r3, [r3, #56]
 4905 08d0 002B     		cmp	r3, #0
 4906 08d2 14BF     		ite	ne
 4907 08d4 0023     		movne	r3, #0
 4908 08d6 0123     		moveq	r3, #1
 4909 08d8 FB60     		str	r3, [r7, #12]
1286:../3rdParty/FreeRTOS/queue.c **** 
1287:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 4910              		.loc 1 1287 0
 4911 08da FB68     		ldr	r3, [r7, #12]
1288:../3rdParty/FreeRTOS/queue.c **** }
 4912              		.loc 1 1288 0
 4913 08dc 1846     		mov	r0, r3
 4914 08de 07F11407 		add	r7, r7, #20
 4915 08e2 BD46     		mov	sp, r7
 4916 08e4 80BC     		pop	{r7}
 4917 08e6 7047     		bx	lr
 4918              	.LFE73:
 4920              		.align	2
 4921              		.thumb
 4922              		.thumb_func
 4924              	prvIsQueueFull:
 4925              	.LFB74:
1289:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1290:../3rdParty/FreeRTOS/queue.c **** 
1291:../3rdParty/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
1292:../3rdParty/FreeRTOS/queue.c **** {
 4926              		.loc 1 1292 0
 4927              		@ args = 0, pretend = 0, frame = 16
 4928              		@ frame_needed = 1, uses_anonymous_args = 0
 4929 08e8 80B5     		push	{r7, lr}
 4930              	.LCFI57:
 4931 08ea 84B0     		sub	sp, sp, #16
 4932              	.LCFI58:
 4933 08ec 00AF     		add	r7, sp, #0
 4934              	.LCFI59:
 4935 08ee 7860     		str	r0, [r7, #4]
1293:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1294:../3rdParty/FreeRTOS/queue.c **** 
1295:../3rdParty/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 4936              		.loc 1 1295 0
 4937 08f0 FFF7FEFF 		bl	vPortEnterCritical
1296:../3rdParty/FreeRTOS/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 4938              		.loc 1 1296 0
 4939 08f4 7B68     		ldr	r3, [r7, #4]
 4940 08f6 9A6B     		ldr	r2, [r3, #56]
 4941 08f8 7B68     		ldr	r3, [r7, #4]
 4942 08fa DB6B     		ldr	r3, [r3, #60]
 4943 08fc 9A42     		cmp	r2, r3
 4944 08fe 14BF     		ite	ne
 4945 0900 0023     		movne	r3, #0
 4946 0902 0123     		moveq	r3, #1
 4947 0904 FB60     		str	r3, [r7, #12]
1297:../3rdParty/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 4948              		.loc 1 1297 0
 4949 0906 FFF7FEFF 		bl	vPortExitCritical
1298:../3rdParty/FreeRTOS/queue.c **** 
1299:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 4950              		.loc 1 1299 0
 4951 090a FB68     		ldr	r3, [r7, #12]
1300:../3rdParty/FreeRTOS/queue.c **** }
 4952              		.loc 1 1300 0
 4953 090c 1846     		mov	r0, r3
 4954 090e 07F11007 		add	r7, r7, #16
 4955 0912 BD46     		mov	sp, r7
 4956 0914 80BD     		pop	{r7, pc}
 4957              	.LFE74:
 4959 0916 00BF     		.align	2
 4960              		.global	xQueueIsQueueFullFromISR
 4961              		.thumb
 4962              		.thumb_func
 4964              	xQueueIsQueueFullFromISR:
 4965              	.LFB75:
1301:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1302:../3rdParty/FreeRTOS/queue.c **** 
1303:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
1304:../3rdParty/FreeRTOS/queue.c **** {
 4966              		.loc 1 1304 0
 4967              		@ args = 0, pretend = 0, frame = 16
 4968              		@ frame_needed = 1, uses_anonymous_args = 0
 4969              		@ link register save eliminated.
 4970 0918 80B4     		push	{r7}
 4971              	.LCFI60:
 4972 091a 85B0     		sub	sp, sp, #20
 4973              	.LCFI61:
 4974 091c 00AF     		add	r7, sp, #0
 4975              	.LCFI62:
 4976 091e 7860     		str	r0, [r7, #4]
1305:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1306:../3rdParty/FreeRTOS/queue.c **** 
1307:../3rdParty/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1308:../3rdParty/FreeRTOS/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 4977              		.loc 1 1308 0
 4978 0920 7B68     		ldr	r3, [r7, #4]
 4979 0922 9A6B     		ldr	r2, [r3, #56]
 4980 0924 7B68     		ldr	r3, [r7, #4]
 4981 0926 DB6B     		ldr	r3, [r3, #60]
 4982 0928 9A42     		cmp	r2, r3
 4983 092a 14BF     		ite	ne
 4984 092c 0023     		movne	r3, #0
 4985 092e 0123     		moveq	r3, #1
 4986 0930 FB60     		str	r3, [r7, #12]
1309:../3rdParty/FreeRTOS/queue.c **** 
1310:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
 4987              		.loc 1 1310 0
 4988 0932 FB68     		ldr	r3, [r7, #12]
1311:../3rdParty/FreeRTOS/queue.c **** }
 4989              		.loc 1 1311 0
 4990 0934 1846     		mov	r0, r3
 4991 0936 07F11407 		add	r7, r7, #20
 4992 093a BD46     		mov	sp, r7
 4993 093c 80BC     		pop	{r7}
 4994 093e 7047     		bx	lr
 4995              	.LFE75:
 4997              		.align	2
 4998              		.global	vQueueAddToRegistry
 4999              		.thumb
 5000              		.thumb_func
 5002              	vQueueAddToRegistry:
 5003              	.LFB76:
1312:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1313:../3rdParty/FreeRTOS/queue.c **** 
1314:../3rdParty/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1315:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xT
1316:../3rdParty/FreeRTOS/queue.c **** {
1317:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1318:../3rdParty/FreeRTOS/queue.c **** 
1319:../3rdParty/FreeRTOS/queue.c **** 	/* If the queue is already full we may have to block.  A critical section
1320:../3rdParty/FreeRTOS/queue.c **** 	is required to prevent an interrupt removing something from the queue
1321:../3rdParty/FreeRTOS/queue.c **** 	between the check to see if the queue is full and blocking on the queue. */
1322:../3rdParty/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1323:../3rdParty/FreeRTOS/queue.c **** 	{
1324:../3rdParty/FreeRTOS/queue.c **** 		if( prvIsQueueFull( pxQueue ) != pdFALSE )
1325:../3rdParty/FreeRTOS/queue.c **** 		{
1326:../3rdParty/FreeRTOS/queue.c **** 			/* The queue is full - do we want to block or just leave without
1327:../3rdParty/FreeRTOS/queue.c **** 			posting? */
1328:../3rdParty/FreeRTOS/queue.c **** 			if( xTicksToWait > ( portTickType ) 0 )
1329:../3rdParty/FreeRTOS/queue.c **** 			{
1330:../3rdParty/FreeRTOS/queue.c **** 				/* As this is called from a coroutine we cannot block directly, but
1331:../3rdParty/FreeRTOS/queue.c **** 				return indicating that we need to block. */
1332:../3rdParty/FreeRTOS/queue.c **** 				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1333:../3rdParty/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1334:../3rdParty/FreeRTOS/queue.c **** 				return errQUEUE_BLOCKED;
1335:../3rdParty/FreeRTOS/queue.c **** 			}
1336:../3rdParty/FreeRTOS/queue.c **** 			else
1337:../3rdParty/FreeRTOS/queue.c **** 			{
1338:../3rdParty/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1339:../3rdParty/FreeRTOS/queue.c **** 				return errQUEUE_FULL;
1340:../3rdParty/FreeRTOS/queue.c **** 			}
1341:../3rdParty/FreeRTOS/queue.c **** 		}
1342:../3rdParty/FreeRTOS/queue.c **** 	}
1343:../3rdParty/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1344:../3rdParty/FreeRTOS/queue.c **** 
1345:../3rdParty/FreeRTOS/queue.c **** 	portNOP();
1346:../3rdParty/FreeRTOS/queue.c **** 
1347:../3rdParty/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1348:../3rdParty/FreeRTOS/queue.c **** 	{
1349:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1350:../3rdParty/FreeRTOS/queue.c **** 		{
1351:../3rdParty/FreeRTOS/queue.c **** 			/* There is room in the queue, copy the data into the queue. */
1352:../3rdParty/FreeRTOS/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1353:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdPASS;
1354:../3rdParty/FreeRTOS/queue.c **** 
1355:../3rdParty/FreeRTOS/queue.c **** 			/* Were any co-routines waiting for data to become available? */
1356:../3rdParty/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1357:../3rdParty/FreeRTOS/queue.c **** 			{
1358:../3rdParty/FreeRTOS/queue.c **** 				/* In this instance the co-routine could be placed directly
1359:../3rdParty/FreeRTOS/queue.c **** 				into the ready list as we are within a critical section.
1360:../3rdParty/FreeRTOS/queue.c **** 				Instead the same pending ready list mechanism is used as if
1361:../3rdParty/FreeRTOS/queue.c **** 				the event were caused from within an interrupt. */
1362:../3rdParty/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1363:../3rdParty/FreeRTOS/queue.c **** 				{
1364:../3rdParty/FreeRTOS/queue.c **** 					/* The co-routine waiting has a higher priority so record
1365:../3rdParty/FreeRTOS/queue.c **** 					that a yield might be appropriate. */
1366:../3rdParty/FreeRTOS/queue.c **** 					xReturn = errQUEUE_YIELD;
1367:../3rdParty/FreeRTOS/queue.c **** 				}
1368:../3rdParty/FreeRTOS/queue.c **** 			}
1369:../3rdParty/FreeRTOS/queue.c **** 		}
1370:../3rdParty/FreeRTOS/queue.c **** 		else
1371:../3rdParty/FreeRTOS/queue.c **** 		{
1372:../3rdParty/FreeRTOS/queue.c **** 			xReturn = errQUEUE_FULL;
1373:../3rdParty/FreeRTOS/queue.c **** 		}
1374:../3rdParty/FreeRTOS/queue.c **** 	}
1375:../3rdParty/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1376:../3rdParty/FreeRTOS/queue.c **** 
1377:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
1378:../3rdParty/FreeRTOS/queue.c **** }
1379:../3rdParty/FreeRTOS/queue.c **** #endif
1380:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1381:../3rdParty/FreeRTOS/queue.c **** 
1382:../3rdParty/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1383:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWa
1384:../3rdParty/FreeRTOS/queue.c **** {
1385:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1386:../3rdParty/FreeRTOS/queue.c **** 
1387:../3rdParty/FreeRTOS/queue.c **** 	/* If the queue is already empty we may have to block.  A critical section
1388:../3rdParty/FreeRTOS/queue.c **** 	is required to prevent an interrupt adding something to the queue
1389:../3rdParty/FreeRTOS/queue.c **** 	between the check to see if the queue is empty and blocking on the queue. */
1390:../3rdParty/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1391:../3rdParty/FreeRTOS/queue.c **** 	{
1392:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
1393:../3rdParty/FreeRTOS/queue.c **** 		{
1394:../3rdParty/FreeRTOS/queue.c **** 			/* There are no messages in the queue, do we want to block or just
1395:../3rdParty/FreeRTOS/queue.c **** 			leave with nothing? */
1396:../3rdParty/FreeRTOS/queue.c **** 			if( xTicksToWait > ( portTickType ) 0 )
1397:../3rdParty/FreeRTOS/queue.c **** 			{
1398:../3rdParty/FreeRTOS/queue.c **** 				/* As this is a co-routine we cannot block directly, but return
1399:../3rdParty/FreeRTOS/queue.c **** 				indicating that we need to block. */
1400:../3rdParty/FreeRTOS/queue.c **** 				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
1401:../3rdParty/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1402:../3rdParty/FreeRTOS/queue.c **** 				return errQUEUE_BLOCKED;
1403:../3rdParty/FreeRTOS/queue.c **** 			}
1404:../3rdParty/FreeRTOS/queue.c **** 			else
1405:../3rdParty/FreeRTOS/queue.c **** 			{
1406:../3rdParty/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1407:../3rdParty/FreeRTOS/queue.c **** 				return errQUEUE_FULL;
1408:../3rdParty/FreeRTOS/queue.c **** 			}
1409:../3rdParty/FreeRTOS/queue.c **** 		}
1410:../3rdParty/FreeRTOS/queue.c **** 	}
1411:../3rdParty/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1412:../3rdParty/FreeRTOS/queue.c **** 
1413:../3rdParty/FreeRTOS/queue.c **** 	portNOP();
1414:../3rdParty/FreeRTOS/queue.c **** 
1415:../3rdParty/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1416:../3rdParty/FreeRTOS/queue.c **** 	{
1417:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1418:../3rdParty/FreeRTOS/queue.c **** 		{
1419:../3rdParty/FreeRTOS/queue.c **** 			/* Data is available from the queue. */
1420:../3rdParty/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom += pxQueue->uxItemSize;
1421:../3rdParty/FreeRTOS/queue.c **** 			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1422:../3rdParty/FreeRTOS/queue.c **** 			{
1423:../3rdParty/FreeRTOS/queue.c **** 				pxQueue->pcReadFrom = pxQueue->pcHead;
1424:../3rdParty/FreeRTOS/queue.c **** 			}
1425:../3rdParty/FreeRTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1426:../3rdParty/FreeRTOS/queue.c **** 			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1427:../3rdParty/FreeRTOS/queue.c **** 
1428:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdPASS;
1429:../3rdParty/FreeRTOS/queue.c **** 
1430:../3rdParty/FreeRTOS/queue.c **** 			/* Were any co-routines waiting for space to become available? */
1431:../3rdParty/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1432:../3rdParty/FreeRTOS/queue.c **** 			{
1433:../3rdParty/FreeRTOS/queue.c **** 				/* In this instance the co-routine could be placed directly
1434:../3rdParty/FreeRTOS/queue.c **** 				into the ready list as we are within a critical section.
1435:../3rdParty/FreeRTOS/queue.c **** 				Instead the same pending ready list mechanism is used as if
1436:../3rdParty/FreeRTOS/queue.c **** 				the event were caused from within an interrupt. */
1437:../3rdParty/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1438:../3rdParty/FreeRTOS/queue.c **** 				{
1439:../3rdParty/FreeRTOS/queue.c **** 					xReturn = errQUEUE_YIELD;
1440:../3rdParty/FreeRTOS/queue.c **** 				}
1441:../3rdParty/FreeRTOS/queue.c **** 			}
1442:../3rdParty/FreeRTOS/queue.c **** 		}
1443:../3rdParty/FreeRTOS/queue.c **** 		else
1444:../3rdParty/FreeRTOS/queue.c **** 		{
1445:../3rdParty/FreeRTOS/queue.c **** 			xReturn = pdFAIL;
1446:../3rdParty/FreeRTOS/queue.c **** 		}
1447:../3rdParty/FreeRTOS/queue.c **** 	}
1448:../3rdParty/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1449:../3rdParty/FreeRTOS/queue.c **** 
1450:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
1451:../3rdParty/FreeRTOS/queue.c **** }
1452:../3rdParty/FreeRTOS/queue.c **** #endif
1453:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1454:../3rdParty/FreeRTOS/queue.c **** 
1455:../3rdParty/FreeRTOS/queue.c **** 
1456:../3rdParty/FreeRTOS/queue.c **** 
1457:../3rdParty/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1458:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed p
1459:../3rdParty/FreeRTOS/queue.c **** {
1460:../3rdParty/FreeRTOS/queue.c **** 	/* Cannot block within an ISR so if there is no space on the queue then
1461:../3rdParty/FreeRTOS/queue.c **** 	exit without doing anything. */
1462:../3rdParty/FreeRTOS/queue.c **** 	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1463:../3rdParty/FreeRTOS/queue.c **** 	{
1464:../3rdParty/FreeRTOS/queue.c **** 		prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1465:../3rdParty/FreeRTOS/queue.c **** 
1466:../3rdParty/FreeRTOS/queue.c **** 		/* We only want to wake one co-routine per ISR, so check that a
1467:../3rdParty/FreeRTOS/queue.c **** 		co-routine has not already been woken. */
1468:../3rdParty/FreeRTOS/queue.c **** 		if( xCoRoutinePreviouslyWoken == pdFALSE )
1469:../3rdParty/FreeRTOS/queue.c **** 		{
1470:../3rdParty/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1471:../3rdParty/FreeRTOS/queue.c **** 			{
1472:../3rdParty/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1473:../3rdParty/FreeRTOS/queue.c **** 				{
1474:../3rdParty/FreeRTOS/queue.c **** 					return pdTRUE;
1475:../3rdParty/FreeRTOS/queue.c **** 				}
1476:../3rdParty/FreeRTOS/queue.c **** 			}
1477:../3rdParty/FreeRTOS/queue.c **** 		}
1478:../3rdParty/FreeRTOS/queue.c **** 	}
1479:../3rdParty/FreeRTOS/queue.c **** 
1480:../3rdParty/FreeRTOS/queue.c **** 	return xCoRoutinePreviouslyWoken;
1481:../3rdParty/FreeRTOS/queue.c **** }
1482:../3rdParty/FreeRTOS/queue.c **** #endif
1483:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1484:../3rdParty/FreeRTOS/queue.c **** 
1485:../3rdParty/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1486:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_
1487:../3rdParty/FreeRTOS/queue.c **** {
1488:../3rdParty/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1489:../3rdParty/FreeRTOS/queue.c **** 
1490:../3rdParty/FreeRTOS/queue.c **** 	/* We cannot block from an ISR, so check there is data available. If
1491:../3rdParty/FreeRTOS/queue.c **** 	not then just leave without doing anything. */
1492:../3rdParty/FreeRTOS/queue.c **** 	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1493:../3rdParty/FreeRTOS/queue.c **** 	{
1494:../3rdParty/FreeRTOS/queue.c **** 		/* Copy the data from the queue. */
1495:../3rdParty/FreeRTOS/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
1496:../3rdParty/FreeRTOS/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1497:../3rdParty/FreeRTOS/queue.c **** 		{
1498:../3rdParty/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
1499:../3rdParty/FreeRTOS/queue.c **** 		}
1500:../3rdParty/FreeRTOS/queue.c **** 		--( pxQueue->uxMessagesWaiting );
1501:../3rdParty/FreeRTOS/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1502:../3rdParty/FreeRTOS/queue.c **** 
1503:../3rdParty/FreeRTOS/queue.c **** 		if( ( *pxCoRoutineWoken ) == pdFALSE )
1504:../3rdParty/FreeRTOS/queue.c **** 		{
1505:../3rdParty/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1506:../3rdParty/FreeRTOS/queue.c **** 			{
1507:../3rdParty/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1508:../3rdParty/FreeRTOS/queue.c **** 				{
1509:../3rdParty/FreeRTOS/queue.c **** 					*pxCoRoutineWoken = pdTRUE;
1510:../3rdParty/FreeRTOS/queue.c **** 				}
1511:../3rdParty/FreeRTOS/queue.c **** 			}
1512:../3rdParty/FreeRTOS/queue.c **** 		}
1513:../3rdParty/FreeRTOS/queue.c **** 
1514:../3rdParty/FreeRTOS/queue.c **** 		xReturn = pdPASS;
1515:../3rdParty/FreeRTOS/queue.c **** 	}
1516:../3rdParty/FreeRTOS/queue.c **** 	else
1517:../3rdParty/FreeRTOS/queue.c **** 	{
1518:../3rdParty/FreeRTOS/queue.c **** 		xReturn = pdFAIL;
1519:../3rdParty/FreeRTOS/queue.c **** 	}
1520:../3rdParty/FreeRTOS/queue.c **** 
1521:../3rdParty/FreeRTOS/queue.c **** 	return xReturn;
1522:../3rdParty/FreeRTOS/queue.c **** }
1523:../3rdParty/FreeRTOS/queue.c **** #endif
1524:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1525:../3rdParty/FreeRTOS/queue.c **** 
1526:../3rdParty/FreeRTOS/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
1527:../3rdParty/FreeRTOS/queue.c **** 
1528:../3rdParty/FreeRTOS/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
1529:../3rdParty/FreeRTOS/queue.c **** 	{
 5004              		.loc 1 1529 0
 5005              		@ args = 0, pretend = 0, frame = 16
 5006              		@ frame_needed = 1, uses_anonymous_args = 0
 5007              		@ link register save eliminated.
 5008 0940 80B4     		push	{r7}
 5009              	.LCFI63:
 5010 0942 85B0     		sub	sp, sp, #20
 5011              	.LCFI64:
 5012 0944 00AF     		add	r7, sp, #0
 5013              	.LCFI65:
 5014 0946 7860     		str	r0, [r7, #4]
 5015 0948 3960     		str	r1, [r7, #0]
1530:../3rdParty/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE ux;
1531:../3rdParty/FreeRTOS/queue.c **** 
1532:../3rdParty/FreeRTOS/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
1533:../3rdParty/FreeRTOS/queue.c **** 		a free slot. */
1534:../3rdParty/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5016              		.loc 1 1534 0
 5017 094a 4FF00003 		mov	r3, #0
 5018 094e FB60     		str	r3, [r7, #12]
 5019 0950 1FE0     		b	.L119
 5020              	.L122:
1535:../3rdParty/FreeRTOS/queue.c **** 		{
1536:../3rdParty/FreeRTOS/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 5021              		.loc 1 1536 0
 5022 0952 FA68     		ldr	r2, [r7, #12]
 5023 0954 40F20003 		movw	r3, #:lower16:xQueueRegistry
 5024 0958 C0F20003 		movt	r3, #:upper16:xQueueRegistry
 5025 095c 53F83230 		ldr	r3, [r3, r2, lsl #3]
 5026 0960 002B     		cmp	r3, #0
 5027 0962 12D1     		bne	.L120
1537:../3rdParty/FreeRTOS/queue.c **** 			{
1538:../3rdParty/FreeRTOS/queue.c **** 				/* Store the information on this queue. */
1539:../3rdParty/FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 5028              		.loc 1 1539 0
 5029 0964 FA68     		ldr	r2, [r7, #12]
 5030 0966 40F20003 		movw	r3, #:lower16:xQueueRegistry
 5031 096a C0F20003 		movt	r3, #:upper16:xQueueRegistry
 5032 096e 3968     		ldr	r1, [r7, #0]
 5033 0970 43F83210 		str	r1, [r3, r2, lsl #3]
1540:../3rdParty/FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 5034              		.loc 1 1540 0
 5035 0974 FB68     		ldr	r3, [r7, #12]
 5036 0976 40F20002 		movw	r2, #:lower16:xQueueRegistry
 5037 097a C0F20002 		movt	r2, #:upper16:xQueueRegistry
 5038 097e 4FEAC303 		lsl	r3, r3, #3
 5039 0982 1344     		add	r3, r3, r2
 5040 0984 7A68     		ldr	r2, [r7, #4]
 5041 0986 5A60     		str	r2, [r3, #4]
1541:../3rdParty/FreeRTOS/queue.c **** 				break;
 5042              		.loc 1 1541 0
 5043 0988 06E0     		b	.L123
 5044              	.L120:
 5045              		.loc 1 1534 0
 5046 098a FB68     		ldr	r3, [r7, #12]
 5047 098c 03F10103 		add	r3, r3, #1
 5048 0990 FB60     		str	r3, [r7, #12]
 5049              	.L119:
 5050 0992 FB68     		ldr	r3, [r7, #12]
 5051 0994 092B     		cmp	r3, #9
 5052 0996 DCD9     		bls	.L122
 5053              	.L123:
1542:../3rdParty/FreeRTOS/queue.c **** 			}
1543:../3rdParty/FreeRTOS/queue.c **** 		}
1544:../3rdParty/FreeRTOS/queue.c **** 	}
 5054              		.loc 1 1544 0
 5055 0998 07F11407 		add	r7, r7, #20
 5056 099c BD46     		mov	sp, r7
 5057 099e 80BC     		pop	{r7}
 5058 09a0 7047     		bx	lr
 5059              	.LFE76:
 5061 09a2 00BF     		.align	2
 5062              		.thumb
 5063              		.thumb_func
 5065              	vQueueUnregisterQueue:
 5066              	.LFB77:
1545:../3rdParty/FreeRTOS/queue.c **** 
1546:../3rdParty/FreeRTOS/queue.c **** #endif
1547:../3rdParty/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1548:../3rdParty/FreeRTOS/queue.c **** 
1549:../3rdParty/FreeRTOS/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
1550:../3rdParty/FreeRTOS/queue.c **** 
1551:../3rdParty/FreeRTOS/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue )
1552:../3rdParty/FreeRTOS/queue.c **** 	{
 5067              		.loc 1 1552 0
 5068              		@ args = 0, pretend = 0, frame = 16
 5069              		@ frame_needed = 1, uses_anonymous_args = 0
 5070              		@ link register save eliminated.
 5071 09a4 80B4     		push	{r7}
 5072              	.LCFI66:
 5073 09a6 85B0     		sub	sp, sp, #20
 5074              	.LCFI67:
 5075 09a8 00AF     		add	r7, sp, #0
 5076              	.LCFI68:
 5077 09aa 7860     		str	r0, [r7, #4]
1553:../3rdParty/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE ux;
1554:../3rdParty/FreeRTOS/queue.c **** 
1555:../3rdParty/FreeRTOS/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
1556:../3rdParty/FreeRTOS/queue.c **** 		registry. */
1557:../3rdParty/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5078              		.loc 1 1557 0
 5079 09ac 4FF00003 		mov	r3, #0
 5080 09b0 FB60     		str	r3, [r7, #12]
 5081 09b2 19E0     		b	.L125
 5082              	.L128:
1558:../3rdParty/FreeRTOS/queue.c **** 		{
1559:../3rdParty/FreeRTOS/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 5083              		.loc 1 1559 0
 5084 09b4 FB68     		ldr	r3, [r7, #12]
 5085 09b6 40F20002 		movw	r2, #:lower16:xQueueRegistry
 5086 09ba C0F20002 		movt	r2, #:upper16:xQueueRegistry
 5087 09be 4FEAC303 		lsl	r3, r3, #3
 5088 09c2 1344     		add	r3, r3, r2
 5089 09c4 5A68     		ldr	r2, [r3, #4]
 5090 09c6 7B68     		ldr	r3, [r7, #4]
 5091 09c8 9A42     		cmp	r2, r3
 5092 09ca 09D1     		bne	.L126
1560:../3rdParty/FreeRTOS/queue.c **** 			{
1561:../3rdParty/FreeRTOS/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
1562:../3rdParty/FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 5093              		.loc 1 1562 0
 5094 09cc FA68     		ldr	r2, [r7, #12]
 5095 09ce 40F20003 		movw	r3, #:lower16:xQueueRegistry
 5096 09d2 C0F20003 		movt	r3, #:upper16:xQueueRegistry
 5097 09d6 4FF00001 		mov	r1, #0
 5098 09da 43F83210 		str	r1, [r3, r2, lsl #3]
1563:../3rdParty/FreeRTOS/queue.c **** 				break;
 5099              		.loc 1 1563 0
 5100 09de 06E0     		b	.L129
 5101              	.L126:
 5102              		.loc 1 1557 0
 5103 09e0 FB68     		ldr	r3, [r7, #12]
 5104 09e2 03F10103 		add	r3, r3, #1
 5105 09e6 FB60     		str	r3, [r7, #12]
 5106              	.L125:
 5107 09e8 FB68     		ldr	r3, [r7, #12]
 5108 09ea 092B     		cmp	r3, #9
 5109 09ec E2D9     		bls	.L128
 5110              	.L129:
1564:../3rdParty/FreeRTOS/queue.c **** 			}
1565:../3rdParty/FreeRTOS/queue.c **** 		}
1566:../3rdParty/FreeRTOS/queue.c **** 
1567:../3rdParty/FreeRTOS/queue.c **** 	}
 5111              		.loc 1 1567 0
 5112 09ee 07F11407 		add	r7, r7, #20
 5113 09f2 BD46     		mov	sp, r7
 5114 09f4 80BC     		pop	{r7}
 5115 09f6 7047     		bx	lr
 5116              	.LFE77:
 5714              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 queue.c
                            *COM*:0000000000000050 xQueueRegistry
/var/tmp//ccAqzzhG.s:3403   .text:0000000000000000 $t
/var/tmp//ccAqzzhG.s:3408   .text:0000000000000000 xQueueGenericCreate
/var/tmp//ccAqzzhG.s:3538   .text:00000000000000dc xQueueCreateMutex
/var/tmp//ccAqzzhG.s:3755   .text:0000000000000238 xQueueGenericSend
/var/tmp//ccAqzzhG.s:3631   .text:0000000000000180 xQueueGiveMutexRecursive
/var/tmp//ccAqzzhG.s:3691   .text:00000000000001d8 xQueueTakeMutexRecursive
/var/tmp//ccAqzzhG.s:4026   .text:00000000000003f0 xQueueGenericReceive
/var/tmp//ccAqzzhG.s:4553   .text:00000000000006dc prvCopyDataToQueue
/var/tmp//ccAqzzhG.s:4924   .text:00000000000008e8 prvIsQueueFull
/var/tmp//ccAqzzhG.s:4741   .text:00000000000007f8 prvUnlockQueue
/var/tmp//ccAqzzhG.s:3922   .text:0000000000000358 xQueueGenericSendFromISR
/var/tmp//ccAqzzhG.s:4682   .text:00000000000007a8 prvCopyDataFromQueue
/var/tmp//ccAqzzhG.s:4851   .text:0000000000000898 prvIsQueueEmpty
/var/tmp//ccAqzzhG.s:4259   .text:0000000000000580 xQueueReceiveFromISR
/var/tmp//ccAqzzhG.s:4365   .text:000000000000061c uxQueueMessagesWaiting
/var/tmp//ccAqzzhG.s:4399   .text:0000000000000640 uxQueueMessagesWaitingFromISR
/var/tmp//ccAqzzhG.s:4431   .text:000000000000065c vQueueDelete
/var/tmp//ccAqzzhG.s:5065   .text:00000000000009a4 vQueueUnregisterQueue
/var/tmp//ccAqzzhG.s:4465   .text:0000000000000684 ucQueueGetQueueNumber
/var/tmp//ccAqzzhG.s:4494   .text:00000000000006a0 vQueueSetQueueNumber
/var/tmp//ccAqzzhG.s:4525   .text:00000000000006c0 ucQueueGetQueueType
/var/tmp//ccAqzzhG.s:4889   .text:00000000000008c4 xQueueIsQueueEmptyFromISR
/var/tmp//ccAqzzhG.s:4964   .text:0000000000000918 xQueueIsQueueFullFromISR
/var/tmp//ccAqzzhG.s:5002   .text:0000000000000940 vQueueAddToRegistry
/var/tmp//ccAqzzhG.s:5131   .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
pvPortMalloc
vListInitialise
vPortFree
xTaskGetCurrentTaskHandle
vPortEnterCritical
xTaskRemoveFromEventList
vPortYieldFromISR
vPortExitCritical
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vTaskPriorityInherit
vTaskPriorityDisinherit
memcpy
vTaskMissedYield
