   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"tasks.c"
  23              	.Ltext0:
  24              		.file 1 "../3rdParty/FreeRTOS/tasks.c"
 3847              		.align	2
 3850              	pxCurrentTCB:
 3851 0000 00000000 		.space	4
 3852              		.align	2
 3853              	pxReadyTasksLists:
 3854 0004 00000000 		.space	100
 3854      00000000 
 3854      00000000 
 3854      00000000 
 3854      00000000 
 3855              		.align	2
 3856              	xDelayedTaskList1:
 3857 0068 00000000 		.space	20
 3857      00000000 
 3857      00000000 
 3857      00000000 
 3857      00000000 
 3858              		.align	2
 3859              	xDelayedTaskList2:
 3860 007c 00000000 		.space	20
 3860      00000000 
 3860      00000000 
 3860      00000000 
 3860      00000000 
 3861              		.align	2
 3862              	pxDelayedTaskList:
 3863 0090 00000000 		.space	4
 3864              		.align	2
 3865              	pxOverflowDelayedTaskList:
 3866 0094 00000000 		.space	4
 3867              		.align	2
 3868              	xPendingReadyList:
 3869 0098 00000000 		.space	20
 3869      00000000 
 3869      00000000 
 3869      00000000 
 3869      00000000 
 3870              		.align	2
 3871              	xTasksWaitingTermination:
 3872 00ac 00000000 		.space	20
 3872      00000000 
 3872      00000000 
 3872      00000000 
 3872      00000000 
 3873              		.align	2
 3874              	uxTasksDeleted:
 3875 00c0 00000000 		.space	4
 3876              		.align	2
 3877              	xSuspendedTaskList:
 3878 00c4 00000000 		.space	20
 3878      00000000 
 3878      00000000 
 3878      00000000 
 3878      00000000 
 3879              		.align	2
 3880              	uxCurrentNumberOfTasks:
 3881 00d8 00000000 		.space	4
 3882              		.align	2
 3883              	xTickCount:
 3884 00dc 00000000 		.space	4
 3885              		.align	2
 3886              	uxTopUsedPriority:
 3887 00e0 00000000 		.space	4
 3888              		.align	2
 3889              	uxTopReadyPriority:
 3890 00e4 00000000 		.space	4
 3891              		.align	2
 3892              	xSchedulerRunning:
 3893 00e8 00000000 		.space	4
 3894              		.align	2
 3895              	uxSchedulerSuspended:
 3896 00ec 00000000 		.space	4
 3897              		.align	2
 3898              	uxMissedTicks:
 3899 00f0 00000000 		.space	4
 3900              		.align	2
 3901              	xMissedYield:
 3902 00f4 00000000 		.space	4
 3903              		.align	2
 3904              	xNumOfOverflows:
 3905 00f8 00000000 		.space	4
 3906              		.align	2
 3907              	uxTCBNumber:
 3908 00fc 00000000 		.space	4
 3909              		.data
 3910              		.align	2
 3913              	xNextTaskUnblockTime:
 3914 0000 FFFFFFFF 		.word	-1
 3915              		.bss
 3916              		.align	2
 3917              	pcStatsString:
 3918 0100 00000000 		.space	50
 3918      00000000 
 3918      00000000 
 3918      00000000 
 3918      00000000 
 3919 0132 0000     		.align	2
 3920              	ulTaskSwitchedInTime:
 3921 0134 00000000 		.space	4
 3922              		.text
 3923              		.align	2
 3924              		.global	xTaskGenericCreate
 3925              		.thumb
 3926              		.thumb_func
 3928              	xTaskGenericCreate:
 3929              	.LFB55:
   1:../3rdParty/FreeRTOS/tasks.c **** /*
   2:../3rdParty/FreeRTOS/tasks.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../3rdParty/FreeRTOS/tasks.c **** 	
   4:../3rdParty/FreeRTOS/tasks.c **** 
   5:../3rdParty/FreeRTOS/tasks.c ****     ***************************************************************************
   6:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
   7:../3rdParty/FreeRTOS/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../3rdParty/FreeRTOS/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../3rdParty/FreeRTOS/tasks.c ****      *    available.                                                         *
  10:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
  11:../3rdParty/FreeRTOS/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../3rdParty/FreeRTOS/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../3rdParty/FreeRTOS/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../3rdParty/FreeRTOS/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../3rdParty/FreeRTOS/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../3rdParty/FreeRTOS/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
  18:../3rdParty/FreeRTOS/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
  20:../3rdParty/FreeRTOS/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
  22:../3rdParty/FreeRTOS/tasks.c ****     ***************************************************************************
  23:../3rdParty/FreeRTOS/tasks.c **** 
  24:../3rdParty/FreeRTOS/tasks.c **** 
  25:../3rdParty/FreeRTOS/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:../3rdParty/FreeRTOS/tasks.c **** 
  27:../3rdParty/FreeRTOS/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../3rdParty/FreeRTOS/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../3rdParty/FreeRTOS/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../3rdParty/FreeRTOS/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../3rdParty/FreeRTOS/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../3rdParty/FreeRTOS/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../3rdParty/FreeRTOS/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../3rdParty/FreeRTOS/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../3rdParty/FreeRTOS/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../3rdParty/FreeRTOS/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:../3rdParty/FreeRTOS/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../3rdParty/FreeRTOS/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../3rdParty/FreeRTOS/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../3rdParty/FreeRTOS/tasks.c ****     FreeRTOS WEB site.
  41:../3rdParty/FreeRTOS/tasks.c **** 
  42:../3rdParty/FreeRTOS/tasks.c ****     1 tab == 4 spaces!
  43:../3rdParty/FreeRTOS/tasks.c **** 
  44:../3rdParty/FreeRTOS/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../3rdParty/FreeRTOS/tasks.c ****     contact details.
  46:../3rdParty/FreeRTOS/tasks.c **** 
  47:../3rdParty/FreeRTOS/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../3rdParty/FreeRTOS/tasks.c ****     critical systems.
  49:../3rdParty/FreeRTOS/tasks.c **** 
  50:../3rdParty/FreeRTOS/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../3rdParty/FreeRTOS/tasks.c ****     licensing and training services.
  52:../3rdParty/FreeRTOS/tasks.c **** */
  53:../3rdParty/FreeRTOS/tasks.c **** 
  54:../3rdParty/FreeRTOS/tasks.c **** 
  55:../3rdParty/FreeRTOS/tasks.c **** #include <stdio.h>
  56:../3rdParty/FreeRTOS/tasks.c **** #include <stdlib.h>
  57:../3rdParty/FreeRTOS/tasks.c **** #include <string.h>
  58:../3rdParty/FreeRTOS/tasks.c **** 
  59:../3rdParty/FreeRTOS/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:../3rdParty/FreeRTOS/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:../3rdParty/FreeRTOS/tasks.c **** task.h is included from an application file. */
  62:../3rdParty/FreeRTOS/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:../3rdParty/FreeRTOS/tasks.c **** 
  64:../3rdParty/FreeRTOS/tasks.c **** #include "FreeRTOS.h"
  65:../3rdParty/FreeRTOS/tasks.c **** #include "task.h"
  66:../3rdParty/FreeRTOS/tasks.c **** #include "timers.h"
  67:../3rdParty/FreeRTOS/tasks.c **** #include "StackMacros.h"
  68:../3rdParty/FreeRTOS/tasks.c **** 
  69:../3rdParty/FreeRTOS/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../3rdParty/FreeRTOS/tasks.c **** 
  71:../3rdParty/FreeRTOS/tasks.c **** /*
  72:../3rdParty/FreeRTOS/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  73:../3rdParty/FreeRTOS/tasks.c ****  */
  74:../3rdParty/FreeRTOS/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  75:../3rdParty/FreeRTOS/tasks.c **** 
  76:../3rdParty/FreeRTOS/tasks.c **** /*
  77:../3rdParty/FreeRTOS/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  78:../3rdParty/FreeRTOS/tasks.c ****  * and stores the context of the task.
  79:../3rdParty/FreeRTOS/tasks.c ****  */
  80:../3rdParty/FreeRTOS/tasks.c **** typedef struct tskTaskControlBlock
  81:../3rdParty/FreeRTOS/tasks.c **** {
  82:../3rdParty/FreeRTOS/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  83:../3rdParty/FreeRTOS/tasks.c **** 
  84:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  85:../3rdParty/FreeRTOS/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  86:../3rdParty/FreeRTOS/tasks.c **** 	#endif	
  87:../3rdParty/FreeRTOS/tasks.c **** 	
  88:../3rdParty/FreeRTOS/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  89:../3rdParty/FreeRTOS/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  90:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  91:../3rdParty/FreeRTOS/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  92:../3rdParty/FreeRTOS/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  93:../3rdParty/FreeRTOS/tasks.c **** 
  94:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  95:../3rdParty/FreeRTOS/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  96:../3rdParty/FreeRTOS/tasks.c **** 	#endif
  97:../3rdParty/FreeRTOS/tasks.c **** 
  98:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  99:../3rdParty/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 100:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 101:../3rdParty/FreeRTOS/tasks.c **** 
 102:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 103:../3rdParty/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This stores a number that increments each time a TCB is c
 104:../3rdParty/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< This stores a number specifically for use by third part
 105:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 106:../3rdParty/FreeRTOS/tasks.c **** 
 107:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 108:../3rdParty/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 109:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 110:../3rdParty/FreeRTOS/tasks.c **** 
 111:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 112:../3rdParty/FreeRTOS/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 113:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 114:../3rdParty/FreeRTOS/tasks.c **** 
 115:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 116:../3rdParty/FreeRTOS/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 117:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 118:../3rdParty/FreeRTOS/tasks.c **** 
 119:../3rdParty/FreeRTOS/tasks.c **** } tskTCB;
 120:../3rdParty/FreeRTOS/tasks.c **** 
 121:../3rdParty/FreeRTOS/tasks.c **** 
 122:../3rdParty/FreeRTOS/tasks.c **** /*
 123:../3rdParty/FreeRTOS/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 124:../3rdParty/FreeRTOS/tasks.c ****  * than file scope.
 125:../3rdParty/FreeRTOS/tasks.c ****  */
 126:../3rdParty/FreeRTOS/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 127:../3rdParty/FreeRTOS/tasks.c **** 	#define static
 128:../3rdParty/FreeRTOS/tasks.c **** #endif
 129:../3rdParty/FreeRTOS/tasks.c **** 
 130:../3rdParty/FreeRTOS/tasks.c **** /*lint -e956 */
 131:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 132:../3rdParty/FreeRTOS/tasks.c **** 
 133:../3rdParty/FreeRTOS/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 134:../3rdParty/FreeRTOS/tasks.c **** 
 135:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 136:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 137:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 138:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 139:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 140:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 141:../3rdParty/FreeRTOS/tasks.c **** 
 142:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 143:../3rdParty/FreeRTOS/tasks.c **** 
 144:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 145:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 146:../3rdParty/FreeRTOS/tasks.c **** 
 147:../3rdParty/FreeRTOS/tasks.c **** #endif
 148:../3rdParty/FreeRTOS/tasks.c **** 
 149:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 150:../3rdParty/FreeRTOS/tasks.c **** 
 151:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 152:../3rdParty/FreeRTOS/tasks.c **** 
 153:../3rdParty/FreeRTOS/tasks.c **** #endif
 154:../3rdParty/FreeRTOS/tasks.c **** 
 155:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 156:../3rdParty/FreeRTOS/tasks.c **** 	
 157:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
 158:../3rdParty/FreeRTOS/tasks.c **** 	
 159:../3rdParty/FreeRTOS/tasks.c **** #endif
 160:../3rdParty/FreeRTOS/tasks.c **** 
 161:../3rdParty/FreeRTOS/tasks.c **** /* File private variables. --------------------------------*/
 162:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 163:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 164:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 165:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 166:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 167:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 168:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 169:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 170:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 171:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTCBNumber 						= ( unsigned portBASE_TYPE ) 0U;
 172:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
 173:../3rdParty/FreeRTOS/tasks.c **** 
 174:../3rdParty/FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 175:../3rdParty/FreeRTOS/tasks.c **** 
 176:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 177:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 178:../3rdParty/FreeRTOS/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 179:../3rdParty/FreeRTOS/tasks.c **** 
 180:../3rdParty/FreeRTOS/tasks.c **** #endif
 181:../3rdParty/FreeRTOS/tasks.c **** 
 182:../3rdParty/FreeRTOS/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 183:../3rdParty/FreeRTOS/tasks.c **** 
 184:../3rdParty/FreeRTOS/tasks.c **** /*
 185:../3rdParty/FreeRTOS/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 186:../3rdParty/FreeRTOS/tasks.c ****  * is used purely for checking the high water mark for tasks.
 187:../3rdParty/FreeRTOS/tasks.c ****  */
 188:../3rdParty/FreeRTOS/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 189:../3rdParty/FreeRTOS/tasks.c **** 
 190:../3rdParty/FreeRTOS/tasks.c **** /*
 191:../3rdParty/FreeRTOS/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 192:../3rdParty/FreeRTOS/tasks.c ****  */
 193:../3rdParty/FreeRTOS/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 194:../3rdParty/FreeRTOS/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 195:../3rdParty/FreeRTOS/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 196:../3rdParty/FreeRTOS/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 197:../3rdParty/FreeRTOS/tasks.c **** 
 198:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 199:../3rdParty/FreeRTOS/tasks.c **** 
 200:../3rdParty/FreeRTOS/tasks.c **** /*
 201:../3rdParty/FreeRTOS/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 202:../3rdParty/FreeRTOS/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 203:../3rdParty/FreeRTOS/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 204:../3rdParty/FreeRTOS/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 205:../3rdParty/FreeRTOS/tasks.c ****  * executing task has been rescheduled.
 206:../3rdParty/FreeRTOS/tasks.c ****  */
 207:../3rdParty/FreeRTOS/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																					\
 208:../3rdParty/FreeRTOS/tasks.c **** 	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
 209:../3rdParty/FreeRTOS/tasks.c **** 	{																													\
 210:../3rdParty/FreeRTOS/tasks.c **** 		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
 211:../3rdParty/FreeRTOS/tasks.c **** 	}																													\
 212:../3rdParty/FreeRTOS/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 213:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 214:../3rdParty/FreeRTOS/tasks.c **** 
 215:../3rdParty/FreeRTOS/tasks.c **** /*
 216:../3rdParty/FreeRTOS/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 217:../3rdParty/FreeRTOS/tasks.c ****  * any require waking.
 218:../3rdParty/FreeRTOS/tasks.c ****  *
 219:../3rdParty/FreeRTOS/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 220:../3rdParty/FreeRTOS/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 221:../3rdParty/FreeRTOS/tasks.c ****  * any further down the list.
 222:../3rdParty/FreeRTOS/tasks.c ****  */
 223:../3rdParty/FreeRTOS/tasks.c **** #define prvCheckDelayedTasks()															\
 224:../3rdParty/FreeRTOS/tasks.c **** {																						\
 225:../3rdParty/FreeRTOS/tasks.c **** portTickType xItemValue;																\
 226:../3rdParty/FreeRTOS/tasks.c **** 																						\
 227:../3rdParty/FreeRTOS/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 228:../3rdParty/FreeRTOS/tasks.c **** 	task referenced from the delayed tasks list? */										\
 229:../3rdParty/FreeRTOS/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 230:../3rdParty/FreeRTOS/tasks.c **** 	{																					\
 231:../3rdParty/FreeRTOS/tasks.c **** 		for( ;; )																		\
 232:../3rdParty/FreeRTOS/tasks.c **** 		{																				\
 233:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 234:../3rdParty/FreeRTOS/tasks.c **** 			{																			\
 235:../3rdParty/FreeRTOS/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 236:../3rdParty/FreeRTOS/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 237:../3rdParty/FreeRTOS/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 238:../3rdParty/FreeRTOS/tasks.c **** 				time through. */														\
 239:../3rdParty/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 240:../3rdParty/FreeRTOS/tasks.c **** 				break;																	\
 241:../3rdParty/FreeRTOS/tasks.c **** 			}																			\
 242:../3rdParty/FreeRTOS/tasks.c **** 			else																		\
 243:../3rdParty/FreeRTOS/tasks.c **** 			{																			\
 244:../3rdParty/FreeRTOS/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 245:../3rdParty/FreeRTOS/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 246:../3rdParty/FreeRTOS/tasks.c **** 				task at the head of the delayed list should be removed from				\
 247:../3rdParty/FreeRTOS/tasks.c **** 				the Blocked state. */													\
 248:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 249:../3rdParty/FreeRTOS/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 250:../3rdParty/FreeRTOS/tasks.c **** 																						\
 251:../3rdParty/FreeRTOS/tasks.c **** 				if( xTickCount < xItemValue )											\
 252:../3rdParty/FreeRTOS/tasks.c **** 				{																		\
 253:../3rdParty/FreeRTOS/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 254:../3rdParty/FreeRTOS/tasks.c **** 					value is the time at which the task at the head of the				\
 255:../3rdParty/FreeRTOS/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 256:../3rdParty/FreeRTOS/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 257:../3rdParty/FreeRTOS/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 258:../3rdParty/FreeRTOS/tasks.c **** 					break;																\
 259:../3rdParty/FreeRTOS/tasks.c **** 				}																		\
 260:../3rdParty/FreeRTOS/tasks.c **** 																						\
 261:../3rdParty/FreeRTOS/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 262:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );							\
 263:../3rdParty/FreeRTOS/tasks.c **** 																						\
 264:../3rdParty/FreeRTOS/tasks.c **** 				/* Is the task waiting on an event also? */								\
 265:../3rdParty/FreeRTOS/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 266:../3rdParty/FreeRTOS/tasks.c **** 				{																		\
 267:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );							\
 268:../3rdParty/FreeRTOS/tasks.c **** 				}																		\
 269:../3rdParty/FreeRTOS/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 270:../3rdParty/FreeRTOS/tasks.c **** 			}																			\
 271:../3rdParty/FreeRTOS/tasks.c **** 		}																				\
 272:../3rdParty/FreeRTOS/tasks.c **** 	}																					\
 273:../3rdParty/FreeRTOS/tasks.c **** }
 274:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 275:../3rdParty/FreeRTOS/tasks.c **** 
 276:../3rdParty/FreeRTOS/tasks.c **** /*
 277:../3rdParty/FreeRTOS/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 278:../3rdParty/FreeRTOS/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 279:../3rdParty/FreeRTOS/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 280:../3rdParty/FreeRTOS/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 281:../3rdParty/FreeRTOS/tasks.c ****  */
 282:../3rdParty/FreeRTOS/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 283:../3rdParty/FreeRTOS/tasks.c **** 
 284:../3rdParty/FreeRTOS/tasks.c **** /* Callback function prototypes. --------------------------*/
 285:../3rdParty/FreeRTOS/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
 286:../3rdParty/FreeRTOS/tasks.c **** //extern void vApplicationTickHook( void );
 287:../3rdParty/FreeRTOS/tasks.c **** 		
 288:../3rdParty/FreeRTOS/tasks.c **** /* File private functions. --------------------------------*/
 289:../3rdParty/FreeRTOS/tasks.c **** 
 290:../3rdParty/FreeRTOS/tasks.c **** /*
 291:../3rdParty/FreeRTOS/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 292:../3rdParty/FreeRTOS/tasks.c ****  * into the TCB structure.
 293:../3rdParty/FreeRTOS/tasks.c ****  */
 294:../3rdParty/FreeRTOS/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 295:../3rdParty/FreeRTOS/tasks.c **** 
 296:../3rdParty/FreeRTOS/tasks.c **** /*
 297:../3rdParty/FreeRTOS/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 298:../3rdParty/FreeRTOS/tasks.c ****  * automatically upon the creation of the first task.
 299:../3rdParty/FreeRTOS/tasks.c ****  */
 300:../3rdParty/FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 301:../3rdParty/FreeRTOS/tasks.c **** 
 302:../3rdParty/FreeRTOS/tasks.c **** /*
 303:../3rdParty/FreeRTOS/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 304:../3rdParty/FreeRTOS/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 305:../3rdParty/FreeRTOS/tasks.c ****  * creation of the first user task.
 306:../3rdParty/FreeRTOS/tasks.c ****  *
 307:../3rdParty/FreeRTOS/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 308:../3rdParty/FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 309:../3rdParty/FreeRTOS/tasks.c ****  *
 310:../3rdParty/FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
 311:../3rdParty/FreeRTOS/tasks.c ****  *
 312:../3rdParty/FreeRTOS/tasks.c ****  */
 313:../3rdParty/FreeRTOS/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 314:../3rdParty/FreeRTOS/tasks.c **** 
 315:../3rdParty/FreeRTOS/tasks.c **** /*
 316:../3rdParty/FreeRTOS/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 317:../3rdParty/FreeRTOS/tasks.c ****  * including the stack pointed to by the TCB.
 318:../3rdParty/FreeRTOS/tasks.c ****  *
 319:../3rdParty/FreeRTOS/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 320:../3rdParty/FreeRTOS/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 321:../3rdParty/FreeRTOS/tasks.c ****  */
 322:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 323:../3rdParty/FreeRTOS/tasks.c **** 
 324:../3rdParty/FreeRTOS/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 325:../3rdParty/FreeRTOS/tasks.c **** 
 326:../3rdParty/FreeRTOS/tasks.c **** #endif
 327:../3rdParty/FreeRTOS/tasks.c **** 
 328:../3rdParty/FreeRTOS/tasks.c **** /*
 329:../3rdParty/FreeRTOS/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 330:../3rdParty/FreeRTOS/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 331:../3rdParty/FreeRTOS/tasks.c ****  * and its TCB deleted.
 332:../3rdParty/FreeRTOS/tasks.c ****  */
 333:../3rdParty/FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 334:../3rdParty/FreeRTOS/tasks.c **** 
 335:../3rdParty/FreeRTOS/tasks.c **** /*
 336:../3rdParty/FreeRTOS/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 337:../3rdParty/FreeRTOS/tasks.c ****  * either the current or the overflow delayed task list.
 338:../3rdParty/FreeRTOS/tasks.c ****  */
 339:../3rdParty/FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 340:../3rdParty/FreeRTOS/tasks.c **** 
 341:../3rdParty/FreeRTOS/tasks.c **** /*
 342:../3rdParty/FreeRTOS/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 343:../3rdParty/FreeRTOS/tasks.c ****  * allocation was successful.
 344:../3rdParty/FreeRTOS/tasks.c ****  */
 345:../3rdParty/FreeRTOS/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 346:../3rdParty/FreeRTOS/tasks.c **** 
 347:../3rdParty/FreeRTOS/tasks.c **** /*
 348:../3rdParty/FreeRTOS/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 349:../3rdParty/FreeRTOS/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 350:../3rdParty/FreeRTOS/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 351:../3rdParty/FreeRTOS/tasks.c ****  * within just that list.
 352:../3rdParty/FreeRTOS/tasks.c ****  *
 353:../3rdParty/FreeRTOS/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 354:../3rdParty/FreeRTOS/tasks.c ****  * NORMAL APPLICATION CODE.
 355:../3rdParty/FreeRTOS/tasks.c ****  */
 356:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 357:../3rdParty/FreeRTOS/tasks.c **** 
 358:../3rdParty/FreeRTOS/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 359:../3rdParty/FreeRTOS/tasks.c **** 
 360:../3rdParty/FreeRTOS/tasks.c **** #endif
 361:../3rdParty/FreeRTOS/tasks.c **** 
 362:../3rdParty/FreeRTOS/tasks.c **** /*
 363:../3rdParty/FreeRTOS/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 364:../3rdParty/FreeRTOS/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 365:../3rdParty/FreeRTOS/tasks.c ****  * determining how much of the stack remains at the original preset value.
 366:../3rdParty/FreeRTOS/tasks.c ****  */
 367:../3rdParty/FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 368:../3rdParty/FreeRTOS/tasks.c **** 
 369:../3rdParty/FreeRTOS/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 370:../3rdParty/FreeRTOS/tasks.c **** 
 371:../3rdParty/FreeRTOS/tasks.c **** #endif
 372:../3rdParty/FreeRTOS/tasks.c **** 
 373:../3rdParty/FreeRTOS/tasks.c **** 
 374:../3rdParty/FreeRTOS/tasks.c **** /*lint +e956 */
 375:../3rdParty/FreeRTOS/tasks.c **** 
 376:../3rdParty/FreeRTOS/tasks.c **** 
 377:../3rdParty/FreeRTOS/tasks.c **** 
 378:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
 379:../3rdParty/FreeRTOS/tasks.c ****  * TASK CREATION API documented in task.h
 380:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
 381:../3rdParty/FreeRTOS/tasks.c **** 
 382:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 383:../3rdParty/FreeRTOS/tasks.c **** {
 3930              		.loc 1 383 0
 3931              		@ args = 16, pretend = 0, frame = 32
 3932              		@ frame_needed = 1, uses_anonymous_args = 0
 3933 0000 80B5     		push	{r7, lr}
 3934              	.LCFI0:
 3935 0002 8AB0     		sub	sp, sp, #40
 3936              	.LCFI1:
 3937 0004 02AF     		add	r7, sp, #8
 3938              	.LCFI2:
 3939 0006 F860     		str	r0, [r7, #12]
 3940 0008 B960     		str	r1, [r7, #8]
 3941 000a 3B60     		str	r3, [r7, #0]
 3942 000c 1346     		mov	r3, r2	@ movhi
 3943 000e FB80     		strh	r3, [r7, #6]	@ movhi
 384:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xReturn;
 385:../3rdParty/FreeRTOS/tasks.c **** tskTCB * pxNewTCB;
 386:../3rdParty/FreeRTOS/tasks.c **** 
 387:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxTaskCode );
 388:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
 389:../3rdParty/FreeRTOS/tasks.c **** 
 390:../3rdParty/FreeRTOS/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 391:../3rdParty/FreeRTOS/tasks.c **** 	checking that the allocation was successful. */
 392:../3rdParty/FreeRTOS/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 3944              		.loc 1 392 0
 3945 0010 FB88     		ldrh	r3, [r7, #6]
 3946 0012 1846     		mov	r0, r3
 3947 0014 396B     		ldr	r1, [r7, #48]
 3948 0016 01F04DFA 		bl	prvAllocateTCBAndStack
 3949 001a 0346     		mov	r3, r0
 3950 001c BB61     		str	r3, [r7, #24]
 393:../3rdParty/FreeRTOS/tasks.c **** 
 394:../3rdParty/FreeRTOS/tasks.c **** 	if( pxNewTCB != NULL )
 3951              		.loc 1 394 0
 3952 001e BB69     		ldr	r3, [r7, #24]
 3953 0020 002B     		cmp	r3, #0
 3954 0022 00F0AF80 		beq	.L2
 3955              	.LBB2:
 395:../3rdParty/FreeRTOS/tasks.c **** 	{
 396:../3rdParty/FreeRTOS/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 397:../3rdParty/FreeRTOS/tasks.c **** 
 398:../3rdParty/FreeRTOS/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 399:../3rdParty/FreeRTOS/tasks.c **** 			/* Should the task be created in privileged mode? */
 400:../3rdParty/FreeRTOS/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 401:../3rdParty/FreeRTOS/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 402:../3rdParty/FreeRTOS/tasks.c **** 			{
 403:../3rdParty/FreeRTOS/tasks.c **** 				xRunPrivileged = pdTRUE;
 404:../3rdParty/FreeRTOS/tasks.c **** 			}
 405:../3rdParty/FreeRTOS/tasks.c **** 			else
 406:../3rdParty/FreeRTOS/tasks.c **** 			{
 407:../3rdParty/FreeRTOS/tasks.c **** 				xRunPrivileged = pdFALSE;
 408:../3rdParty/FreeRTOS/tasks.c **** 			}
 409:../3rdParty/FreeRTOS/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 410:../3rdParty/FreeRTOS/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 411:../3rdParty/FreeRTOS/tasks.c **** 
 412:../3rdParty/FreeRTOS/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 413:../3rdParty/FreeRTOS/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 414:../3rdParty/FreeRTOS/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 415:../3rdParty/FreeRTOS/tasks.c **** 		required by the port. */
 416:../3rdParty/FreeRTOS/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 417:../3rdParty/FreeRTOS/tasks.c **** 		{
 418:../3rdParty/FreeRTOS/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 3956              		.loc 1 418 0
 3957 0026 BB69     		ldr	r3, [r7, #24]
 3958 0028 1A6B     		ldr	r2, [r3, #48]
 3959 002a FB88     		ldrh	r3, [r7, #6]
 3960 002c 03F1FF33 		add	r3, r3, #-1
 3961 0030 4FEA8303 		lsl	r3, r3, #2
 3962 0034 1344     		add	r3, r2, r3
 3963 0036 FB61     		str	r3, [r7, #28]
 419:../3rdParty/FreeRTOS/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 3964              		.loc 1 419 0
 3965 0038 FB69     		ldr	r3, [r7, #28]
 3966 003a 23F00703 		bic	r3, r3, #7
 3967 003e FB61     		str	r3, [r7, #28]
 420:../3rdParty/FreeRTOS/tasks.c **** 
 421:../3rdParty/FreeRTOS/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 422:../3rdParty/FreeRTOS/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 423:../3rdParty/FreeRTOS/tasks.c **** 		}
 424:../3rdParty/FreeRTOS/tasks.c **** 		#else
 425:../3rdParty/FreeRTOS/tasks.c **** 		{
 426:../3rdParty/FreeRTOS/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 427:../3rdParty/FreeRTOS/tasks.c **** 			
 428:../3rdParty/FreeRTOS/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 429:../3rdParty/FreeRTOS/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 430:../3rdParty/FreeRTOS/tasks.c **** 
 431:../3rdParty/FreeRTOS/tasks.c **** 			/* If we want to use stack checking on architectures that use
 432:../3rdParty/FreeRTOS/tasks.c **** 			a positive stack growth direction then we also need to store the
 433:../3rdParty/FreeRTOS/tasks.c **** 			other extreme of the stack space. */
 434:../3rdParty/FreeRTOS/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 435:../3rdParty/FreeRTOS/tasks.c **** 		}
 436:../3rdParty/FreeRTOS/tasks.c **** 		#endif
 437:../3rdParty/FreeRTOS/tasks.c **** 
 438:../3rdParty/FreeRTOS/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 439:../3rdParty/FreeRTOS/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 3968              		.loc 1 439 0
 3969 0040 FB88     		ldrh	r3, [r7, #6]
 3970 0042 0093     		str	r3, [sp, #0]
 3971 0044 B869     		ldr	r0, [r7, #24]
 3972 0046 B968     		ldr	r1, [r7, #8]
 3973 0048 BA6A     		ldr	r2, [r7, #40]
 3974 004a 7B6B     		ldr	r3, [r7, #52]
 3975 004c 01F00CF9 		bl	prvInitialiseTCBVariables
 440:../3rdParty/FreeRTOS/tasks.c **** 
 441:../3rdParty/FreeRTOS/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 442:../3rdParty/FreeRTOS/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 443:../3rdParty/FreeRTOS/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 444:../3rdParty/FreeRTOS/tasks.c **** 		the	top of stack variable is updated. */
 445:../3rdParty/FreeRTOS/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 446:../3rdParty/FreeRTOS/tasks.c **** 		{
 447:../3rdParty/FreeRTOS/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 448:../3rdParty/FreeRTOS/tasks.c **** 		}
 449:../3rdParty/FreeRTOS/tasks.c **** 		#else
 450:../3rdParty/FreeRTOS/tasks.c **** 		{
 451:../3rdParty/FreeRTOS/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 3976              		.loc 1 451 0
 3977 0050 F869     		ldr	r0, [r7, #28]
 3978 0052 F968     		ldr	r1, [r7, #12]
 3979 0054 3A68     		ldr	r2, [r7, #0]
 3980 0056 FFF7FEFF 		bl	pxPortInitialiseStack
 3981 005a 0346     		mov	r3, r0
 3982 005c 1A46     		mov	r2, r3
 3983 005e BB69     		ldr	r3, [r7, #24]
 3984 0060 1A60     		str	r2, [r3, #0]
 452:../3rdParty/FreeRTOS/tasks.c **** 		}
 453:../3rdParty/FreeRTOS/tasks.c **** 		#endif
 454:../3rdParty/FreeRTOS/tasks.c **** 
 455:../3rdParty/FreeRTOS/tasks.c **** 		/* Check the alignment of the initialised stack. */
 456:../3rdParty/FreeRTOS/tasks.c **** 		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long
 457:../3rdParty/FreeRTOS/tasks.c **** 
 458:../3rdParty/FreeRTOS/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 3985              		.loc 1 458 0
 3986 0062 FB6A     		ldr	r3, [r7, #44]
 3987 0064 002B     		cmp	r3, #0
 3988 0066 02D0     		beq	.L3
 459:../3rdParty/FreeRTOS/tasks.c **** 		{
 460:../3rdParty/FreeRTOS/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 461:../3rdParty/FreeRTOS/tasks.c **** 			task can use this as a handle to delete the task later if
 462:../3rdParty/FreeRTOS/tasks.c **** 			required.*/
 463:../3rdParty/FreeRTOS/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 3989              		.loc 1 463 0
 3990 0068 FB6A     		ldr	r3, [r7, #44]
 3991 006a BA69     		ldr	r2, [r7, #24]
 3992 006c 1A60     		str	r2, [r3, #0]
 3993              	.L3:
 464:../3rdParty/FreeRTOS/tasks.c **** 		}
 465:../3rdParty/FreeRTOS/tasks.c **** 		
 466:../3rdParty/FreeRTOS/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 467:../3rdParty/FreeRTOS/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 468:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 3994              		.loc 1 468 0
 3995 006e FFF7FEFF 		bl	vPortEnterCritical
 469:../3rdParty/FreeRTOS/tasks.c **** 		{
 470:../3rdParty/FreeRTOS/tasks.c **** 			uxCurrentNumberOfTasks++;
 3996              		.loc 1 470 0
 3997 0072 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 3998 0076 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 3999 007a 1B68     		ldr	r3, [r3, #0]
 4000 007c 03F10102 		add	r2, r3, #1
 4001 0080 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 4002 0084 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 4003 0088 1A60     		str	r2, [r3, #0]
 471:../3rdParty/FreeRTOS/tasks.c **** 			if( pxCurrentTCB == NULL )
 4004              		.loc 1 471 0
 4005 008a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4006 008e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4007 0092 1B68     		ldr	r3, [r3, #0]
 4008 0094 002B     		cmp	r3, #0
 4009 0096 0FD1     		bne	.L4
 472:../3rdParty/FreeRTOS/tasks.c **** 			{
 473:../3rdParty/FreeRTOS/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 474:../3rdParty/FreeRTOS/tasks.c **** 				the suspended state - make this the current task. */
 475:../3rdParty/FreeRTOS/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 4010              		.loc 1 475 0
 4011 0098 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4012 009c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4013 00a0 BA69     		ldr	r2, [r7, #24]
 4014 00a2 1A60     		str	r2, [r3, #0]
 476:../3rdParty/FreeRTOS/tasks.c **** 
 477:../3rdParty/FreeRTOS/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 4015              		.loc 1 477 0
 4016 00a4 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 4017 00a8 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 4018 00ac 1B68     		ldr	r3, [r3, #0]
 4019 00ae 012B     		cmp	r3, #1
 4020 00b0 19D1     		bne	.L12
 478:../3rdParty/FreeRTOS/tasks.c **** 				{
 479:../3rdParty/FreeRTOS/tasks.c **** 					/* This is the first task to be created so do the preliminary
 480:../3rdParty/FreeRTOS/tasks.c **** 					initialisation required.  We will not recover if this call
 481:../3rdParty/FreeRTOS/tasks.c **** 					fails, but we will report the failure. */
 482:../3rdParty/FreeRTOS/tasks.c **** 					prvInitialiseTaskLists();
 4021              		.loc 1 482 0
 4022 00b2 01F01BF9 		bl	prvInitialiseTaskLists
 4023 00b6 17E0     		b	.L6
 4024              	.L4:
 483:../3rdParty/FreeRTOS/tasks.c **** 				}
 484:../3rdParty/FreeRTOS/tasks.c **** 			}
 485:../3rdParty/FreeRTOS/tasks.c **** 			else
 486:../3rdParty/FreeRTOS/tasks.c **** 			{
 487:../3rdParty/FreeRTOS/tasks.c **** 				/* If the scheduler is not already running, make this task the
 488:../3rdParty/FreeRTOS/tasks.c **** 				current task if it is the highest priority task to be created
 489:../3rdParty/FreeRTOS/tasks.c **** 				so far. */
 490:../3rdParty/FreeRTOS/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 4025              		.loc 1 490 0
 4026 00b8 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 4027 00bc C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 4028 00c0 1B68     		ldr	r3, [r3, #0]
 4029 00c2 002B     		cmp	r3, #0
 4030 00c4 10D1     		bne	.L6
 491:../3rdParty/FreeRTOS/tasks.c **** 				{
 492:../3rdParty/FreeRTOS/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 4031              		.loc 1 492 0
 4032 00c6 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4033 00ca C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4034 00ce 1B68     		ldr	r3, [r3, #0]
 4035 00d0 DA6A     		ldr	r2, [r3, #44]
 4036 00d2 BB6A     		ldr	r3, [r7, #40]
 4037 00d4 9A42     		cmp	r2, r3
 4038 00d6 07D8     		bhi	.L6
 493:../3rdParty/FreeRTOS/tasks.c **** 					{
 494:../3rdParty/FreeRTOS/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 4039              		.loc 1 494 0
 4040 00d8 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4041 00dc C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4042 00e0 BA69     		ldr	r2, [r7, #24]
 4043 00e2 1A60     		str	r2, [r3, #0]
 4044 00e4 00E0     		b	.L6
 4045              	.L12:
 4046              		.loc 1 482 0
 4047 00e6 00BF     		nop
 4048              	.L6:
 495:../3rdParty/FreeRTOS/tasks.c **** 					}
 496:../3rdParty/FreeRTOS/tasks.c **** 				}
 497:../3rdParty/FreeRTOS/tasks.c **** 			}
 498:../3rdParty/FreeRTOS/tasks.c **** 
 499:../3rdParty/FreeRTOS/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 500:../3rdParty/FreeRTOS/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 501:../3rdParty/FreeRTOS/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 4049              		.loc 1 501 0
 4050 00e8 BB69     		ldr	r3, [r7, #24]
 4051 00ea DA6A     		ldr	r2, [r3, #44]
 4052 00ec 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 4053 00f0 C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 4054 00f4 1B68     		ldr	r3, [r3, #0]
 4055 00f6 9A42     		cmp	r2, r3
 4056 00f8 06D9     		bls	.L7
 502:../3rdParty/FreeRTOS/tasks.c **** 			{
 503:../3rdParty/FreeRTOS/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 4057              		.loc 1 503 0
 4058 00fa BB69     		ldr	r3, [r7, #24]
 4059 00fc DA6A     		ldr	r2, [r3, #44]
 4060 00fe 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 4061 0102 C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 4062 0106 1A60     		str	r2, [r3, #0]
 4063              	.L7:
 504:../3rdParty/FreeRTOS/tasks.c **** 			}
 505:../3rdParty/FreeRTOS/tasks.c **** 
 506:../3rdParty/FreeRTOS/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 507:../3rdParty/FreeRTOS/tasks.c **** 			{
 508:../3rdParty/FreeRTOS/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 509:../3rdParty/FreeRTOS/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTCBNumber;
 4064              		.loc 1 509 0
 4065 0108 40F20003 		movw	r3, #:lower16:uxTCBNumber
 4066 010c C0F20003 		movt	r3, #:upper16:uxTCBNumber
 4067 0110 1A68     		ldr	r2, [r3, #0]
 4068 0112 BB69     		ldr	r3, [r7, #24]
 4069 0114 1A64     		str	r2, [r3, #64]
 510:../3rdParty/FreeRTOS/tasks.c **** 			}
 511:../3rdParty/FreeRTOS/tasks.c **** 			#endif
 512:../3rdParty/FreeRTOS/tasks.c **** 			uxTCBNumber++;
 4070              		.loc 1 512 0
 4071 0116 40F20003 		movw	r3, #:lower16:uxTCBNumber
 4072 011a C0F20003 		movt	r3, #:upper16:uxTCBNumber
 4073 011e 1B68     		ldr	r3, [r3, #0]
 4074 0120 03F10102 		add	r2, r3, #1
 4075 0124 40F20003 		movw	r3, #:lower16:uxTCBNumber
 4076 0128 C0F20003 		movt	r3, #:upper16:uxTCBNumber
 4077 012c 1A60     		str	r2, [r3, #0]
 513:../3rdParty/FreeRTOS/tasks.c **** 
 514:../3rdParty/FreeRTOS/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 4078              		.loc 1 514 0
 4079 012e BB69     		ldr	r3, [r7, #24]
 4080 0130 DA6A     		ldr	r2, [r3, #44]
 4081 0132 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4082 0136 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4083 013a 1B68     		ldr	r3, [r3, #0]
 4084 013c 9A42     		cmp	r2, r3
 4085 013e 06D9     		bls	.L8
 4086 0140 BB69     		ldr	r3, [r7, #24]
 4087 0142 DA6A     		ldr	r2, [r3, #44]
 4088 0144 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4089 0148 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4090 014c 1A60     		str	r2, [r3, #0]
 4091              	.L8:
 4092 014e BB69     		ldr	r3, [r7, #24]
 4093 0150 DA6A     		ldr	r2, [r3, #44]
 4094 0152 1346     		mov	r3, r2
 4095 0154 4FEA8303 		lsl	r3, r3, #2
 4096 0158 1344     		add	r3, r3, r2
 4097 015a 4FEA8303 		lsl	r3, r3, #2
 4098 015e 1A46     		mov	r2, r3
 4099 0160 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 4100 0164 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 4101 0168 1A44     		add	r2, r2, r3
 4102 016a BB69     		ldr	r3, [r7, #24]
 4103 016c 03F10403 		add	r3, r3, #4
 4104 0170 1046     		mov	r0, r2
 4105 0172 1946     		mov	r1, r3
 4106 0174 FFF7FEFF 		bl	vListInsertEnd
 515:../3rdParty/FreeRTOS/tasks.c **** 
 516:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdPASS;
 4107              		.loc 1 516 0
 4108 0178 4FF00103 		mov	r3, #1
 4109 017c 7B61     		str	r3, [r7, #20]
 517:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 518:../3rdParty/FreeRTOS/tasks.c **** 		}
 519:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 4110              		.loc 1 519 0
 4111 017e FFF7FEFF 		bl	vPortExitCritical
 4112 0182 02E0     		b	.L9
 4113              	.L2:
 4114              	.LBE2:
 520:../3rdParty/FreeRTOS/tasks.c **** 	}
 521:../3rdParty/FreeRTOS/tasks.c **** 	else
 522:../3rdParty/FreeRTOS/tasks.c **** 	{
 523:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 4115              		.loc 1 523 0
 4116 0184 4FF0FF33 		mov	r3, #-1
 4117 0188 7B61     		str	r3, [r7, #20]
 4118              	.L9:
 524:../3rdParty/FreeRTOS/tasks.c **** 		traceTASK_CREATE_FAILED();
 525:../3rdParty/FreeRTOS/tasks.c **** 	}
 526:../3rdParty/FreeRTOS/tasks.c **** 
 527:../3rdParty/FreeRTOS/tasks.c **** 	if( xReturn == pdPASS )
 4119              		.loc 1 527 0
 4120 018a 7B69     		ldr	r3, [r7, #20]
 4121 018c 012B     		cmp	r3, #1
 4122 018e 11D1     		bne	.L10
 528:../3rdParty/FreeRTOS/tasks.c **** 	{
 529:../3rdParty/FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 4123              		.loc 1 529 0
 4124 0190 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 4125 0194 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 4126 0198 1B68     		ldr	r3, [r3, #0]
 4127 019a 002B     		cmp	r3, #0
 4128 019c 0AD0     		beq	.L10
 530:../3rdParty/FreeRTOS/tasks.c **** 		{
 531:../3rdParty/FreeRTOS/tasks.c **** 			/* If the created task is of a higher priority than the current task
 532:../3rdParty/FreeRTOS/tasks.c **** 			then it should run now. */
 533:../3rdParty/FreeRTOS/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 4129              		.loc 1 533 0
 4130 019e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4131 01a2 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4132 01a6 1B68     		ldr	r3, [r3, #0]
 4133 01a8 DA6A     		ldr	r2, [r3, #44]
 4134 01aa BB6A     		ldr	r3, [r7, #40]
 4135 01ac 9A42     		cmp	r2, r3
 4136 01ae 01D2     		bcs	.L10
 534:../3rdParty/FreeRTOS/tasks.c **** 			{
 535:../3rdParty/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 4137              		.loc 1 535 0
 4138 01b0 FFF7FEFF 		bl	vPortYieldFromISR
 4139              	.L10:
 536:../3rdParty/FreeRTOS/tasks.c **** 			}
 537:../3rdParty/FreeRTOS/tasks.c **** 		}
 538:../3rdParty/FreeRTOS/tasks.c **** 	}
 539:../3rdParty/FreeRTOS/tasks.c **** 
 540:../3rdParty/FreeRTOS/tasks.c **** 	return xReturn;
 4140              		.loc 1 540 0
 4141 01b4 7B69     		ldr	r3, [r7, #20]
 541:../3rdParty/FreeRTOS/tasks.c **** }
 4142              		.loc 1 541 0
 4143 01b6 1846     		mov	r0, r3
 4144 01b8 07F12007 		add	r7, r7, #32
 4145 01bc BD46     		mov	sp, r7
 4146 01be 80BD     		pop	{r7, pc}
 4147              	.LFE55:
 4149              		.align	2
 4150              		.global	vTaskDelete
 4151              		.thumb
 4152              		.thumb_func
 4154              	vTaskDelete:
 4155              	.LFB56:
 542:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 543:../3rdParty/FreeRTOS/tasks.c **** 
 544:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 545:../3rdParty/FreeRTOS/tasks.c **** 
 546:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 547:../3rdParty/FreeRTOS/tasks.c **** 	{
 4156              		.loc 1 547 0
 4157              		@ args = 0, pretend = 0, frame = 16
 4158              		@ frame_needed = 1, uses_anonymous_args = 0
 4159 01c0 80B5     		push	{r7, lr}
 4160              	.LCFI3:
 4161 01c2 84B0     		sub	sp, sp, #16
 4162              	.LCFI4:
 4163 01c4 00AF     		add	r7, sp, #0
 4164              	.LCFI5:
 4165 01c6 7860     		str	r0, [r7, #4]
 548:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 549:../3rdParty/FreeRTOS/tasks.c **** 
 550:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 4166              		.loc 1 550 0
 4167 01c8 FFF7FEFF 		bl	vPortEnterCritical
 551:../3rdParty/FreeRTOS/tasks.c **** 		{
 552:../3rdParty/FreeRTOS/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 553:../3rdParty/FreeRTOS/tasks.c **** 			deleted. */
 554:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 4168              		.loc 1 554 0
 4169 01cc 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4170 01d0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4171 01d4 1B68     		ldr	r3, [r3, #0]
 4172 01d6 7A68     		ldr	r2, [r7, #4]
 4173 01d8 9A42     		cmp	r2, r3
 4174 01da 02D1     		bne	.L14
 555:../3rdParty/FreeRTOS/tasks.c **** 			{
 556:../3rdParty/FreeRTOS/tasks.c **** 				pxTaskToDelete = NULL;
 4175              		.loc 1 556 0
 4176 01dc 4FF00003 		mov	r3, #0
 4177 01e0 7B60     		str	r3, [r7, #4]
 4178              	.L14:
 557:../3rdParty/FreeRTOS/tasks.c **** 			}
 558:../3rdParty/FreeRTOS/tasks.c **** 
 559:../3rdParty/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 560:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 4179              		.loc 1 560 0
 4180 01e2 7B68     		ldr	r3, [r7, #4]
 4181 01e4 002B     		cmp	r3, #0
 4182 01e6 05D1     		bne	.L15
 4183 01e8 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4184 01ec C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4185 01f0 1B68     		ldr	r3, [r3, #0]
 4186 01f2 00E0     		b	.L16
 4187              	.L15:
 4188 01f4 7B68     		ldr	r3, [r7, #4]
 4189              	.L16:
 4190 01f6 FB60     		str	r3, [r7, #12]
 561:../3rdParty/FreeRTOS/tasks.c **** 
 562:../3rdParty/FreeRTOS/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 563:../3rdParty/FreeRTOS/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 564:../3rdParty/FreeRTOS/tasks.c **** 			the termination list and free up any memory allocated by the
 565:../3rdParty/FreeRTOS/tasks.c **** 			scheduler for the TCB and stack. */
 566:../3rdParty/FreeRTOS/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 4191              		.loc 1 566 0
 4192 01f8 FB68     		ldr	r3, [r7, #12]
 4193 01fa 03F10403 		add	r3, r3, #4
 4194 01fe 1846     		mov	r0, r3
 4195 0200 FFF7FEFF 		bl	vListRemove
 567:../3rdParty/FreeRTOS/tasks.c **** 
 568:../3rdParty/FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
 569:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 4196              		.loc 1 569 0
 4197 0204 FB68     		ldr	r3, [r7, #12]
 4198 0206 9B6A     		ldr	r3, [r3, #40]
 4199 0208 002B     		cmp	r3, #0
 4200 020a 05D0     		beq	.L17
 570:../3rdParty/FreeRTOS/tasks.c **** 			{
 571:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 4201              		.loc 1 571 0
 4202 020c FB68     		ldr	r3, [r7, #12]
 4203 020e 03F11803 		add	r3, r3, #24
 4204 0212 1846     		mov	r0, r3
 4205 0214 FFF7FEFF 		bl	vListRemove
 4206              	.L17:
 572:../3rdParty/FreeRTOS/tasks.c **** 			}
 573:../3rdParty/FreeRTOS/tasks.c **** 
 574:../3rdParty/FreeRTOS/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 4207              		.loc 1 574 0
 4208 0218 FB68     		ldr	r3, [r7, #12]
 4209 021a 03F10403 		add	r3, r3, #4
 4210 021e 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 4211 0222 C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 4212 0226 1946     		mov	r1, r3
 4213 0228 FFF7FEFF 		bl	vListInsertEnd
 575:../3rdParty/FreeRTOS/tasks.c **** 
 576:../3rdParty/FreeRTOS/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 577:../3rdParty/FreeRTOS/tasks.c **** 			there is a task that has been deleted and that it should therefore
 578:../3rdParty/FreeRTOS/tasks.c **** 			check the xTasksWaitingTermination list. */
 579:../3rdParty/FreeRTOS/tasks.c **** 			++uxTasksDeleted;
 4214              		.loc 1 579 0
 4215 022c 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 4216 0230 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 4217 0234 1B68     		ldr	r3, [r3, #0]
 4218 0236 03F10102 		add	r2, r3, #1
 4219 023a 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 4220 023e C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 4221 0242 1A60     		str	r2, [r3, #0]
 580:../3rdParty/FreeRTOS/tasks.c **** 
 581:../3rdParty/FreeRTOS/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 582:../3rdParty/FreeRTOS/tasks.c **** 			can detect that the task lists need re-generating. */
 583:../3rdParty/FreeRTOS/tasks.c **** 			uxTCBNumber++;
 4222              		.loc 1 583 0
 4223 0244 40F20003 		movw	r3, #:lower16:uxTCBNumber
 4224 0248 C0F20003 		movt	r3, #:upper16:uxTCBNumber
 4225 024c 1B68     		ldr	r3, [r3, #0]
 4226 024e 03F10102 		add	r2, r3, #1
 4227 0252 40F20003 		movw	r3, #:lower16:uxTCBNumber
 4228 0256 C0F20003 		movt	r3, #:upper16:uxTCBNumber
 4229 025a 1A60     		str	r2, [r3, #0]
 584:../3rdParty/FreeRTOS/tasks.c **** 
 585:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_DELETE( pxTCB );
 586:../3rdParty/FreeRTOS/tasks.c **** 		}
 587:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 4230              		.loc 1 587 0
 4231 025c FFF7FEFF 		bl	vPortExitCritical
 588:../3rdParty/FreeRTOS/tasks.c **** 
 589:../3rdParty/FreeRTOS/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 590:../3rdParty/FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 4232              		.loc 1 590 0
 4233 0260 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 4234 0264 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 4235 0268 1B68     		ldr	r3, [r3, #0]
 4236 026a 002B     		cmp	r3, #0
 4237 026c 04D0     		beq	.L19
 591:../3rdParty/FreeRTOS/tasks.c **** 		{
 592:../3rdParty/FreeRTOS/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 4238              		.loc 1 592 0
 4239 026e 7B68     		ldr	r3, [r7, #4]
 4240 0270 002B     		cmp	r3, #0
 4241 0272 01D1     		bne	.L19
 593:../3rdParty/FreeRTOS/tasks.c **** 			{
 594:../3rdParty/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 4242              		.loc 1 594 0
 4243 0274 FFF7FEFF 		bl	vPortYieldFromISR
 4244              	.L19:
 595:../3rdParty/FreeRTOS/tasks.c **** 			}
 596:../3rdParty/FreeRTOS/tasks.c **** 		}
 597:../3rdParty/FreeRTOS/tasks.c **** 	}
 4245              		.loc 1 597 0
 4246 0278 07F11007 		add	r7, r7, #16
 4247 027c BD46     		mov	sp, r7
 4248 027e 80BD     		pop	{r7, pc}
 4249              	.LFE56:
 4251              		.align	2
 4252              		.global	vTaskDelayUntil
 4253              		.thumb
 4254              		.thumb_func
 4256              	vTaskDelayUntil:
 4257              	.LFB57:
 598:../3rdParty/FreeRTOS/tasks.c **** 
 599:../3rdParty/FreeRTOS/tasks.c **** #endif
 600:../3rdParty/FreeRTOS/tasks.c **** 
 601:../3rdParty/FreeRTOS/tasks.c **** 
 602:../3rdParty/FreeRTOS/tasks.c **** 
 603:../3rdParty/FreeRTOS/tasks.c **** 
 604:../3rdParty/FreeRTOS/tasks.c **** 
 605:../3rdParty/FreeRTOS/tasks.c **** 
 606:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
 607:../3rdParty/FreeRTOS/tasks.c ****  * TASK CONTROL API documented in task.h
 608:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
 609:../3rdParty/FreeRTOS/tasks.c **** 
 610:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 611:../3rdParty/FreeRTOS/tasks.c **** 
 612:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 613:../3rdParty/FreeRTOS/tasks.c **** 	{
 4258              		.loc 1 613 0
 4259              		@ args = 0, pretend = 0, frame = 24
 4260              		@ frame_needed = 1, uses_anonymous_args = 0
 4261 0280 80B5     		push	{r7, lr}
 4262              	.LCFI6:
 4263 0282 86B0     		sub	sp, sp, #24
 4264              	.LCFI7:
 4265 0284 00AF     		add	r7, sp, #0
 4266              	.LCFI8:
 4267 0286 7860     		str	r0, [r7, #4]
 4268 0288 3960     		str	r1, [r7, #0]
 614:../3rdParty/FreeRTOS/tasks.c **** 	portTickType xTimeToWake;
 615:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 4269              		.loc 1 615 0
 4270 028a 4FF00003 		mov	r3, #0
 4271 028e 7B61     		str	r3, [r7, #20]
 616:../3rdParty/FreeRTOS/tasks.c **** 
 617:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 618:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 619:../3rdParty/FreeRTOS/tasks.c **** 
 620:../3rdParty/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
 4272              		.loc 1 620 0
 4273 0290 FFF7FEFF 		bl	vTaskSuspendAll
 621:../3rdParty/FreeRTOS/tasks.c **** 		{
 622:../3rdParty/FreeRTOS/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 623:../3rdParty/FreeRTOS/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 4274              		.loc 1 623 0
 4275 0294 7B68     		ldr	r3, [r7, #4]
 4276 0296 1A68     		ldr	r2, [r3, #0]
 4277 0298 3B68     		ldr	r3, [r7, #0]
 4278 029a 1344     		add	r3, r2, r3
 4279 029c FB60     		str	r3, [r7, #12]
 624:../3rdParty/FreeRTOS/tasks.c **** 
 625:../3rdParty/FreeRTOS/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 4280              		.loc 1 625 0
 4281 029e 7B68     		ldr	r3, [r7, #4]
 4282 02a0 1A68     		ldr	r2, [r3, #0]
 4283 02a2 40F20003 		movw	r3, #:lower16:xTickCount
 4284 02a6 C0F20003 		movt	r3, #:upper16:xTickCount
 4285 02aa 1B68     		ldr	r3, [r3, #0]
 4286 02ac 9A42     		cmp	r2, r3
 4287 02ae 10D9     		bls	.L21
 626:../3rdParty/FreeRTOS/tasks.c **** 			{
 627:../3rdParty/FreeRTOS/tasks.c **** 				/* The tick count has overflowed since this function was
 628:../3rdParty/FreeRTOS/tasks.c **** 				lasted called.  In this case the only time we should ever
 629:../3rdParty/FreeRTOS/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 630:../3rdParty/FreeRTOS/tasks.c **** 				and the wake time is greater than the tick time.  When this
 631:../3rdParty/FreeRTOS/tasks.c **** 				is the case it is as if neither time had overflowed. */
 632:../3rdParty/FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 4288              		.loc 1 632 0
 4289 02b0 7B68     		ldr	r3, [r7, #4]
 4290 02b2 1A68     		ldr	r2, [r3, #0]
 4291 02b4 FB68     		ldr	r3, [r7, #12]
 4292 02b6 9A42     		cmp	r2, r3
 4293 02b8 1CD9     		bls	.L28
 4294 02ba 40F20003 		movw	r3, #:lower16:xTickCount
 4295 02be C0F20003 		movt	r3, #:upper16:xTickCount
 4296 02c2 1B68     		ldr	r3, [r3, #0]
 4297 02c4 FA68     		ldr	r2, [r7, #12]
 4298 02c6 9A42     		cmp	r2, r3
 4299 02c8 16D9     		bls	.L29
 633:../3rdParty/FreeRTOS/tasks.c **** 				{
 634:../3rdParty/FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 4300              		.loc 1 634 0
 4301 02ca 4FF00103 		mov	r3, #1
 4302 02ce 7B61     		str	r3, [r7, #20]
 4303 02d0 13E0     		b	.L23
 4304              	.L21:
 635:../3rdParty/FreeRTOS/tasks.c **** 				}
 636:../3rdParty/FreeRTOS/tasks.c **** 			}
 637:../3rdParty/FreeRTOS/tasks.c **** 			else
 638:../3rdParty/FreeRTOS/tasks.c **** 			{
 639:../3rdParty/FreeRTOS/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 640:../3rdParty/FreeRTOS/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 641:../3rdParty/FreeRTOS/tasks.c **** 				tick time is less than the wake time. */
 642:../3rdParty/FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 4305              		.loc 1 642 0
 4306 02d2 7B68     		ldr	r3, [r7, #4]
 4307 02d4 1A68     		ldr	r2, [r3, #0]
 4308 02d6 FB68     		ldr	r3, [r7, #12]
 4309 02d8 9A42     		cmp	r2, r3
 4310 02da 07D8     		bhi	.L24
 4311 02dc 40F20003 		movw	r3, #:lower16:xTickCount
 4312 02e0 C0F20003 		movt	r3, #:upper16:xTickCount
 4313 02e4 1B68     		ldr	r3, [r3, #0]
 4314 02e6 FA68     		ldr	r2, [r7, #12]
 4315 02e8 9A42     		cmp	r2, r3
 4316 02ea 06D9     		bls	.L23
 4317              	.L24:
 643:../3rdParty/FreeRTOS/tasks.c **** 				{
 644:../3rdParty/FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 4318              		.loc 1 644 0
 4319 02ec 4FF00103 		mov	r3, #1
 4320 02f0 7B61     		str	r3, [r7, #20]
 4321 02f2 02E0     		b	.L23
 4322              	.L28:
 4323              		.loc 1 634 0
 4324 02f4 00BF     		nop
 4325 02f6 00E0     		b	.L23
 4326              	.L29:
 4327 02f8 00BF     		nop
 4328              	.L23:
 645:../3rdParty/FreeRTOS/tasks.c **** 				}
 646:../3rdParty/FreeRTOS/tasks.c **** 			}
 647:../3rdParty/FreeRTOS/tasks.c **** 
 648:../3rdParty/FreeRTOS/tasks.c **** 			/* Update the wake time ready for the next call. */
 649:../3rdParty/FreeRTOS/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 4329              		.loc 1 649 0
 4330 02fa 7B68     		ldr	r3, [r7, #4]
 4331 02fc FA68     		ldr	r2, [r7, #12]
 4332 02fe 1A60     		str	r2, [r3, #0]
 650:../3rdParty/FreeRTOS/tasks.c **** 
 651:../3rdParty/FreeRTOS/tasks.c **** 			if( xShouldDelay != pdFALSE )
 4333              		.loc 1 651 0
 4334 0300 7B69     		ldr	r3, [r7, #20]
 4335 0302 002B     		cmp	r3, #0
 4336 0304 0CD0     		beq	.L25
 652:../3rdParty/FreeRTOS/tasks.c **** 			{
 653:../3rdParty/FreeRTOS/tasks.c **** 				traceTASK_DELAY_UNTIL();
 654:../3rdParty/FreeRTOS/tasks.c **** 
 655:../3rdParty/FreeRTOS/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 656:../3rdParty/FreeRTOS/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 657:../3rdParty/FreeRTOS/tasks.c **** 				both lists. */
 658:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 4337              		.loc 1 658 0
 4338 0306 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4339 030a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4340 030e 1B68     		ldr	r3, [r3, #0]
 4341 0310 03F10403 		add	r3, r3, #4
 4342 0314 1846     		mov	r0, r3
 4343 0316 FFF7FEFF 		bl	vListRemove
 659:../3rdParty/FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 4344              		.loc 1 659 0
 4345 031a F868     		ldr	r0, [r7, #12]
 4346 031c 01F084F8 		bl	prvAddCurrentTaskToDelayedList
 4347              	.L25:
 660:../3rdParty/FreeRTOS/tasks.c **** 			}
 661:../3rdParty/FreeRTOS/tasks.c **** 		}
 662:../3rdParty/FreeRTOS/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 4348              		.loc 1 662 0
 4349 0320 FFF7FEFF 		bl	xTaskResumeAll
 4350 0324 0346     		mov	r3, r0
 4351 0326 3B61     		str	r3, [r7, #16]
 663:../3rdParty/FreeRTOS/tasks.c **** 
 664:../3rdParty/FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 665:../3rdParty/FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
 666:../3rdParty/FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 4352              		.loc 1 666 0
 4353 0328 3B69     		ldr	r3, [r7, #16]
 4354 032a 002B     		cmp	r3, #0
 4355 032c 01D1     		bne	.L27
 667:../3rdParty/FreeRTOS/tasks.c **** 		{
 668:../3rdParty/FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
 4356              		.loc 1 668 0
 4357 032e FFF7FEFF 		bl	vPortYieldFromISR
 4358              	.L27:
 669:../3rdParty/FreeRTOS/tasks.c **** 		}
 670:../3rdParty/FreeRTOS/tasks.c **** 	}
 4359              		.loc 1 670 0
 4360 0332 07F11807 		add	r7, r7, #24
 4361 0336 BD46     		mov	sp, r7
 4362 0338 80BD     		pop	{r7, pc}
 4363              	.LFE57:
 4365 033a 00BF     		.align	2
 4366              		.global	vTaskDelay
 4367              		.thumb
 4368              		.thumb_func
 4370              	vTaskDelay:
 4371              	.LFB58:
 671:../3rdParty/FreeRTOS/tasks.c **** 
 672:../3rdParty/FreeRTOS/tasks.c **** #endif
 673:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 674:../3rdParty/FreeRTOS/tasks.c **** 
 675:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 676:../3rdParty/FreeRTOS/tasks.c **** 
 677:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 678:../3rdParty/FreeRTOS/tasks.c **** 	{
 4372              		.loc 1 678 0
 4373              		@ args = 0, pretend = 0, frame = 16
 4374              		@ frame_needed = 1, uses_anonymous_args = 0
 4375 033c 80B5     		push	{r7, lr}
 4376              	.LCFI9:
 4377 033e 84B0     		sub	sp, sp, #16
 4378              	.LCFI10:
 4379 0340 00AF     		add	r7, sp, #0
 4380              	.LCFI11:
 4381 0342 7860     		str	r0, [r7, #4]
 679:../3rdParty/FreeRTOS/tasks.c **** 	portTickType xTimeToWake;
 680:../3rdParty/FreeRTOS/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 4382              		.loc 1 680 0
 4383 0344 4FF00003 		mov	r3, #0
 4384 0348 FB60     		str	r3, [r7, #12]
 681:../3rdParty/FreeRTOS/tasks.c **** 
 682:../3rdParty/FreeRTOS/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 683:../3rdParty/FreeRTOS/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 4385              		.loc 1 683 0
 4386 034a 7B68     		ldr	r3, [r7, #4]
 4387 034c 002B     		cmp	r3, #0
 4388 034e 1AD0     		beq	.L31
 684:../3rdParty/FreeRTOS/tasks.c **** 		{
 685:../3rdParty/FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 4389              		.loc 1 685 0
 4390 0350 FFF7FEFF 		bl	vTaskSuspendAll
 686:../3rdParty/FreeRTOS/tasks.c **** 			{
 687:../3rdParty/FreeRTOS/tasks.c **** 				traceTASK_DELAY();
 688:../3rdParty/FreeRTOS/tasks.c **** 
 689:../3rdParty/FreeRTOS/tasks.c **** 				/* A task that is removed from the event list while the
 690:../3rdParty/FreeRTOS/tasks.c **** 				scheduler is suspended will not get placed in the ready
 691:../3rdParty/FreeRTOS/tasks.c **** 				list or removed from the blocked list until the scheduler
 692:../3rdParty/FreeRTOS/tasks.c **** 				is resumed.
 693:../3rdParty/FreeRTOS/tasks.c **** 
 694:../3rdParty/FreeRTOS/tasks.c **** 				This task cannot be in an event list as it is the currently
 695:../3rdParty/FreeRTOS/tasks.c **** 				executing task. */
 696:../3rdParty/FreeRTOS/tasks.c **** 
 697:../3rdParty/FreeRTOS/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 698:../3rdParty/FreeRTOS/tasks.c **** 				not a problem. */
 699:../3rdParty/FreeRTOS/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 4391              		.loc 1 699 0
 4392 0354 40F20003 		movw	r3, #:lower16:xTickCount
 4393 0358 C0F20003 		movt	r3, #:upper16:xTickCount
 4394 035c 1A68     		ldr	r2, [r3, #0]
 4395 035e 7B68     		ldr	r3, [r7, #4]
 4396 0360 1344     		add	r3, r2, r3
 4397 0362 BB60     		str	r3, [r7, #8]
 700:../3rdParty/FreeRTOS/tasks.c **** 
 701:../3rdParty/FreeRTOS/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 702:../3rdParty/FreeRTOS/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 703:../3rdParty/FreeRTOS/tasks.c **** 				both lists. */
 704:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 4398              		.loc 1 704 0
 4399 0364 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4400 0368 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4401 036c 1B68     		ldr	r3, [r3, #0]
 4402 036e 03F10403 		add	r3, r3, #4
 4403 0372 1846     		mov	r0, r3
 4404 0374 FFF7FEFF 		bl	vListRemove
 705:../3rdParty/FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 4405              		.loc 1 705 0
 4406 0378 B868     		ldr	r0, [r7, #8]
 4407 037a 01F055F8 		bl	prvAddCurrentTaskToDelayedList
 706:../3rdParty/FreeRTOS/tasks.c **** 			}
 707:../3rdParty/FreeRTOS/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 4408              		.loc 1 707 0
 4409 037e FFF7FEFF 		bl	xTaskResumeAll
 4410 0382 0346     		mov	r3, r0
 4411 0384 FB60     		str	r3, [r7, #12]
 4412              	.L31:
 708:../3rdParty/FreeRTOS/tasks.c **** 		}
 709:../3rdParty/FreeRTOS/tasks.c **** 
 710:../3rdParty/FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 711:../3rdParty/FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
 712:../3rdParty/FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 4413              		.loc 1 712 0
 4414 0386 FB68     		ldr	r3, [r7, #12]
 4415 0388 002B     		cmp	r3, #0
 4416 038a 01D1     		bne	.L33
 713:../3rdParty/FreeRTOS/tasks.c **** 		{
 714:../3rdParty/FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
 4417              		.loc 1 714 0
 4418 038c FFF7FEFF 		bl	vPortYieldFromISR
 4419              	.L33:
 715:../3rdParty/FreeRTOS/tasks.c **** 		}
 716:../3rdParty/FreeRTOS/tasks.c **** 	}
 4420              		.loc 1 716 0
 4421 0390 07F11007 		add	r7, r7, #16
 4422 0394 BD46     		mov	sp, r7
 4423 0396 80BD     		pop	{r7, pc}
 4424              	.LFE58:
 4426              		.align	2
 4427              		.global	uxTaskPriorityGet
 4428              		.thumb
 4429              		.thumb_func
 4431              	uxTaskPriorityGet:
 4432              	.LFB59:
 717:../3rdParty/FreeRTOS/tasks.c **** 
 718:../3rdParty/FreeRTOS/tasks.c **** #endif
 719:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 720:../3rdParty/FreeRTOS/tasks.c **** 
 721:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 722:../3rdParty/FreeRTOS/tasks.c **** 
 723:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 724:../3rdParty/FreeRTOS/tasks.c **** 	{
 4433              		.loc 1 724 0
 4434              		@ args = 0, pretend = 0, frame = 16
 4435              		@ frame_needed = 1, uses_anonymous_args = 0
 4436 0398 80B5     		push	{r7, lr}
 4437              	.LCFI12:
 4438 039a 84B0     		sub	sp, sp, #16
 4439              	.LCFI13:
 4440 039c 00AF     		add	r7, sp, #0
 4441              	.LCFI14:
 4442 039e 7860     		str	r0, [r7, #4]
 725:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 726:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 727:../3rdParty/FreeRTOS/tasks.c **** 
 728:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 4443              		.loc 1 728 0
 4444 03a0 FFF7FEFF 		bl	vPortEnterCritical
 729:../3rdParty/FreeRTOS/tasks.c **** 		{
 730:../3rdParty/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are changing the
 731:../3rdParty/FreeRTOS/tasks.c **** 			priority of the calling function. */
 732:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 4445              		.loc 1 732 0
 4446 03a4 7B68     		ldr	r3, [r7, #4]
 4447 03a6 002B     		cmp	r3, #0
 4448 03a8 05D1     		bne	.L35
 4449 03aa 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4450 03ae C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4451 03b2 1B68     		ldr	r3, [r3, #0]
 4452 03b4 00E0     		b	.L36
 4453              	.L35:
 4454 03b6 7B68     		ldr	r3, [r7, #4]
 4455              	.L36:
 4456 03b8 BB60     		str	r3, [r7, #8]
 733:../3rdParty/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 4457              		.loc 1 733 0
 4458 03ba BB68     		ldr	r3, [r7, #8]
 4459 03bc DB6A     		ldr	r3, [r3, #44]
 4460 03be FB60     		str	r3, [r7, #12]
 734:../3rdParty/FreeRTOS/tasks.c **** 		}
 735:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 4461              		.loc 1 735 0
 4462 03c0 FFF7FEFF 		bl	vPortExitCritical
 736:../3rdParty/FreeRTOS/tasks.c **** 
 737:../3rdParty/FreeRTOS/tasks.c **** 		return uxReturn;
 4463              		.loc 1 737 0
 4464 03c4 FB68     		ldr	r3, [r7, #12]
 738:../3rdParty/FreeRTOS/tasks.c **** 	}
 4465              		.loc 1 738 0
 4466 03c6 1846     		mov	r0, r3
 4467 03c8 07F11007 		add	r7, r7, #16
 4468 03cc BD46     		mov	sp, r7
 4469 03ce 80BD     		pop	{r7, pc}
 4470              	.LFE59:
 4472              		.align	2
 4473              		.global	vTaskPrioritySet
 4474              		.thumb
 4475              		.thumb_func
 4477              	vTaskPrioritySet:
 4478              	.LFB60:
 739:../3rdParty/FreeRTOS/tasks.c **** 
 740:../3rdParty/FreeRTOS/tasks.c **** #endif
 741:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 742:../3rdParty/FreeRTOS/tasks.c **** 
 743:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 744:../3rdParty/FreeRTOS/tasks.c **** 
 745:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 746:../3rdParty/FreeRTOS/tasks.c **** 	{
 4479              		.loc 1 746 0
 4480              		@ args = 0, pretend = 0, frame = 24
 4481              		@ frame_needed = 1, uses_anonymous_args = 0
 4482 03d0 80B5     		push	{r7, lr}
 4483              	.LCFI15:
 4484 03d2 86B0     		sub	sp, sp, #24
 4485              	.LCFI16:
 4486 03d4 00AF     		add	r7, sp, #0
 4487              	.LCFI17:
 4488 03d6 7860     		str	r0, [r7, #4]
 4489 03d8 3960     		str	r1, [r7, #0]
 747:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 748:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority;
 749:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 4490              		.loc 1 749 0
 4491 03da 4FF00003 		mov	r3, #0
 4492 03de 7B61     		str	r3, [r7, #20]
 750:../3rdParty/FreeRTOS/tasks.c **** 
 751:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 752:../3rdParty/FreeRTOS/tasks.c **** 
 753:../3rdParty/FreeRTOS/tasks.c **** 		/* Ensure the new priority is valid. */
 754:../3rdParty/FreeRTOS/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 4493              		.loc 1 754 0
 4494 03e0 3B68     		ldr	r3, [r7, #0]
 4495 03e2 042B     		cmp	r3, #4
 4496 03e4 02D9     		bls	.L39
 755:../3rdParty/FreeRTOS/tasks.c **** 		{
 756:../3rdParty/FreeRTOS/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 4497              		.loc 1 756 0
 4498 03e6 4FF00403 		mov	r3, #4
 4499 03ea 3B60     		str	r3, [r7, #0]
 4500              	.L39:
 757:../3rdParty/FreeRTOS/tasks.c **** 		}
 758:../3rdParty/FreeRTOS/tasks.c **** 
 759:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 4501              		.loc 1 759 0
 4502 03ec FFF7FEFF 		bl	vPortEnterCritical
 760:../3rdParty/FreeRTOS/tasks.c **** 		{
 761:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTask == pxCurrentTCB )
 4503              		.loc 1 761 0
 4504 03f0 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4505 03f4 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4506 03f8 1B68     		ldr	r3, [r3, #0]
 4507 03fa 7A68     		ldr	r2, [r7, #4]
 4508 03fc 9A42     		cmp	r2, r3
 4509 03fe 02D1     		bne	.L40
 762:../3rdParty/FreeRTOS/tasks.c **** 			{
 763:../3rdParty/FreeRTOS/tasks.c **** 				pxTask = NULL;
 4510              		.loc 1 763 0
 4511 0400 4FF00003 		mov	r3, #0
 4512 0404 7B60     		str	r3, [r7, #4]
 4513              	.L40:
 764:../3rdParty/FreeRTOS/tasks.c **** 			}
 765:../3rdParty/FreeRTOS/tasks.c **** 
 766:../3rdParty/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are changing the
 767:../3rdParty/FreeRTOS/tasks.c **** 			priority of the calling function. */
 768:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 4514              		.loc 1 768 0
 4515 0406 7B68     		ldr	r3, [r7, #4]
 4516 0408 002B     		cmp	r3, #0
 4517 040a 05D1     		bne	.L41
 4518 040c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4519 0410 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4520 0414 1B68     		ldr	r3, [r3, #0]
 4521 0416 00E0     		b	.L42
 4522              	.L41:
 4523 0418 7B68     		ldr	r3, [r7, #4]
 4524              	.L42:
 4525 041a FB60     		str	r3, [r7, #12]
 769:../3rdParty/FreeRTOS/tasks.c **** 
 770:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 771:../3rdParty/FreeRTOS/tasks.c **** 
 772:../3rdParty/FreeRTOS/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 773:../3rdParty/FreeRTOS/tasks.c **** 			{
 774:../3rdParty/FreeRTOS/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 4526              		.loc 1 774 0
 4527 041c FB68     		ldr	r3, [r7, #12]
 4528 041e 9B6C     		ldr	r3, [r3, #72]
 4529 0420 3B61     		str	r3, [r7, #16]
 775:../3rdParty/FreeRTOS/tasks.c **** 			}
 776:../3rdParty/FreeRTOS/tasks.c **** 			#else
 777:../3rdParty/FreeRTOS/tasks.c **** 			{
 778:../3rdParty/FreeRTOS/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 779:../3rdParty/FreeRTOS/tasks.c **** 			}
 780:../3rdParty/FreeRTOS/tasks.c **** 			#endif
 781:../3rdParty/FreeRTOS/tasks.c **** 
 782:../3rdParty/FreeRTOS/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 4530              		.loc 1 782 0
 4531 0422 3A69     		ldr	r2, [r7, #16]
 4532 0424 3B68     		ldr	r3, [r7, #0]
 4533 0426 9A42     		cmp	r2, r3
 4534 0428 64D0     		beq	.L43
 783:../3rdParty/FreeRTOS/tasks.c **** 			{
 784:../3rdParty/FreeRTOS/tasks.c **** 				/* The priority change may have readied a task of higher
 785:../3rdParty/FreeRTOS/tasks.c **** 				priority than the calling task. */
 786:../3rdParty/FreeRTOS/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 4535              		.loc 1 786 0
 4536 042a 3A68     		ldr	r2, [r7, #0]
 4537 042c 3B69     		ldr	r3, [r7, #16]
 4538 042e 9A42     		cmp	r2, r3
 4539 0430 06D9     		bls	.L44
 787:../3rdParty/FreeRTOS/tasks.c **** 				{
 788:../3rdParty/FreeRTOS/tasks.c **** 					if( pxTask != NULL )
 4540              		.loc 1 788 0
 4541 0432 7B68     		ldr	r3, [r7, #4]
 4542 0434 002B     		cmp	r3, #0
 4543 0436 0AD0     		beq	.L51
 789:../3rdParty/FreeRTOS/tasks.c **** 					{
 790:../3rdParty/FreeRTOS/tasks.c **** 						/* The priority of another task is being raised.  If we
 791:../3rdParty/FreeRTOS/tasks.c **** 						were raising the priority of the currently running task
 792:../3rdParty/FreeRTOS/tasks.c **** 						there would be no need to switch as it must have already
 793:../3rdParty/FreeRTOS/tasks.c **** 						been the highest priority task. */
 794:../3rdParty/FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 4544              		.loc 1 794 0
 4545 0438 4FF00103 		mov	r3, #1
 4546 043c 7B61     		str	r3, [r7, #20]
 4547 043e 07E0     		b	.L46
 4548              	.L44:
 795:../3rdParty/FreeRTOS/tasks.c **** 					}
 796:../3rdParty/FreeRTOS/tasks.c **** 				}
 797:../3rdParty/FreeRTOS/tasks.c **** 				else if( pxTask == NULL )
 4549              		.loc 1 797 0
 4550 0440 7B68     		ldr	r3, [r7, #4]
 4551 0442 002B     		cmp	r3, #0
 4552 0444 04D1     		bne	.L46
 798:../3rdParty/FreeRTOS/tasks.c **** 				{
 799:../3rdParty/FreeRTOS/tasks.c **** 					/* Setting our own priority down means there may now be another
 800:../3rdParty/FreeRTOS/tasks.c **** 					task of higher priority that is ready to execute. */
 801:../3rdParty/FreeRTOS/tasks.c **** 					xYieldRequired = pdTRUE;
 4553              		.loc 1 801 0
 4554 0446 4FF00103 		mov	r3, #1
 4555 044a 7B61     		str	r3, [r7, #20]
 4556 044c 00E0     		b	.L46
 4557              	.L51:
 4558              		.loc 1 794 0
 4559 044e 00BF     		nop
 4560              	.L46:
 802:../3rdParty/FreeRTOS/tasks.c **** 				}
 803:../3rdParty/FreeRTOS/tasks.c **** 
 804:../3rdParty/FreeRTOS/tasks.c **** 
 805:../3rdParty/FreeRTOS/tasks.c **** 
 806:../3rdParty/FreeRTOS/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 807:../3rdParty/FreeRTOS/tasks.c **** 				{
 808:../3rdParty/FreeRTOS/tasks.c **** 					/* Only change the priority being used if the task is not
 809:../3rdParty/FreeRTOS/tasks.c **** 					currently using an inherited priority. */
 810:../3rdParty/FreeRTOS/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 4561              		.loc 1 810 0
 4562 0450 FB68     		ldr	r3, [r7, #12]
 4563 0452 9A6C     		ldr	r2, [r3, #72]
 4564 0454 FB68     		ldr	r3, [r7, #12]
 4565 0456 DB6A     		ldr	r3, [r3, #44]
 4566 0458 9A42     		cmp	r2, r3
 4567 045a 02D1     		bne	.L47
 811:../3rdParty/FreeRTOS/tasks.c **** 					{
 812:../3rdParty/FreeRTOS/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 4568              		.loc 1 812 0
 4569 045c FB68     		ldr	r3, [r7, #12]
 4570 045e 3A68     		ldr	r2, [r7, #0]
 4571 0460 DA62     		str	r2, [r3, #44]
 4572              	.L47:
 813:../3rdParty/FreeRTOS/tasks.c **** 					}
 814:../3rdParty/FreeRTOS/tasks.c **** 
 815:../3rdParty/FreeRTOS/tasks.c **** 					/* The base priority gets set whatever. */
 816:../3rdParty/FreeRTOS/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 4573              		.loc 1 816 0
 4574 0462 FB68     		ldr	r3, [r7, #12]
 4575 0464 3A68     		ldr	r2, [r7, #0]
 4576 0466 9A64     		str	r2, [r3, #72]
 817:../3rdParty/FreeRTOS/tasks.c **** 				}
 818:../3rdParty/FreeRTOS/tasks.c **** 				#else
 819:../3rdParty/FreeRTOS/tasks.c **** 				{
 820:../3rdParty/FreeRTOS/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 821:../3rdParty/FreeRTOS/tasks.c **** 				}
 822:../3rdParty/FreeRTOS/tasks.c **** 				#endif
 823:../3rdParty/FreeRTOS/tasks.c **** 
 824:../3rdParty/FreeRTOS/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 4577              		.loc 1 824 0
 4578 0468 3B68     		ldr	r3, [r7, #0]
 4579 046a C3F10502 		rsb	r2, r3, #5
 4580 046e FB68     		ldr	r3, [r7, #12]
 4581 0470 9A61     		str	r2, [r3, #24]
 825:../3rdParty/FreeRTOS/tasks.c **** 
 826:../3rdParty/FreeRTOS/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 827:../3rdParty/FreeRTOS/tasks.c **** 				nothing more than change it's priority variable. However, if
 828:../3rdParty/FreeRTOS/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 829:../3rdParty/FreeRTOS/tasks.c **** 				in the queue appropriate to its new priority. */
 830:../3rdParty/FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 4582              		.loc 1 830 0
 4583 0472 FB68     		ldr	r3, [r7, #12]
 4584 0474 5969     		ldr	r1, [r3, #20]
 4585 0476 3A69     		ldr	r2, [r7, #16]
 4586 0478 1346     		mov	r3, r2
 4587 047a 4FEA8303 		lsl	r3, r3, #2
 4588 047e 1344     		add	r3, r3, r2
 4589 0480 4FEA8303 		lsl	r3, r3, #2
 4590 0484 1A46     		mov	r2, r3
 4591 0486 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 4592 048a C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 4593 048e 1344     		add	r3, r2, r3
 4594 0490 9942     		cmp	r1, r3
 4595 0492 2AD1     		bne	.L48
 831:../3rdParty/FreeRTOS/tasks.c **** 				{
 832:../3rdParty/FreeRTOS/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 833:../3rdParty/FreeRTOS/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 834:../3rdParty/FreeRTOS/tasks.c **** 					can do this even if the scheduler is suspended. */
 835:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 4596              		.loc 1 835 0
 4597 0494 FB68     		ldr	r3, [r7, #12]
 4598 0496 03F10403 		add	r3, r3, #4
 4599 049a 1846     		mov	r0, r3
 4600 049c FFF7FEFF 		bl	vListRemove
 836:../3rdParty/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 4601              		.loc 1 836 0
 4602 04a0 FB68     		ldr	r3, [r7, #12]
 4603 04a2 DA6A     		ldr	r2, [r3, #44]
 4604 04a4 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4605 04a8 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4606 04ac 1B68     		ldr	r3, [r3, #0]
 4607 04ae 9A42     		cmp	r2, r3
 4608 04b0 06D9     		bls	.L49
 4609 04b2 FB68     		ldr	r3, [r7, #12]
 4610 04b4 DA6A     		ldr	r2, [r3, #44]
 4611 04b6 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4612 04ba C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4613 04be 1A60     		str	r2, [r3, #0]
 4614              	.L49:
 4615 04c0 FB68     		ldr	r3, [r7, #12]
 4616 04c2 DA6A     		ldr	r2, [r3, #44]
 4617 04c4 1346     		mov	r3, r2
 4618 04c6 4FEA8303 		lsl	r3, r3, #2
 4619 04ca 1344     		add	r3, r3, r2
 4620 04cc 4FEA8303 		lsl	r3, r3, #2
 4621 04d0 1A46     		mov	r2, r3
 4622 04d2 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 4623 04d6 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 4624 04da 1A44     		add	r2, r2, r3
 4625 04dc FB68     		ldr	r3, [r7, #12]
 4626 04de 03F10403 		add	r3, r3, #4
 4627 04e2 1046     		mov	r0, r2
 4628 04e4 1946     		mov	r1, r3
 4629 04e6 FFF7FEFF 		bl	vListInsertEnd
 4630              	.L48:
 837:../3rdParty/FreeRTOS/tasks.c **** 				}
 838:../3rdParty/FreeRTOS/tasks.c **** 
 839:../3rdParty/FreeRTOS/tasks.c **** 				if( xYieldRequired == pdTRUE )
 4631              		.loc 1 839 0
 4632 04ea 7B69     		ldr	r3, [r7, #20]
 4633 04ec 012B     		cmp	r3, #1
 4634 04ee 01D1     		bne	.L43
 840:../3rdParty/FreeRTOS/tasks.c **** 				{
 841:../3rdParty/FreeRTOS/tasks.c **** 					portYIELD_WITHIN_API();
 4635              		.loc 1 841 0
 4636 04f0 FFF7FEFF 		bl	vPortYieldFromISR
 4637              	.L43:
 842:../3rdParty/FreeRTOS/tasks.c **** 				}
 843:../3rdParty/FreeRTOS/tasks.c **** 			}
 844:../3rdParty/FreeRTOS/tasks.c **** 		}
 845:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 4638              		.loc 1 845 0
 4639 04f4 FFF7FEFF 		bl	vPortExitCritical
 846:../3rdParty/FreeRTOS/tasks.c **** 	}
 4640              		.loc 1 846 0
 4641 04f8 07F11807 		add	r7, r7, #24
 4642 04fc BD46     		mov	sp, r7
 4643 04fe 80BD     		pop	{r7, pc}
 4644              	.LFE60:
 4646              		.align	2
 4647              		.global	vTaskSuspend
 4648              		.thumb
 4649              		.thumb_func
 4651              	vTaskSuspend:
 4652              	.LFB61:
 847:../3rdParty/FreeRTOS/tasks.c **** 
 848:../3rdParty/FreeRTOS/tasks.c **** #endif
 849:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 850:../3rdParty/FreeRTOS/tasks.c **** 
 851:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 852:../3rdParty/FreeRTOS/tasks.c **** 
 853:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 854:../3rdParty/FreeRTOS/tasks.c **** 	{
 4653              		.loc 1 854 0
 4654              		@ args = 0, pretend = 0, frame = 16
 4655              		@ frame_needed = 1, uses_anonymous_args = 0
 4656 0500 80B5     		push	{r7, lr}
 4657              	.LCFI18:
 4658 0502 84B0     		sub	sp, sp, #16
 4659              	.LCFI19:
 4660 0504 00AF     		add	r7, sp, #0
 4661              	.LCFI20:
 4662 0506 7860     		str	r0, [r7, #4]
 855:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 856:../3rdParty/FreeRTOS/tasks.c **** 
 857:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 4663              		.loc 1 857 0
 4664 0508 FFF7FEFF 		bl	vPortEnterCritical
 858:../3rdParty/FreeRTOS/tasks.c **** 		{
 859:../3rdParty/FreeRTOS/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 860:../3rdParty/FreeRTOS/tasks.c **** 			suspended. */
 861:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 4665              		.loc 1 861 0
 4666 050c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4667 0510 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4668 0514 1B68     		ldr	r3, [r3, #0]
 4669 0516 7A68     		ldr	r2, [r7, #4]
 4670 0518 9A42     		cmp	r2, r3
 4671 051a 02D1     		bne	.L53
 862:../3rdParty/FreeRTOS/tasks.c **** 			{
 863:../3rdParty/FreeRTOS/tasks.c **** 				pxTaskToSuspend = NULL;
 4672              		.loc 1 863 0
 4673 051c 4FF00003 		mov	r3, #0
 4674 0520 7B60     		str	r3, [r7, #4]
 4675              	.L53:
 864:../3rdParty/FreeRTOS/tasks.c **** 			}
 865:../3rdParty/FreeRTOS/tasks.c **** 
 866:../3rdParty/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 867:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 4676              		.loc 1 867 0
 4677 0522 7B68     		ldr	r3, [r7, #4]
 4678 0524 002B     		cmp	r3, #0
 4679 0526 05D1     		bne	.L54
 4680 0528 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4681 052c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4682 0530 1B68     		ldr	r3, [r3, #0]
 4683 0532 00E0     		b	.L55
 4684              	.L54:
 4685 0534 7B68     		ldr	r3, [r7, #4]
 4686              	.L55:
 4687 0536 FB60     		str	r3, [r7, #12]
 868:../3rdParty/FreeRTOS/tasks.c **** 
 869:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 870:../3rdParty/FreeRTOS/tasks.c **** 
 871:../3rdParty/FreeRTOS/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 872:../3rdParty/FreeRTOS/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 4688              		.loc 1 872 0
 4689 0538 FB68     		ldr	r3, [r7, #12]
 4690 053a 03F10403 		add	r3, r3, #4
 4691 053e 1846     		mov	r0, r3
 4692 0540 FFF7FEFF 		bl	vListRemove
 873:../3rdParty/FreeRTOS/tasks.c **** 
 874:../3rdParty/FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
 875:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 4693              		.loc 1 875 0
 4694 0544 FB68     		ldr	r3, [r7, #12]
 4695 0546 9B6A     		ldr	r3, [r3, #40]
 4696 0548 002B     		cmp	r3, #0
 4697 054a 05D0     		beq	.L56
 876:../3rdParty/FreeRTOS/tasks.c **** 			{
 877:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 4698              		.loc 1 877 0
 4699 054c FB68     		ldr	r3, [r7, #12]
 4700 054e 03F11803 		add	r3, r3, #24
 4701 0552 1846     		mov	r0, r3
 4702 0554 FFF7FEFF 		bl	vListRemove
 4703              	.L56:
 878:../3rdParty/FreeRTOS/tasks.c **** 			}
 879:../3rdParty/FreeRTOS/tasks.c **** 
 880:../3rdParty/FreeRTOS/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 4704              		.loc 1 880 0
 4705 0558 FB68     		ldr	r3, [r7, #12]
 4706 055a 03F10403 		add	r3, r3, #4
 4707 055e 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 4708 0562 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 4709 0566 1946     		mov	r1, r3
 4710 0568 FFF7FEFF 		bl	vListInsertEnd
 881:../3rdParty/FreeRTOS/tasks.c **** 		}
 882:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 4711              		.loc 1 882 0
 4712 056c FFF7FEFF 		bl	vPortExitCritical
 883:../3rdParty/FreeRTOS/tasks.c **** 
 884:../3rdParty/FreeRTOS/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 4713              		.loc 1 884 0
 4714 0570 7B68     		ldr	r3, [r7, #4]
 4715 0572 002B     		cmp	r3, #0
 4716 0574 1FD1     		bne	.L60
 885:../3rdParty/FreeRTOS/tasks.c **** 		{
 886:../3rdParty/FreeRTOS/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 4717              		.loc 1 886 0
 4718 0576 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 4719 057a C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 4720 057e 1B68     		ldr	r3, [r3, #0]
 4721 0580 002B     		cmp	r3, #0
 4722 0582 02D0     		beq	.L58
 887:../3rdParty/FreeRTOS/tasks.c **** 			{
 888:../3rdParty/FreeRTOS/tasks.c **** 				/* We have just suspended the current task. */
 889:../3rdParty/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 4723              		.loc 1 889 0
 4724 0584 FFF7FEFF 		bl	vPortYieldFromISR
 4725 0588 15E0     		b	.L60
 4726              	.L58:
 890:../3rdParty/FreeRTOS/tasks.c **** 			}
 891:../3rdParty/FreeRTOS/tasks.c **** 			else
 892:../3rdParty/FreeRTOS/tasks.c **** 			{
 893:../3rdParty/FreeRTOS/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 894:../3rdParty/FreeRTOS/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 895:../3rdParty/FreeRTOS/tasks.c **** 				must be adjusted to point to a different task. */
 896:../3rdParty/FreeRTOS/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 4727              		.loc 1 896 0
 4728 058a 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 4729 058e C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 4730 0592 1A68     		ldr	r2, [r3, #0]
 4731 0594 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 4732 0598 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 4733 059c 1B68     		ldr	r3, [r3, #0]
 4734 059e 9A42     		cmp	r2, r3
 4735 05a0 07D1     		bne	.L59
 897:../3rdParty/FreeRTOS/tasks.c **** 				{
 898:../3rdParty/FreeRTOS/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
 899:../3rdParty/FreeRTOS/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 900:../3rdParty/FreeRTOS/tasks.c **** 					be set to point to it no matter what its relative priority
 901:../3rdParty/FreeRTOS/tasks.c **** 					is. */
 902:../3rdParty/FreeRTOS/tasks.c **** 					pxCurrentTCB = NULL;
 4736              		.loc 1 902 0
 4737 05a2 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4738 05a6 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4739 05aa 4FF00002 		mov	r2, #0
 4740 05ae 1A60     		str	r2, [r3, #0]
 4741 05b0 01E0     		b	.L60
 4742              	.L59:
 903:../3rdParty/FreeRTOS/tasks.c **** 				}
 904:../3rdParty/FreeRTOS/tasks.c **** 				else
 905:../3rdParty/FreeRTOS/tasks.c **** 				{
 906:../3rdParty/FreeRTOS/tasks.c **** 					vTaskSwitchContext();
 4743              		.loc 1 906 0
 4744 05b2 FFF7FEFF 		bl	vTaskSwitchContext
 4745              	.L60:
 907:../3rdParty/FreeRTOS/tasks.c **** 				}
 908:../3rdParty/FreeRTOS/tasks.c **** 			}
 909:../3rdParty/FreeRTOS/tasks.c **** 		}
 910:../3rdParty/FreeRTOS/tasks.c **** 	}
 4746              		.loc 1 910 0
 4747 05b6 07F11007 		add	r7, r7, #16
 4748 05ba BD46     		mov	sp, r7
 4749 05bc 80BD     		pop	{r7, pc}
 4750              	.LFE61:
 4752 05be 00BF     		.align	2
 4753              		.global	xTaskIsTaskSuspended
 4754              		.thumb
 4755              		.thumb_func
 4757              	xTaskIsTaskSuspended:
 4758              	.LFB62:
 911:../3rdParty/FreeRTOS/tasks.c **** 
 912:../3rdParty/FreeRTOS/tasks.c **** #endif
 913:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 914:../3rdParty/FreeRTOS/tasks.c **** 
 915:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 916:../3rdParty/FreeRTOS/tasks.c **** 
 917:../3rdParty/FreeRTOS/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 918:../3rdParty/FreeRTOS/tasks.c **** 	{
 4759              		.loc 1 918 0
 4760              		@ args = 0, pretend = 0, frame = 16
 4761              		@ frame_needed = 1, uses_anonymous_args = 0
 4762              		@ link register save eliminated.
 4763 05c0 80B4     		push	{r7}
 4764              	.LCFI21:
 4765 05c2 85B0     		sub	sp, sp, #20
 4766              	.LCFI22:
 4767 05c4 00AF     		add	r7, sp, #0
 4768              	.LCFI23:
 4769 05c6 7860     		str	r0, [r7, #4]
 919:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 4770              		.loc 1 919 0
 4771 05c8 4FF00003 		mov	r3, #0
 4772 05cc BB60     		str	r3, [r7, #8]
 920:../3rdParty/FreeRTOS/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 4773              		.loc 1 920 0
 4774 05ce 7B68     		ldr	r3, [r7, #4]
 4775 05d0 FB60     		str	r3, [r7, #12]
 921:../3rdParty/FreeRTOS/tasks.c **** 
 922:../3rdParty/FreeRTOS/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
 923:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( xTask );
 924:../3rdParty/FreeRTOS/tasks.c **** 
 925:../3rdParty/FreeRTOS/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 926:../3rdParty/FreeRTOS/tasks.c **** 		suspended list? */
 927:../3rdParty/FreeRTOS/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 4776              		.loc 1 927 0
 4777 05d2 FB68     		ldr	r3, [r7, #12]
 4778 05d4 5A69     		ldr	r2, [r3, #20]
 4779 05d6 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 4780 05da C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 4781 05de 9A42     		cmp	r2, r3
 4782 05e0 0ED1     		bne	.L62
 928:../3rdParty/FreeRTOS/tasks.c **** 		{
 929:../3rdParty/FreeRTOS/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 930:../3rdParty/FreeRTOS/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 4783              		.loc 1 930 0
 4784 05e2 FB68     		ldr	r3, [r7, #12]
 4785 05e4 9A6A     		ldr	r2, [r3, #40]
 4786 05e6 40F20003 		movw	r3, #:lower16:xPendingReadyList
 4787 05ea C0F20003 		movt	r3, #:upper16:xPendingReadyList
 4788 05ee 9A42     		cmp	r2, r3
 4789 05f0 06D0     		beq	.L62
 931:../3rdParty/FreeRTOS/tasks.c **** 			{
 932:../3rdParty/FreeRTOS/tasks.c **** 				/* Is it in the suspended list because it is in the
 933:../3rdParty/FreeRTOS/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 934:../3rdParty/FreeRTOS/tasks.c **** 				list because it is blocked on a task with no timeout
 935:../3rdParty/FreeRTOS/tasks.c **** 				specified. */
 936:../3rdParty/FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 4790              		.loc 1 936 0
 4791 05f2 FB68     		ldr	r3, [r7, #12]
 4792 05f4 9B6A     		ldr	r3, [r3, #40]
 4793 05f6 002B     		cmp	r3, #0
 4794 05f8 02D1     		bne	.L62
 937:../3rdParty/FreeRTOS/tasks.c **** 				{
 938:../3rdParty/FreeRTOS/tasks.c **** 					xReturn = pdTRUE;
 4795              		.loc 1 938 0
 4796 05fa 4FF00103 		mov	r3, #1
 4797 05fe BB60     		str	r3, [r7, #8]
 4798              	.L62:
 939:../3rdParty/FreeRTOS/tasks.c **** 				}
 940:../3rdParty/FreeRTOS/tasks.c **** 			}
 941:../3rdParty/FreeRTOS/tasks.c **** 		}
 942:../3rdParty/FreeRTOS/tasks.c **** 
 943:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
 4799              		.loc 1 943 0
 4800 0600 BB68     		ldr	r3, [r7, #8]
 944:../3rdParty/FreeRTOS/tasks.c **** 	}
 4801              		.loc 1 944 0
 4802 0602 1846     		mov	r0, r3
 4803 0604 07F11407 		add	r7, r7, #20
 4804 0608 BD46     		mov	sp, r7
 4805 060a 80BC     		pop	{r7}
 4806 060c 7047     		bx	lr
 4807              	.LFE62:
 4809 060e 00BF     		.align	2
 4810              		.global	vTaskResume
 4811              		.thumb
 4812              		.thumb_func
 4814              	vTaskResume:
 4815              	.LFB63:
 945:../3rdParty/FreeRTOS/tasks.c **** 
 946:../3rdParty/FreeRTOS/tasks.c **** #endif
 947:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 948:../3rdParty/FreeRTOS/tasks.c **** 
 949:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 950:../3rdParty/FreeRTOS/tasks.c **** 
 951:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 952:../3rdParty/FreeRTOS/tasks.c **** 	{
 4816              		.loc 1 952 0
 4817              		@ args = 0, pretend = 0, frame = 16
 4818              		@ frame_needed = 1, uses_anonymous_args = 0
 4819 0610 80B5     		push	{r7, lr}
 4820              	.LCFI24:
 4821 0612 84B0     		sub	sp, sp, #16
 4822              	.LCFI25:
 4823 0614 00AF     		add	r7, sp, #0
 4824              	.LCFI26:
 4825 0616 7860     		str	r0, [r7, #4]
 953:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 954:../3rdParty/FreeRTOS/tasks.c **** 
 955:../3rdParty/FreeRTOS/tasks.c **** 		/* It does not make sense to resume the calling task. */
 956:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxTaskToResume );
 957:../3rdParty/FreeRTOS/tasks.c **** 
 958:../3rdParty/FreeRTOS/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
 959:../3rdParty/FreeRTOS/tasks.c **** 		it in the ready list. */
 960:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 4826              		.loc 1 960 0
 4827 0618 7B68     		ldr	r3, [r7, #4]
 4828 061a FB60     		str	r3, [r7, #12]
 961:../3rdParty/FreeRTOS/tasks.c **** 
 962:../3rdParty/FreeRTOS/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
 963:../3rdParty/FreeRTOS/tasks.c **** 		currently executing task. */
 964:../3rdParty/FreeRTOS/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 4829              		.loc 1 964 0
 4830 061c FB68     		ldr	r3, [r7, #12]
 4831 061e 002B     		cmp	r3, #0
 4832 0620 48D0     		beq	.L68
 4833 0622 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4834 0626 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4835 062a 1B68     		ldr	r3, [r3, #0]
 4836 062c FA68     		ldr	r2, [r7, #12]
 4837 062e 9A42     		cmp	r2, r3
 4838 0630 40D0     		beq	.L68
 965:../3rdParty/FreeRTOS/tasks.c **** 		{
 966:../3rdParty/FreeRTOS/tasks.c **** 			taskENTER_CRITICAL();
 4839              		.loc 1 966 0
 4840 0632 FFF7FEFF 		bl	vPortEnterCritical
 967:../3rdParty/FreeRTOS/tasks.c **** 			{
 968:../3rdParty/FreeRTOS/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 4841              		.loc 1 968 0
 4842 0636 F868     		ldr	r0, [r7, #12]
 4843 0638 FFF7FEFF 		bl	xTaskIsTaskSuspended
 4844 063c 0346     		mov	r3, r0
 4845 063e 012B     		cmp	r3, #1
 4846 0640 36D1     		bne	.L66
 969:../3rdParty/FreeRTOS/tasks.c **** 				{
 970:../3rdParty/FreeRTOS/tasks.c **** 					traceTASK_RESUME( pxTCB );
 971:../3rdParty/FreeRTOS/tasks.c **** 
 972:../3rdParty/FreeRTOS/tasks.c **** 					/* As we are in a critical section we can access the ready
 973:../3rdParty/FreeRTOS/tasks.c **** 					lists even if the scheduler is suspended. */
 974:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 4847              		.loc 1 974 0
 4848 0642 FB68     		ldr	r3, [r7, #12]
 4849 0644 03F10403 		add	r3, r3, #4
 4850 0648 1846     		mov	r0, r3
 4851 064a FFF7FEFF 		bl	vListRemove
 975:../3rdParty/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 4852              		.loc 1 975 0
 4853 064e FB68     		ldr	r3, [r7, #12]
 4854 0650 DA6A     		ldr	r2, [r3, #44]
 4855 0652 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4856 0656 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4857 065a 1B68     		ldr	r3, [r3, #0]
 4858 065c 9A42     		cmp	r2, r3
 4859 065e 06D9     		bls	.L67
 4860 0660 FB68     		ldr	r3, [r7, #12]
 4861 0662 DA6A     		ldr	r2, [r3, #44]
 4862 0664 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4863 0668 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4864 066c 1A60     		str	r2, [r3, #0]
 4865              	.L67:
 4866 066e FB68     		ldr	r3, [r7, #12]
 4867 0670 DA6A     		ldr	r2, [r3, #44]
 4868 0672 1346     		mov	r3, r2
 4869 0674 4FEA8303 		lsl	r3, r3, #2
 4870 0678 1344     		add	r3, r3, r2
 4871 067a 4FEA8303 		lsl	r3, r3, #2
 4872 067e 1A46     		mov	r2, r3
 4873 0680 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 4874 0684 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 4875 0688 1A44     		add	r2, r2, r3
 4876 068a FB68     		ldr	r3, [r7, #12]
 4877 068c 03F10403 		add	r3, r3, #4
 4878 0690 1046     		mov	r0, r2
 4879 0692 1946     		mov	r1, r3
 4880 0694 FFF7FEFF 		bl	vListInsertEnd
 976:../3rdParty/FreeRTOS/tasks.c **** 
 977:../3rdParty/FreeRTOS/tasks.c **** 					/* We may have just resumed a higher priority task. */
 978:../3rdParty/FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 4881              		.loc 1 978 0
 4882 0698 FB68     		ldr	r3, [r7, #12]
 4883 069a DA6A     		ldr	r2, [r3, #44]
 4884 069c 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4885 06a0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4886 06a4 1B68     		ldr	r3, [r3, #0]
 4887 06a6 DB6A     		ldr	r3, [r3, #44]
 4888 06a8 9A42     		cmp	r2, r3
 4889 06aa 01D3     		bcc	.L66
 979:../3rdParty/FreeRTOS/tasks.c **** 					{
 980:../3rdParty/FreeRTOS/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
 981:../3rdParty/FreeRTOS/tasks.c **** 						will leave the lists in the correct state for the next yield. */
 982:../3rdParty/FreeRTOS/tasks.c **** 						portYIELD_WITHIN_API();
 4890              		.loc 1 982 0
 4891 06ac FFF7FEFF 		bl	vPortYieldFromISR
 4892              	.L66:
 983:../3rdParty/FreeRTOS/tasks.c **** 					}
 984:../3rdParty/FreeRTOS/tasks.c **** 				}
 985:../3rdParty/FreeRTOS/tasks.c **** 			}
 986:../3rdParty/FreeRTOS/tasks.c **** 			taskEXIT_CRITICAL();
 4893              		.loc 1 986 0
 4894 06b0 FFF7FEFF 		bl	vPortExitCritical
 4895              	.L68:
 987:../3rdParty/FreeRTOS/tasks.c **** 		}
 988:../3rdParty/FreeRTOS/tasks.c **** 	}
 4896              		.loc 1 988 0
 4897 06b4 07F11007 		add	r7, r7, #16
 4898 06b8 BD46     		mov	sp, r7
 4899 06ba 80BD     		pop	{r7, pc}
 4900              	.LFE63:
 4902              		.align	2
 4903              		.global	xTaskResumeFromISR
 4904              		.thumb
 4905              		.thumb_func
 4907              	xTaskResumeFromISR:
 4908              	.LFB64:
 989:../3rdParty/FreeRTOS/tasks.c **** 
 990:../3rdParty/FreeRTOS/tasks.c **** #endif
 991:../3rdParty/FreeRTOS/tasks.c **** 
 992:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 993:../3rdParty/FreeRTOS/tasks.c **** 
 994:../3rdParty/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
 995:../3rdParty/FreeRTOS/tasks.c **** 
 996:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
 997:../3rdParty/FreeRTOS/tasks.c **** 	{
 4909              		.loc 1 997 0
 4910              		@ args = 0, pretend = 0, frame = 24
 4911              		@ frame_needed = 1, uses_anonymous_args = 0
 4912 06bc 80B5     		push	{r7, lr}
 4913              	.LCFI27:
 4914 06be 86B0     		sub	sp, sp, #24
 4915              	.LCFI28:
 4916 06c0 00AF     		add	r7, sp, #0
 4917              	.LCFI29:
 4918 06c2 7860     		str	r0, [r7, #4]
 998:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 4919              		.loc 1 998 0
 4920 06c4 4FF00003 		mov	r3, #0
 4921 06c8 FB60     		str	r3, [r7, #12]
 999:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1000:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1001:../3rdParty/FreeRTOS/tasks.c **** 
1002:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxTaskToResume );
1003:../3rdParty/FreeRTOS/tasks.c **** 
1004:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 4922              		.loc 1 1004 0
 4923 06ca 7B68     		ldr	r3, [r7, #4]
 4924 06cc 3B61     		str	r3, [r7, #16]
1005:../3rdParty/FreeRTOS/tasks.c **** 
1006:../3rdParty/FreeRTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4925              		.loc 1 1006 0
 4926 06ce 4FF00003 		mov	r3, #0
 4927 06d2 7B61     		str	r3, [r7, #20]
 4928              	@ 1006 "../3rdParty/FreeRTOS/tasks.c" 1
 4929 06d4 4FF02800 			mov r0, #40								
 4930 06d8 80F31188 		msr basepri, r0							
 4931              	
 4932              	@ 0 "" 2
1007:../3rdParty/FreeRTOS/tasks.c **** 		{
1008:../3rdParty/FreeRTOS/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 4933              		.loc 1 1008 0
 4934              		.thumb
 4935 06dc 3869     		ldr	r0, [r7, #16]
 4936 06de FFF7FEFF 		bl	xTaskIsTaskSuspended
 4937 06e2 0346     		mov	r3, r0
 4938 06e4 012B     		cmp	r3, #1
 4939 06e6 49D1     		bne	.L70
1009:../3rdParty/FreeRTOS/tasks.c **** 			{
1010:../3rdParty/FreeRTOS/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1011:../3rdParty/FreeRTOS/tasks.c **** 
1012:../3rdParty/FreeRTOS/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 4940              		.loc 1 1012 0
 4941 06e8 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 4942 06ec C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 4943 06f0 1B68     		ldr	r3, [r3, #0]
 4944 06f2 002B     		cmp	r3, #0
 4945 06f4 38D1     		bne	.L71
1013:../3rdParty/FreeRTOS/tasks.c **** 				{
1014:../3rdParty/FreeRTOS/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 4946              		.loc 1 1014 0
 4947 06f6 3B69     		ldr	r3, [r7, #16]
 4948 06f8 DA6A     		ldr	r2, [r3, #44]
 4949 06fa 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 4950 06fe C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 4951 0702 1B68     		ldr	r3, [r3, #0]
 4952 0704 DB6A     		ldr	r3, [r3, #44]
 4953 0706 9A42     		cmp	r2, r3
 4954 0708 34BF     		ite	cc
 4955 070a 0023     		movcc	r3, #0
 4956 070c 0123     		movcs	r3, #1
 4957 070e FB60     		str	r3, [r7, #12]
1015:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 4958              		.loc 1 1015 0
 4959 0710 3B69     		ldr	r3, [r7, #16]
 4960 0712 03F10403 		add	r3, r3, #4
 4961 0716 1846     		mov	r0, r3
 4962 0718 FFF7FEFF 		bl	vListRemove
1016:../3rdParty/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 4963              		.loc 1 1016 0
 4964 071c 3B69     		ldr	r3, [r7, #16]
 4965 071e DA6A     		ldr	r2, [r3, #44]
 4966 0720 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4967 0724 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4968 0728 1B68     		ldr	r3, [r3, #0]
 4969 072a 9A42     		cmp	r2, r3
 4970 072c 06D9     		bls	.L72
 4971 072e 3B69     		ldr	r3, [r7, #16]
 4972 0730 DA6A     		ldr	r2, [r3, #44]
 4973 0732 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 4974 0736 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 4975 073a 1A60     		str	r2, [r3, #0]
 4976              	.L72:
 4977 073c 3B69     		ldr	r3, [r7, #16]
 4978 073e DA6A     		ldr	r2, [r3, #44]
 4979 0740 1346     		mov	r3, r2
 4980 0742 4FEA8303 		lsl	r3, r3, #2
 4981 0746 1344     		add	r3, r3, r2
 4982 0748 4FEA8303 		lsl	r3, r3, #2
 4983 074c 1A46     		mov	r2, r3
 4984 074e 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 4985 0752 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 4986 0756 1A44     		add	r2, r2, r3
 4987 0758 3B69     		ldr	r3, [r7, #16]
 4988 075a 03F10403 		add	r3, r3, #4
 4989 075e 1046     		mov	r0, r2
 4990 0760 1946     		mov	r1, r3
 4991 0762 FFF7FEFF 		bl	vListInsertEnd
 4992 0766 09E0     		b	.L70
 4993              	.L71:
1017:../3rdParty/FreeRTOS/tasks.c **** 				}
1018:../3rdParty/FreeRTOS/tasks.c **** 				else
1019:../3rdParty/FreeRTOS/tasks.c **** 				{
1020:../3rdParty/FreeRTOS/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1021:../3rdParty/FreeRTOS/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1022:../3rdParty/FreeRTOS/tasks.c **** 					yield will be performed if necessary. */
1023:../3rdParty/FreeRTOS/tasks.c **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 4994              		.loc 1 1023 0
 4995 0768 3B69     		ldr	r3, [r7, #16]
 4996 076a 03F11803 		add	r3, r3, #24
 4997 076e 40F20000 		movw	r0, #:lower16:xPendingReadyList
 4998 0772 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 4999 0776 1946     		mov	r1, r3
 5000 0778 FFF7FEFF 		bl	vListInsertEnd
 5001              	.L70:
1024:../3rdParty/FreeRTOS/tasks.c **** 				}
1025:../3rdParty/FreeRTOS/tasks.c **** 			}
1026:../3rdParty/FreeRTOS/tasks.c **** 		}
1027:../3rdParty/FreeRTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 5002              		.loc 1 1027 0
 5003              	@ 1027 "../3rdParty/FreeRTOS/tasks.c" 1
 5004 077c 4FF00000 			mov r0, #0					
 5005 0780 80F31188 		msr basepri, r0				
 5006              	
 5007              	@ 0 "" 2
1028:../3rdParty/FreeRTOS/tasks.c **** 
1029:../3rdParty/FreeRTOS/tasks.c **** 		return xYieldRequired;
 5008              		.loc 1 1029 0
 5009              		.thumb
 5010 0784 FB68     		ldr	r3, [r7, #12]
1030:../3rdParty/FreeRTOS/tasks.c **** 	}
 5011              		.loc 1 1030 0
 5012 0786 1846     		mov	r0, r3
 5013 0788 07F11807 		add	r7, r7, #24
 5014 078c BD46     		mov	sp, r7
 5015 078e 80BD     		pop	{r7, pc}
 5016              	.LFE64:
 5018              		.section	.rodata
 5019              		.align	2
 5020              	.LC0:
 5021 0000 49444C45 		.ascii	"IDLE\000"
 5021      00
 5022              		.text
 5023              		.align	2
 5024              		.global	vTaskStartScheduler
 5025              		.thumb
 5026              		.thumb_func
 5028              	vTaskStartScheduler:
 5029              	.LFB65:
1031:../3rdParty/FreeRTOS/tasks.c **** 
1032:../3rdParty/FreeRTOS/tasks.c **** #endif
1033:../3rdParty/FreeRTOS/tasks.c **** 
1034:../3rdParty/FreeRTOS/tasks.c **** 
1035:../3rdParty/FreeRTOS/tasks.c **** 
1036:../3rdParty/FreeRTOS/tasks.c **** 
1037:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1038:../3rdParty/FreeRTOS/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1039:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1040:../3rdParty/FreeRTOS/tasks.c **** 
1041:../3rdParty/FreeRTOS/tasks.c **** 
1042:../3rdParty/FreeRTOS/tasks.c **** void vTaskStartScheduler( void )
1043:../3rdParty/FreeRTOS/tasks.c **** {
 5030              		.loc 1 1043 0
 5031              		@ args = 0, pretend = 0, frame = 8
 5032              		@ frame_needed = 1, uses_anonymous_args = 0
 5033 0790 80B5     		push	{r7, lr}
 5034              	.LCFI30:
 5035 0792 86B0     		sub	sp, sp, #24
 5036              	.LCFI31:
 5037 0794 04AF     		add	r7, sp, #16
 5038              	.LCFI32:
1044:../3rdParty/FreeRTOS/tasks.c **** portBASE_TYPE xReturn;
1045:../3rdParty/FreeRTOS/tasks.c **** 
1046:../3rdParty/FreeRTOS/tasks.c **** 	/* Add the idle task at the lowest priority. */
1047:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1048:../3rdParty/FreeRTOS/tasks.c **** 	{
1049:../3rdParty/FreeRTOS/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1050:../3rdParty/FreeRTOS/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1051:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1052:../3rdParty/FreeRTOS/tasks.c **** 	}
1053:../3rdParty/FreeRTOS/tasks.c **** 	#else
1054:../3rdParty/FreeRTOS/tasks.c **** 	{
1055:../3rdParty/FreeRTOS/tasks.c **** 		/* Create the idle task without storing its handle. */
1056:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 5039              		.loc 1 1056 0
 5040 0796 40F20003 		movw	r3, #:lower16:.LC0
 5041 079a C0F20003 		movt	r3, #:upper16:.LC0
 5042 079e 4FF00002 		mov	r2, #0
 5043 07a2 0092     		str	r2, [sp, #0]
 5044 07a4 4FF00002 		mov	r2, #0
 5045 07a8 0192     		str	r2, [sp, #4]
 5046 07aa 4FF00002 		mov	r2, #0
 5047 07ae 0292     		str	r2, [sp, #8]
 5048 07b0 4FF00002 		mov	r2, #0
 5049 07b4 0392     		str	r2, [sp, #12]
 5050 07b6 40F20000 		movw	r0, #:lower16:prvIdleTask
 5051 07ba C0F20000 		movt	r0, #:upper16:prvIdleTask
 5052 07be 1946     		mov	r1, r3
 5053 07c0 4FF05002 		mov	r2, #80
 5054 07c4 4FF00003 		mov	r3, #0
 5055 07c8 FFF7FEFF 		bl	xTaskGenericCreate
 5056 07cc 0346     		mov	r3, r0
 5057 07ce 7B60     		str	r3, [r7, #4]
1057:../3rdParty/FreeRTOS/tasks.c **** 	}
1058:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1059:../3rdParty/FreeRTOS/tasks.c **** 
1060:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1061:../3rdParty/FreeRTOS/tasks.c **** 	{
1062:../3rdParty/FreeRTOS/tasks.c **** 		if( xReturn == pdPASS )
1063:../3rdParty/FreeRTOS/tasks.c **** 		{
1064:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1065:../3rdParty/FreeRTOS/tasks.c **** 		}
1066:../3rdParty/FreeRTOS/tasks.c **** 	}
1067:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1068:../3rdParty/FreeRTOS/tasks.c **** 
1069:../3rdParty/FreeRTOS/tasks.c **** 	if( xReturn == pdPASS )
 5058              		.loc 1 1069 0
 5059 07d0 7B68     		ldr	r3, [r7, #4]
 5060 07d2 012B     		cmp	r3, #1
 5061 07d4 15D1     		bne	.L76
1070:../3rdParty/FreeRTOS/tasks.c **** 	{
1071:../3rdParty/FreeRTOS/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1072:../3rdParty/FreeRTOS/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1073:../3rdParty/FreeRTOS/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1074:../3rdParty/FreeRTOS/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1075:../3rdParty/FreeRTOS/tasks.c **** 		starts to run.
1076:../3rdParty/FreeRTOS/tasks.c **** 
1077:../3rdParty/FreeRTOS/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1078:../3rdParty/FreeRTOS/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1079:../3rdParty/FreeRTOS/tasks.c **** 		portDISABLE_INTERRUPTS();
 5062              		.loc 1 1079 0
 5063              	@ 1079 "../3rdParty/FreeRTOS/tasks.c" 1
 5064 07d6 4FF02800 			mov r0, #40								
 5065 07da 80F31188 		msr basepri, r0							
 5066              	
 5067              	@ 0 "" 2
1080:../3rdParty/FreeRTOS/tasks.c **** 
1081:../3rdParty/FreeRTOS/tasks.c **** 		xSchedulerRunning = pdTRUE;
 5068              		.loc 1 1081 0
 5069              		.thumb
 5070 07de 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 5071 07e2 C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 5072 07e6 4FF00102 		mov	r2, #1
 5073 07ea 1A60     		str	r2, [r3, #0]
1082:../3rdParty/FreeRTOS/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 5074              		.loc 1 1082 0
 5075 07ec 40F20003 		movw	r3, #:lower16:xTickCount
 5076 07f0 C0F20003 		movt	r3, #:upper16:xTickCount
 5077 07f4 4FF00002 		mov	r2, #0
 5078 07f8 1A60     		str	r2, [r3, #0]
1083:../3rdParty/FreeRTOS/tasks.c **** 
1084:../3rdParty/FreeRTOS/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1085:../3rdParty/FreeRTOS/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1086:../3rdParty/FreeRTOS/tasks.c **** 		the run time counter time base. */
1087:../3rdParty/FreeRTOS/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 5079              		.loc 1 1087 0
 5080 07fa FFF7FEFF 		bl	vConfigureTimerForRunTimeStats
1088:../3rdParty/FreeRTOS/tasks.c **** 		
1089:../3rdParty/FreeRTOS/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1090:../3rdParty/FreeRTOS/tasks.c **** 		portable interface. */
1091:../3rdParty/FreeRTOS/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 5081              		.loc 1 1091 0
 5082 07fe FFF7FEFF 		bl	xPortStartScheduler
 5083              	.L76:
1092:../3rdParty/FreeRTOS/tasks.c **** 		{
1093:../3rdParty/FreeRTOS/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1094:../3rdParty/FreeRTOS/tasks.c **** 			function will not return. */
1095:../3rdParty/FreeRTOS/tasks.c **** 		}
1096:../3rdParty/FreeRTOS/tasks.c **** 		else
1097:../3rdParty/FreeRTOS/tasks.c **** 		{
1098:../3rdParty/FreeRTOS/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1099:../3rdParty/FreeRTOS/tasks.c **** 		}
1100:../3rdParty/FreeRTOS/tasks.c **** 	}
1101:../3rdParty/FreeRTOS/tasks.c **** 
1102:../3rdParty/FreeRTOS/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1103:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( xReturn );
1104:../3rdParty/FreeRTOS/tasks.c **** }
 5084              		.loc 1 1104 0
 5085 0802 07F10807 		add	r7, r7, #8
 5086 0806 BD46     		mov	sp, r7
 5087 0808 80BD     		pop	{r7, pc}
 5088              	.LFE65:
 5090 080a 00BF     		.align	2
 5091              		.global	vTaskEndScheduler
 5092              		.thumb
 5093              		.thumb_func
 5095              	vTaskEndScheduler:
 5096              	.LFB66:
1105:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1106:../3rdParty/FreeRTOS/tasks.c **** 
1107:../3rdParty/FreeRTOS/tasks.c **** void vTaskEndScheduler( void )
1108:../3rdParty/FreeRTOS/tasks.c **** {
 5097              		.loc 1 1108 0
 5098              		@ args = 0, pretend = 0, frame = 0
 5099              		@ frame_needed = 1, uses_anonymous_args = 0
 5100 080c 80B5     		push	{r7, lr}
 5101              	.LCFI33:
 5102 080e 00AF     		add	r7, sp, #0
 5103              	.LCFI34:
1109:../3rdParty/FreeRTOS/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1110:../3rdParty/FreeRTOS/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1111:../3rdParty/FreeRTOS/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1112:../3rdParty/FreeRTOS/tasks.c **** 	portDISABLE_INTERRUPTS();
 5104              		.loc 1 1112 0
 5105              	@ 1112 "../3rdParty/FreeRTOS/tasks.c" 1
 5106 0810 4FF02800 			mov r0, #40								
 5107 0814 80F31188 		msr basepri, r0							
 5108              	
 5109              	@ 0 "" 2
1113:../3rdParty/FreeRTOS/tasks.c **** 	xSchedulerRunning = pdFALSE;
 5110              		.loc 1 1113 0
 5111              		.thumb
 5112 0818 40F20003 		movw	r3, #:lower16:xSchedulerRunning
 5113 081c C0F20003 		movt	r3, #:upper16:xSchedulerRunning
 5114 0820 4FF00002 		mov	r2, #0
 5115 0824 1A60     		str	r2, [r3, #0]
1114:../3rdParty/FreeRTOS/tasks.c **** 	vPortEndScheduler();
 5116              		.loc 1 1114 0
 5117 0826 FFF7FEFF 		bl	vPortEndScheduler
1115:../3rdParty/FreeRTOS/tasks.c **** }
 5118              		.loc 1 1115 0
 5119 082a 80BD     		pop	{r7, pc}
 5120              	.LFE66:
 5122              		.align	2
 5123              		.global	vTaskSuspendAll
 5124              		.thumb
 5125              		.thumb_func
 5127              	vTaskSuspendAll:
 5128              	.LFB67:
1116:../3rdParty/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1117:../3rdParty/FreeRTOS/tasks.c **** 
1118:../3rdParty/FreeRTOS/tasks.c **** void vTaskSuspendAll( void )
1119:../3rdParty/FreeRTOS/tasks.c **** {
 5129              		.loc 1 1119 0
 5130              		@ args = 0, pretend = 0, frame = 0
 5131              		@ frame_needed = 1, uses_anonymous_args = 0
 5132              		@ link register save eliminated.
 5133 082c 80B4     		push	{r7}
 5134              	.LCFI35:
 5135 082e 00AF     		add	r7, sp, #0
 5136              	.LCFI36:
1120:../3rdParty/FreeRTOS/tasks.c **** 	/* A critical section is not required as the variable is of type
1121:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE. */
1122:../3rdParty/FreeRTOS/tasks.c **** 	++uxSchedulerSuspended;
 5137              		.loc 1 1122 0
 5138 0830 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 5139 0834 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 5140 0838 1B68     		ldr	r3, [r3, #0]
 5141 083a 03F10102 		add	r2, r3, #1
 5142 083e 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 5143 0842 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 5144 0846 1A60     		str	r2, [r3, #0]
1123:../3rdParty/FreeRTOS/tasks.c **** }
 5145              		.loc 1 1123 0
 5146 0848 BD46     		mov	sp, r7
 5147 084a 80BC     		pop	{r7}
 5148 084c 7047     		bx	lr
 5149              	.LFE67:
 5151 084e 00BF     		.align	2
 5152              		.global	xTaskResumeAll
 5153              		.thumb
 5154              		.thumb_func
 5156              	xTaskResumeAll:
 5157              	.LFB68:
1124:../3rdParty/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1125:../3rdParty/FreeRTOS/tasks.c **** 
1126:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1127:../3rdParty/FreeRTOS/tasks.c **** {
 5158              		.loc 1 1127 0
 5159              		@ args = 0, pretend = 0, frame = 8
 5160              		@ frame_needed = 1, uses_anonymous_args = 0
 5161 0850 90B5     		push	{r4, r7, lr}
 5162              	.LCFI37:
 5163 0852 83B0     		sub	sp, sp, #12
 5164              	.LCFI38:
 5165 0854 00AF     		add	r7, sp, #0
 5166              	.LCFI39:
1128:../3rdParty/FreeRTOS/tasks.c **** register tskTCB *pxTCB;
1129:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 5167              		.loc 1 1129 0
 5168 0856 4FF00003 		mov	r3, #0
 5169 085a 3B60     		str	r3, [r7, #0]
1130:../3rdParty/FreeRTOS/tasks.c **** 
1131:../3rdParty/FreeRTOS/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1132:../3rdParty/FreeRTOS/tasks.c **** 	previous call to vTaskSuspendAll(). */
1133:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1134:../3rdParty/FreeRTOS/tasks.c **** 
1135:../3rdParty/FreeRTOS/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1136:../3rdParty/FreeRTOS/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1137:../3rdParty/FreeRTOS/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1138:../3rdParty/FreeRTOS/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1139:../3rdParty/FreeRTOS/tasks.c **** 	tasks from this list into their appropriate ready list. */
1140:../3rdParty/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 5170              		.loc 1 1140 0
 5171 085c FFF7FEFF 		bl	vPortEnterCritical
1141:../3rdParty/FreeRTOS/tasks.c **** 	{
1142:../3rdParty/FreeRTOS/tasks.c **** 		--uxSchedulerSuspended;
 5172              		.loc 1 1142 0
 5173 0860 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 5174 0864 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 5175 0868 1B68     		ldr	r3, [r3, #0]
 5176 086a 03F1FF32 		add	r2, r3, #-1
 5177 086e 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 5178 0872 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 5179 0876 1A60     		str	r2, [r3, #0]
1143:../3rdParty/FreeRTOS/tasks.c **** 
1144:../3rdParty/FreeRTOS/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 5180              		.loc 1 1144 0
 5181 0878 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 5182 087c C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 5183 0880 1B68     		ldr	r3, [r3, #0]
 5184 0882 002B     		cmp	r3, #0
 5185 0884 40F08680 		bne	.L82
1145:../3rdParty/FreeRTOS/tasks.c **** 		{
1146:../3rdParty/FreeRTOS/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 5186              		.loc 1 1146 0
 5187 0888 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 5188 088c C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 5189 0890 1B68     		ldr	r3, [r3, #0]
 5190 0892 002B     		cmp	r3, #0
 5191 0894 7ED0     		beq	.L82
 5192              	.LBB3:
1147:../3rdParty/FreeRTOS/tasks.c **** 			{
1148:../3rdParty/FreeRTOS/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 5193              		.loc 1 1148 0
 5194 0896 4FF00003 		mov	r3, #0
 5195 089a 7B60     		str	r3, [r7, #4]
1149:../3rdParty/FreeRTOS/tasks.c **** 
1150:../3rdParty/FreeRTOS/tasks.c **** 				/* Move any readied tasks from the pending list into the
1151:../3rdParty/FreeRTOS/tasks.c **** 				appropriate ready list. */
1152:../3rdParty/FreeRTOS/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 5196              		.loc 1 1152 0
 5197 089c 3DE0     		b	.L83
 5198              	.L85:
1153:../3rdParty/FreeRTOS/tasks.c **** 				{
1154:../3rdParty/FreeRTOS/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 5199              		.loc 1 1154 0
 5200 089e 40F20003 		movw	r3, #:lower16:xPendingReadyList
 5201 08a2 C0F20003 		movt	r3, #:upper16:xPendingReadyList
 5202 08a6 DB68     		ldr	r3, [r3, #12]
 5203 08a8 DB68     		ldr	r3, [r3, #12]
 5204 08aa 1C46     		mov	r4, r3
1155:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 5205              		.loc 1 1155 0
 5206 08ac 04F11803 		add	r3, r4, #24
 5207 08b0 1846     		mov	r0, r3
 5208 08b2 FFF7FEFF 		bl	vListRemove
1156:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 5209              		.loc 1 1156 0
 5210 08b6 04F10403 		add	r3, r4, #4
 5211 08ba 1846     		mov	r0, r3
 5212 08bc FFF7FEFF 		bl	vListRemove
1157:../3rdParty/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 5213              		.loc 1 1157 0
 5214 08c0 E26A     		ldr	r2, [r4, #44]
 5215 08c2 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 5216 08c6 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 5217 08ca 1B68     		ldr	r3, [r3, #0]
 5218 08cc 9A42     		cmp	r2, r3
 5219 08ce 05D9     		bls	.L84
 5220 08d0 E26A     		ldr	r2, [r4, #44]
 5221 08d2 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 5222 08d6 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 5223 08da 1A60     		str	r2, [r3, #0]
 5224              	.L84:
 5225 08dc E26A     		ldr	r2, [r4, #44]
 5226 08de 1346     		mov	r3, r2
 5227 08e0 4FEA8303 		lsl	r3, r3, #2
 5228 08e4 1344     		add	r3, r3, r2
 5229 08e6 4FEA8303 		lsl	r3, r3, #2
 5230 08ea 1A46     		mov	r2, r3
 5231 08ec 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 5232 08f0 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 5233 08f4 1A44     		add	r2, r2, r3
 5234 08f6 04F10403 		add	r3, r4, #4
 5235 08fa 1046     		mov	r0, r2
 5236 08fc 1946     		mov	r1, r3
 5237 08fe FFF7FEFF 		bl	vListInsertEnd
1158:../3rdParty/FreeRTOS/tasks.c **** 
1159:../3rdParty/FreeRTOS/tasks.c **** 					/* If we have moved a task that has a priority higher than
1160:../3rdParty/FreeRTOS/tasks.c **** 					the current task then we should yield. */
1161:../3rdParty/FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 5238              		.loc 1 1161 0
 5239 0902 E26A     		ldr	r2, [r4, #44]
 5240 0904 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 5241 0908 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 5242 090c 1B68     		ldr	r3, [r3, #0]
 5243 090e DB6A     		ldr	r3, [r3, #44]
 5244 0910 9A42     		cmp	r2, r3
 5245 0912 02D3     		bcc	.L83
1162:../3rdParty/FreeRTOS/tasks.c **** 					{
1163:../3rdParty/FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 5246              		.loc 1 1163 0
 5247 0914 4FF00103 		mov	r3, #1
 5248 0918 7B60     		str	r3, [r7, #4]
 5249              	.L83:
 5250              		.loc 1 1152 0
 5251 091a 40F20003 		movw	r3, #:lower16:xPendingReadyList
 5252 091e C0F20003 		movt	r3, #:upper16:xPendingReadyList
 5253 0922 1B68     		ldr	r3, [r3, #0]
 5254 0924 002B     		cmp	r3, #0
 5255 0926 BAD1     		bne	.L85
1164:../3rdParty/FreeRTOS/tasks.c **** 					}
1165:../3rdParty/FreeRTOS/tasks.c **** 				}
1166:../3rdParty/FreeRTOS/tasks.c **** 
1167:../3rdParty/FreeRTOS/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1168:../3rdParty/FreeRTOS/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1169:../3rdParty/FreeRTOS/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1170:../3rdParty/FreeRTOS/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 5256              		.loc 1 1170 0
 5257 0928 40F20003 		movw	r3, #:lower16:uxMissedTicks
 5258 092c C0F20003 		movt	r3, #:upper16:uxMissedTicks
 5259 0930 1B68     		ldr	r3, [r3, #0]
 5260 0932 002B     		cmp	r3, #0
 5261 0934 18D0     		beq	.L86
1171:../3rdParty/FreeRTOS/tasks.c **** 				{
1172:../3rdParty/FreeRTOS/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 5262              		.loc 1 1172 0
 5263 0936 0DE0     		b	.L87
 5264              	.L88:
1173:../3rdParty/FreeRTOS/tasks.c **** 					{
1174:../3rdParty/FreeRTOS/tasks.c **** 						vTaskIncrementTick();
 5265              		.loc 1 1174 0
 5266 0938 FFF7FEFF 		bl	vTaskIncrementTick
1175:../3rdParty/FreeRTOS/tasks.c **** 						--uxMissedTicks;
 5267              		.loc 1 1175 0
 5268 093c 40F20003 		movw	r3, #:lower16:uxMissedTicks
 5269 0940 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 5270 0944 1B68     		ldr	r3, [r3, #0]
 5271 0946 03F1FF32 		add	r2, r3, #-1
 5272 094a 40F20003 		movw	r3, #:lower16:uxMissedTicks
 5273 094e C0F20003 		movt	r3, #:upper16:uxMissedTicks
 5274 0952 1A60     		str	r2, [r3, #0]
 5275              	.L87:
 5276              		.loc 1 1172 0
 5277 0954 40F20003 		movw	r3, #:lower16:uxMissedTicks
 5278 0958 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 5279 095c 1B68     		ldr	r3, [r3, #0]
 5280 095e 002B     		cmp	r3, #0
 5281 0960 EAD1     		bne	.L88
1176:../3rdParty/FreeRTOS/tasks.c **** 					}
1177:../3rdParty/FreeRTOS/tasks.c **** 
1178:../3rdParty/FreeRTOS/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1179:../3rdParty/FreeRTOS/tasks.c **** 					to ensure the highest priority task that is ready to run is
1180:../3rdParty/FreeRTOS/tasks.c **** 					the task actually running. */
1181:../3rdParty/FreeRTOS/tasks.c **** 					#if configUSE_PREEMPTION == 1
1182:../3rdParty/FreeRTOS/tasks.c **** 					{
1183:../3rdParty/FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 5282              		.loc 1 1183 0
 5283 0962 4FF00103 		mov	r3, #1
 5284 0966 7B60     		str	r3, [r7, #4]
 5285              	.L86:
1184:../3rdParty/FreeRTOS/tasks.c **** 					}
1185:../3rdParty/FreeRTOS/tasks.c **** 					#endif
1186:../3rdParty/FreeRTOS/tasks.c **** 				}
1187:../3rdParty/FreeRTOS/tasks.c **** 
1188:../3rdParty/FreeRTOS/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 5286              		.loc 1 1188 0
 5287 0968 7B68     		ldr	r3, [r7, #4]
 5288 096a 012B     		cmp	r3, #1
 5289 096c 06D0     		beq	.L89
 5290 096e 40F20003 		movw	r3, #:lower16:xMissedYield
 5291 0972 C0F20003 		movt	r3, #:upper16:xMissedYield
 5292 0976 1B68     		ldr	r3, [r3, #0]
 5293 0978 012B     		cmp	r3, #1
 5294 097a 0BD1     		bne	.L82
 5295              	.L89:
1189:../3rdParty/FreeRTOS/tasks.c **** 				{
1190:../3rdParty/FreeRTOS/tasks.c **** 					xAlreadyYielded = pdTRUE;
 5296              		.loc 1 1190 0
 5297 097c 4FF00103 		mov	r3, #1
 5298 0980 3B60     		str	r3, [r7, #0]
1191:../3rdParty/FreeRTOS/tasks.c **** 					xMissedYield = pdFALSE;
 5299              		.loc 1 1191 0
 5300 0982 40F20003 		movw	r3, #:lower16:xMissedYield
 5301 0986 C0F20003 		movt	r3, #:upper16:xMissedYield
 5302 098a 4FF00002 		mov	r2, #0
 5303 098e 1A60     		str	r2, [r3, #0]
1192:../3rdParty/FreeRTOS/tasks.c **** 					portYIELD_WITHIN_API();
 5304              		.loc 1 1192 0
 5305 0990 FFF7FEFF 		bl	vPortYieldFromISR
 5306              	.L82:
 5307              	.LBE3:
1193:../3rdParty/FreeRTOS/tasks.c **** 				}
1194:../3rdParty/FreeRTOS/tasks.c **** 			}
1195:../3rdParty/FreeRTOS/tasks.c **** 		}
1196:../3rdParty/FreeRTOS/tasks.c **** 	}
1197:../3rdParty/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 5308              		.loc 1 1197 0
 5309 0994 FFF7FEFF 		bl	vPortExitCritical
1198:../3rdParty/FreeRTOS/tasks.c **** 
1199:../3rdParty/FreeRTOS/tasks.c **** 	return xAlreadyYielded;
 5310              		.loc 1 1199 0
 5311 0998 3B68     		ldr	r3, [r7, #0]
1200:../3rdParty/FreeRTOS/tasks.c **** }
 5312              		.loc 1 1200 0
 5313 099a 1846     		mov	r0, r3
 5314 099c 07F10C07 		add	r7, r7, #12
 5315 09a0 BD46     		mov	sp, r7
 5316 09a2 90BD     		pop	{r4, r7, pc}
 5317              	.LFE68:
 5319              		.align	2
 5320              		.global	xTaskGetTickCount
 5321              		.thumb
 5322              		.thumb_func
 5324              	xTaskGetTickCount:
 5325              	.LFB69:
1201:../3rdParty/FreeRTOS/tasks.c **** 
1202:../3rdParty/FreeRTOS/tasks.c **** 
1203:../3rdParty/FreeRTOS/tasks.c **** 
1204:../3rdParty/FreeRTOS/tasks.c **** 
1205:../3rdParty/FreeRTOS/tasks.c **** 
1206:../3rdParty/FreeRTOS/tasks.c **** 
1207:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1208:../3rdParty/FreeRTOS/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1209:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1210:../3rdParty/FreeRTOS/tasks.c **** 
1211:../3rdParty/FreeRTOS/tasks.c **** 
1212:../3rdParty/FreeRTOS/tasks.c **** 
1213:../3rdParty/FreeRTOS/tasks.c **** portTickType xTaskGetTickCount( void )
1214:../3rdParty/FreeRTOS/tasks.c **** {
 5326              		.loc 1 1214 0
 5327              		@ args = 0, pretend = 0, frame = 8
 5328              		@ frame_needed = 1, uses_anonymous_args = 0
 5329 09a4 80B5     		push	{r7, lr}
 5330              	.LCFI40:
 5331 09a6 82B0     		sub	sp, sp, #8
 5332              	.LCFI41:
 5333 09a8 00AF     		add	r7, sp, #0
 5334              	.LCFI42:
1215:../3rdParty/FreeRTOS/tasks.c **** portTickType xTicks;
1216:../3rdParty/FreeRTOS/tasks.c **** 
1217:../3rdParty/FreeRTOS/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1218:../3rdParty/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 5335              		.loc 1 1218 0
 5336 09aa FFF7FEFF 		bl	vPortEnterCritical
1219:../3rdParty/FreeRTOS/tasks.c **** 	{
1220:../3rdParty/FreeRTOS/tasks.c **** 		xTicks = xTickCount;
 5337              		.loc 1 1220 0
 5338 09ae 40F20003 		movw	r3, #:lower16:xTickCount
 5339 09b2 C0F20003 		movt	r3, #:upper16:xTickCount
 5340 09b6 1B68     		ldr	r3, [r3, #0]
 5341 09b8 7B60     		str	r3, [r7, #4]
1221:../3rdParty/FreeRTOS/tasks.c **** 	}
1222:../3rdParty/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 5342              		.loc 1 1222 0
 5343 09ba FFF7FEFF 		bl	vPortExitCritical
1223:../3rdParty/FreeRTOS/tasks.c **** 
1224:../3rdParty/FreeRTOS/tasks.c **** 	return xTicks;
 5344              		.loc 1 1224 0
 5345 09be 7B68     		ldr	r3, [r7, #4]
1225:../3rdParty/FreeRTOS/tasks.c **** }
 5346              		.loc 1 1225 0
 5347 09c0 1846     		mov	r0, r3
 5348 09c2 07F10807 		add	r7, r7, #8
 5349 09c6 BD46     		mov	sp, r7
 5350 09c8 80BD     		pop	{r7, pc}
 5351              	.LFE69:
 5353 09ca 00BF     		.align	2
 5354              		.global	xTaskGetTickCountFromISR
 5355              		.thumb
 5356              		.thumb_func
 5358              	xTaskGetTickCountFromISR:
 5359              	.LFB70:
1226:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1227:../3rdParty/FreeRTOS/tasks.c **** 
1228:../3rdParty/FreeRTOS/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1229:../3rdParty/FreeRTOS/tasks.c **** {
 5360              		.loc 1 1229 0
 5361              		@ args = 0, pretend = 0, frame = 8
 5362              		@ frame_needed = 1, uses_anonymous_args = 0
 5363              		@ link register save eliminated.
 5364 09cc 80B4     		push	{r7}
 5365              	.LCFI43:
 5366 09ce 83B0     		sub	sp, sp, #12
 5367              	.LCFI44:
 5368 09d0 00AF     		add	r7, sp, #0
 5369              	.LCFI45:
1230:../3rdParty/FreeRTOS/tasks.c **** portTickType xReturn;
1231:../3rdParty/FreeRTOS/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1232:../3rdParty/FreeRTOS/tasks.c **** 
1233:../3rdParty/FreeRTOS/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 5370              		.loc 1 1233 0
 5371 09d2 4FF00003 		mov	r3, #0
 5372 09d6 7B60     		str	r3, [r7, #4]
 5373              	@ 1233 "../3rdParty/FreeRTOS/tasks.c" 1
 5374 09d8 4FF02800 			mov r0, #40								
 5375 09dc 80F31188 		msr basepri, r0							
 5376              	
 5377              	@ 0 "" 2
1234:../3rdParty/FreeRTOS/tasks.c **** 	xReturn = xTickCount;
 5378              		.loc 1 1234 0
 5379              		.thumb
 5380 09e0 40F20003 		movw	r3, #:lower16:xTickCount
 5381 09e4 C0F20003 		movt	r3, #:upper16:xTickCount
 5382 09e8 1B68     		ldr	r3, [r3, #0]
 5383 09ea 3B60     		str	r3, [r7, #0]
1235:../3rdParty/FreeRTOS/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 5384              		.loc 1 1235 0
 5385              	@ 1235 "../3rdParty/FreeRTOS/tasks.c" 1
 5386 09ec 4FF00000 			mov r0, #0					
 5387 09f0 80F31188 		msr basepri, r0				
 5388              	
 5389              	@ 0 "" 2
1236:../3rdParty/FreeRTOS/tasks.c **** 
1237:../3rdParty/FreeRTOS/tasks.c **** 	return xReturn;
 5390              		.loc 1 1237 0
 5391              		.thumb
 5392 09f4 3B68     		ldr	r3, [r7, #0]
1238:../3rdParty/FreeRTOS/tasks.c **** }
 5393              		.loc 1 1238 0
 5394 09f6 1846     		mov	r0, r3
 5395 09f8 07F10C07 		add	r7, r7, #12
 5396 09fc BD46     		mov	sp, r7
 5397 09fe 80BC     		pop	{r7}
 5398 0a00 7047     		bx	lr
 5399              	.LFE70:
 5401 0a02 00BF     		.align	2
 5402              		.global	uxTaskGetNumberOfTasks
 5403              		.thumb
 5404              		.thumb_func
 5406              	uxTaskGetNumberOfTasks:
 5407              	.LFB71:
1239:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1240:../3rdParty/FreeRTOS/tasks.c **** 
1241:../3rdParty/FreeRTOS/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1242:../3rdParty/FreeRTOS/tasks.c **** {
 5408              		.loc 1 1242 0
 5409              		@ args = 0, pretend = 0, frame = 0
 5410              		@ frame_needed = 1, uses_anonymous_args = 0
 5411              		@ link register save eliminated.
 5412 0a04 80B4     		push	{r7}
 5413              	.LCFI46:
 5414 0a06 00AF     		add	r7, sp, #0
 5415              	.LCFI47:
1243:../3rdParty/FreeRTOS/tasks.c **** 	/* A critical section is not required because the variables are of type
1244:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE. */
1245:../3rdParty/FreeRTOS/tasks.c **** 	return uxCurrentNumberOfTasks;
 5416              		.loc 1 1245 0
 5417 0a08 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 5418 0a0c C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 5419 0a10 1B68     		ldr	r3, [r3, #0]
1246:../3rdParty/FreeRTOS/tasks.c **** }
 5420              		.loc 1 1246 0
 5421 0a12 1846     		mov	r0, r3
 5422 0a14 BD46     		mov	sp, r7
 5423 0a16 80BC     		pop	{r7}
 5424 0a18 7047     		bx	lr
 5425              	.LFE71:
 5427              		.section	.rodata
 5428 0005 000000   		.align	2
 5429              	.LC1:
 5430 0008 0D0A00   		.ascii	"\015\012\000"
 5431              		.text
 5432 0a1a 00BF     		.align	2
 5433              		.global	vTaskList
 5434              		.thumb
 5435              		.thumb_func
 5437              	vTaskList:
 5438              	.LFB72:
1247:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1248:../3rdParty/FreeRTOS/tasks.c **** 
1249:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1250:../3rdParty/FreeRTOS/tasks.c **** 
1251:../3rdParty/FreeRTOS/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1252:../3rdParty/FreeRTOS/tasks.c **** 	{
1253:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1254:../3rdParty/FreeRTOS/tasks.c **** 
1255:../3rdParty/FreeRTOS/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1256:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1257:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxTCB );
1258:../3rdParty/FreeRTOS/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1259:../3rdParty/FreeRTOS/tasks.c **** 	}
1260:../3rdParty/FreeRTOS/tasks.c **** 
1261:../3rdParty/FreeRTOS/tasks.c **** #endif
1262:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1263:../3rdParty/FreeRTOS/tasks.c **** 
1264:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1265:../3rdParty/FreeRTOS/tasks.c **** 
1266:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1267:../3rdParty/FreeRTOS/tasks.c **** 	{
 5439              		.loc 1 1267 0
 5440              		@ args = 0, pretend = 0, frame = 16
 5441              		@ frame_needed = 1, uses_anonymous_args = 0
 5442 0a1c 90B5     		push	{r4, r7, lr}
 5443              	.LCFI48:
 5444 0a1e 85B0     		sub	sp, sp, #20
 5445              	.LCFI49:
 5446 0a20 00AF     		add	r7, sp, #0
 5447              	.LCFI50:
 5448 0a22 7860     		str	r0, [r7, #4]
1268:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1269:../3rdParty/FreeRTOS/tasks.c **** 
1270:../3rdParty/FreeRTOS/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1271:../3rdParty/FreeRTOS/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1272:../3rdParty/FreeRTOS/tasks.c **** 
1273:../3rdParty/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
 5449              		.loc 1 1273 0
 5450 0a24 FFF7FEFF 		bl	vTaskSuspendAll
1274:../3rdParty/FreeRTOS/tasks.c **** 		{
1275:../3rdParty/FreeRTOS/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1276:../3rdParty/FreeRTOS/tasks.c **** 			report the task name, state and stack high water mark. */
1277:../3rdParty/FreeRTOS/tasks.c **** 
1278:../3rdParty/FreeRTOS/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
 5451              		.loc 1 1278 0
 5452 0a28 7B68     		ldr	r3, [r7, #4]
 5453 0a2a 4FF00002 		mov	r2, #0
 5454 0a2e 1A70     		strb	r2, [r3, #0]
1279:../3rdParty/FreeRTOS/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 5455              		.loc 1 1279 0
 5456 0a30 7C68     		ldr	r4, [r7, #4]
 5457 0a32 2046     		mov	r0, r4
 5458 0a34 FFF7FEFF 		bl	strlen
 5459 0a38 0346     		mov	r3, r0
 5460 0a3a 2344     		add	r3, r4, r3
 5461 0a3c 1846     		mov	r0, r3
 5462 0a3e 40F20001 		movw	r1, #:lower16:.LC1
 5463 0a42 C0F20001 		movt	r1, #:upper16:.LC1
 5464 0a46 4FF00302 		mov	r2, #3
 5465 0a4a FFF7FEFF 		bl	memcpy
1280:../3rdParty/FreeRTOS/tasks.c **** 
1281:../3rdParty/FreeRTOS/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 5466              		.loc 1 1281 0
 5467 0a4e 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 5468 0a52 C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 5469 0a56 1B68     		ldr	r3, [r3, #0]
 5470 0a58 03F10103 		add	r3, r3, #1
 5471 0a5c FB60     		str	r3, [r7, #12]
 5472              	.L99:
1282:../3rdParty/FreeRTOS/tasks.c **** 
1283:../3rdParty/FreeRTOS/tasks.c **** 			do
1284:../3rdParty/FreeRTOS/tasks.c **** 			{
1285:../3rdParty/FreeRTOS/tasks.c **** 				uxQueue--;
 5473              		.loc 1 1285 0
 5474 0a5e FB68     		ldr	r3, [r7, #12]
 5475 0a60 03F1FF33 		add	r3, r3, #-1
 5476 0a64 FB60     		str	r3, [r7, #12]
1286:../3rdParty/FreeRTOS/tasks.c **** 
1287:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 5477              		.loc 1 1287 0
 5478 0a66 FA68     		ldr	r2, [r7, #12]
 5479 0a68 1346     		mov	r3, r2
 5480 0a6a 4FEA8303 		lsl	r3, r3, #2
 5481 0a6e 1344     		add	r3, r3, r2
 5482 0a70 4FEA8303 		lsl	r3, r3, #2
 5483 0a74 1A46     		mov	r2, r3
 5484 0a76 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 5485 0a7a C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 5486 0a7e 1344     		add	r3, r2, r3
 5487 0a80 1B68     		ldr	r3, [r3, #0]
 5488 0a82 002B     		cmp	r3, #0
 5489 0a84 12D0     		beq	.L98
1288:../3rdParty/FreeRTOS/tasks.c **** 				{
1289:../3rdParty/FreeRTOS/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
 5490              		.loc 1 1289 0
 5491 0a86 FA68     		ldr	r2, [r7, #12]
 5492 0a88 1346     		mov	r3, r2
 5493 0a8a 4FEA8303 		lsl	r3, r3, #2
 5494 0a8e 1344     		add	r3, r3, r2
 5495 0a90 4FEA8303 		lsl	r3, r3, #2
 5496 0a94 1A46     		mov	r2, r3
 5497 0a96 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 5498 0a9a C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 5499 0a9e 1344     		add	r3, r2, r3
 5500 0aa0 7868     		ldr	r0, [r7, #4]
 5501 0aa2 1946     		mov	r1, r3
 5502 0aa4 4FF05202 		mov	r2, #82
 5503 0aa8 00F03EFD 		bl	prvListTaskWithinSingleList
 5504              	.L98:
1290:../3rdParty/FreeRTOS/tasks.c **** 				}
1291:../3rdParty/FreeRTOS/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 5505              		.loc 1 1291 0
 5506 0aac FB68     		ldr	r3, [r7, #12]
 5507 0aae 002B     		cmp	r3, #0
 5508 0ab0 D5D1     		bne	.L99
1292:../3rdParty/FreeRTOS/tasks.c **** 
1293:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 5509              		.loc 1 1293 0
 5510 0ab2 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 5511 0ab6 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 5512 0aba 1B68     		ldr	r3, [r3, #0]
 5513 0abc 1B68     		ldr	r3, [r3, #0]
 5514 0abe 002B     		cmp	r3, #0
 5515 0ac0 0AD0     		beq	.L100
1294:../3rdParty/FreeRTOS/tasks.c **** 			{
1295:../3rdParty/FreeRTOS/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
 5516              		.loc 1 1295 0
 5517 0ac2 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 5518 0ac6 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 5519 0aca 1B68     		ldr	r3, [r3, #0]
 5520 0acc 7868     		ldr	r0, [r7, #4]
 5521 0ace 1946     		mov	r1, r3
 5522 0ad0 4FF04202 		mov	r2, #66
 5523 0ad4 00F028FD 		bl	prvListTaskWithinSingleList
 5524              	.L100:
1296:../3rdParty/FreeRTOS/tasks.c **** 			}
1297:../3rdParty/FreeRTOS/tasks.c **** 
1298:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 5525              		.loc 1 1298 0
 5526 0ad8 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 5527 0adc C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 5528 0ae0 1B68     		ldr	r3, [r3, #0]
 5529 0ae2 1B68     		ldr	r3, [r3, #0]
 5530 0ae4 002B     		cmp	r3, #0
 5531 0ae6 0AD0     		beq	.L101
1299:../3rdParty/FreeRTOS/tasks.c **** 			{
1300:../3rdParty/FreeRTOS/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
 5532              		.loc 1 1300 0
 5533 0ae8 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 5534 0aec C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 5535 0af0 1B68     		ldr	r3, [r3, #0]
 5536 0af2 7868     		ldr	r0, [r7, #4]
 5537 0af4 1946     		mov	r1, r3
 5538 0af6 4FF04202 		mov	r2, #66
 5539 0afa 00F015FD 		bl	prvListTaskWithinSingleList
 5540              	.L101:
1301:../3rdParty/FreeRTOS/tasks.c **** 			}
1302:../3rdParty/FreeRTOS/tasks.c **** 
1303:../3rdParty/FreeRTOS/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1304:../3rdParty/FreeRTOS/tasks.c **** 			{
1305:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 5541              		.loc 1 1305 0
 5542 0afe 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 5543 0b02 C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 5544 0b06 1B68     		ldr	r3, [r3, #0]
 5545 0b08 002B     		cmp	r3, #0
 5546 0b0a 08D0     		beq	.L102
1306:../3rdParty/FreeRTOS/tasks.c **** 				{
1307:../3rdParty/FreeRTOS/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
 5547              		.loc 1 1307 0
 5548 0b0c 7868     		ldr	r0, [r7, #4]
 5549 0b0e 40F20001 		movw	r1, #:lower16:xTasksWaitingTermination
 5550 0b12 C0F20001 		movt	r1, #:upper16:xTasksWaitingTermination
 5551 0b16 4FF04402 		mov	r2, #68
 5552 0b1a 00F005FD 		bl	prvListTaskWithinSingleList
 5553              	.L102:
1308:../3rdParty/FreeRTOS/tasks.c **** 				}
1309:../3rdParty/FreeRTOS/tasks.c **** 			}
1310:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1311:../3rdParty/FreeRTOS/tasks.c **** 
1312:../3rdParty/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1313:../3rdParty/FreeRTOS/tasks.c **** 			{
1314:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 5554              		.loc 1 1314 0
 5555 0b1e 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 5556 0b22 C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 5557 0b26 1B68     		ldr	r3, [r3, #0]
 5558 0b28 002B     		cmp	r3, #0
 5559 0b2a 08D0     		beq	.L103
1315:../3rdParty/FreeRTOS/tasks.c **** 				{
1316:../3rdParty/FreeRTOS/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
 5560              		.loc 1 1316 0
 5561 0b2c 7868     		ldr	r0, [r7, #4]
 5562 0b2e 40F20001 		movw	r1, #:lower16:xSuspendedTaskList
 5563 0b32 C0F20001 		movt	r1, #:upper16:xSuspendedTaskList
 5564 0b36 4FF05302 		mov	r2, #83
 5565 0b3a 00F0F5FC 		bl	prvListTaskWithinSingleList
 5566              	.L103:
1317:../3rdParty/FreeRTOS/tasks.c **** 				}
1318:../3rdParty/FreeRTOS/tasks.c **** 			}
1319:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1320:../3rdParty/FreeRTOS/tasks.c **** 		}
1321:../3rdParty/FreeRTOS/tasks.c **** 		xTaskResumeAll();
 5567              		.loc 1 1321 0
 5568 0b3e FFF7FEFF 		bl	xTaskResumeAll
1322:../3rdParty/FreeRTOS/tasks.c **** 	}
 5569              		.loc 1 1322 0
 5570 0b42 07F11407 		add	r7, r7, #20
 5571 0b46 BD46     		mov	sp, r7
 5572 0b48 90BD     		pop	{r4, r7, pc}
 5573              	.LFE72:
 5575 0b4a 00BF     		.align	2
 5576              		.global	vTaskGetRunTimeStats
 5577              		.thumb
 5578              		.thumb_func
 5580              	vTaskGetRunTimeStats:
 5581              	.LFB73:
1323:../3rdParty/FreeRTOS/tasks.c **** 
1324:../3rdParty/FreeRTOS/tasks.c **** #endif
1325:../3rdParty/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1326:../3rdParty/FreeRTOS/tasks.c **** 
1327:../3rdParty/FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1328:../3rdParty/FreeRTOS/tasks.c **** 
1329:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1330:../3rdParty/FreeRTOS/tasks.c **** 	{
 5582              		.loc 1 1330 0
 5583              		@ args = 0, pretend = 0, frame = 16
 5584              		@ frame_needed = 1, uses_anonymous_args = 0
 5585 0b4c 90B5     		push	{r4, r7, lr}
 5586              	.LCFI51:
 5587 0b4e 85B0     		sub	sp, sp, #20
 5588              	.LCFI52:
 5589 0b50 00AF     		add	r7, sp, #0
 5590              	.LCFI53:
 5591 0b52 7860     		str	r0, [r7, #4]
1331:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1332:../3rdParty/FreeRTOS/tasks.c **** 	unsigned long ulTotalRunTime;
1333:../3rdParty/FreeRTOS/tasks.c **** 
1334:../3rdParty/FreeRTOS/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1335:../3rdParty/FreeRTOS/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1336:../3rdParty/FreeRTOS/tasks.c **** 
1337:../3rdParty/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
 5592              		.loc 1 1337 0
 5593 0b54 FFF7FEFF 		bl	vTaskSuspendAll
1338:../3rdParty/FreeRTOS/tasks.c **** 		{
1339:../3rdParty/FreeRTOS/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1340:../3rdParty/FreeRTOS/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1341:../3rdParty/FreeRTOS/tasks.c **** 			#else
1342:../3rdParty/FreeRTOS/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 5594              		.loc 1 1342 0
 5595 0b58 44F20003 		movw	r3, #:lower16:1073758208
 5596 0b5c C4F20003 		movt	r3, #:upper16:1073758208
 5597 0b60 9B68     		ldr	r3, [r3, #8]
 5598 0b62 FB60     		str	r3, [r7, #12]
1343:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1344:../3rdParty/FreeRTOS/tasks.c **** 
1345:../3rdParty/FreeRTOS/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1346:../3rdParty/FreeRTOS/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1347:../3rdParty/FreeRTOS/tasks.c **** 			ulTotalRunTime /= 100UL;
 5599              		.loc 1 1347 0
 5600 0b64 FA68     		ldr	r2, [r7, #12]
 5601 0b66 48F21F53 		movw	r3, #:lower16:1374389535
 5602 0b6a C5F2EB13 		movt	r3, #:upper16:1374389535
 5603 0b6e A3FB0213 		umull	r1, r3, r3, r2
 5604 0b72 4FEA5313 		lsr	r3, r3, #5
 5605 0b76 FB60     		str	r3, [r7, #12]
1348:../3rdParty/FreeRTOS/tasks.c **** 			
1349:../3rdParty/FreeRTOS/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1350:../3rdParty/FreeRTOS/tasks.c **** 			generating a table of run timer percentages in the provided
1351:../3rdParty/FreeRTOS/tasks.c **** 			buffer. */
1352:../3rdParty/FreeRTOS/tasks.c **** 
1353:../3rdParty/FreeRTOS/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
 5606              		.loc 1 1353 0
 5607 0b78 7B68     		ldr	r3, [r7, #4]
 5608 0b7a 4FF00002 		mov	r2, #0
 5609 0b7e 1A70     		strb	r2, [r3, #0]
1354:../3rdParty/FreeRTOS/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 5610              		.loc 1 1354 0
 5611 0b80 7C68     		ldr	r4, [r7, #4]
 5612 0b82 2046     		mov	r0, r4
 5613 0b84 FFF7FEFF 		bl	strlen
 5614 0b88 0346     		mov	r3, r0
 5615 0b8a 2344     		add	r3, r4, r3
 5616 0b8c 1846     		mov	r0, r3
 5617 0b8e 40F20001 		movw	r1, #:lower16:.LC1
 5618 0b92 C0F20001 		movt	r1, #:upper16:.LC1
 5619 0b96 4FF00302 		mov	r2, #3
 5620 0b9a FFF7FEFF 		bl	memcpy
1355:../3rdParty/FreeRTOS/tasks.c **** 
1356:../3rdParty/FreeRTOS/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 5621              		.loc 1 1356 0
 5622 0b9e 40F20003 		movw	r3, #:lower16:uxTopUsedPriority
 5623 0ba2 C0F20003 		movt	r3, #:upper16:uxTopUsedPriority
 5624 0ba6 1B68     		ldr	r3, [r3, #0]
 5625 0ba8 03F10103 		add	r3, r3, #1
 5626 0bac BB60     		str	r3, [r7, #8]
 5627              	.L107:
1357:../3rdParty/FreeRTOS/tasks.c **** 
1358:../3rdParty/FreeRTOS/tasks.c **** 			do
1359:../3rdParty/FreeRTOS/tasks.c **** 			{
1360:../3rdParty/FreeRTOS/tasks.c **** 				uxQueue--;
 5628              		.loc 1 1360 0
 5629 0bae BB68     		ldr	r3, [r7, #8]
 5630 0bb0 03F1FF33 		add	r3, r3, #-1
 5631 0bb4 BB60     		str	r3, [r7, #8]
1361:../3rdParty/FreeRTOS/tasks.c **** 
1362:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 5632              		.loc 1 1362 0
 5633 0bb6 BA68     		ldr	r2, [r7, #8]
 5634 0bb8 1346     		mov	r3, r2
 5635 0bba 4FEA8303 		lsl	r3, r3, #2
 5636 0bbe 1344     		add	r3, r3, r2
 5637 0bc0 4FEA8303 		lsl	r3, r3, #2
 5638 0bc4 1A46     		mov	r2, r3
 5639 0bc6 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 5640 0bca C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 5641 0bce 1344     		add	r3, r2, r3
 5642 0bd0 1B68     		ldr	r3, [r3, #0]
 5643 0bd2 002B     		cmp	r3, #0
 5644 0bd4 11D0     		beq	.L106
1363:../3rdParty/FreeRTOS/tasks.c **** 				{
1364:../3rdParty/FreeRTOS/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
 5645              		.loc 1 1364 0
 5646 0bd6 BA68     		ldr	r2, [r7, #8]
 5647 0bd8 1346     		mov	r3, r2
 5648 0bda 4FEA8303 		lsl	r3, r3, #2
 5649 0bde 1344     		add	r3, r3, r2
 5650 0be0 4FEA8303 		lsl	r3, r3, #2
 5651 0be4 1A46     		mov	r2, r3
 5652 0be6 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 5653 0bea C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 5654 0bee 1344     		add	r3, r2, r3
 5655 0bf0 7868     		ldr	r0, [r7, #4]
 5656 0bf2 1946     		mov	r1, r3
 5657 0bf4 FA68     		ldr	r2, [r7, #12]
 5658 0bf6 00F0FDFC 		bl	prvGenerateRunTimeStatsForTasksInList
 5659              	.L106:
1365:../3rdParty/FreeRTOS/tasks.c **** 				}
1366:../3rdParty/FreeRTOS/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 5660              		.loc 1 1366 0
 5661 0bfa BB68     		ldr	r3, [r7, #8]
 5662 0bfc 002B     		cmp	r3, #0
 5663 0bfe D6D1     		bne	.L107
1367:../3rdParty/FreeRTOS/tasks.c **** 
1368:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 5664              		.loc 1 1368 0
 5665 0c00 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 5666 0c04 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 5667 0c08 1B68     		ldr	r3, [r3, #0]
 5668 0c0a 1B68     		ldr	r3, [r3, #0]
 5669 0c0c 002B     		cmp	r3, #0
 5670 0c0e 09D0     		beq	.L108
1369:../3rdParty/FreeRTOS/tasks.c **** 			{
1370:../3rdParty/FreeRTOS/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
 5671              		.loc 1 1370 0
 5672 0c10 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 5673 0c14 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 5674 0c18 1B68     		ldr	r3, [r3, #0]
 5675 0c1a 7868     		ldr	r0, [r7, #4]
 5676 0c1c 1946     		mov	r1, r3
 5677 0c1e FA68     		ldr	r2, [r7, #12]
 5678 0c20 00F0E8FC 		bl	prvGenerateRunTimeStatsForTasksInList
 5679              	.L108:
1371:../3rdParty/FreeRTOS/tasks.c **** 			}
1372:../3rdParty/FreeRTOS/tasks.c **** 
1373:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 5680              		.loc 1 1373 0
 5681 0c24 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 5682 0c28 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 5683 0c2c 1B68     		ldr	r3, [r3, #0]
 5684 0c2e 1B68     		ldr	r3, [r3, #0]
 5685 0c30 002B     		cmp	r3, #0
 5686 0c32 09D0     		beq	.L109
1374:../3rdParty/FreeRTOS/tasks.c **** 			{
1375:../3rdParty/FreeRTOS/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
 5687              		.loc 1 1375 0
 5688 0c34 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 5689 0c38 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 5690 0c3c 1B68     		ldr	r3, [r3, #0]
 5691 0c3e 7868     		ldr	r0, [r7, #4]
 5692 0c40 1946     		mov	r1, r3
 5693 0c42 FA68     		ldr	r2, [r7, #12]
 5694 0c44 00F0D6FC 		bl	prvGenerateRunTimeStatsForTasksInList
 5695              	.L109:
1376:../3rdParty/FreeRTOS/tasks.c **** 			}
1377:../3rdParty/FreeRTOS/tasks.c **** 
1378:../3rdParty/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1379:../3rdParty/FreeRTOS/tasks.c **** 			{
1380:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 5696              		.loc 1 1380 0
 5697 0c48 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 5698 0c4c C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 5699 0c50 1B68     		ldr	r3, [r3, #0]
 5700 0c52 002B     		cmp	r3, #0
 5701 0c54 07D0     		beq	.L110
1381:../3rdParty/FreeRTOS/tasks.c **** 				{
1382:../3rdParty/FreeRTOS/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
 5702              		.loc 1 1382 0
 5703 0c56 7868     		ldr	r0, [r7, #4]
 5704 0c58 40F20001 		movw	r1, #:lower16:xTasksWaitingTermination
 5705 0c5c C0F20001 		movt	r1, #:upper16:xTasksWaitingTermination
 5706 0c60 FA68     		ldr	r2, [r7, #12]
 5707 0c62 00F0C7FC 		bl	prvGenerateRunTimeStatsForTasksInList
 5708              	.L110:
1383:../3rdParty/FreeRTOS/tasks.c **** 				}
1384:../3rdParty/FreeRTOS/tasks.c **** 			}
1385:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1386:../3rdParty/FreeRTOS/tasks.c **** 
1387:../3rdParty/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1388:../3rdParty/FreeRTOS/tasks.c **** 			{
1389:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 5709              		.loc 1 1389 0
 5710 0c66 40F20003 		movw	r3, #:lower16:xSuspendedTaskList
 5711 0c6a C0F20003 		movt	r3, #:upper16:xSuspendedTaskList
 5712 0c6e 1B68     		ldr	r3, [r3, #0]
 5713 0c70 002B     		cmp	r3, #0
 5714 0c72 07D0     		beq	.L111
1390:../3rdParty/FreeRTOS/tasks.c **** 				{
1391:../3rdParty/FreeRTOS/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
 5715              		.loc 1 1391 0
 5716 0c74 7868     		ldr	r0, [r7, #4]
 5717 0c76 40F20001 		movw	r1, #:lower16:xSuspendedTaskList
 5718 0c7a C0F20001 		movt	r1, #:upper16:xSuspendedTaskList
 5719 0c7e FA68     		ldr	r2, [r7, #12]
 5720 0c80 00F0B8FC 		bl	prvGenerateRunTimeStatsForTasksInList
 5721              	.L111:
1392:../3rdParty/FreeRTOS/tasks.c **** 				}
1393:../3rdParty/FreeRTOS/tasks.c **** 			}
1394:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1395:../3rdParty/FreeRTOS/tasks.c **** 		}
1396:../3rdParty/FreeRTOS/tasks.c **** 		xTaskResumeAll();
 5722              		.loc 1 1396 0
 5723 0c84 FFF7FEFF 		bl	xTaskResumeAll
1397:../3rdParty/FreeRTOS/tasks.c **** 	}
 5724              		.loc 1 1397 0
 5725 0c88 07F11407 		add	r7, r7, #20
 5726 0c8c BD46     		mov	sp, r7
 5727 0c8e 90BD     		pop	{r4, r7, pc}
 5728              	.LFE73:
 5730              		.align	2
 5731              		.global	vTaskIncrementTick
 5732              		.thumb
 5733              		.thumb_func
 5735              	vTaskIncrementTick:
 5736              	.LFB74:
1398:../3rdParty/FreeRTOS/tasks.c **** 
1399:../3rdParty/FreeRTOS/tasks.c **** #endif
1400:../3rdParty/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1401:../3rdParty/FreeRTOS/tasks.c **** 
1402:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1403:../3rdParty/FreeRTOS/tasks.c **** 
1404:../3rdParty/FreeRTOS/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1405:../3rdParty/FreeRTOS/tasks.c **** 	{
1406:../3rdParty/FreeRTOS/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1407:../3rdParty/FreeRTOS/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1408:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1409:../3rdParty/FreeRTOS/tasks.c **** 		return xIdleTaskHandle;
1410:../3rdParty/FreeRTOS/tasks.c **** 	}
1411:../3rdParty/FreeRTOS/tasks.c **** 	
1412:../3rdParty/FreeRTOS/tasks.c **** #endif
1413:../3rdParty/FreeRTOS/tasks.c **** 
1414:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1415:../3rdParty/FreeRTOS/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1416:../3rdParty/FreeRTOS/tasks.c ****  * documented in task.h
1417:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1418:../3rdParty/FreeRTOS/tasks.c **** 
1419:../3rdParty/FreeRTOS/tasks.c **** void vTaskIncrementTick( void )
1420:../3rdParty/FreeRTOS/tasks.c **** {
 5737              		.loc 1 1420 0
 5738              		@ args = 0, pretend = 0, frame = 16
 5739              		@ frame_needed = 1, uses_anonymous_args = 0
 5740 0c90 80B5     		push	{r7, lr}
 5741              	.LCFI54:
 5742 0c92 84B0     		sub	sp, sp, #16
 5743              	.LCFI55:
 5744 0c94 00AF     		add	r7, sp, #0
 5745              	.LCFI56:
1421:../3rdParty/FreeRTOS/tasks.c **** tskTCB * pxTCB;
1422:../3rdParty/FreeRTOS/tasks.c **** 
1423:../3rdParty/FreeRTOS/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1424:../3rdParty/FreeRTOS/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1425:../3rdParty/FreeRTOS/tasks.c **** 	tasks to be unblocked. */
1426:../3rdParty/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 5746              		.loc 1 1426 0
 5747 0c96 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 5748 0c9a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 5749 0c9e 1B68     		ldr	r3, [r3, #0]
 5750 0ca0 002B     		cmp	r3, #0
 5751 0ca2 40F0C080 		bne	.L114
1427:../3rdParty/FreeRTOS/tasks.c **** 	{
1428:../3rdParty/FreeRTOS/tasks.c **** 		++xTickCount;
 5752              		.loc 1 1428 0
 5753 0ca6 40F20003 		movw	r3, #:lower16:xTickCount
 5754 0caa C0F20003 		movt	r3, #:upper16:xTickCount
 5755 0cae 1B68     		ldr	r3, [r3, #0]
 5756 0cb0 03F10102 		add	r2, r3, #1
 5757 0cb4 40F20003 		movw	r3, #:lower16:xTickCount
 5758 0cb8 C0F20003 		movt	r3, #:upper16:xTickCount
 5759 0cbc 1A60     		str	r2, [r3, #0]
1429:../3rdParty/FreeRTOS/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 5760              		.loc 1 1429 0
 5761 0cbe 40F20003 		movw	r3, #:lower16:xTickCount
 5762 0cc2 C0F20003 		movt	r3, #:upper16:xTickCount
 5763 0cc6 1B68     		ldr	r3, [r3, #0]
 5764 0cc8 002B     		cmp	r3, #0
 5765 0cca 40D1     		bne	.L115
 5766              	.LBB4:
1430:../3rdParty/FreeRTOS/tasks.c **** 		{
1431:../3rdParty/FreeRTOS/tasks.c **** 			xList *pxTemp;
1432:../3rdParty/FreeRTOS/tasks.c **** 
1433:../3rdParty/FreeRTOS/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1434:../3rdParty/FreeRTOS/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1435:../3rdParty/FreeRTOS/tasks.c **** 			an error! */
1436:../3rdParty/FreeRTOS/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1437:../3rdParty/FreeRTOS/tasks.c **** 			
1438:../3rdParty/FreeRTOS/tasks.c **** 			pxTemp = pxDelayedTaskList;
 5767              		.loc 1 1438 0
 5768 0ccc 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 5769 0cd0 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 5770 0cd4 1B68     		ldr	r3, [r3, #0]
 5771 0cd6 BB60     		str	r3, [r7, #8]
1439:../3rdParty/FreeRTOS/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 5772              		.loc 1 1439 0
 5773 0cd8 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 5774 0cdc C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 5775 0ce0 1A68     		ldr	r2, [r3, #0]
 5776 0ce2 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 5777 0ce6 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 5778 0cea 1A60     		str	r2, [r3, #0]
1440:../3rdParty/FreeRTOS/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 5779              		.loc 1 1440 0
 5780 0cec 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 5781 0cf0 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 5782 0cf4 BA68     		ldr	r2, [r7, #8]
 5783 0cf6 1A60     		str	r2, [r3, #0]
1441:../3rdParty/FreeRTOS/tasks.c **** 			xNumOfOverflows++;
 5784              		.loc 1 1441 0
 5785 0cf8 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 5786 0cfc C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 5787 0d00 1B68     		ldr	r3, [r3, #0]
 5788 0d02 03F10102 		add	r2, r3, #1
 5789 0d06 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 5790 0d0a C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 5791 0d0e 1A60     		str	r2, [r3, #0]
1442:../3rdParty/FreeRTOS/tasks.c **** 	
1443:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 5792              		.loc 1 1443 0
 5793 0d10 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 5794 0d14 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 5795 0d18 1B68     		ldr	r3, [r3, #0]
 5796 0d1a 1B68     		ldr	r3, [r3, #0]
 5797 0d1c 002B     		cmp	r3, #0
 5798 0d1e 07D1     		bne	.L116
1444:../3rdParty/FreeRTOS/tasks.c **** 			{
1445:../3rdParty/FreeRTOS/tasks.c **** 				/* The new current delayed list is empty.  Set
1446:../3rdParty/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1447:../3rdParty/FreeRTOS/tasks.c **** 				extremely unlikely that the	
1448:../3rdParty/FreeRTOS/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1449:../3rdParty/FreeRTOS/tasks.c **** 				there is an item in the delayed list. */
1450:../3rdParty/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 5799              		.loc 1 1450 0
 5800 0d20 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 5801 0d24 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 5802 0d28 4FF0FF32 		mov	r2, #-1
 5803 0d2c 1A60     		str	r2, [r3, #0]
 5804 0d2e 0EE0     		b	.L115
 5805              	.L116:
1451:../3rdParty/FreeRTOS/tasks.c **** 			}
1452:../3rdParty/FreeRTOS/tasks.c **** 			else
1453:../3rdParty/FreeRTOS/tasks.c **** 			{
1454:../3rdParty/FreeRTOS/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1455:../3rdParty/FreeRTOS/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1456:../3rdParty/FreeRTOS/tasks.c **** 				which the task at the head of the delayed list should be removed
1457:../3rdParty/FreeRTOS/tasks.c **** 				from the Blocked state. */
1458:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 5806              		.loc 1 1458 0
 5807 0d30 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 5808 0d34 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 5809 0d38 1B68     		ldr	r3, [r3, #0]
 5810 0d3a DB68     		ldr	r3, [r3, #12]
 5811 0d3c DB68     		ldr	r3, [r3, #12]
 5812 0d3e 7B60     		str	r3, [r7, #4]
1459:../3rdParty/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 5813              		.loc 1 1459 0
 5814 0d40 7B68     		ldr	r3, [r7, #4]
 5815 0d42 5A68     		ldr	r2, [r3, #4]
 5816 0d44 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 5817 0d48 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 5818 0d4c 1A60     		str	r2, [r3, #0]
 5819              	.L115:
 5820              	.LBE4:
 5821              	.LBB5:
1460:../3rdParty/FreeRTOS/tasks.c **** 			}
1461:../3rdParty/FreeRTOS/tasks.c **** 		}
1462:../3rdParty/FreeRTOS/tasks.c **** 
1463:../3rdParty/FreeRTOS/tasks.c **** 		/* See if this tick has made a timeout expire. */
1464:../3rdParty/FreeRTOS/tasks.c **** 		prvCheckDelayedTasks();
 5822              		.loc 1 1464 0
 5823 0d4e 40F20003 		movw	r3, #:lower16:xTickCount
 5824 0d52 C0F20003 		movt	r3, #:upper16:xTickCount
 5825 0d56 1A68     		ldr	r2, [r3, #0]
 5826 0d58 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 5827 0d5c C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 5828 0d60 1B68     		ldr	r3, [r3, #0]
 5829 0d62 9A42     		cmp	r2, r3
 5830 0d64 6BD3     		bcc	.L123
 5831              	.L122:
 5832 0d66 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 5833 0d6a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 5834 0d6e 1B68     		ldr	r3, [r3, #0]
 5835 0d70 1B68     		ldr	r3, [r3, #0]
 5836 0d72 002B     		cmp	r3, #0
 5837 0d74 07D1     		bne	.L118
 5838 0d76 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 5839 0d7a C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 5840 0d7e 4FF0FF32 		mov	r2, #-1
 5841 0d82 1A60     		str	r2, [r3, #0]
 5842 0d84 5BE0     		b	.L123
 5843              	.L118:
 5844 0d86 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 5845 0d8a C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 5846 0d8e 1B68     		ldr	r3, [r3, #0]
 5847 0d90 DB68     		ldr	r3, [r3, #12]
 5848 0d92 DB68     		ldr	r3, [r3, #12]
 5849 0d94 7B60     		str	r3, [r7, #4]
 5850 0d96 7B68     		ldr	r3, [r7, #4]
 5851 0d98 5B68     		ldr	r3, [r3, #4]
 5852 0d9a FB60     		str	r3, [r7, #12]
 5853 0d9c 40F20003 		movw	r3, #:lower16:xTickCount
 5854 0da0 C0F20003 		movt	r3, #:upper16:xTickCount
 5855 0da4 1A68     		ldr	r2, [r3, #0]
 5856 0da6 FB68     		ldr	r3, [r7, #12]
 5857 0da8 9A42     		cmp	r2, r3
 5858 0daa 06D2     		bcs	.L119
 5859 0dac 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 5860 0db0 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 5861 0db4 FA68     		ldr	r2, [r7, #12]
 5862 0db6 1A60     		str	r2, [r3, #0]
 5863 0db8 41E0     		b	.L123
 5864              	.L119:
 5865 0dba 7B68     		ldr	r3, [r7, #4]
 5866 0dbc 03F10403 		add	r3, r3, #4
 5867 0dc0 1846     		mov	r0, r3
 5868 0dc2 FFF7FEFF 		bl	vListRemove
 5869 0dc6 7B68     		ldr	r3, [r7, #4]
 5870 0dc8 9B6A     		ldr	r3, [r3, #40]
 5871 0dca 002B     		cmp	r3, #0
 5872 0dcc 05D0     		beq	.L120
 5873 0dce 7B68     		ldr	r3, [r7, #4]
 5874 0dd0 03F11803 		add	r3, r3, #24
 5875 0dd4 1846     		mov	r0, r3
 5876 0dd6 FFF7FEFF 		bl	vListRemove
 5877              	.L120:
 5878 0dda 7B68     		ldr	r3, [r7, #4]
 5879 0ddc DA6A     		ldr	r2, [r3, #44]
 5880 0dde 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 5881 0de2 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 5882 0de6 1B68     		ldr	r3, [r3, #0]
 5883 0de8 9A42     		cmp	r2, r3
 5884 0dea 06D9     		bls	.L121
 5885 0dec 7B68     		ldr	r3, [r7, #4]
 5886 0dee DA6A     		ldr	r2, [r3, #44]
 5887 0df0 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 5888 0df4 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 5889 0df8 1A60     		str	r2, [r3, #0]
 5890              	.L121:
 5891 0dfa 7B68     		ldr	r3, [r7, #4]
 5892 0dfc DA6A     		ldr	r2, [r3, #44]
 5893 0dfe 1346     		mov	r3, r2
 5894 0e00 4FEA8303 		lsl	r3, r3, #2
 5895 0e04 1344     		add	r3, r3, r2
 5896 0e06 4FEA8303 		lsl	r3, r3, #2
 5897 0e0a 1A46     		mov	r2, r3
 5898 0e0c 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 5899 0e10 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 5900 0e14 1A44     		add	r2, r2, r3
 5901 0e16 7B68     		ldr	r3, [r7, #4]
 5902 0e18 03F10403 		add	r3, r3, #4
 5903 0e1c 1046     		mov	r0, r2
 5904 0e1e 1946     		mov	r1, r3
 5905 0e20 FFF7FEFF 		bl	vListInsertEnd
 5906 0e24 9FE7     		b	.L122
 5907              	.L114:
 5908              	.LBE5:
1465:../3rdParty/FreeRTOS/tasks.c **** 	}
1466:../3rdParty/FreeRTOS/tasks.c **** 	else
1467:../3rdParty/FreeRTOS/tasks.c **** 	{
1468:../3rdParty/FreeRTOS/tasks.c **** 		++uxMissedTicks;
 5909              		.loc 1 1468 0
 5910 0e26 40F20003 		movw	r3, #:lower16:uxMissedTicks
 5911 0e2a C0F20003 		movt	r3, #:upper16:uxMissedTicks
 5912 0e2e 1B68     		ldr	r3, [r3, #0]
 5913 0e30 03F10102 		add	r2, r3, #1
 5914 0e34 40F20003 		movw	r3, #:lower16:uxMissedTicks
 5915 0e38 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 5916 0e3c 1A60     		str	r2, [r3, #0]
 5917              	.L123:
1469:../3rdParty/FreeRTOS/tasks.c **** 
1470:../3rdParty/FreeRTOS/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1471:../3rdParty/FreeRTOS/tasks.c **** 		scheduler is locked. */
1472:../3rdParty/FreeRTOS/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1473:../3rdParty/FreeRTOS/tasks.c **** 		{
1474:../3rdParty/FreeRTOS/tasks.c **** 			//vApplicationTickHook();
1475:../3rdParty/FreeRTOS/tasks.c **** 		}
1476:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1477:../3rdParty/FreeRTOS/tasks.c **** 	}
1478:../3rdParty/FreeRTOS/tasks.c **** 
1479:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1480:../3rdParty/FreeRTOS/tasks.c **** 	{
1481:../3rdParty/FreeRTOS/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1482:../3rdParty/FreeRTOS/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1483:../3rdParty/FreeRTOS/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
 5918              		.loc 1 1483 0
 5919 0e3e 40F20003 		movw	r3, #:lower16:uxMissedTicks
 5920 0e42 C0F20003 		movt	r3, #:upper16:uxMissedTicks
 5921 0e46 1B68     		ldr	r3, [r3, #0]
1484:../3rdParty/FreeRTOS/tasks.c **** 		{
1485:../3rdParty/FreeRTOS/tasks.c **** 			//vApplicationTickHook();
1486:../3rdParty/FreeRTOS/tasks.c **** 		}
1487:../3rdParty/FreeRTOS/tasks.c **** 	}
1488:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1489:../3rdParty/FreeRTOS/tasks.c **** 
1490:../3rdParty/FreeRTOS/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1491:../3rdParty/FreeRTOS/tasks.c **** }
 5922              		.loc 1 1491 0
 5923 0e48 07F11007 		add	r7, r7, #16
 5924 0e4c BD46     		mov	sp, r7
 5925 0e4e 80BD     		pop	{r7, pc}
 5926              	.LFE74:
 5928              		.align	2
 5929              		.global	vTaskSwitchContext
 5930              		.thumb
 5931              		.thumb_func
 5933              	vTaskSwitchContext:
 5934              	.LFB75:
1492:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1493:../3rdParty/FreeRTOS/tasks.c **** 
1494:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1495:../3rdParty/FreeRTOS/tasks.c **** 
1496:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1497:../3rdParty/FreeRTOS/tasks.c **** 	{
1498:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *xTCB;
1499:../3rdParty/FreeRTOS/tasks.c **** 
1500:../3rdParty/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1501:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask == NULL )
1502:../3rdParty/FreeRTOS/tasks.c **** 		{
1503:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1504:../3rdParty/FreeRTOS/tasks.c **** 		}
1505:../3rdParty/FreeRTOS/tasks.c **** 		else
1506:../3rdParty/FreeRTOS/tasks.c **** 		{
1507:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1508:../3rdParty/FreeRTOS/tasks.c **** 		}
1509:../3rdParty/FreeRTOS/tasks.c **** 
1510:../3rdParty/FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1511:../3rdParty/FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
1512:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
1513:../3rdParty/FreeRTOS/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1514:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
1515:../3rdParty/FreeRTOS/tasks.c **** 	}
1516:../3rdParty/FreeRTOS/tasks.c **** 
1517:../3rdParty/FreeRTOS/tasks.c **** #endif
1518:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1519:../3rdParty/FreeRTOS/tasks.c **** 
1520:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1521:../3rdParty/FreeRTOS/tasks.c **** 
1522:../3rdParty/FreeRTOS/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1523:../3rdParty/FreeRTOS/tasks.c **** 	{
1524:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *xTCB;
1525:../3rdParty/FreeRTOS/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1526:../3rdParty/FreeRTOS/tasks.c **** 
1527:../3rdParty/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1528:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask == NULL )
1529:../3rdParty/FreeRTOS/tasks.c **** 		{
1530:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1531:../3rdParty/FreeRTOS/tasks.c **** 		}
1532:../3rdParty/FreeRTOS/tasks.c **** 		else
1533:../3rdParty/FreeRTOS/tasks.c **** 		{
1534:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1535:../3rdParty/FreeRTOS/tasks.c **** 		}
1536:../3rdParty/FreeRTOS/tasks.c **** 
1537:../3rdParty/FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1538:../3rdParty/FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
1539:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
1540:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1541:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
1542:../3rdParty/FreeRTOS/tasks.c **** 
1543:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
1544:../3rdParty/FreeRTOS/tasks.c **** 	}
1545:../3rdParty/FreeRTOS/tasks.c **** 
1546:../3rdParty/FreeRTOS/tasks.c **** #endif
1547:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1548:../3rdParty/FreeRTOS/tasks.c **** 
1549:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1550:../3rdParty/FreeRTOS/tasks.c **** 
1551:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1552:../3rdParty/FreeRTOS/tasks.c **** 	{
1553:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *xTCB;
1554:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xReturn;
1555:../3rdParty/FreeRTOS/tasks.c **** 
1556:../3rdParty/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1557:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask == NULL )
1558:../3rdParty/FreeRTOS/tasks.c **** 		{
1559:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1560:../3rdParty/FreeRTOS/tasks.c **** 		}
1561:../3rdParty/FreeRTOS/tasks.c **** 		else
1562:../3rdParty/FreeRTOS/tasks.c **** 		{
1563:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1564:../3rdParty/FreeRTOS/tasks.c **** 		}
1565:../3rdParty/FreeRTOS/tasks.c **** 
1566:../3rdParty/FreeRTOS/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1567:../3rdParty/FreeRTOS/tasks.c **** 		{
1568:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1569:../3rdParty/FreeRTOS/tasks.c **** 		}
1570:../3rdParty/FreeRTOS/tasks.c **** 		else
1571:../3rdParty/FreeRTOS/tasks.c **** 		{
1572:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdFAIL;
1573:../3rdParty/FreeRTOS/tasks.c **** 		}
1574:../3rdParty/FreeRTOS/tasks.c **** 
1575:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
1576:../3rdParty/FreeRTOS/tasks.c **** 	}
1577:../3rdParty/FreeRTOS/tasks.c **** 
1578:../3rdParty/FreeRTOS/tasks.c **** #endif
1579:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1580:../3rdParty/FreeRTOS/tasks.c **** 
1581:../3rdParty/FreeRTOS/tasks.c **** void vTaskSwitchContext( void )
1582:../3rdParty/FreeRTOS/tasks.c **** {
 5935              		.loc 1 1582 0
 5936              		@ args = 0, pretend = 0, frame = 8
 5937              		@ frame_needed = 1, uses_anonymous_args = 0
 5938 0e50 80B5     		push	{r7, lr}
 5939              	.LCFI57:
 5940 0e52 82B0     		sub	sp, sp, #8
 5941              	.LCFI58:
 5942 0e54 00AF     		add	r7, sp, #0
 5943              	.LCFI59:
1583:../3rdParty/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 5944              		.loc 1 1583 0
 5945 0e56 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 5946 0e5a C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 5947 0e5e 1B68     		ldr	r3, [r3, #0]
 5948 0e60 002B     		cmp	r3, #0
 5949 0e62 07D0     		beq	.L126
1584:../3rdParty/FreeRTOS/tasks.c **** 	{
1585:../3rdParty/FreeRTOS/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1586:../3rdParty/FreeRTOS/tasks.c **** 		switch. */
1587:../3rdParty/FreeRTOS/tasks.c **** 		xMissedYield = pdTRUE;
 5950              		.loc 1 1587 0
 5951 0e64 40F20003 		movw	r3, #:lower16:xMissedYield
 5952 0e68 C0F20003 		movt	r3, #:upper16:xMissedYield
 5953 0e6c 4FF00102 		mov	r2, #1
 5954 0e70 1A60     		str	r2, [r3, #0]
 5955 0e72 ACE0     		b	.L133
 5956              	.L126:
 5957              	.LBB6:
1588:../3rdParty/FreeRTOS/tasks.c **** 	}
1589:../3rdParty/FreeRTOS/tasks.c **** 	else
1590:../3rdParty/FreeRTOS/tasks.c **** 	{
1591:../3rdParty/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_OUT();
1592:../3rdParty/FreeRTOS/tasks.c **** 	
1593:../3rdParty/FreeRTOS/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1594:../3rdParty/FreeRTOS/tasks.c **** 		{
1595:../3rdParty/FreeRTOS/tasks.c **** 			unsigned long ulTempCounter;
1596:../3rdParty/FreeRTOS/tasks.c **** 			
1597:../3rdParty/FreeRTOS/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1598:../3rdParty/FreeRTOS/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1599:../3rdParty/FreeRTOS/tasks.c **** 				#else
1600:../3rdParty/FreeRTOS/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 5958              		.loc 1 1600 0
 5959 0e74 44F20003 		movw	r3, #:lower16:1073758208
 5960 0e78 C4F20003 		movt	r3, #:upper16:1073758208
 5961 0e7c 9B68     		ldr	r3, [r3, #8]
 5962 0e7e 3B60     		str	r3, [r7, #0]
1601:../3rdParty/FreeRTOS/tasks.c **** 				#endif
1602:../3rdParty/FreeRTOS/tasks.c **** 	
1603:../3rdParty/FreeRTOS/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1604:../3rdParty/FreeRTOS/tasks.c **** 				time so far.  The time the task started running was stored in
1605:../3rdParty/FreeRTOS/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1606:../3rdParty/FreeRTOS/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1607:../3rdParty/FreeRTOS/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1608:../3rdParty/FreeRTOS/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 5963              		.loc 1 1608 0
 5964 0e80 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 5965 0e84 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 5966 0e88 1A68     		ldr	r2, [r3, #0]
 5967 0e8a D16C     		ldr	r1, [r2, #76]
 5968 0e8c 40F20003 		movw	r3, #:lower16:ulTaskSwitchedInTime
 5969 0e90 C0F20003 		movt	r3, #:upper16:ulTaskSwitchedInTime
 5970 0e94 1B68     		ldr	r3, [r3, #0]
 5971 0e96 3868     		ldr	r0, [r7, #0]
 5972 0e98 C3EB0003 		rsb	r3, r3, r0
 5973 0e9c 0B44     		add	r3, r1, r3
 5974 0e9e D364     		str	r3, [r2, #76]
1609:../3rdParty/FreeRTOS/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
 5975              		.loc 1 1609 0
 5976 0ea0 40F20003 		movw	r3, #:lower16:ulTaskSwitchedInTime
 5977 0ea4 C0F20003 		movt	r3, #:upper16:ulTaskSwitchedInTime
 5978 0ea8 3A68     		ldr	r2, [r7, #0]
 5979 0eaa 1A60     		str	r2, [r3, #0]
 5980              	.LBE6:
1610:../3rdParty/FreeRTOS/tasks.c **** 		}
1611:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1612:../3rdParty/FreeRTOS/tasks.c **** 	
1613:../3rdParty/FreeRTOS/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 5981              		.loc 1 1613 0
 5982 0eac 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 5983 0eb0 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 5984 0eb4 1B68     		ldr	r3, [r3, #0]
 5985 0eb6 1A68     		ldr	r2, [r3, #0]
 5986 0eb8 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 5987 0ebc C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 5988 0ec0 1B68     		ldr	r3, [r3, #0]
 5989 0ec2 1B6B     		ldr	r3, [r3, #48]
 5990 0ec4 9A42     		cmp	r2, r3
 5991 0ec6 10D8     		bhi	.L128
 5992 0ec8 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 5993 0ecc C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 5994 0ed0 1B68     		ldr	r3, [r3, #0]
 5995 0ed2 1A46     		mov	r2, r3
 5996 0ed4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 5997 0ed8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 5998 0edc 1B68     		ldr	r3, [r3, #0]
 5999 0ede 03F13403 		add	r3, r3, #52
 6000 0ee2 1046     		mov	r0, r2
 6001 0ee4 1946     		mov	r1, r3
 6002 0ee6 FFF7FEFF 		bl	vApplicationStackOverflowHook
 6003              	.L128:
 6004              	.LBB7:
1614:../3rdParty/FreeRTOS/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 6005              		.loc 1 1614 0
 6006 0eea 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 6007 0eee C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 6008 0ef2 1B68     		ldr	r3, [r3, #0]
 6009 0ef4 1B6B     		ldr	r3, [r3, #48]
 6010 0ef6 1846     		mov	r0, r3
 6011 0ef8 40F20001 		movw	r1, #:lower16:ucExpectedStackBytes.4784
 6012 0efc C0F20001 		movt	r1, #:upper16:ucExpectedStackBytes.4784
 6013 0f00 4FF01402 		mov	r2, #20
 6014 0f04 FFF7FEFF 		bl	memcmp
 6015 0f08 0346     		mov	r3, r0
 6016 0f0a 002B     		cmp	r3, #0
 6017 0f0c 1ED0     		beq	.L134
 6018 0f0e 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 6019 0f12 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 6020 0f16 1B68     		ldr	r3, [r3, #0]
 6021 0f18 1A46     		mov	r2, r3
 6022 0f1a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 6023 0f1e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 6024 0f22 1B68     		ldr	r3, [r3, #0]
 6025 0f24 03F13403 		add	r3, r3, #52
 6026 0f28 1046     		mov	r0, r2
 6027 0f2a 1946     		mov	r1, r3
 6028 0f2c FFF7FEFF 		bl	vApplicationStackOverflowHook
 6029              	.LBE7:
1615:../3rdParty/FreeRTOS/tasks.c **** 	
1616:../3rdParty/FreeRTOS/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */
1617:../3rdParty/FreeRTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 6030              		.loc 1 1617 0
 6031 0f30 0DE0     		b	.L130
 6032              	.L131:
1618:../3rdParty/FreeRTOS/tasks.c **** 		{
1619:../3rdParty/FreeRTOS/tasks.c **** 			configASSERT( uxTopReadyPriority );
1620:../3rdParty/FreeRTOS/tasks.c **** 			--uxTopReadyPriority;
 6033              		.loc 1 1620 0
 6034 0f32 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 6035 0f36 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 6036 0f3a 1B68     		ldr	r3, [r3, #0]
 6037 0f3c 03F1FF32 		add	r2, r3, #-1
 6038 0f40 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 6039 0f44 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 6040 0f48 1A60     		str	r2, [r3, #0]
 6041 0f4a 00E0     		b	.L130
 6042              	.L134:
 6043              		.loc 1 1617 0
 6044 0f4c 00BF     		nop
 6045              	.L130:
 6046 0f4e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 6047 0f52 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 6048 0f56 1A68     		ldr	r2, [r3, #0]
 6049 0f58 1346     		mov	r3, r2
 6050 0f5a 4FEA8303 		lsl	r3, r3, #2
 6051 0f5e 1344     		add	r3, r3, r2
 6052 0f60 4FEA8303 		lsl	r3, r3, #2
 6053 0f64 1A46     		mov	r2, r3
 6054 0f66 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 6055 0f6a C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 6056 0f6e 1344     		add	r3, r2, r3
 6057 0f70 1B68     		ldr	r3, [r3, #0]
 6058 0f72 002B     		cmp	r3, #0
 6059 0f74 DDD0     		beq	.L131
 6060              	.LBB8:
1621:../3rdParty/FreeRTOS/tasks.c **** 		}
1622:../3rdParty/FreeRTOS/tasks.c **** 	
1623:../3rdParty/FreeRTOS/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1624:../3rdParty/FreeRTOS/tasks.c **** 		same priority get an equal share of the processor time. */
1625:../3rdParty/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 6061              		.loc 1 1625 0
 6062 0f76 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 6063 0f7a C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 6064 0f7e 1A68     		ldr	r2, [r3, #0]
 6065 0f80 1346     		mov	r3, r2
 6066 0f82 4FEA8303 		lsl	r3, r3, #2
 6067 0f86 1344     		add	r3, r3, r2
 6068 0f88 4FEA8303 		lsl	r3, r3, #2
 6069 0f8c 1A46     		mov	r2, r3
 6070 0f8e 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 6071 0f92 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 6072 0f96 1344     		add	r3, r2, r3
 6073 0f98 7B60     		str	r3, [r7, #4]
 6074 0f9a 7B68     		ldr	r3, [r7, #4]
 6075 0f9c 5B68     		ldr	r3, [r3, #4]
 6076 0f9e 5A68     		ldr	r2, [r3, #4]
 6077 0fa0 7B68     		ldr	r3, [r7, #4]
 6078 0fa2 5A60     		str	r2, [r3, #4]
 6079 0fa4 7B68     		ldr	r3, [r7, #4]
 6080 0fa6 5A68     		ldr	r2, [r3, #4]
 6081 0fa8 7B68     		ldr	r3, [r7, #4]
 6082 0faa 03F10803 		add	r3, r3, #8
 6083 0fae 9A42     		cmp	r2, r3
 6084 0fb0 04D1     		bne	.L132
 6085 0fb2 7B68     		ldr	r3, [r7, #4]
 6086 0fb4 5B68     		ldr	r3, [r3, #4]
 6087 0fb6 5A68     		ldr	r2, [r3, #4]
 6088 0fb8 7B68     		ldr	r3, [r7, #4]
 6089 0fba 5A60     		str	r2, [r3, #4]
 6090              	.L132:
 6091 0fbc 7B68     		ldr	r3, [r7, #4]
 6092 0fbe 5B68     		ldr	r3, [r3, #4]
 6093 0fc0 DB68     		ldr	r3, [r3, #12]
 6094 0fc2 1A46     		mov	r2, r3
 6095 0fc4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 6096 0fc8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 6097 0fcc 1A60     		str	r2, [r3, #0]
 6098              	.L133:
 6099              	.LBE8:
1626:../3rdParty/FreeRTOS/tasks.c **** 	
1627:../3rdParty/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
1628:../3rdParty/FreeRTOS/tasks.c **** 	}
1629:../3rdParty/FreeRTOS/tasks.c **** }
 6100              		.loc 1 1629 0
 6101 0fce 07F10807 		add	r7, r7, #8
 6102 0fd2 BD46     		mov	sp, r7
 6103 0fd4 80BD     		pop	{r7, pc}
 6104              	.LFE75:
 6106 0fd6 00BF     		.align	2
 6107              		.global	vTaskPlaceOnEventList
 6108              		.thumb
 6109              		.thumb_func
 6111              	vTaskPlaceOnEventList:
 6112              	.LFB76:
1630:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1631:../3rdParty/FreeRTOS/tasks.c **** 
1632:../3rdParty/FreeRTOS/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1633:../3rdParty/FreeRTOS/tasks.c **** {
 6113              		.loc 1 1633 0
 6114              		@ args = 0, pretend = 0, frame = 16
 6115              		@ frame_needed = 1, uses_anonymous_args = 0
 6116 0fd8 80B5     		push	{r7, lr}
 6117              	.LCFI60:
 6118 0fda 84B0     		sub	sp, sp, #16
 6119              	.LCFI61:
 6120 0fdc 00AF     		add	r7, sp, #0
 6121              	.LCFI62:
 6122 0fde 7860     		str	r0, [r7, #4]
 6123 0fe0 3960     		str	r1, [r7, #0]
1634:../3rdParty/FreeRTOS/tasks.c **** portTickType xTimeToWake;
1635:../3rdParty/FreeRTOS/tasks.c **** 
1636:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxEventList );
1637:../3rdParty/FreeRTOS/tasks.c **** 
1638:../3rdParty/FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1639:../3rdParty/FreeRTOS/tasks.c **** 	SCHEDULER SUSPENDED. */
1640:../3rdParty/FreeRTOS/tasks.c **** 
1641:../3rdParty/FreeRTOS/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1642:../3rdParty/FreeRTOS/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1643:../3rdParty/FreeRTOS/tasks.c **** 	is the first to be woken by the event. */
1644:../3rdParty/FreeRTOS/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 6124              		.loc 1 1644 0
 6125 0fe2 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 6126 0fe6 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 6127 0fea 1B68     		ldr	r3, [r3, #0]
 6128 0fec 03F11803 		add	r3, r3, #24
 6129 0ff0 7868     		ldr	r0, [r7, #4]
 6130 0ff2 1946     		mov	r1, r3
 6131 0ff4 FFF7FEFF 		bl	vListInsert
1645:../3rdParty/FreeRTOS/tasks.c **** 
1646:../3rdParty/FreeRTOS/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1647:../3rdParty/FreeRTOS/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1648:../3rdParty/FreeRTOS/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1649:../3rdParty/FreeRTOS/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 6132              		.loc 1 1649 0
 6133 0ff8 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 6134 0ffc C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 6135 1000 1B68     		ldr	r3, [r3, #0]
 6136 1002 03F10403 		add	r3, r3, #4
 6137 1006 1846     		mov	r0, r3
 6138 1008 FFF7FEFF 		bl	vListRemove
1650:../3rdParty/FreeRTOS/tasks.c **** 
1651:../3rdParty/FreeRTOS/tasks.c **** 
1652:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1653:../3rdParty/FreeRTOS/tasks.c **** 	{
1654:../3rdParty/FreeRTOS/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 6139              		.loc 1 1654 0
 6140 100c 3B68     		ldr	r3, [r7, #0]
 6141 100e B3F1FF3F 		cmp	r3, #-1
 6142 1012 0ED1     		bne	.L136
1655:../3rdParty/FreeRTOS/tasks.c **** 		{
1656:../3rdParty/FreeRTOS/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1657:../3rdParty/FreeRTOS/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1658:../3rdParty/FreeRTOS/tasks.c **** 			indefinitely. */
1659:../3rdParty/FreeRTOS/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 6143              		.loc 1 1659 0
 6144 1014 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 6145 1018 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 6146 101c 1B68     		ldr	r3, [r3, #0]
 6147 101e 03F10403 		add	r3, r3, #4
 6148 1022 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 6149 1026 C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 6150 102a 1946     		mov	r1, r3
 6151 102c FFF7FEFF 		bl	vListInsertEnd
 6152 1030 0AE0     		b	.L138
 6153              	.L136:
1660:../3rdParty/FreeRTOS/tasks.c **** 		}
1661:../3rdParty/FreeRTOS/tasks.c **** 		else
1662:../3rdParty/FreeRTOS/tasks.c **** 		{
1663:../3rdParty/FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1664:../3rdParty/FreeRTOS/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1665:../3rdParty/FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 6154              		.loc 1 1665 0
 6155 1032 40F20003 		movw	r3, #:lower16:xTickCount
 6156 1036 C0F20003 		movt	r3, #:upper16:xTickCount
 6157 103a 1A68     		ldr	r2, [r3, #0]
 6158 103c 3B68     		ldr	r3, [r7, #0]
 6159 103e 1344     		add	r3, r2, r3
 6160 1040 FB60     		str	r3, [r7, #12]
1666:../3rdParty/FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 6161              		.loc 1 1666 0
 6162 1042 F868     		ldr	r0, [r7, #12]
 6163 1044 00F0F0F9 		bl	prvAddCurrentTaskToDelayedList
 6164              	.L138:
1667:../3rdParty/FreeRTOS/tasks.c **** 		}
1668:../3rdParty/FreeRTOS/tasks.c **** 	}
1669:../3rdParty/FreeRTOS/tasks.c **** 	#else
1670:../3rdParty/FreeRTOS/tasks.c **** 	{
1671:../3rdParty/FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1672:../3rdParty/FreeRTOS/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1673:../3rdParty/FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1674:../3rdParty/FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1675:../3rdParty/FreeRTOS/tasks.c **** 	}
1676:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1677:../3rdParty/FreeRTOS/tasks.c **** }
 6165              		.loc 1 1677 0
 6166 1048 07F11007 		add	r7, r7, #16
 6167 104c BD46     		mov	sp, r7
 6168 104e 80BD     		pop	{r7, pc}
 6169              	.LFE76:
 6171              		.align	2
 6172              		.global	xTaskRemoveFromEventList
 6173              		.thumb
 6174              		.thumb_func
 6176              	xTaskRemoveFromEventList:
 6177              	.LFB77:
1678:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1679:../3rdParty/FreeRTOS/tasks.c **** 
1680:../3rdParty/FreeRTOS/tasks.c **** #if configUSE_TIMERS == 1
1681:../3rdParty/FreeRTOS/tasks.c **** 
1682:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1683:../3rdParty/FreeRTOS/tasks.c **** 	{
1684:../3rdParty/FreeRTOS/tasks.c **** 	portTickType xTimeToWake;
1685:../3rdParty/FreeRTOS/tasks.c **** 
1686:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxEventList );
1687:../3rdParty/FreeRTOS/tasks.c **** 
1688:../3rdParty/FreeRTOS/tasks.c **** 		/* This function should not be called by application code hence the
1689:../3rdParty/FreeRTOS/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1690:../3rdParty/FreeRTOS/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1691:../3rdParty/FreeRTOS/tasks.c **** 		it should be called from a critical section. */
1692:../3rdParty/FreeRTOS/tasks.c **** 
1693:../3rdParty/FreeRTOS/tasks.c **** 	
1694:../3rdParty/FreeRTOS/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1695:../3rdParty/FreeRTOS/tasks.c **** 		In this case it is assume that this is the only task that is going to
1696:../3rdParty/FreeRTOS/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1697:../3rdParty/FreeRTOS/tasks.c **** 		can be used in place of vListInsert. */
1698:../3rdParty/FreeRTOS/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1699:../3rdParty/FreeRTOS/tasks.c **** 
1700:../3rdParty/FreeRTOS/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1701:../3rdParty/FreeRTOS/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1702:../3rdParty/FreeRTOS/tasks.c **** 		function is called form a critical section. */
1703:../3rdParty/FreeRTOS/tasks.c **** 		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1704:../3rdParty/FreeRTOS/tasks.c **** 
1705:../3rdParty/FreeRTOS/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1706:../3rdParty/FreeRTOS/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1707:../3rdParty/FreeRTOS/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1708:../3rdParty/FreeRTOS/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1709:../3rdParty/FreeRTOS/tasks.c **** 	}
1710:../3rdParty/FreeRTOS/tasks.c **** 	
1711:../3rdParty/FreeRTOS/tasks.c **** #endif /* configUSE_TIMERS */
1712:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1713:../3rdParty/FreeRTOS/tasks.c **** 
1714:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1715:../3rdParty/FreeRTOS/tasks.c **** {
 6178              		.loc 1 1715 0
 6179              		@ args = 0, pretend = 0, frame = 16
 6180              		@ frame_needed = 1, uses_anonymous_args = 0
 6181 1050 80B5     		push	{r7, lr}
 6182              	.LCFI63:
 6183 1052 84B0     		sub	sp, sp, #16
 6184              	.LCFI64:
 6185 1054 00AF     		add	r7, sp, #0
 6186              	.LCFI65:
 6187 1056 7860     		str	r0, [r7, #4]
1716:../3rdParty/FreeRTOS/tasks.c **** tskTCB *pxUnblockedTCB;
1717:../3rdParty/FreeRTOS/tasks.c **** portBASE_TYPE xReturn;
1718:../3rdParty/FreeRTOS/tasks.c **** 
1719:../3rdParty/FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1720:../3rdParty/FreeRTOS/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1721:../3rdParty/FreeRTOS/tasks.c **** 
1722:../3rdParty/FreeRTOS/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1723:../3rdParty/FreeRTOS/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1724:../3rdParty/FreeRTOS/tasks.c **** 	it to the ready list.
1725:../3rdParty/FreeRTOS/tasks.c **** 
1726:../3rdParty/FreeRTOS/tasks.c **** 	If an event is for a queue that is locked then this function will never
1727:../3rdParty/FreeRTOS/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1728:../3rdParty/FreeRTOS/tasks.c **** 	means we can always expect exclusive access to the event list here.
1729:../3rdParty/FreeRTOS/tasks.c **** 	
1730:../3rdParty/FreeRTOS/tasks.c **** 	This function assumes that a check has already been made to ensure that
1731:../3rdParty/FreeRTOS/tasks.c **** 	pxEventList is not empty. */
1732:../3rdParty/FreeRTOS/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 6188              		.loc 1 1732 0
 6189 1058 7B68     		ldr	r3, [r7, #4]
 6190 105a DB68     		ldr	r3, [r3, #12]
 6191 105c DB68     		ldr	r3, [r3, #12]
 6192 105e BB60     		str	r3, [r7, #8]
1733:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
1734:../3rdParty/FreeRTOS/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 6193              		.loc 1 1734 0
 6194 1060 BB68     		ldr	r3, [r7, #8]
 6195 1062 03F11803 		add	r3, r3, #24
 6196 1066 1846     		mov	r0, r3
 6197 1068 FFF7FEFF 		bl	vListRemove
1735:../3rdParty/FreeRTOS/tasks.c **** 
1736:../3rdParty/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 6198              		.loc 1 1736 0
 6199 106c 40F20003 		movw	r3, #:lower16:uxSchedulerSuspended
 6200 1070 C0F20003 		movt	r3, #:upper16:uxSchedulerSuspended
 6201 1074 1B68     		ldr	r3, [r3, #0]
 6202 1076 002B     		cmp	r3, #0
 6203 1078 2BD1     		bne	.L140
1737:../3rdParty/FreeRTOS/tasks.c **** 	{
1738:../3rdParty/FreeRTOS/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 6204              		.loc 1 1738 0
 6205 107a BB68     		ldr	r3, [r7, #8]
 6206 107c 03F10403 		add	r3, r3, #4
 6207 1080 1846     		mov	r0, r3
 6208 1082 FFF7FEFF 		bl	vListRemove
1739:../3rdParty/FreeRTOS/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 6209              		.loc 1 1739 0
 6210 1086 BB68     		ldr	r3, [r7, #8]
 6211 1088 DA6A     		ldr	r2, [r3, #44]
 6212 108a 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 6213 108e C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 6214 1092 1B68     		ldr	r3, [r3, #0]
 6215 1094 9A42     		cmp	r2, r3
 6216 1096 06D9     		bls	.L141
 6217 1098 BB68     		ldr	r3, [r7, #8]
 6218 109a DA6A     		ldr	r2, [r3, #44]
 6219 109c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 6220 10a0 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 6221 10a4 1A60     		str	r2, [r3, #0]
 6222              	.L141:
 6223 10a6 BB68     		ldr	r3, [r7, #8]
 6224 10a8 DA6A     		ldr	r2, [r3, #44]
 6225 10aa 1346     		mov	r3, r2
 6226 10ac 4FEA8303 		lsl	r3, r3, #2
 6227 10b0 1344     		add	r3, r3, r2
 6228 10b2 4FEA8303 		lsl	r3, r3, #2
 6229 10b6 1A46     		mov	r2, r3
 6230 10b8 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 6231 10bc C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 6232 10c0 1A44     		add	r2, r2, r3
 6233 10c2 BB68     		ldr	r3, [r7, #8]
 6234 10c4 03F10403 		add	r3, r3, #4
 6235 10c8 1046     		mov	r0, r2
 6236 10ca 1946     		mov	r1, r3
 6237 10cc FFF7FEFF 		bl	vListInsertEnd
 6238 10d0 09E0     		b	.L142
 6239              	.L140:
1740:../3rdParty/FreeRTOS/tasks.c **** 	}
1741:../3rdParty/FreeRTOS/tasks.c **** 	else
1742:../3rdParty/FreeRTOS/tasks.c **** 	{
1743:../3rdParty/FreeRTOS/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1744:../3rdParty/FreeRTOS/tasks.c **** 		task pending until the scheduler is resumed. */
1745:../3rdParty/FreeRTOS/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 6240              		.loc 1 1745 0
 6241 10d2 BB68     		ldr	r3, [r7, #8]
 6242 10d4 03F11803 		add	r3, r3, #24
 6243 10d8 40F20000 		movw	r0, #:lower16:xPendingReadyList
 6244 10dc C0F20000 		movt	r0, #:upper16:xPendingReadyList
 6245 10e0 1946     		mov	r1, r3
 6246 10e2 FFF7FEFF 		bl	vListInsertEnd
 6247              	.L142:
1746:../3rdParty/FreeRTOS/tasks.c **** 	}
1747:../3rdParty/FreeRTOS/tasks.c **** 
1748:../3rdParty/FreeRTOS/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 6248              		.loc 1 1748 0
 6249 10e6 BB68     		ldr	r3, [r7, #8]
 6250 10e8 DA6A     		ldr	r2, [r3, #44]
 6251 10ea 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 6252 10ee C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 6253 10f2 1B68     		ldr	r3, [r3, #0]
 6254 10f4 DB6A     		ldr	r3, [r3, #44]
 6255 10f6 9A42     		cmp	r2, r3
 6256 10f8 03D3     		bcc	.L143
1749:../3rdParty/FreeRTOS/tasks.c **** 	{
1750:../3rdParty/FreeRTOS/tasks.c **** 		/* Return true if the task removed from the event list has
1751:../3rdParty/FreeRTOS/tasks.c **** 		a higher priority than the calling task.  This allows
1752:../3rdParty/FreeRTOS/tasks.c **** 		the calling task to know if it should force a context
1753:../3rdParty/FreeRTOS/tasks.c **** 		switch now. */
1754:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = pdTRUE;
 6257              		.loc 1 1754 0
 6258 10fa 4FF00103 		mov	r3, #1
 6259 10fe FB60     		str	r3, [r7, #12]
 6260 1100 02E0     		b	.L144
 6261              	.L143:
1755:../3rdParty/FreeRTOS/tasks.c **** 	}
1756:../3rdParty/FreeRTOS/tasks.c **** 	else
1757:../3rdParty/FreeRTOS/tasks.c **** 	{
1758:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = pdFALSE;
 6262              		.loc 1 1758 0
 6263 1102 4FF00003 		mov	r3, #0
 6264 1106 FB60     		str	r3, [r7, #12]
 6265              	.L144:
1759:../3rdParty/FreeRTOS/tasks.c **** 	}
1760:../3rdParty/FreeRTOS/tasks.c **** 
1761:../3rdParty/FreeRTOS/tasks.c **** 	return xReturn;
 6266              		.loc 1 1761 0
 6267 1108 FB68     		ldr	r3, [r7, #12]
1762:../3rdParty/FreeRTOS/tasks.c **** }
 6268              		.loc 1 1762 0
 6269 110a 1846     		mov	r0, r3
 6270 110c 07F11007 		add	r7, r7, #16
 6271 1110 BD46     		mov	sp, r7
 6272 1112 80BD     		pop	{r7, pc}
 6273              	.LFE77:
 6275              		.align	2
 6276              		.global	vTaskSetTimeOutState
 6277              		.thumb
 6278              		.thumb_func
 6280              	vTaskSetTimeOutState:
 6281              	.LFB78:
1763:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1764:../3rdParty/FreeRTOS/tasks.c **** 
1765:../3rdParty/FreeRTOS/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1766:../3rdParty/FreeRTOS/tasks.c **** {
 6282              		.loc 1 1766 0
 6283              		@ args = 0, pretend = 0, frame = 8
 6284              		@ frame_needed = 1, uses_anonymous_args = 0
 6285              		@ link register save eliminated.
 6286 1114 80B4     		push	{r7}
 6287              	.LCFI66:
 6288 1116 83B0     		sub	sp, sp, #12
 6289              	.LCFI67:
 6290 1118 00AF     		add	r7, sp, #0
 6291              	.LCFI68:
 6292 111a 7860     		str	r0, [r7, #4]
1767:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
1768:../3rdParty/FreeRTOS/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 6293              		.loc 1 1768 0
 6294 111c 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 6295 1120 C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 6296 1124 1A68     		ldr	r2, [r3, #0]
 6297 1126 7B68     		ldr	r3, [r7, #4]
 6298 1128 1A60     		str	r2, [r3, #0]
1769:../3rdParty/FreeRTOS/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 6299              		.loc 1 1769 0
 6300 112a 40F20003 		movw	r3, #:lower16:xTickCount
 6301 112e C0F20003 		movt	r3, #:upper16:xTickCount
 6302 1132 1A68     		ldr	r2, [r3, #0]
 6303 1134 7B68     		ldr	r3, [r7, #4]
 6304 1136 5A60     		str	r2, [r3, #4]
1770:../3rdParty/FreeRTOS/tasks.c **** }
 6305              		.loc 1 1770 0
 6306 1138 07F10C07 		add	r7, r7, #12
 6307 113c BD46     		mov	sp, r7
 6308 113e 80BC     		pop	{r7}
 6309 1140 7047     		bx	lr
 6310              	.LFE78:
 6312 1142 00BF     		.align	2
 6313              		.global	xTaskCheckForTimeOut
 6314              		.thumb
 6315              		.thumb_func
 6317              	xTaskCheckForTimeOut:
 6318              	.LFB79:
1771:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1772:../3rdParty/FreeRTOS/tasks.c **** 
1773:../3rdParty/FreeRTOS/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1774:../3rdParty/FreeRTOS/tasks.c **** {
 6319              		.loc 1 1774 0
 6320              		@ args = 0, pretend = 0, frame = 16
 6321              		@ frame_needed = 1, uses_anonymous_args = 0
 6322 1144 80B5     		push	{r7, lr}
 6323              	.LCFI69:
 6324 1146 84B0     		sub	sp, sp, #16
 6325              	.LCFI70:
 6326 1148 00AF     		add	r7, sp, #0
 6327              	.LCFI71:
 6328 114a 7860     		str	r0, [r7, #4]
 6329 114c 3960     		str	r1, [r7, #0]
1775:../3rdParty/FreeRTOS/tasks.c **** portBASE_TYPE xReturn;
1776:../3rdParty/FreeRTOS/tasks.c **** 
1777:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
1778:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxTicksToWait );
1779:../3rdParty/FreeRTOS/tasks.c **** 
1780:../3rdParty/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 6330              		.loc 1 1780 0
 6331 114e FFF7FEFF 		bl	vPortEnterCritical
1781:../3rdParty/FreeRTOS/tasks.c **** 	{
1782:../3rdParty/FreeRTOS/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1783:../3rdParty/FreeRTOS/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1784:../3rdParty/FreeRTOS/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1785:../3rdParty/FreeRTOS/tasks.c **** 			therefore never time out. */
1786:../3rdParty/FreeRTOS/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 6332              		.loc 1 1786 0
 6333 1152 3B68     		ldr	r3, [r7, #0]
 6334 1154 1B68     		ldr	r3, [r3, #0]
 6335 1156 B3F1FF3F 		cmp	r3, #-1
 6336 115a 03D1     		bne	.L149
1787:../3rdParty/FreeRTOS/tasks.c **** 			{
1788:../3rdParty/FreeRTOS/tasks.c **** 				xReturn = pdFALSE;
 6337              		.loc 1 1788 0
 6338 115c 4FF00003 		mov	r3, #0
 6339 1160 FB60     		str	r3, [r7, #12]
 6340 1162 3AE0     		b	.L150
 6341              	.L149:
1789:../3rdParty/FreeRTOS/tasks.c **** 			}
1790:../3rdParty/FreeRTOS/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1791:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1792:../3rdParty/FreeRTOS/tasks.c **** 
1793:../3rdParty/FreeRTOS/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 6342              		.loc 1 1793 0
 6343 1164 7B68     		ldr	r3, [r7, #4]
 6344 1166 1A68     		ldr	r2, [r3, #0]
 6345 1168 40F20003 		movw	r3, #:lower16:xNumOfOverflows
 6346 116c C0F20003 		movt	r3, #:upper16:xNumOfOverflows
 6347 1170 1B68     		ldr	r3, [r3, #0]
 6348 1172 9A42     		cmp	r2, r3
 6349 1174 0CD0     		beq	.L151
 6350 1176 7B68     		ldr	r3, [r7, #4]
 6351 1178 5A68     		ldr	r2, [r3, #4]
 6352 117a 40F20003 		movw	r3, #:lower16:xTickCount
 6353 117e C0F20003 		movt	r3, #:upper16:xTickCount
 6354 1182 1B68     		ldr	r3, [r3, #0]
 6355 1184 9A42     		cmp	r2, r3
 6356 1186 03D8     		bhi	.L151
1794:../3rdParty/FreeRTOS/tasks.c **** 		{
1795:../3rdParty/FreeRTOS/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1796:../3rdParty/FreeRTOS/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1797:../3rdParty/FreeRTOS/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1798:../3rdParty/FreeRTOS/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1799:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
 6357              		.loc 1 1799 0
 6358 1188 4FF00103 		mov	r3, #1
 6359 118c FB60     		str	r3, [r7, #12]
 6360              		.loc 1 1793 0
 6361 118e 24E0     		b	.L150
 6362              	.L151:
1800:../3rdParty/FreeRTOS/tasks.c **** 		}
1801:../3rdParty/FreeRTOS/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 6363              		.loc 1 1801 0
 6364 1190 40F20003 		movw	r3, #:lower16:xTickCount
 6365 1194 C0F20003 		movt	r3, #:upper16:xTickCount
 6366 1198 1A68     		ldr	r2, [r3, #0]
 6367 119a 7B68     		ldr	r3, [r7, #4]
 6368 119c 5B68     		ldr	r3, [r3, #4]
 6369 119e C3EB0202 		rsb	r2, r3, r2
 6370 11a2 3B68     		ldr	r3, [r7, #0]
 6371 11a4 1B68     		ldr	r3, [r3, #0]
 6372 11a6 9A42     		cmp	r2, r3
 6373 11a8 14D2     		bcs	.L152
1802:../3rdParty/FreeRTOS/tasks.c **** 		{
1803:../3rdParty/FreeRTOS/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1804:../3rdParty/FreeRTOS/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 6374              		.loc 1 1804 0
 6375 11aa 3B68     		ldr	r3, [r7, #0]
 6376 11ac 1A68     		ldr	r2, [r3, #0]
 6377 11ae 7B68     		ldr	r3, [r7, #4]
 6378 11b0 5968     		ldr	r1, [r3, #4]
 6379 11b2 40F20003 		movw	r3, #:lower16:xTickCount
 6380 11b6 C0F20003 		movt	r3, #:upper16:xTickCount
 6381 11ba 1B68     		ldr	r3, [r3, #0]
 6382 11bc C3EB0103 		rsb	r3, r3, r1
 6383 11c0 1A44     		add	r2, r2, r3
 6384 11c2 3B68     		ldr	r3, [r7, #0]
 6385 11c4 1A60     		str	r2, [r3, #0]
1805:../3rdParty/FreeRTOS/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 6386              		.loc 1 1805 0
 6387 11c6 7868     		ldr	r0, [r7, #4]
 6388 11c8 FFF7FEFF 		bl	vTaskSetTimeOutState
1806:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdFALSE;
 6389              		.loc 1 1806 0
 6390 11cc 4FF00003 		mov	r3, #0
 6391 11d0 FB60     		str	r3, [r7, #12]
 6392 11d2 02E0     		b	.L150
 6393              	.L152:
1807:../3rdParty/FreeRTOS/tasks.c **** 		}
1808:../3rdParty/FreeRTOS/tasks.c **** 		else
1809:../3rdParty/FreeRTOS/tasks.c **** 		{
1810:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
 6394              		.loc 1 1810 0
 6395 11d4 4FF00103 		mov	r3, #1
 6396 11d8 FB60     		str	r3, [r7, #12]
 6397              	.L150:
1811:../3rdParty/FreeRTOS/tasks.c **** 		}
1812:../3rdParty/FreeRTOS/tasks.c **** 	}
1813:../3rdParty/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 6398              		.loc 1 1813 0
 6399 11da FFF7FEFF 		bl	vPortExitCritical
1814:../3rdParty/FreeRTOS/tasks.c **** 
1815:../3rdParty/FreeRTOS/tasks.c **** 	return xReturn;
 6400              		.loc 1 1815 0
 6401 11de FB68     		ldr	r3, [r7, #12]
1816:../3rdParty/FreeRTOS/tasks.c **** }
 6402              		.loc 1 1816 0
 6403 11e0 1846     		mov	r0, r3
 6404 11e2 07F11007 		add	r7, r7, #16
 6405 11e6 BD46     		mov	sp, r7
 6406 11e8 80BD     		pop	{r7, pc}
 6407              	.LFE79:
 6409 11ea 00BF     		.align	2
 6410              		.global	vTaskMissedYield
 6411              		.thumb
 6412              		.thumb_func
 6414              	vTaskMissedYield:
 6415              	.LFB80:
1817:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1818:../3rdParty/FreeRTOS/tasks.c **** 
1819:../3rdParty/FreeRTOS/tasks.c **** void vTaskMissedYield( void )
1820:../3rdParty/FreeRTOS/tasks.c **** {
 6416              		.loc 1 1820 0
 6417              		@ args = 0, pretend = 0, frame = 0
 6418              		@ frame_needed = 1, uses_anonymous_args = 0
 6419              		@ link register save eliminated.
 6420 11ec 80B4     		push	{r7}
 6421              	.LCFI72:
 6422 11ee 00AF     		add	r7, sp, #0
 6423              	.LCFI73:
1821:../3rdParty/FreeRTOS/tasks.c **** 	xMissedYield = pdTRUE;
 6424              		.loc 1 1821 0
 6425 11f0 40F20003 		movw	r3, #:lower16:xMissedYield
 6426 11f4 C0F20003 		movt	r3, #:upper16:xMissedYield
 6427 11f8 4FF00102 		mov	r2, #1
 6428 11fc 1A60     		str	r2, [r3, #0]
1822:../3rdParty/FreeRTOS/tasks.c **** }
 6429              		.loc 1 1822 0
 6430 11fe BD46     		mov	sp, r7
 6431 1200 80BC     		pop	{r7}
 6432 1202 7047     		bx	lr
 6433              	.LFE80:
 6435              		.align	2
 6436              		.global	uxTaskGetTaskNumber
 6437              		.thumb
 6438              		.thumb_func
 6440              	uxTaskGetTaskNumber:
 6441              	.LFB81:
1823:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1824:../3rdParty/FreeRTOS/tasks.c **** 
1825:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1826:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
1827:../3rdParty/FreeRTOS/tasks.c **** 	{
 6442              		.loc 1 1827 0
 6443              		@ args = 0, pretend = 0, frame = 16
 6444              		@ frame_needed = 1, uses_anonymous_args = 0
 6445              		@ link register save eliminated.
 6446 1204 80B4     		push	{r7}
 6447              	.LCFI74:
 6448 1206 85B0     		sub	sp, sp, #20
 6449              	.LCFI75:
 6450 1208 00AF     		add	r7, sp, #0
 6451              	.LCFI76:
 6452 120a 7860     		str	r0, [r7, #4]
1828:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
1829:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1830:../3rdParty/FreeRTOS/tasks.c **** 	
1831:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask != NULL )
 6453              		.loc 1 1831 0
 6454 120c 7B68     		ldr	r3, [r7, #4]
 6455 120e 002B     		cmp	r3, #0
 6456 1210 05D0     		beq	.L157
1832:../3rdParty/FreeRTOS/tasks.c **** 		{
1833:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
 6457              		.loc 1 1833 0
 6458 1212 7B68     		ldr	r3, [r7, #4]
 6459 1214 FB60     		str	r3, [r7, #12]
1834:../3rdParty/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
 6460              		.loc 1 1834 0
 6461 1216 FB68     		ldr	r3, [r7, #12]
 6462 1218 5B6C     		ldr	r3, [r3, #68]
 6463 121a BB60     		str	r3, [r7, #8]
 6464 121c 02E0     		b	.L158
 6465              	.L157:
1835:../3rdParty/FreeRTOS/tasks.c **** 		}
1836:../3rdParty/FreeRTOS/tasks.c **** 		else
1837:../3rdParty/FreeRTOS/tasks.c **** 		{
1838:../3rdParty/FreeRTOS/tasks.c **** 			uxReturn = 0U;
 6466              		.loc 1 1838 0
 6467 121e 4FF00003 		mov	r3, #0
 6468 1222 BB60     		str	r3, [r7, #8]
 6469              	.L158:
1839:../3rdParty/FreeRTOS/tasks.c **** 		}
1840:../3rdParty/FreeRTOS/tasks.c **** 		
1841:../3rdParty/FreeRTOS/tasks.c **** 		return uxReturn;
 6470              		.loc 1 1841 0
 6471 1224 BB68     		ldr	r3, [r7, #8]
1842:../3rdParty/FreeRTOS/tasks.c **** 	}
 6472              		.loc 1 1842 0
 6473 1226 1846     		mov	r0, r3
 6474 1228 07F11407 		add	r7, r7, #20
 6475 122c BD46     		mov	sp, r7
 6476 122e 80BC     		pop	{r7}
 6477 1230 7047     		bx	lr
 6478              	.LFE81:
 6480 1232 00BF     		.align	2
 6481              		.global	vTaskSetTaskNumber
 6482              		.thumb
 6483              		.thumb_func
 6485              	vTaskSetTaskNumber:
 6486              	.LFB82:
1843:../3rdParty/FreeRTOS/tasks.c **** #endif
1844:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1845:../3rdParty/FreeRTOS/tasks.c **** 
1846:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1847:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
1848:../3rdParty/FreeRTOS/tasks.c **** 	{
 6487              		.loc 1 1848 0
 6488              		@ args = 0, pretend = 0, frame = 16
 6489              		@ frame_needed = 1, uses_anonymous_args = 0
 6490              		@ link register save eliminated.
 6491 1234 80B4     		push	{r7}
 6492              	.LCFI77:
 6493 1236 85B0     		sub	sp, sp, #20
 6494              	.LCFI78:
 6495 1238 00AF     		add	r7, sp, #0
 6496              	.LCFI79:
 6497 123a 7860     		str	r0, [r7, #4]
 6498 123c 3960     		str	r1, [r7, #0]
1849:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1850:../3rdParty/FreeRTOS/tasks.c **** 	
1851:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask != NULL )
 6499              		.loc 1 1851 0
 6500 123e 7B68     		ldr	r3, [r7, #4]
 6501 1240 002B     		cmp	r3, #0
 6502 1242 04D0     		beq	.L162
1852:../3rdParty/FreeRTOS/tasks.c **** 		{
1853:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
 6503              		.loc 1 1853 0
 6504 1244 7B68     		ldr	r3, [r7, #4]
 6505 1246 FB60     		str	r3, [r7, #12]
1854:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
 6506              		.loc 1 1854 0
 6507 1248 FB68     		ldr	r3, [r7, #12]
 6508 124a 3A68     		ldr	r2, [r7, #0]
 6509 124c 5A64     		str	r2, [r3, #68]
 6510              	.L162:
1855:../3rdParty/FreeRTOS/tasks.c **** 		}
1856:../3rdParty/FreeRTOS/tasks.c **** 	}
 6511              		.loc 1 1856 0
 6512 124e 07F11407 		add	r7, r7, #20
 6513 1252 BD46     		mov	sp, r7
 6514 1254 80BC     		pop	{r7}
 6515 1256 7047     		bx	lr
 6516              	.LFE82:
 6518              		.align	2
 6519              		.thumb
 6520              		.thumb_func
 6522              	prvIdleTask:
 6523              	.LFB83:
1857:../3rdParty/FreeRTOS/tasks.c **** #endif
1858:../3rdParty/FreeRTOS/tasks.c **** 
1859:../3rdParty/FreeRTOS/tasks.c **** 
1860:../3rdParty/FreeRTOS/tasks.c **** /*
1861:../3rdParty/FreeRTOS/tasks.c ****  * -----------------------------------------------------------
1862:../3rdParty/FreeRTOS/tasks.c ****  * The Idle task.
1863:../3rdParty/FreeRTOS/tasks.c ****  * ----------------------------------------------------------
1864:../3rdParty/FreeRTOS/tasks.c ****  *
1865:../3rdParty/FreeRTOS/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1866:../3rdParty/FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1867:../3rdParty/FreeRTOS/tasks.c ****  *
1868:../3rdParty/FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
1869:../3rdParty/FreeRTOS/tasks.c ****  *
1870:../3rdParty/FreeRTOS/tasks.c ****  */
1871:../3rdParty/FreeRTOS/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1872:../3rdParty/FreeRTOS/tasks.c **** {
 6524              		.loc 1 1872 0
 6525              		@ args = 0, pretend = 0, frame = 8
 6526              		@ frame_needed = 1, uses_anonymous_args = 0
 6527 1258 80B5     		push	{r7, lr}
 6528              	.LCFI80:
 6529 125a 82B0     		sub	sp, sp, #8
 6530              	.LCFI81:
 6531 125c 00AF     		add	r7, sp, #0
 6532              	.LCFI82:
 6533 125e 7860     		str	r0, [r7, #4]
 6534              	.L164:
1873:../3rdParty/FreeRTOS/tasks.c **** 	/* Stop warnings. */
1874:../3rdParty/FreeRTOS/tasks.c **** 	( void ) pvParameters;
1875:../3rdParty/FreeRTOS/tasks.c **** 
1876:../3rdParty/FreeRTOS/tasks.c **** 	for( ;; )
1877:../3rdParty/FreeRTOS/tasks.c **** 	{
1878:../3rdParty/FreeRTOS/tasks.c **** 		/* See if any tasks have been deleted. */
1879:../3rdParty/FreeRTOS/tasks.c **** 		prvCheckTasksWaitingTermination();
 6535              		.loc 1 1879 0
 6536 1260 00F096F8 		bl	prvCheckTasksWaitingTermination
1880:../3rdParty/FreeRTOS/tasks.c **** 
1881:../3rdParty/FreeRTOS/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1882:../3rdParty/FreeRTOS/tasks.c **** 		{
1883:../3rdParty/FreeRTOS/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1884:../3rdParty/FreeRTOS/tasks.c **** 			see if any other task has become available.  If we are using
1885:../3rdParty/FreeRTOS/tasks.c **** 			preemption we don't need to do this as any task becoming available
1886:../3rdParty/FreeRTOS/tasks.c **** 			will automatically get the processor anyway. */
1887:../3rdParty/FreeRTOS/tasks.c **** 			taskYIELD();
1888:../3rdParty/FreeRTOS/tasks.c **** 		}
1889:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1890:../3rdParty/FreeRTOS/tasks.c **** 
1891:../3rdParty/FreeRTOS/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1892:../3rdParty/FreeRTOS/tasks.c **** 		{
1893:../3rdParty/FreeRTOS/tasks.c **** 			/* When using preemption tasks of equal priority will be
1894:../3rdParty/FreeRTOS/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1895:../3rdParty/FreeRTOS/tasks.c **** 			to run then the idle task should yield before the end of the
1896:../3rdParty/FreeRTOS/tasks.c **** 			timeslice.
1897:../3rdParty/FreeRTOS/tasks.c **** 
1898:../3rdParty/FreeRTOS/tasks.c **** 			A critical region is not required here as we are just reading from
1899:../3rdParty/FreeRTOS/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1900:../3rdParty/FreeRTOS/tasks.c **** 			the ready list at the idle priority contains more than one task
1901:../3rdParty/FreeRTOS/tasks.c **** 			then a task other than the idle task is ready to execute. */
1902:../3rdParty/FreeRTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1903:../3rdParty/FreeRTOS/tasks.c **** 			{
1904:../3rdParty/FreeRTOS/tasks.c **** 				taskYIELD();
1905:../3rdParty/FreeRTOS/tasks.c **** 			}
1906:../3rdParty/FreeRTOS/tasks.c **** 		}
1907:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1908:../3rdParty/FreeRTOS/tasks.c **** 
1909:../3rdParty/FreeRTOS/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1910:../3rdParty/FreeRTOS/tasks.c **** 		{
1911:../3rdParty/FreeRTOS/tasks.c **** 			extern void vApplicationIdleHook( void );
1912:../3rdParty/FreeRTOS/tasks.c **** 
1913:../3rdParty/FreeRTOS/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1914:../3rdParty/FreeRTOS/tasks.c **** 			allows the application designer to add background functionality
1915:../3rdParty/FreeRTOS/tasks.c **** 			without the overhead of a separate task.
1916:../3rdParty/FreeRTOS/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1917:../3rdParty/FreeRTOS/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1918:../3rdParty/FreeRTOS/tasks.c **** 			vApplicationIdleHook();
1919:../3rdParty/FreeRTOS/tasks.c **** 		}
1920:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1921:../3rdParty/FreeRTOS/tasks.c **** 	}
 6537              		.loc 1 1921 0
 6538 1264 FCE7     		b	.L164
 6539              	.LFE83:
 6541 1266 00BF     		.align	2
 6542              		.thumb
 6543              		.thumb_func
 6545              	prvInitialiseTCBVariables:
 6546              	.LFB84:
1922:../3rdParty/FreeRTOS/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1923:../3rdParty/FreeRTOS/tasks.c **** 
1924:../3rdParty/FreeRTOS/tasks.c **** 
1925:../3rdParty/FreeRTOS/tasks.c **** 
1926:../3rdParty/FreeRTOS/tasks.c **** 
1927:../3rdParty/FreeRTOS/tasks.c **** 
1928:../3rdParty/FreeRTOS/tasks.c **** 
1929:../3rdParty/FreeRTOS/tasks.c **** 
1930:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1931:../3rdParty/FreeRTOS/tasks.c ****  * File private functions documented at the top of the file.
1932:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1933:../3rdParty/FreeRTOS/tasks.c **** 
1934:../3rdParty/FreeRTOS/tasks.c **** 
1935:../3rdParty/FreeRTOS/tasks.c **** 
1936:../3rdParty/FreeRTOS/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1937:../3rdParty/FreeRTOS/tasks.c **** {
 6547              		.loc 1 1937 0
 6548              		@ args = 4, pretend = 0, frame = 16
 6549              		@ frame_needed = 1, uses_anonymous_args = 0
 6550 1268 80B5     		push	{r7, lr}
 6551              	.LCFI83:
 6552 126a 84B0     		sub	sp, sp, #16
 6553              	.LCFI84:
 6554 126c 00AF     		add	r7, sp, #0
 6555              	.LCFI85:
 6556 126e F860     		str	r0, [r7, #12]
 6557 1270 B960     		str	r1, [r7, #8]
 6558 1272 7A60     		str	r2, [r7, #4]
 6559 1274 3B60     		str	r3, [r7, #0]
1938:../3rdParty/FreeRTOS/tasks.c **** 	/* Store the function name in the TCB. */
1939:../3rdParty/FreeRTOS/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1940:../3rdParty/FreeRTOS/tasks.c **** 	{
1941:../3rdParty/FreeRTOS/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1942:../3rdParty/FreeRTOS/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 6560              		.loc 1 1942 0
 6561 1276 FB68     		ldr	r3, [r7, #12]
 6562 1278 03F13403 		add	r3, r3, #52
 6563 127c 1A46     		mov	r2, r3
 6564 127e BB68     		ldr	r3, [r7, #8]
 6565 1280 1046     		mov	r0, r2
 6566 1282 1946     		mov	r1, r3
 6567 1284 4FF00C02 		mov	r2, #12
 6568 1288 FFF7FEFF 		bl	strncpy
1943:../3rdParty/FreeRTOS/tasks.c **** 	}
1944:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1945:../3rdParty/FreeRTOS/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 6569              		.loc 1 1945 0
 6570 128c FB68     		ldr	r3, [r7, #12]
 6571 128e 4FF00002 		mov	r2, #0
 6572 1292 83F83F20 		strb	r2, [r3, #63]
1946:../3rdParty/FreeRTOS/tasks.c **** 
1947:../3rdParty/FreeRTOS/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1948:../3rdParty/FreeRTOS/tasks.c **** 	remove the privilege bit if one is present. */
1949:../3rdParty/FreeRTOS/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 6573              		.loc 1 1949 0
 6574 1296 7B68     		ldr	r3, [r7, #4]
 6575 1298 042B     		cmp	r3, #4
 6576 129a 02D9     		bls	.L167
1950:../3rdParty/FreeRTOS/tasks.c **** 	{
1951:../3rdParty/FreeRTOS/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 6577              		.loc 1 1951 0
 6578 129c 4FF00403 		mov	r3, #4
 6579 12a0 7B60     		str	r3, [r7, #4]
 6580              	.L167:
1952:../3rdParty/FreeRTOS/tasks.c **** 	}
1953:../3rdParty/FreeRTOS/tasks.c **** 
1954:../3rdParty/FreeRTOS/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 6581              		.loc 1 1954 0
 6582 12a2 FB68     		ldr	r3, [r7, #12]
 6583 12a4 7A68     		ldr	r2, [r7, #4]
 6584 12a6 DA62     		str	r2, [r3, #44]
1955:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
1956:../3rdParty/FreeRTOS/tasks.c **** 	{
1957:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 6585              		.loc 1 1957 0
 6586 12a8 FB68     		ldr	r3, [r7, #12]
 6587 12aa 7A68     		ldr	r2, [r7, #4]
 6588 12ac 9A64     		str	r2, [r3, #72]
1958:../3rdParty/FreeRTOS/tasks.c **** 	}
1959:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1960:../3rdParty/FreeRTOS/tasks.c **** 
1961:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 6589              		.loc 1 1961 0
 6590 12ae FB68     		ldr	r3, [r7, #12]
 6591 12b0 03F10403 		add	r3, r3, #4
 6592 12b4 1846     		mov	r0, r3
 6593 12b6 FFF7FEFF 		bl	vListInitialiseItem
1962:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 6594              		.loc 1 1962 0
 6595 12ba FB68     		ldr	r3, [r7, #12]
 6596 12bc 03F11803 		add	r3, r3, #24
 6597 12c0 1846     		mov	r0, r3
 6598 12c2 FFF7FEFF 		bl	vListInitialiseItem
1963:../3rdParty/FreeRTOS/tasks.c **** 
1964:../3rdParty/FreeRTOS/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1965:../3rdParty/FreeRTOS/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
1966:../3rdParty/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 6599              		.loc 1 1966 0
 6600 12c6 FB68     		ldr	r3, [r7, #12]
 6601 12c8 FA68     		ldr	r2, [r7, #12]
 6602 12ca 1A61     		str	r2, [r3, #16]
1967:../3rdParty/FreeRTOS/tasks.c **** 
1968:../3rdParty/FreeRTOS/tasks.c **** 	/* Event lists are always in priority order. */
1969:../3rdParty/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 6603              		.loc 1 1969 0
 6604 12cc 7B68     		ldr	r3, [r7, #4]
 6605 12ce C3F10502 		rsb	r2, r3, #5
 6606 12d2 FB68     		ldr	r3, [r7, #12]
 6607 12d4 9A61     		str	r2, [r3, #24]
1970:../3rdParty/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 6608              		.loc 1 1970 0
 6609 12d6 FB68     		ldr	r3, [r7, #12]
 6610 12d8 FA68     		ldr	r2, [r7, #12]
 6611 12da 5A62     		str	r2, [r3, #36]
1971:../3rdParty/FreeRTOS/tasks.c **** 
1972:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1973:../3rdParty/FreeRTOS/tasks.c **** 	{
1974:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
1975:../3rdParty/FreeRTOS/tasks.c **** 	}
1976:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1977:../3rdParty/FreeRTOS/tasks.c **** 
1978:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1979:../3rdParty/FreeRTOS/tasks.c **** 	{
1980:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB->pxTaskTag = NULL;
1981:../3rdParty/FreeRTOS/tasks.c **** 	}
1982:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1983:../3rdParty/FreeRTOS/tasks.c **** 
1984:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1985:../3rdParty/FreeRTOS/tasks.c **** 	{
1986:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
 6612              		.loc 1 1986 0
 6613 12dc FB68     		ldr	r3, [r7, #12]
 6614 12de 4FF00002 		mov	r2, #0
 6615 12e2 DA64     		str	r2, [r3, #76]
1987:../3rdParty/FreeRTOS/tasks.c **** 	}
1988:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1989:../3rdParty/FreeRTOS/tasks.c **** 
1990:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1991:../3rdParty/FreeRTOS/tasks.c **** 	{
1992:../3rdParty/FreeRTOS/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1993:../3rdParty/FreeRTOS/tasks.c **** 	}
1994:../3rdParty/FreeRTOS/tasks.c **** 	#else
1995:../3rdParty/FreeRTOS/tasks.c **** 	{
1996:../3rdParty/FreeRTOS/tasks.c **** 		( void ) xRegions;
1997:../3rdParty/FreeRTOS/tasks.c **** 		( void ) usStackDepth;
1998:../3rdParty/FreeRTOS/tasks.c **** 	}
1999:../3rdParty/FreeRTOS/tasks.c **** 	#endif
2000:../3rdParty/FreeRTOS/tasks.c **** }
 6616              		.loc 1 2000 0
 6617 12e4 07F11007 		add	r7, r7, #16
 6618 12e8 BD46     		mov	sp, r7
 6619 12ea 80BD     		pop	{r7, pc}
 6620              	.LFE84:
 6622              		.align	2
 6623              		.thumb
 6624              		.thumb_func
 6626              	prvInitialiseTaskLists:
 6627              	.LFB85:
2001:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2002:../3rdParty/FreeRTOS/tasks.c **** 
2003:../3rdParty/FreeRTOS/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2004:../3rdParty/FreeRTOS/tasks.c **** 
2005:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2006:../3rdParty/FreeRTOS/tasks.c **** 	{
2007:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
2008:../3rdParty/FreeRTOS/tasks.c **** 	
2009:../3rdParty/FreeRTOS/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2010:../3rdParty/FreeRTOS/tasks.c **** 		{
2011:../3rdParty/FreeRTOS/tasks.c **** 			xTaskToModify = NULL;
2012:../3rdParty/FreeRTOS/tasks.c **** 		}
2013:../3rdParty/FreeRTOS/tasks.c **** 
2014:../3rdParty/FreeRTOS/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2015:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2016:../3rdParty/FreeRTOS/tasks.c **** 
2017:../3rdParty/FreeRTOS/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2018:../3rdParty/FreeRTOS/tasks.c **** 	}
2019:../3rdParty/FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
2020:../3rdParty/FreeRTOS/tasks.c **** #endif
2021:../3rdParty/FreeRTOS/tasks.c **** 
2022:../3rdParty/FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void )
2023:../3rdParty/FreeRTOS/tasks.c **** {
 6628              		.loc 1 2023 0
 6629              		@ args = 0, pretend = 0, frame = 8
 6630              		@ frame_needed = 1, uses_anonymous_args = 0
 6631 12ec 80B5     		push	{r7, lr}
 6632              	.LCFI86:
 6633 12ee 82B0     		sub	sp, sp, #8
 6634              	.LCFI87:
 6635 12f0 00AF     		add	r7, sp, #0
 6636              	.LCFI88:
2024:../3rdParty/FreeRTOS/tasks.c **** unsigned portBASE_TYPE uxPriority;
2025:../3rdParty/FreeRTOS/tasks.c **** 
2026:../3rdParty/FreeRTOS/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 6637              		.loc 1 2026 0
 6638 12f2 4FF00003 		mov	r3, #0
 6639 12f6 7B60     		str	r3, [r7, #4]
 6640 12f8 13E0     		b	.L170
 6641              	.L171:
2027:../3rdParty/FreeRTOS/tasks.c **** 	{
2028:../3rdParty/FreeRTOS/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 6642              		.loc 1 2028 0
 6643 12fa 7A68     		ldr	r2, [r7, #4]
 6644 12fc 1346     		mov	r3, r2
 6645 12fe 4FEA8303 		lsl	r3, r3, #2
 6646 1302 1344     		add	r3, r3, r2
 6647 1304 4FEA8303 		lsl	r3, r3, #2
 6648 1308 1A46     		mov	r2, r3
 6649 130a 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 6650 130e C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 6651 1312 1344     		add	r3, r2, r3
 6652 1314 1846     		mov	r0, r3
 6653 1316 FFF7FEFF 		bl	vListInitialise
 6654              		.loc 1 2026 0
 6655 131a 7B68     		ldr	r3, [r7, #4]
 6656 131c 03F10103 		add	r3, r3, #1
 6657 1320 7B60     		str	r3, [r7, #4]
 6658              	.L170:
 6659 1322 7B68     		ldr	r3, [r7, #4]
 6660 1324 042B     		cmp	r3, #4
 6661 1326 E8D9     		bls	.L171
2029:../3rdParty/FreeRTOS/tasks.c **** 	}
2030:../3rdParty/FreeRTOS/tasks.c **** 
2031:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 6662              		.loc 1 2031 0
 6663 1328 40F20000 		movw	r0, #:lower16:xDelayedTaskList1
 6664 132c C0F20000 		movt	r0, #:upper16:xDelayedTaskList1
 6665 1330 FFF7FEFF 		bl	vListInitialise
2032:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 6666              		.loc 1 2032 0
 6667 1334 40F20000 		movw	r0, #:lower16:xDelayedTaskList2
 6668 1338 C0F20000 		movt	r0, #:upper16:xDelayedTaskList2
 6669 133c FFF7FEFF 		bl	vListInitialise
2033:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 6670              		.loc 1 2033 0
 6671 1340 40F20000 		movw	r0, #:lower16:xPendingReadyList
 6672 1344 C0F20000 		movt	r0, #:upper16:xPendingReadyList
 6673 1348 FFF7FEFF 		bl	vListInitialise
2034:../3rdParty/FreeRTOS/tasks.c **** 
2035:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2036:../3rdParty/FreeRTOS/tasks.c **** 	{
2037:../3rdParty/FreeRTOS/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 6674              		.loc 1 2037 0
 6675 134c 40F20000 		movw	r0, #:lower16:xTasksWaitingTermination
 6676 1350 C0F20000 		movt	r0, #:upper16:xTasksWaitingTermination
 6677 1354 FFF7FEFF 		bl	vListInitialise
2038:../3rdParty/FreeRTOS/tasks.c **** 	}
2039:../3rdParty/FreeRTOS/tasks.c **** 	#endif
2040:../3rdParty/FreeRTOS/tasks.c **** 
2041:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2042:../3rdParty/FreeRTOS/tasks.c **** 	{
2043:../3rdParty/FreeRTOS/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 6678              		.loc 1 2043 0
 6679 1358 40F20000 		movw	r0, #:lower16:xSuspendedTaskList
 6680 135c C0F20000 		movt	r0, #:upper16:xSuspendedTaskList
 6681 1360 FFF7FEFF 		bl	vListInitialise
2044:../3rdParty/FreeRTOS/tasks.c **** 	}
2045:../3rdParty/FreeRTOS/tasks.c **** 	#endif
2046:../3rdParty/FreeRTOS/tasks.c **** 
2047:../3rdParty/FreeRTOS/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2048:../3rdParty/FreeRTOS/tasks.c **** 	using list2. */
2049:../3rdParty/FreeRTOS/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 6682              		.loc 1 2049 0
 6683 1364 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 6684 1368 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 6685 136c 40F20002 		movw	r2, #:lower16:xDelayedTaskList1
 6686 1370 C0F20002 		movt	r2, #:upper16:xDelayedTaskList1
 6687 1374 1A60     		str	r2, [r3, #0]
2050:../3rdParty/FreeRTOS/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 6688              		.loc 1 2050 0
 6689 1376 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 6690 137a C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 6691 137e 40F20002 		movw	r2, #:lower16:xDelayedTaskList2
 6692 1382 C0F20002 		movt	r2, #:upper16:xDelayedTaskList2
 6693 1386 1A60     		str	r2, [r3, #0]
2051:../3rdParty/FreeRTOS/tasks.c **** }
 6694              		.loc 1 2051 0
 6695 1388 07F10807 		add	r7, r7, #8
 6696 138c BD46     		mov	sp, r7
 6697 138e 80BD     		pop	{r7, pc}
 6698              	.LFE85:
 6700              		.align	2
 6701              		.thumb
 6702              		.thumb_func
 6704              	prvCheckTasksWaitingTermination:
 6705              	.LFB86:
2052:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2053:../3rdParty/FreeRTOS/tasks.c **** 
2054:../3rdParty/FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2055:../3rdParty/FreeRTOS/tasks.c **** {
 6706              		.loc 1 2055 0
 6707              		@ args = 0, pretend = 0, frame = 8
 6708              		@ frame_needed = 1, uses_anonymous_args = 0
 6709 1390 80B5     		push	{r7, lr}
 6710              	.LCFI89:
 6711 1392 82B0     		sub	sp, sp, #8
 6712              	.LCFI90:
 6713 1394 00AF     		add	r7, sp, #0
 6714              	.LCFI91:
 6715              	.LBB9:
2056:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2057:../3rdParty/FreeRTOS/tasks.c **** 	{
2058:../3rdParty/FreeRTOS/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2059:../3rdParty/FreeRTOS/tasks.c **** 
2060:../3rdParty/FreeRTOS/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2061:../3rdParty/FreeRTOS/tasks.c **** 		too often in the idle task. */
2062:../3rdParty/FreeRTOS/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 6716              		.loc 1 2062 0
 6717 1396 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 6718 139a C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 6719 139e 1B68     		ldr	r3, [r3, #0]
 6720 13a0 002B     		cmp	r3, #0
 6721 13a2 3CD0     		beq	.L175
2063:../3rdParty/FreeRTOS/tasks.c **** 		{
2064:../3rdParty/FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 6722              		.loc 1 2064 0
 6723 13a4 FFF7FEFF 		bl	vTaskSuspendAll
2065:../3rdParty/FreeRTOS/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 6724              		.loc 1 2065 0
 6725 13a8 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 6726 13ac C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 6727 13b0 1B68     		ldr	r3, [r3, #0]
 6728 13b2 002B     		cmp	r3, #0
 6729 13b4 14BF     		ite	ne
 6730 13b6 0023     		movne	r3, #0
 6731 13b8 0123     		moveq	r3, #1
 6732 13ba 3B60     		str	r3, [r7, #0]
2066:../3rdParty/FreeRTOS/tasks.c **** 			xTaskResumeAll();
 6733              		.loc 1 2066 0
 6734 13bc FFF7FEFF 		bl	xTaskResumeAll
2067:../3rdParty/FreeRTOS/tasks.c **** 
2068:../3rdParty/FreeRTOS/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 6735              		.loc 1 2068 0
 6736 13c0 3B68     		ldr	r3, [r7, #0]
 6737 13c2 002B     		cmp	r3, #0
 6738 13c4 2BD1     		bne	.L175
 6739              	.LBB10:
2069:../3rdParty/FreeRTOS/tasks.c **** 			{
2070:../3rdParty/FreeRTOS/tasks.c **** 				tskTCB *pxTCB;
2071:../3rdParty/FreeRTOS/tasks.c **** 
2072:../3rdParty/FreeRTOS/tasks.c **** 				taskENTER_CRITICAL();
 6740              		.loc 1 2072 0
 6741 13c6 FFF7FEFF 		bl	vPortEnterCritical
2073:../3rdParty/FreeRTOS/tasks.c **** 				{
2074:../3rdParty/FreeRTOS/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 6742              		.loc 1 2074 0
 6743 13ca 40F20003 		movw	r3, #:lower16:xTasksWaitingTermination
 6744 13ce C0F20003 		movt	r3, #:upper16:xTasksWaitingTermination
 6745 13d2 DB68     		ldr	r3, [r3, #12]
 6746 13d4 DB68     		ldr	r3, [r3, #12]
 6747 13d6 7B60     		str	r3, [r7, #4]
2075:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 6748              		.loc 1 2075 0
 6749 13d8 7B68     		ldr	r3, [r7, #4]
 6750 13da 03F10403 		add	r3, r3, #4
 6751 13de 1846     		mov	r0, r3
 6752 13e0 FFF7FEFF 		bl	vListRemove
2076:../3rdParty/FreeRTOS/tasks.c **** 					--uxCurrentNumberOfTasks;
 6753              		.loc 1 2076 0
 6754 13e4 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 6755 13e8 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 6756 13ec 1B68     		ldr	r3, [r3, #0]
 6757 13ee 03F1FF32 		add	r2, r3, #-1
 6758 13f2 40F20003 		movw	r3, #:lower16:uxCurrentNumberOfTasks
 6759 13f6 C0F20003 		movt	r3, #:upper16:uxCurrentNumberOfTasks
 6760 13fa 1A60     		str	r2, [r3, #0]
2077:../3rdParty/FreeRTOS/tasks.c **** 					--uxTasksDeleted;
 6761              		.loc 1 2077 0
 6762 13fc 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 6763 1400 C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 6764 1404 1B68     		ldr	r3, [r3, #0]
 6765 1406 03F1FF32 		add	r2, r3, #-1
 6766 140a 40F20003 		movw	r3, #:lower16:uxTasksDeleted
 6767 140e C0F20003 		movt	r3, #:upper16:uxTasksDeleted
 6768 1412 1A60     		str	r2, [r3, #0]
2078:../3rdParty/FreeRTOS/tasks.c **** 				}
2079:../3rdParty/FreeRTOS/tasks.c **** 				taskEXIT_CRITICAL();
 6769              		.loc 1 2079 0
 6770 1414 FFF7FEFF 		bl	vPortExitCritical
2080:../3rdParty/FreeRTOS/tasks.c **** 
2081:../3rdParty/FreeRTOS/tasks.c **** 				prvDeleteTCB( pxTCB );
 6771              		.loc 1 2081 0
 6772 1418 7868     		ldr	r0, [r7, #4]
 6773 141a 00F0ABF9 		bl	prvDeleteTCB
 6774              	.L175:
 6775              	.LBE10:
 6776              	.LBE9:
2082:../3rdParty/FreeRTOS/tasks.c **** 			}
2083:../3rdParty/FreeRTOS/tasks.c **** 		}
2084:../3rdParty/FreeRTOS/tasks.c **** 	}
2085:../3rdParty/FreeRTOS/tasks.c **** 	#endif
2086:../3rdParty/FreeRTOS/tasks.c **** }
 6777              		.loc 1 2086 0
 6778 141e 07F10807 		add	r7, r7, #8
 6779 1422 BD46     		mov	sp, r7
 6780 1424 80BD     		pop	{r7, pc}
 6781              	.LFE86:
 6783 1426 00BF     		.align	2
 6784              		.thumb
 6785              		.thumb_func
 6787              	prvAddCurrentTaskToDelayedList:
 6788              	.LFB87:
2087:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2088:../3rdParty/FreeRTOS/tasks.c **** 
2089:../3rdParty/FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2090:../3rdParty/FreeRTOS/tasks.c **** {
 6789              		.loc 1 2090 0
 6790              		@ args = 0, pretend = 0, frame = 8
 6791              		@ frame_needed = 1, uses_anonymous_args = 0
 6792 1428 80B5     		push	{r7, lr}
 6793              	.LCFI92:
 6794 142a 82B0     		sub	sp, sp, #8
 6795              	.LCFI93:
 6796 142c 00AF     		add	r7, sp, #0
 6797              	.LCFI94:
 6798 142e 7860     		str	r0, [r7, #4]
2091:../3rdParty/FreeRTOS/tasks.c **** 	/* The list item will be inserted in wake time order. */
2092:../3rdParty/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 6799              		.loc 1 2092 0
 6800 1430 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 6801 1434 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 6802 1438 1B68     		ldr	r3, [r3, #0]
 6803 143a 7A68     		ldr	r2, [r7, #4]
 6804 143c 5A60     		str	r2, [r3, #4]
2093:../3rdParty/FreeRTOS/tasks.c **** 
2094:../3rdParty/FreeRTOS/tasks.c **** 	if( xTimeToWake < xTickCount )
 6805              		.loc 1 2094 0
 6806 143e 40F20003 		movw	r3, #:lower16:xTickCount
 6807 1442 C0F20003 		movt	r3, #:upper16:xTickCount
 6808 1446 1B68     		ldr	r3, [r3, #0]
 6809 1448 7A68     		ldr	r2, [r7, #4]
 6810 144a 9A42     		cmp	r2, r3
 6811 144c 10D2     		bcs	.L177
2095:../3rdParty/FreeRTOS/tasks.c **** 	{
2096:../3rdParty/FreeRTOS/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2097:../3rdParty/FreeRTOS/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 6812              		.loc 1 2097 0
 6813 144e 40F20003 		movw	r3, #:lower16:pxOverflowDelayedTaskList
 6814 1452 C0F20003 		movt	r3, #:upper16:pxOverflowDelayedTaskList
 6815 1456 1A68     		ldr	r2, [r3, #0]
 6816 1458 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 6817 145c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 6818 1460 1B68     		ldr	r3, [r3, #0]
 6819 1462 03F10403 		add	r3, r3, #4
 6820 1466 1046     		mov	r0, r2
 6821 1468 1946     		mov	r1, r3
 6822 146a FFF7FEFF 		bl	vListInsert
 6823 146e 1DE0     		b	.L179
 6824              	.L177:
2098:../3rdParty/FreeRTOS/tasks.c **** 	}
2099:../3rdParty/FreeRTOS/tasks.c **** 	else
2100:../3rdParty/FreeRTOS/tasks.c **** 	{
2101:../3rdParty/FreeRTOS/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2102:../3rdParty/FreeRTOS/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 6825              		.loc 1 2102 0
 6826 1470 40F20003 		movw	r3, #:lower16:pxDelayedTaskList
 6827 1474 C0F20003 		movt	r3, #:upper16:pxDelayedTaskList
 6828 1478 1A68     		ldr	r2, [r3, #0]
 6829 147a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 6830 147e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 6831 1482 1B68     		ldr	r3, [r3, #0]
 6832 1484 03F10403 		add	r3, r3, #4
 6833 1488 1046     		mov	r0, r2
 6834 148a 1946     		mov	r1, r3
 6835 148c FFF7FEFF 		bl	vListInsert
2103:../3rdParty/FreeRTOS/tasks.c **** 
2104:../3rdParty/FreeRTOS/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2105:../3rdParty/FreeRTOS/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2106:../3rdParty/FreeRTOS/tasks.c **** 		too. */
2107:../3rdParty/FreeRTOS/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 6836              		.loc 1 2107 0
 6837 1490 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 6838 1494 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 6839 1498 1B68     		ldr	r3, [r3, #0]
 6840 149a 7A68     		ldr	r2, [r7, #4]
 6841 149c 9A42     		cmp	r2, r3
 6842 149e 05D2     		bcs	.L179
2108:../3rdParty/FreeRTOS/tasks.c **** 		{
2109:../3rdParty/FreeRTOS/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 6843              		.loc 1 2109 0
 6844 14a0 40F20003 		movw	r3, #:lower16:xNextTaskUnblockTime
 6845 14a4 C0F20003 		movt	r3, #:upper16:xNextTaskUnblockTime
 6846 14a8 7A68     		ldr	r2, [r7, #4]
 6847 14aa 1A60     		str	r2, [r3, #0]
 6848              	.L179:
2110:../3rdParty/FreeRTOS/tasks.c **** 		}
2111:../3rdParty/FreeRTOS/tasks.c **** 	}
2112:../3rdParty/FreeRTOS/tasks.c **** }
 6849              		.loc 1 2112 0
 6850 14ac 07F10807 		add	r7, r7, #8
 6851 14b0 BD46     		mov	sp, r7
 6852 14b2 80BD     		pop	{r7, pc}
 6853              	.LFE87:
 6855              		.align	2
 6856              		.thumb
 6857              		.thumb_func
 6859              	prvAllocateTCBAndStack:
 6860              	.LFB88:
2113:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2114:../3rdParty/FreeRTOS/tasks.c **** 
2115:../3rdParty/FreeRTOS/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2116:../3rdParty/FreeRTOS/tasks.c **** {
 6861              		.loc 1 2116 0
 6862              		@ args = 0, pretend = 0, frame = 16
 6863              		@ frame_needed = 1, uses_anonymous_args = 0
 6864 14b4 80B5     		push	{r7, lr}
 6865              	.LCFI95:
 6866 14b6 84B0     		sub	sp, sp, #16
 6867              	.LCFI96:
 6868 14b8 00AF     		add	r7, sp, #0
 6869              	.LCFI97:
 6870 14ba 0346     		mov	r3, r0
 6871 14bc 3960     		str	r1, [r7, #0]
 6872 14be FB80     		strh	r3, [r7, #6]	@ movhi
2117:../3rdParty/FreeRTOS/tasks.c **** tskTCB *pxNewTCB;
2118:../3rdParty/FreeRTOS/tasks.c **** 
2119:../3rdParty/FreeRTOS/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2120:../3rdParty/FreeRTOS/tasks.c **** 	the implementation of the port malloc function. */
2121:../3rdParty/FreeRTOS/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 6873              		.loc 1 2121 0
 6874 14c0 4FF05000 		mov	r0, #80
 6875 14c4 FFF7FEFF 		bl	pvPortMalloc
 6876 14c8 0346     		mov	r3, r0
 6877 14ca FB60     		str	r3, [r7, #12]
2122:../3rdParty/FreeRTOS/tasks.c **** 
2123:../3rdParty/FreeRTOS/tasks.c **** 	if( pxNewTCB != NULL )
 6878              		.loc 1 2123 0
 6879 14cc FB68     		ldr	r3, [r7, #12]
 6880 14ce 002B     		cmp	r3, #0
 6881 14d0 23D0     		beq	.L181
2124:../3rdParty/FreeRTOS/tasks.c **** 	{
2125:../3rdParty/FreeRTOS/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2126:../3rdParty/FreeRTOS/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2127:../3rdParty/FreeRTOS/tasks.c **** 		be deleted later if required. */
2128:../3rdParty/FreeRTOS/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 6882              		.loc 1 2128 0
 6883 14d2 3B68     		ldr	r3, [r7, #0]
 6884 14d4 002B     		cmp	r3, #0
 6885 14d6 07D1     		bne	.L182
 6886 14d8 FB88     		ldrh	r3, [r7, #6]
 6887 14da 4FEA8303 		lsl	r3, r3, #2
 6888 14de 1846     		mov	r0, r3
 6889 14e0 FFF7FEFF 		bl	pvPortMalloc
 6890 14e4 0346     		mov	r3, r0
 6891 14e6 00E0     		b	.L183
 6892              	.L182:
 6893 14e8 3B68     		ldr	r3, [r7, #0]
 6894              	.L183:
 6895 14ea FA68     		ldr	r2, [r7, #12]
 6896 14ec 1363     		str	r3, [r2, #48]
2129:../3rdParty/FreeRTOS/tasks.c **** 
2130:../3rdParty/FreeRTOS/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 6897              		.loc 1 2130 0
 6898 14ee FB68     		ldr	r3, [r7, #12]
 6899 14f0 1B6B     		ldr	r3, [r3, #48]
 6900 14f2 002B     		cmp	r3, #0
 6901 14f4 06D1     		bne	.L184
2131:../3rdParty/FreeRTOS/tasks.c **** 		{
2132:../3rdParty/FreeRTOS/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2133:../3rdParty/FreeRTOS/tasks.c **** 			vPortFree( pxNewTCB );
 6902              		.loc 1 2133 0
 6903 14f6 F868     		ldr	r0, [r7, #12]
 6904 14f8 FFF7FEFF 		bl	vPortFree
2134:../3rdParty/FreeRTOS/tasks.c **** 			pxNewTCB = NULL;
 6905              		.loc 1 2134 0
 6906 14fc 4FF00003 		mov	r3, #0
 6907 1500 FB60     		str	r3, [r7, #12]
 6908 1502 0AE0     		b	.L181
 6909              	.L184:
2135:../3rdParty/FreeRTOS/tasks.c **** 		}
2136:../3rdParty/FreeRTOS/tasks.c **** 		else
2137:../3rdParty/FreeRTOS/tasks.c **** 		{
2138:../3rdParty/FreeRTOS/tasks.c **** 			/* Just to help debugging. */
2139:../3rdParty/FreeRTOS/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 6910              		.loc 1 2139 0
 6911 1504 FB68     		ldr	r3, [r7, #12]
 6912 1506 1A6B     		ldr	r2, [r3, #48]
 6913 1508 FB88     		ldrh	r3, [r7, #6]
 6914 150a 4FEA8303 		lsl	r3, r3, #2
 6915 150e 1046     		mov	r0, r2
 6916 1510 4FF0A501 		mov	r1, #165
 6917 1514 1A46     		mov	r2, r3
 6918 1516 FFF7FEFF 		bl	memset
 6919              	.L181:
2140:../3rdParty/FreeRTOS/tasks.c **** 		}
2141:../3rdParty/FreeRTOS/tasks.c **** 	}
2142:../3rdParty/FreeRTOS/tasks.c **** 
2143:../3rdParty/FreeRTOS/tasks.c **** 	return pxNewTCB;
 6920              		.loc 1 2143 0
 6921 151a FB68     		ldr	r3, [r7, #12]
2144:../3rdParty/FreeRTOS/tasks.c **** }
 6922              		.loc 1 2144 0
 6923 151c 1846     		mov	r0, r3
 6924 151e 07F11007 		add	r7, r7, #16
 6925 1522 BD46     		mov	sp, r7
 6926 1524 80BD     		pop	{r7, pc}
 6927              	.LFE88:
 6929              		.section	.rodata
 6930 000b 00       		.align	2
 6931              	.LC2:
 6932 000c 25730909 		.ascii	"%s\011\011%c\011%u\011%u\011%u\015\012\000"
 6932      25630925 
 6932      75092575 
 6932      0925750D 
 6932      0A00
 6933              		.text
 6934 1526 00BF     		.align	2
 6935              		.thumb
 6936              		.thumb_func
 6938              	prvListTaskWithinSingleList:
 6939              	.LFB89:
2145:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2146:../3rdParty/FreeRTOS/tasks.c **** 
2147:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2148:../3rdParty/FreeRTOS/tasks.c **** 
2149:../3rdParty/FreeRTOS/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2150:../3rdParty/FreeRTOS/tasks.c **** 	{
 6940              		.loc 1 2150 0
 6941              		@ args = 0, pretend = 0, frame = 40
 6942              		@ frame_needed = 1, uses_anonymous_args = 0
 6943 1528 80B5     		push	{r7, lr}
 6944              	.LCFI98:
 6945 152a 8EB0     		sub	sp, sp, #56
 6946              	.LCFI99:
 6947 152c 04AF     		add	r7, sp, #16
 6948              	.LCFI100:
 6949 152e F860     		str	r0, [r7, #12]
 6950 1530 B960     		str	r1, [r7, #8]
 6951 1532 1346     		mov	r3, r2
 6952 1534 FB71     		strb	r3, [r7, #7]
 6953              	.LBB11:
2151:../3rdParty/FreeRTOS/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2152:../3rdParty/FreeRTOS/tasks.c **** 	unsigned short usStackRemaining;
2153:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
2154:../3rdParty/FreeRTOS/tasks.c **** 
2155:../3rdParty/FreeRTOS/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2156:../3rdParty/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 6954              		.loc 1 2156 0
 6955 1536 BB68     		ldr	r3, [r7, #8]
 6956 1538 3B62     		str	r3, [r7, #32]
 6957 153a 3B6A     		ldr	r3, [r7, #32]
 6958 153c 5B68     		ldr	r3, [r3, #4]
 6959 153e 5A68     		ldr	r2, [r3, #4]
 6960 1540 3B6A     		ldr	r3, [r7, #32]
 6961 1542 5A60     		str	r2, [r3, #4]
 6962 1544 3B6A     		ldr	r3, [r7, #32]
 6963 1546 5A68     		ldr	r2, [r3, #4]
 6964 1548 3B6A     		ldr	r3, [r7, #32]
 6965 154a 03F10803 		add	r3, r3, #8
 6966 154e 9A42     		cmp	r2, r3
 6967 1550 04D1     		bne	.L187
 6968 1552 3B6A     		ldr	r3, [r7, #32]
 6969 1554 5B68     		ldr	r3, [r3, #4]
 6970 1556 5A68     		ldr	r2, [r3, #4]
 6971 1558 3B6A     		ldr	r3, [r7, #32]
 6972 155a 5A60     		str	r2, [r3, #4]
 6973              	.L187:
 6974 155c 3B6A     		ldr	r3, [r7, #32]
 6975 155e 5B68     		ldr	r3, [r3, #4]
 6976 1560 DB68     		ldr	r3, [r3, #12]
 6977 1562 BB61     		str	r3, [r7, #24]
 6978              	.L189:
 6979              	.LBE11:
 6980              	.LBB12:
2157:../3rdParty/FreeRTOS/tasks.c **** 		do
2158:../3rdParty/FreeRTOS/tasks.c **** 		{
2159:../3rdParty/FreeRTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 6981              		.loc 1 2159 0
 6982 1564 BB68     		ldr	r3, [r7, #8]
 6983 1566 7B62     		str	r3, [r7, #36]
 6984 1568 7B6A     		ldr	r3, [r7, #36]
 6985 156a 5B68     		ldr	r3, [r3, #4]
 6986 156c 5A68     		ldr	r2, [r3, #4]
 6987 156e 7B6A     		ldr	r3, [r7, #36]
 6988 1570 5A60     		str	r2, [r3, #4]
 6989 1572 7B6A     		ldr	r3, [r7, #36]
 6990 1574 5A68     		ldr	r2, [r3, #4]
 6991 1576 7B6A     		ldr	r3, [r7, #36]
 6992 1578 03F10803 		add	r3, r3, #8
 6993 157c 9A42     		cmp	r2, r3
 6994 157e 04D1     		bne	.L188
 6995 1580 7B6A     		ldr	r3, [r7, #36]
 6996 1582 5B68     		ldr	r3, [r3, #4]
 6997 1584 5A68     		ldr	r2, [r3, #4]
 6998 1586 7B6A     		ldr	r3, [r7, #36]
 6999 1588 5A60     		str	r2, [r3, #4]
 7000              	.L188:
 7001 158a 7B6A     		ldr	r3, [r7, #36]
 7002 158c 5B68     		ldr	r3, [r3, #4]
 7003 158e DB68     		ldr	r3, [r3, #12]
 7004 1590 7B61     		str	r3, [r7, #20]
 7005              	.LBE12:
2160:../3rdParty/FreeRTOS/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2161:../3rdParty/FreeRTOS/tasks.c **** 			{
2162:../3rdParty/FreeRTOS/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2163:../3rdParty/FreeRTOS/tasks.c **** 			}
2164:../3rdParty/FreeRTOS/tasks.c **** 			#else
2165:../3rdParty/FreeRTOS/tasks.c **** 			{
2166:../3rdParty/FreeRTOS/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
 7006              		.loc 1 2166 0
 7007 1592 7B69     		ldr	r3, [r7, #20]
 7008 1594 1B6B     		ldr	r3, [r3, #48]
 7009 1596 1846     		mov	r0, r3
 7010 1598 00F0B2F8 		bl	usTaskCheckFreeStackSpace
 7011 159c 0346     		mov	r3, r0
 7012 159e FB83     		strh	r3, [r7, #30]	@ movhi
2167:../3rdParty/FreeRTOS/tasks.c **** 			}
2168:../3rdParty/FreeRTOS/tasks.c **** 			#endif			
2169:../3rdParty/FreeRTOS/tasks.c **** 			
2170:../3rdParty/FreeRTOS/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 7013              		.loc 1 2170 0
 7014 15a0 7B69     		ldr	r3, [r7, #20]
 7015 15a2 03F13403 		add	r3, r3, #52
 7016 15a6 1A46     		mov	r2, r3
 7017 15a8 97F90730 		ldrsb	r3, [r7, #7]
 7018 15ac 7969     		ldr	r1, [r7, #20]
 7019 15ae D1F82CC0 		ldr	ip, [r1, #44]
 7020 15b2 F88B     		ldrh	r0, [r7, #30]
 7021 15b4 7969     		ldr	r1, [r7, #20]
 7022 15b6 096C     		ldr	r1, [r1, #64]
 7023 15b8 CDF800C0 		str	ip, [sp, #0]
 7024 15bc 0190     		str	r0, [sp, #4]
 7025 15be 0291     		str	r1, [sp, #8]
 7026 15c0 40F20000 		movw	r0, #:lower16:pcStatusString.5034
 7027 15c4 C0F20000 		movt	r0, #:upper16:pcStatusString.5034
 7028 15c8 40F20001 		movw	r1, #:lower16:.LC2
 7029 15cc C0F20001 		movt	r1, #:upper16:.LC2
 7030 15d0 FFF7FEFF 		bl	sprintf
2171:../3rdParty/FreeRTOS/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
 7031              		.loc 1 2171 0
 7032 15d4 FB68     		ldr	r3, [r7, #12]
 7033 15d6 1846     		mov	r0, r3
 7034 15d8 40F20001 		movw	r1, #:lower16:pcStatusString.5034
 7035 15dc C0F20001 		movt	r1, #:upper16:pcStatusString.5034
 7036 15e0 FFF7FEFF 		bl	strcat
2172:../3rdParty/FreeRTOS/tasks.c **** 
2173:../3rdParty/FreeRTOS/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 7037              		.loc 1 2173 0
 7038 15e4 7A69     		ldr	r2, [r7, #20]
 7039 15e6 BB69     		ldr	r3, [r7, #24]
 7040 15e8 9A42     		cmp	r2, r3
 7041 15ea BBD1     		bne	.L189
2174:../3rdParty/FreeRTOS/tasks.c **** 	}
 7042              		.loc 1 2174 0
 7043 15ec 07F12807 		add	r7, r7, #40
 7044 15f0 BD46     		mov	sp, r7
 7045 15f2 80BD     		pop	{r7, pc}
 7046              	.LFE89:
 7048              		.section	.rodata
 7049 001e 0000     		.align	2
 7050              	.LC3:
 7051 0020 25730909 		.ascii	"%s\011\0110\011\0110%%\015\012\000"
 7051      30090930 
 7051      25250D0A 
 7051      00
 7052 002d 000000   		.align	2
 7053              	.LC4:
 7054 0030 25730909 		.ascii	"%s\011\011%u\011\011%u%%\015\012\000"
 7054      25750909 
 7054      25752525 
 7054      0D0A00
 7055 003f 00       		.align	2
 7056              	.LC5:
 7057 0040 25730909 		.ascii	"%s\011\011%u\011\011<1%%\015\012\000"
 7057      25750909 
 7057      3C312525 
 7057      0D0A00
 7058              		.text
 7059              		.align	2
 7060              		.thumb
 7061              		.thumb_func
 7063              	prvGenerateRunTimeStatsForTasksInList:
 7064              	.LFB90:
2175:../3rdParty/FreeRTOS/tasks.c **** 
2176:../3rdParty/FreeRTOS/tasks.c **** #endif
2177:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2178:../3rdParty/FreeRTOS/tasks.c **** 
2179:../3rdParty/FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2180:../3rdParty/FreeRTOS/tasks.c **** 
2181:../3rdParty/FreeRTOS/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2182:../3rdParty/FreeRTOS/tasks.c **** 	{
 7065              		.loc 1 2182 0
 7066              		@ args = 0, pretend = 0, frame = 40
 7067              		@ frame_needed = 1, uses_anonymous_args = 0
 7068 15f4 80B5     		push	{r7, lr}
 7069              	.LCFI101:
 7070 15f6 8CB0     		sub	sp, sp, #48
 7071              	.LCFI102:
 7072 15f8 02AF     		add	r7, sp, #8
 7073              	.LCFI103:
 7074 15fa F860     		str	r0, [r7, #12]
 7075 15fc B960     		str	r1, [r7, #8]
 7076 15fe 7A60     		str	r2, [r7, #4]
 7077              	.LBB13:
2183:../3rdParty/FreeRTOS/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2184:../3rdParty/FreeRTOS/tasks.c **** 	unsigned long ulStatsAsPercentage;
2185:../3rdParty/FreeRTOS/tasks.c **** 
2186:../3rdParty/FreeRTOS/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2187:../3rdParty/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 7078              		.loc 1 2187 0
 7079 1600 BB68     		ldr	r3, [r7, #8]
 7080 1602 3B62     		str	r3, [r7, #32]
 7081 1604 3B6A     		ldr	r3, [r7, #32]
 7082 1606 5B68     		ldr	r3, [r3, #4]
 7083 1608 5A68     		ldr	r2, [r3, #4]
 7084 160a 3B6A     		ldr	r3, [r7, #32]
 7085 160c 5A60     		str	r2, [r3, #4]
 7086 160e 3B6A     		ldr	r3, [r7, #32]
 7087 1610 5A68     		ldr	r2, [r3, #4]
 7088 1612 3B6A     		ldr	r3, [r7, #32]
 7089 1614 03F10803 		add	r3, r3, #8
 7090 1618 9A42     		cmp	r2, r3
 7091 161a 04D1     		bne	.L192
 7092 161c 3B6A     		ldr	r3, [r7, #32]
 7093 161e 5B68     		ldr	r3, [r3, #4]
 7094 1620 5A68     		ldr	r2, [r3, #4]
 7095 1622 3B6A     		ldr	r3, [r7, #32]
 7096 1624 5A60     		str	r2, [r3, #4]
 7097              	.L192:
 7098 1626 3B6A     		ldr	r3, [r7, #32]
 7099 1628 5B68     		ldr	r3, [r3, #4]
 7100 162a DB68     		ldr	r3, [r3, #12]
 7101 162c BB61     		str	r3, [r7, #24]
 7102              	.L198:
 7103              	.LBE13:
 7104              	.LBB14:
2188:../3rdParty/FreeRTOS/tasks.c **** 		do
2189:../3rdParty/FreeRTOS/tasks.c **** 		{
2190:../3rdParty/FreeRTOS/tasks.c **** 			/* Get next TCB in from the list. */
2191:../3rdParty/FreeRTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 7105              		.loc 1 2191 0
 7106 162e BB68     		ldr	r3, [r7, #8]
 7107 1630 7B62     		str	r3, [r7, #36]
 7108 1632 7B6A     		ldr	r3, [r7, #36]
 7109 1634 5B68     		ldr	r3, [r3, #4]
 7110 1636 5A68     		ldr	r2, [r3, #4]
 7111 1638 7B6A     		ldr	r3, [r7, #36]
 7112 163a 5A60     		str	r2, [r3, #4]
 7113 163c 7B6A     		ldr	r3, [r7, #36]
 7114 163e 5A68     		ldr	r2, [r3, #4]
 7115 1640 7B6A     		ldr	r3, [r7, #36]
 7116 1642 03F10803 		add	r3, r3, #8
 7117 1646 9A42     		cmp	r2, r3
 7118 1648 04D1     		bne	.L193
 7119 164a 7B6A     		ldr	r3, [r7, #36]
 7120 164c 5B68     		ldr	r3, [r3, #4]
 7121 164e 5A68     		ldr	r2, [r3, #4]
 7122 1650 7B6A     		ldr	r3, [r7, #36]
 7123 1652 5A60     		str	r2, [r3, #4]
 7124              	.L193:
 7125 1654 7B6A     		ldr	r3, [r7, #36]
 7126 1656 5B68     		ldr	r3, [r3, #4]
 7127 1658 DB68     		ldr	r3, [r3, #12]
 7128 165a 7B61     		str	r3, [r7, #20]
 7129              	.LBE14:
2192:../3rdParty/FreeRTOS/tasks.c **** 
2193:../3rdParty/FreeRTOS/tasks.c **** 			/* Divide by zero check. */
2194:../3rdParty/FreeRTOS/tasks.c **** 			if( ulTotalRunTime > 0UL )
 7130              		.loc 1 2194 0
 7131 165c 7B68     		ldr	r3, [r7, #4]
 7132 165e 002B     		cmp	r3, #0
 7133 1660 46D0     		beq	.L194
2195:../3rdParty/FreeRTOS/tasks.c **** 			{
2196:../3rdParty/FreeRTOS/tasks.c **** 				/* Has the task run at all? */
2197:../3rdParty/FreeRTOS/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
 7134              		.loc 1 2197 0
 7135 1662 7B69     		ldr	r3, [r7, #20]
 7136 1664 DB6C     		ldr	r3, [r3, #76]
 7137 1666 002B     		cmp	r3, #0
 7138 1668 0ED1     		bne	.L195
2198:../3rdParty/FreeRTOS/tasks.c **** 				{
2199:../3rdParty/FreeRTOS/tasks.c **** 					/* The task has used no CPU time at all. */
2200:../3rdParty/FreeRTOS/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
 7139              		.loc 1 2200 0
 7140 166a 7B69     		ldr	r3, [r7, #20]
 7141 166c 03F13403 		add	r3, r3, #52
 7142 1670 40F20000 		movw	r0, #:lower16:pcStatsString
 7143 1674 C0F20000 		movt	r0, #:upper16:pcStatsString
 7144 1678 40F20001 		movw	r1, #:lower16:.LC3
 7145 167c C0F20001 		movt	r1, #:upper16:.LC3
 7146 1680 1A46     		mov	r2, r3
 7147 1682 FFF7FEFF 		bl	sprintf
 7148 1686 2BE0     		b	.L196
 7149              	.L195:
2201:../3rdParty/FreeRTOS/tasks.c **** 				}
2202:../3rdParty/FreeRTOS/tasks.c **** 				else
2203:../3rdParty/FreeRTOS/tasks.c **** 				{
2204:../3rdParty/FreeRTOS/tasks.c **** 					/* What percentage of the total run time has the task used?
2205:../3rdParty/FreeRTOS/tasks.c **** 					This will always be rounded down to the nearest integer.
2206:../3rdParty/FreeRTOS/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2207:../3rdParty/FreeRTOS/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
 7150              		.loc 1 2207 0
 7151 1688 7B69     		ldr	r3, [r7, #20]
 7152 168a DA6C     		ldr	r2, [r3, #76]
 7153 168c 7B68     		ldr	r3, [r7, #4]
 7154 168e B2FBF3F3 		udiv	r3, r2, r3
 7155 1692 FB61     		str	r3, [r7, #28]
2208:../3rdParty/FreeRTOS/tasks.c **** 
2209:../3rdParty/FreeRTOS/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
 7156              		.loc 1 2209 0
 7157 1694 FB69     		ldr	r3, [r7, #28]
 7158 1696 002B     		cmp	r3, #0
 7159 1698 12D0     		beq	.L197
2210:../3rdParty/FreeRTOS/tasks.c **** 					{
2211:../3rdParty/FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2212:../3rdParty/FreeRTOS/tasks.c **** 						{
2213:../3rdParty/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2214:../3rdParty/FreeRTOS/tasks.c **** 						}
2215:../3rdParty/FreeRTOS/tasks.c **** 						#else
2216:../3rdParty/FreeRTOS/tasks.c **** 						{
2217:../3rdParty/FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2218:../3rdParty/FreeRTOS/tasks.c **** 							printf() library can be used. */
2219:../3rdParty/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned
 7160              		.loc 1 2219 0
 7161 169a 7B69     		ldr	r3, [r7, #20]
 7162 169c 03F13403 		add	r3, r3, #52
 7163 16a0 1A46     		mov	r2, r3
 7164 16a2 7B69     		ldr	r3, [r7, #20]
 7165 16a4 DB6C     		ldr	r3, [r3, #76]
 7166 16a6 F969     		ldr	r1, [r7, #28]
 7167 16a8 0091     		str	r1, [sp, #0]
 7168 16aa 40F20000 		movw	r0, #:lower16:pcStatsString
 7169 16ae C0F20000 		movt	r0, #:upper16:pcStatsString
 7170 16b2 40F20001 		movw	r1, #:lower16:.LC4
 7171 16b6 C0F20001 		movt	r1, #:upper16:.LC4
 7172 16ba FFF7FEFF 		bl	sprintf
 7173 16be 0FE0     		b	.L196
 7174              	.L197:
2220:../3rdParty/FreeRTOS/tasks.c **** 						}
2221:../3rdParty/FreeRTOS/tasks.c **** 						#endif
2222:../3rdParty/FreeRTOS/tasks.c **** 					}
2223:../3rdParty/FreeRTOS/tasks.c **** 					else
2224:../3rdParty/FreeRTOS/tasks.c **** 					{
2225:../3rdParty/FreeRTOS/tasks.c **** 						/* If the percentage is zero here then the task has
2226:../3rdParty/FreeRTOS/tasks.c **** 						consumed less than 1% of the total run time. */
2227:../3rdParty/FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2228:../3rdParty/FreeRTOS/tasks.c **** 						{
2229:../3rdParty/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2230:../3rdParty/FreeRTOS/tasks.c **** 						}
2231:../3rdParty/FreeRTOS/tasks.c **** 						#else
2232:../3rdParty/FreeRTOS/tasks.c **** 						{
2233:../3rdParty/FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2234:../3rdParty/FreeRTOS/tasks.c **** 							printf() library can be used. */
2235:../3rdParty/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned
 7175              		.loc 1 2235 0
 7176 16c0 7B69     		ldr	r3, [r7, #20]
 7177 16c2 03F13403 		add	r3, r3, #52
 7178 16c6 1A46     		mov	r2, r3
 7179 16c8 7B69     		ldr	r3, [r7, #20]
 7180 16ca DB6C     		ldr	r3, [r3, #76]
 7181 16cc 40F20000 		movw	r0, #:lower16:pcStatsString
 7182 16d0 C0F20000 		movt	r0, #:upper16:pcStatsString
 7183 16d4 40F20001 		movw	r1, #:lower16:.LC5
 7184 16d8 C0F20001 		movt	r1, #:upper16:.LC5
 7185 16dc FFF7FEFF 		bl	sprintf
 7186              	.L196:
2236:../3rdParty/FreeRTOS/tasks.c **** 						}
2237:../3rdParty/FreeRTOS/tasks.c **** 						#endif
2238:../3rdParty/FreeRTOS/tasks.c **** 					}
2239:../3rdParty/FreeRTOS/tasks.c **** 				}
2240:../3rdParty/FreeRTOS/tasks.c **** 
2241:../3rdParty/FreeRTOS/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
 7187              		.loc 1 2241 0
 7188 16e0 FB68     		ldr	r3, [r7, #12]
 7189 16e2 1846     		mov	r0, r3
 7190 16e4 40F20001 		movw	r1, #:lower16:pcStatsString
 7191 16e8 C0F20001 		movt	r1, #:upper16:pcStatsString
 7192 16ec FFF7FEFF 		bl	strcat
 7193              	.L194:
2242:../3rdParty/FreeRTOS/tasks.c **** 			}
2243:../3rdParty/FreeRTOS/tasks.c **** 
2244:../3rdParty/FreeRTOS/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 7194              		.loc 1 2244 0
 7195 16f0 7A69     		ldr	r2, [r7, #20]
 7196 16f2 BB69     		ldr	r3, [r7, #24]
 7197 16f4 9A42     		cmp	r2, r3
 7198 16f6 9AD1     		bne	.L198
2245:../3rdParty/FreeRTOS/tasks.c **** 	}
 7199              		.loc 1 2245 0
 7200 16f8 07F12807 		add	r7, r7, #40
 7201 16fc BD46     		mov	sp, r7
 7202 16fe 80BD     		pop	{r7, pc}
 7203              	.LFE90:
 7205              		.align	2
 7206              		.thumb
 7207              		.thumb_func
 7209              	usTaskCheckFreeStackSpace:
 7210              	.LFB91:
2246:../3rdParty/FreeRTOS/tasks.c **** 
2247:../3rdParty/FreeRTOS/tasks.c **** #endif
2248:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2249:../3rdParty/FreeRTOS/tasks.c **** 
2250:../3rdParty/FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2251:../3rdParty/FreeRTOS/tasks.c **** 
2252:../3rdParty/FreeRTOS/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2253:../3rdParty/FreeRTOS/tasks.c **** 	{
 7211              		.loc 1 2253 0
 7212              		@ args = 0, pretend = 0, frame = 8
 7213              		@ frame_needed = 1, uses_anonymous_args = 0
 7214              		@ link register save eliminated.
 7215 1700 90B4     		push	{r4, r7}
 7216              	.LCFI104:
 7217 1702 82B0     		sub	sp, sp, #8
 7218              	.LCFI105:
 7219 1704 00AF     		add	r7, sp, #0
 7220              	.LCFI106:
 7221 1706 7860     		str	r0, [r7, #4]
2254:../3rdParty/FreeRTOS/tasks.c **** 	register unsigned short usCount = 0U;
 7222              		.loc 1 2254 0
 7223 1708 4FF00004 		mov	r4, #0
2255:../3rdParty/FreeRTOS/tasks.c **** 
2256:../3rdParty/FreeRTOS/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 7224              		.loc 1 2256 0
 7225 170c 06E0     		b	.L201
 7226              	.L202:
2257:../3rdParty/FreeRTOS/tasks.c **** 		{
2258:../3rdParty/FreeRTOS/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 7227              		.loc 1 2258 0
 7228 170e 7B68     		ldr	r3, [r7, #4]
 7229 1710 03F10103 		add	r3, r3, #1
 7230 1714 7B60     		str	r3, [r7, #4]
2259:../3rdParty/FreeRTOS/tasks.c **** 			usCount++;
 7231              		.loc 1 2259 0
 7232 1716 04F10103 		add	r3, r4, #1
 7233 171a 9CB2     		uxth	r4, r3
 7234              	.L201:
 7235              		.loc 1 2256 0
 7236 171c 7B68     		ldr	r3, [r7, #4]
 7237 171e 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 7238 1720 A52B     		cmp	r3, #165
 7239 1722 F4D0     		beq	.L202
2260:../3rdParty/FreeRTOS/tasks.c **** 		}
2261:../3rdParty/FreeRTOS/tasks.c **** 
2262:../3rdParty/FreeRTOS/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
 7240              		.loc 1 2262 0
 7241 1724 4FEA9403 		lsr	r3, r4, #2
 7242 1728 9CB2     		uxth	r4, r3
2263:../3rdParty/FreeRTOS/tasks.c **** 
2264:../3rdParty/FreeRTOS/tasks.c **** 		return usCount;
 7243              		.loc 1 2264 0
 7244 172a 2346     		mov	r3, r4
2265:../3rdParty/FreeRTOS/tasks.c **** 	}
 7245              		.loc 1 2265 0
 7246 172c 1846     		mov	r0, r3
 7247 172e 07F10807 		add	r7, r7, #8
 7248 1732 BD46     		mov	sp, r7
 7249 1734 90BC     		pop	{r4, r7}
 7250 1736 7047     		bx	lr
 7251              	.LFE91:
 7253              		.align	2
 7254              		.global	uxTaskGetStackHighWaterMark
 7255              		.thumb
 7256              		.thumb_func
 7258              	uxTaskGetStackHighWaterMark:
 7259              	.LFB92:
2266:../3rdParty/FreeRTOS/tasks.c **** 
2267:../3rdParty/FreeRTOS/tasks.c **** #endif
2268:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2269:../3rdParty/FreeRTOS/tasks.c **** 
2270:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2271:../3rdParty/FreeRTOS/tasks.c **** 
2272:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2273:../3rdParty/FreeRTOS/tasks.c **** 	{
 7260              		.loc 1 2273 0
 7261              		@ args = 0, pretend = 0, frame = 24
 7262              		@ frame_needed = 1, uses_anonymous_args = 0
 7263 1738 80B5     		push	{r7, lr}
 7264              	.LCFI107:
 7265 173a 86B0     		sub	sp, sp, #24
 7266              	.LCFI108:
 7267 173c 00AF     		add	r7, sp, #0
 7268              	.LCFI109:
 7269 173e 7860     		str	r0, [r7, #4]
2274:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
2275:../3rdParty/FreeRTOS/tasks.c **** 	unsigned char *pcEndOfStack;
2276:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2277:../3rdParty/FreeRTOS/tasks.c **** 
2278:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 7270              		.loc 1 2278 0
 7271 1740 7B68     		ldr	r3, [r7, #4]
 7272 1742 002B     		cmp	r3, #0
 7273 1744 05D1     		bne	.L205
 7274 1746 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 7275 174a C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 7276 174e 1B68     		ldr	r3, [r3, #0]
 7277 1750 00E0     		b	.L206
 7278              	.L205:
 7279 1752 7B68     		ldr	r3, [r7, #4]
 7280              	.L206:
 7281 1754 FB60     		str	r3, [r7, #12]
2279:../3rdParty/FreeRTOS/tasks.c **** 
2280:../3rdParty/FreeRTOS/tasks.c **** 		#if portSTACK_GROWTH < 0
2281:../3rdParty/FreeRTOS/tasks.c **** 		{
2282:../3rdParty/FreeRTOS/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
 7282              		.loc 1 2282 0
 7283 1756 FB68     		ldr	r3, [r7, #12]
 7284 1758 1B6B     		ldr	r3, [r3, #48]
 7285 175a 3B61     		str	r3, [r7, #16]
2283:../3rdParty/FreeRTOS/tasks.c **** 		}
2284:../3rdParty/FreeRTOS/tasks.c **** 		#else
2285:../3rdParty/FreeRTOS/tasks.c **** 		{
2286:../3rdParty/FreeRTOS/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2287:../3rdParty/FreeRTOS/tasks.c **** 		}
2288:../3rdParty/FreeRTOS/tasks.c **** 		#endif
2289:../3rdParty/FreeRTOS/tasks.c **** 
2290:../3rdParty/FreeRTOS/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
 7286              		.loc 1 2290 0
 7287 175c 3869     		ldr	r0, [r7, #16]
 7288 175e FFF7CFFF 		bl	usTaskCheckFreeStackSpace
 7289 1762 0346     		mov	r3, r0
 7290 1764 7B61     		str	r3, [r7, #20]
2291:../3rdParty/FreeRTOS/tasks.c **** 
2292:../3rdParty/FreeRTOS/tasks.c **** 		return uxReturn;
 7291              		.loc 1 2292 0
 7292 1766 7B69     		ldr	r3, [r7, #20]
2293:../3rdParty/FreeRTOS/tasks.c **** 	}
 7293              		.loc 1 2293 0
 7294 1768 1846     		mov	r0, r3
 7295 176a 07F11807 		add	r7, r7, #24
 7296 176e BD46     		mov	sp, r7
 7297 1770 80BD     		pop	{r7, pc}
 7298              	.LFE92:
 7300 1772 00BF     		.align	2
 7301              		.thumb
 7302              		.thumb_func
 7304              	prvDeleteTCB:
 7305              	.LFB93:
2294:../3rdParty/FreeRTOS/tasks.c **** 
2295:../3rdParty/FreeRTOS/tasks.c **** #endif
2296:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2297:../3rdParty/FreeRTOS/tasks.c **** 
2298:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2299:../3rdParty/FreeRTOS/tasks.c **** 
2300:../3rdParty/FreeRTOS/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2301:../3rdParty/FreeRTOS/tasks.c **** 	{
 7306              		.loc 1 2301 0
 7307              		@ args = 0, pretend = 0, frame = 8
 7308              		@ frame_needed = 1, uses_anonymous_args = 0
 7309 1774 80B5     		push	{r7, lr}
 7310              	.LCFI110:
 7311 1776 82B0     		sub	sp, sp, #8
 7312              	.LCFI111:
 7313 1778 00AF     		add	r7, sp, #0
 7314              	.LCFI112:
 7315 177a 7860     		str	r0, [r7, #4]
2302:../3rdParty/FreeRTOS/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2303:../3rdParty/FreeRTOS/tasks.c **** 		above the vPortFree() calls. */
2304:../3rdParty/FreeRTOS/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2305:../3rdParty/FreeRTOS/tasks.c **** 
2306:../3rdParty/FreeRTOS/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2307:../3rdParty/FreeRTOS/tasks.c **** 		the task to free any memory allocated at the application level. */
2308:../3rdParty/FreeRTOS/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 7316              		.loc 1 2308 0
 7317 177c 7B68     		ldr	r3, [r7, #4]
 7318 177e 1B6B     		ldr	r3, [r3, #48]
 7319 1780 1846     		mov	r0, r3
 7320 1782 FFF7FEFF 		bl	vPortFree
2309:../3rdParty/FreeRTOS/tasks.c **** 		vPortFree( pxTCB );
 7321              		.loc 1 2309 0
 7322 1786 7868     		ldr	r0, [r7, #4]
 7323 1788 FFF7FEFF 		bl	vPortFree
2310:../3rdParty/FreeRTOS/tasks.c **** 	}
 7324              		.loc 1 2310 0
 7325 178c 07F10807 		add	r7, r7, #8
 7326 1790 BD46     		mov	sp, r7
 7327 1792 80BD     		pop	{r7, pc}
 7328              	.LFE93:
 7330              		.align	2
 7331              		.global	xTaskGetCurrentTaskHandle
 7332              		.thumb
 7333              		.thumb_func
 7335              	xTaskGetCurrentTaskHandle:
 7336              	.LFB94:
2311:../3rdParty/FreeRTOS/tasks.c **** 
2312:../3rdParty/FreeRTOS/tasks.c **** #endif
2313:../3rdParty/FreeRTOS/tasks.c **** 
2314:../3rdParty/FreeRTOS/tasks.c **** 
2315:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2316:../3rdParty/FreeRTOS/tasks.c **** 
2317:../3rdParty/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2318:../3rdParty/FreeRTOS/tasks.c **** 
2319:../3rdParty/FreeRTOS/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2320:../3rdParty/FreeRTOS/tasks.c **** 	{
 7337              		.loc 1 2320 0
 7338              		@ args = 0, pretend = 0, frame = 8
 7339              		@ frame_needed = 1, uses_anonymous_args = 0
 7340              		@ link register save eliminated.
 7341 1794 80B4     		push	{r7}
 7342              	.LCFI113:
 7343 1796 83B0     		sub	sp, sp, #12
 7344              	.LCFI114:
 7345 1798 00AF     		add	r7, sp, #0
 7346              	.LCFI115:
2321:../3rdParty/FreeRTOS/tasks.c **** 	xTaskHandle xReturn;
2322:../3rdParty/FreeRTOS/tasks.c **** 
2323:../3rdParty/FreeRTOS/tasks.c **** 		/* A critical section is not required as this is not called from
2324:../3rdParty/FreeRTOS/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2325:../3rdParty/FreeRTOS/tasks.c **** 		individual execution thread. */
2326:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = pxCurrentTCB;
 7347              		.loc 1 2326 0
 7348 179a 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 7349 179e C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 7350 17a2 1B68     		ldr	r3, [r3, #0]
 7351 17a4 7B60     		str	r3, [r7, #4]
2327:../3rdParty/FreeRTOS/tasks.c **** 
2328:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
 7352              		.loc 1 2328 0
 7353 17a6 7B68     		ldr	r3, [r7, #4]
2329:../3rdParty/FreeRTOS/tasks.c **** 	}
 7354              		.loc 1 2329 0
 7355 17a8 1846     		mov	r0, r3
 7356 17aa 07F10C07 		add	r7, r7, #12
 7357 17ae BD46     		mov	sp, r7
 7358 17b0 80BC     		pop	{r7}
 7359 17b2 7047     		bx	lr
 7360              	.LFE94:
 7362              		.align	2
 7363              		.global	vTaskPriorityInherit
 7364              		.thumb
 7365              		.thumb_func
 7367              	vTaskPriorityInherit:
 7368              	.LFB95:
2330:../3rdParty/FreeRTOS/tasks.c **** 
2331:../3rdParty/FreeRTOS/tasks.c **** #endif
2332:../3rdParty/FreeRTOS/tasks.c **** 
2333:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2334:../3rdParty/FreeRTOS/tasks.c **** 
2335:../3rdParty/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2336:../3rdParty/FreeRTOS/tasks.c **** 
2337:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2338:../3rdParty/FreeRTOS/tasks.c **** 	{
2339:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xReturn;
2340:../3rdParty/FreeRTOS/tasks.c **** 
2341:../3rdParty/FreeRTOS/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
2342:../3rdParty/FreeRTOS/tasks.c **** 		{
2343:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2344:../3rdParty/FreeRTOS/tasks.c **** 		}
2345:../3rdParty/FreeRTOS/tasks.c **** 		else
2346:../3rdParty/FreeRTOS/tasks.c **** 		{
2347:../3rdParty/FreeRTOS/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2348:../3rdParty/FreeRTOS/tasks.c **** 			{
2349:../3rdParty/FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
2350:../3rdParty/FreeRTOS/tasks.c **** 			}
2351:../3rdParty/FreeRTOS/tasks.c **** 			else
2352:../3rdParty/FreeRTOS/tasks.c **** 			{
2353:../3rdParty/FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2354:../3rdParty/FreeRTOS/tasks.c **** 			}
2355:../3rdParty/FreeRTOS/tasks.c **** 		}
2356:../3rdParty/FreeRTOS/tasks.c **** 
2357:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
2358:../3rdParty/FreeRTOS/tasks.c **** 	}
2359:../3rdParty/FreeRTOS/tasks.c **** 
2360:../3rdParty/FreeRTOS/tasks.c **** #endif
2361:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2362:../3rdParty/FreeRTOS/tasks.c **** 
2363:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2364:../3rdParty/FreeRTOS/tasks.c **** 
2365:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2366:../3rdParty/FreeRTOS/tasks.c **** 	{
 7369              		.loc 1 2366 0
 7370              		@ args = 0, pretend = 0, frame = 16
 7371              		@ frame_needed = 1, uses_anonymous_args = 0
 7372 17b4 80B5     		push	{r7, lr}
 7373              	.LCFI116:
 7374 17b6 84B0     		sub	sp, sp, #16
 7375              	.LCFI117:
 7376 17b8 00AF     		add	r7, sp, #0
 7377              	.LCFI118:
 7378 17ba 7860     		str	r0, [r7, #4]
2367:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 7379              		.loc 1 2367 0
 7380 17bc 7B68     		ldr	r3, [r7, #4]
 7381 17be FB60     		str	r3, [r7, #12]
2368:../3rdParty/FreeRTOS/tasks.c **** 
2369:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxMutexHolder );
2370:../3rdParty/FreeRTOS/tasks.c **** 
2371:../3rdParty/FreeRTOS/tasks.c **** 		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 7382              		.loc 1 2371 0
 7383 17c0 FB68     		ldr	r3, [r7, #12]
 7384 17c2 DA6A     		ldr	r2, [r3, #44]
 7385 17c4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 7386 17c8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 7387 17cc 1B68     		ldr	r3, [r3, #0]
 7388 17ce DB6A     		ldr	r3, [r3, #44]
 7389 17d0 9A42     		cmp	r2, r3
 7390 17d2 57D2     		bcs	.L216
2372:../3rdParty/FreeRTOS/tasks.c **** 		{
2373:../3rdParty/FreeRTOS/tasks.c **** 			/* Adjust the mutex holder state to account for its new priority. */
2374:../3rdParty/FreeRTOS/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 7391              		.loc 1 2374 0
 7392 17d4 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 7393 17d8 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 7394 17dc 1B68     		ldr	r3, [r3, #0]
 7395 17de DB6A     		ldr	r3, [r3, #44]
 7396 17e0 C3F10502 		rsb	r2, r3, #5
 7397 17e4 FB68     		ldr	r3, [r7, #12]
 7398 17e6 9A61     		str	r2, [r3, #24]
2375:../3rdParty/FreeRTOS/tasks.c **** 
2376:../3rdParty/FreeRTOS/tasks.c **** 			/* If the task being modified is in the ready state it will need to
2377:../3rdParty/FreeRTOS/tasks.c **** 			be moved in to a new list. */
2378:../3rdParty/FreeRTOS/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 7399              		.loc 1 2378 0
 7400 17e8 FB68     		ldr	r3, [r7, #12]
 7401 17ea 5969     		ldr	r1, [r3, #20]
 7402 17ec FB68     		ldr	r3, [r7, #12]
 7403 17ee DA6A     		ldr	r2, [r3, #44]
 7404 17f0 1346     		mov	r3, r2
 7405 17f2 4FEA8303 		lsl	r3, r3, #2
 7406 17f6 1344     		add	r3, r3, r2
 7407 17f8 4FEA8303 		lsl	r3, r3, #2
 7408 17fc 1A46     		mov	r2, r3
 7409 17fe 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 7410 1802 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 7411 1806 1344     		add	r3, r2, r3
 7412 1808 9942     		cmp	r1, r3
 7413 180a 33D1     		bne	.L214
2379:../3rdParty/FreeRTOS/tasks.c **** 			{
2380:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 7414              		.loc 1 2380 0
 7415 180c FB68     		ldr	r3, [r7, #12]
 7416 180e 03F10403 		add	r3, r3, #4
 7417 1812 1846     		mov	r0, r3
 7418 1814 FFF7FEFF 		bl	vListRemove
2381:../3rdParty/FreeRTOS/tasks.c **** 
2382:../3rdParty/FreeRTOS/tasks.c **** 				/* Inherit the priority before being moved into the new list. */
2383:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 7419              		.loc 1 2383 0
 7420 1818 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 7421 181c C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 7422 1820 1B68     		ldr	r3, [r3, #0]
 7423 1822 DA6A     		ldr	r2, [r3, #44]
 7424 1824 FB68     		ldr	r3, [r7, #12]
 7425 1826 DA62     		str	r2, [r3, #44]
2384:../3rdParty/FreeRTOS/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 7426              		.loc 1 2384 0
 7427 1828 FB68     		ldr	r3, [r7, #12]
 7428 182a DA6A     		ldr	r2, [r3, #44]
 7429 182c 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 7430 1830 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 7431 1834 1B68     		ldr	r3, [r3, #0]
 7432 1836 9A42     		cmp	r2, r3
 7433 1838 06D9     		bls	.L215
 7434 183a FB68     		ldr	r3, [r7, #12]
 7435 183c DA6A     		ldr	r2, [r3, #44]
 7436 183e 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 7437 1842 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 7438 1846 1A60     		str	r2, [r3, #0]
 7439              	.L215:
 7440 1848 FB68     		ldr	r3, [r7, #12]
 7441 184a DA6A     		ldr	r2, [r3, #44]
 7442 184c 1346     		mov	r3, r2
 7443 184e 4FEA8303 		lsl	r3, r3, #2
 7444 1852 1344     		add	r3, r3, r2
 7445 1854 4FEA8303 		lsl	r3, r3, #2
 7446 1858 1A46     		mov	r2, r3
 7447 185a 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 7448 185e C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 7449 1862 1A44     		add	r2, r2, r3
 7450 1864 FB68     		ldr	r3, [r7, #12]
 7451 1866 03F10403 		add	r3, r3, #4
 7452 186a 1046     		mov	r0, r2
 7453 186c 1946     		mov	r1, r3
 7454 186e FFF7FEFF 		bl	vListInsertEnd
 7455 1872 07E0     		b	.L216
 7456              	.L214:
2385:../3rdParty/FreeRTOS/tasks.c **** 			}
2386:../3rdParty/FreeRTOS/tasks.c **** 			else
2387:../3rdParty/FreeRTOS/tasks.c **** 			{
2388:../3rdParty/FreeRTOS/tasks.c **** 				/* Just inherit the priority. */
2389:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 7457              		.loc 1 2389 0
 7458 1874 40F20003 		movw	r3, #:lower16:pxCurrentTCB
 7459 1878 C0F20003 		movt	r3, #:upper16:pxCurrentTCB
 7460 187c 1B68     		ldr	r3, [r3, #0]
 7461 187e DA6A     		ldr	r2, [r3, #44]
 7462 1880 FB68     		ldr	r3, [r7, #12]
 7463 1882 DA62     		str	r2, [r3, #44]
 7464              	.L216:
2390:../3rdParty/FreeRTOS/tasks.c **** 			}
2391:../3rdParty/FreeRTOS/tasks.c **** 
2392:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2393:../3rdParty/FreeRTOS/tasks.c **** 		}
2394:../3rdParty/FreeRTOS/tasks.c **** 	}
 7465              		.loc 1 2394 0
 7466 1884 07F11007 		add	r7, r7, #16
 7467 1888 BD46     		mov	sp, r7
 7468 188a 80BD     		pop	{r7, pc}
 7469              	.LFE95:
 7471              		.align	2
 7472              		.global	vTaskPriorityDisinherit
 7473              		.thumb
 7474              		.thumb_func
 7476              	vTaskPriorityDisinherit:
 7477              	.LFB96:
2395:../3rdParty/FreeRTOS/tasks.c **** 
2396:../3rdParty/FreeRTOS/tasks.c **** #endif
2397:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2398:../3rdParty/FreeRTOS/tasks.c **** 
2399:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2400:../3rdParty/FreeRTOS/tasks.c **** 
2401:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2402:../3rdParty/FreeRTOS/tasks.c **** 	{
 7478              		.loc 1 2402 0
 7479              		@ args = 0, pretend = 0, frame = 16
 7480              		@ frame_needed = 1, uses_anonymous_args = 0
 7481 188c 80B5     		push	{r7, lr}
 7482              	.LCFI119:
 7483 188e 84B0     		sub	sp, sp, #16
 7484              	.LCFI120:
 7485 1890 00AF     		add	r7, sp, #0
 7486              	.LCFI121:
 7487 1892 7860     		str	r0, [r7, #4]
2403:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 7488              		.loc 1 2403 0
 7489 1894 7B68     		ldr	r3, [r7, #4]
 7490 1896 FB60     		str	r3, [r7, #12]
2404:../3rdParty/FreeRTOS/tasks.c **** 
2405:../3rdParty/FreeRTOS/tasks.c **** 		if( pxMutexHolder != NULL )
 7491              		.loc 1 2405 0
 7492 1898 7B68     		ldr	r3, [r7, #4]
 7493 189a 002B     		cmp	r3, #0
 7494 189c 3AD0     		beq	.L220
2406:../3rdParty/FreeRTOS/tasks.c **** 		{
2407:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 7495              		.loc 1 2407 0
 7496 189e FB68     		ldr	r3, [r7, #12]
 7497 18a0 DA6A     		ldr	r2, [r3, #44]
 7498 18a2 FB68     		ldr	r3, [r7, #12]
 7499 18a4 9B6C     		ldr	r3, [r3, #72]
 7500 18a6 9A42     		cmp	r2, r3
 7501 18a8 34D0     		beq	.L220
2408:../3rdParty/FreeRTOS/tasks.c **** 			{
2409:../3rdParty/FreeRTOS/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2410:../3rdParty/FreeRTOS/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2411:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 7502              		.loc 1 2411 0
 7503 18aa FB68     		ldr	r3, [r7, #12]
 7504 18ac 03F10403 		add	r3, r3, #4
 7505 18b0 1846     		mov	r0, r3
 7506 18b2 FFF7FEFF 		bl	vListRemove
2412:../3rdParty/FreeRTOS/tasks.c **** 
2413:../3rdParty/FreeRTOS/tasks.c **** 				/* Disinherit the priority before adding the task into the new
2414:../3rdParty/FreeRTOS/tasks.c **** 				ready list. */
2415:../3rdParty/FreeRTOS/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2416:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 7507              		.loc 1 2416 0
 7508 18b6 FB68     		ldr	r3, [r7, #12]
 7509 18b8 9A6C     		ldr	r2, [r3, #72]
 7510 18ba FB68     		ldr	r3, [r7, #12]
 7511 18bc DA62     		str	r2, [r3, #44]
2417:../3rdParty/FreeRTOS/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 7512              		.loc 1 2417 0
 7513 18be FB68     		ldr	r3, [r7, #12]
 7514 18c0 DB6A     		ldr	r3, [r3, #44]
 7515 18c2 C3F10502 		rsb	r2, r3, #5
 7516 18c6 FB68     		ldr	r3, [r7, #12]
 7517 18c8 9A61     		str	r2, [r3, #24]
2418:../3rdParty/FreeRTOS/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 7518              		.loc 1 2418 0
 7519 18ca FB68     		ldr	r3, [r7, #12]
 7520 18cc DA6A     		ldr	r2, [r3, #44]
 7521 18ce 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 7522 18d2 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 7523 18d6 1B68     		ldr	r3, [r3, #0]
 7524 18d8 9A42     		cmp	r2, r3
 7525 18da 06D9     		bls	.L219
 7526 18dc FB68     		ldr	r3, [r7, #12]
 7527 18de DA6A     		ldr	r2, [r3, #44]
 7528 18e0 40F20003 		movw	r3, #:lower16:uxTopReadyPriority
 7529 18e4 C0F20003 		movt	r3, #:upper16:uxTopReadyPriority
 7530 18e8 1A60     		str	r2, [r3, #0]
 7531              	.L219:
 7532 18ea FB68     		ldr	r3, [r7, #12]
 7533 18ec DA6A     		ldr	r2, [r3, #44]
 7534 18ee 1346     		mov	r3, r2
 7535 18f0 4FEA8303 		lsl	r3, r3, #2
 7536 18f4 1344     		add	r3, r3, r2
 7537 18f6 4FEA8303 		lsl	r3, r3, #2
 7538 18fa 1A46     		mov	r2, r3
 7539 18fc 40F20003 		movw	r3, #:lower16:pxReadyTasksLists
 7540 1900 C0F20003 		movt	r3, #:upper16:pxReadyTasksLists
 7541 1904 1A44     		add	r2, r2, r3
 7542 1906 FB68     		ldr	r3, [r7, #12]
 7543 1908 03F10403 		add	r3, r3, #4
 7544 190c 1046     		mov	r0, r2
 7545 190e 1946     		mov	r1, r3
 7546 1910 FFF7FEFF 		bl	vListInsertEnd
 7547              	.L220:
2419:../3rdParty/FreeRTOS/tasks.c **** 			}
2420:../3rdParty/FreeRTOS/tasks.c **** 		}
2421:../3rdParty/FreeRTOS/tasks.c **** 	}
 7548              		.loc 1 2421 0
 7549 1914 07F11007 		add	r7, r7, #16
 7550 1918 BD46     		mov	sp, r7
 7551 191a 80BD     		pop	{r7, pc}
 7552              	.LFE96:
 7554              		.bss
 7555              		.align	2
 7556              	pcStatusString.5034:
 7557 0138 00000000 		.space	50
 7557      00000000 
 7557      00000000 
 7557      00000000 
 7557      00000000 
 7558 016a 0000     		.section	.rodata
 7559 004f 00       		.align	2
 7562              	ucExpectedStackBytes.4784:
 7563 0050 A5       		.byte	-91
 7564 0051 A5       		.byte	-91
 7565 0052 A5       		.byte	-91
 7566 0053 A5       		.byte	-91
 7567 0054 A5       		.byte	-91
 7568 0055 A5       		.byte	-91
 7569 0056 A5       		.byte	-91
 7570 0057 A5       		.byte	-91
 7571 0058 A5       		.byte	-91
 7572 0059 A5       		.byte	-91
 7573 005a A5       		.byte	-91
 7574 005b A5       		.byte	-91
 7575 005c A5       		.byte	-91
 7576 005d A5       		.byte	-91
 7577 005e A5       		.byte	-91
 7578 005f A5       		.byte	-91
 7579 0060 A5       		.byte	-91
 7580 0061 A5       		.byte	-91
 7581 0062 A5       		.byte	-91
 7582 0063 A5       		.byte	-91
 8661              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
/var/tmp//ccY78ujo.s:3850   .bss:0000000000000000 pxCurrentTCB
/var/tmp//ccY78ujo.s:3847   .bss:0000000000000000 $d
/var/tmp//ccY78ujo.s:3853   .bss:0000000000000004 pxReadyTasksLists
/var/tmp//ccY78ujo.s:3856   .bss:0000000000000068 xDelayedTaskList1
/var/tmp//ccY78ujo.s:3859   .bss:000000000000007c xDelayedTaskList2
/var/tmp//ccY78ujo.s:3862   .bss:0000000000000090 pxDelayedTaskList
/var/tmp//ccY78ujo.s:3865   .bss:0000000000000094 pxOverflowDelayedTaskList
/var/tmp//ccY78ujo.s:3868   .bss:0000000000000098 xPendingReadyList
/var/tmp//ccY78ujo.s:3871   .bss:00000000000000ac xTasksWaitingTermination
/var/tmp//ccY78ujo.s:3874   .bss:00000000000000c0 uxTasksDeleted
/var/tmp//ccY78ujo.s:3877   .bss:00000000000000c4 xSuspendedTaskList
/var/tmp//ccY78ujo.s:3880   .bss:00000000000000d8 uxCurrentNumberOfTasks
/var/tmp//ccY78ujo.s:3883   .bss:00000000000000dc xTickCount
/var/tmp//ccY78ujo.s:3886   .bss:00000000000000e0 uxTopUsedPriority
/var/tmp//ccY78ujo.s:3889   .bss:00000000000000e4 uxTopReadyPriority
/var/tmp//ccY78ujo.s:3892   .bss:00000000000000e8 xSchedulerRunning
/var/tmp//ccY78ujo.s:3895   .bss:00000000000000ec uxSchedulerSuspended
/var/tmp//ccY78ujo.s:3898   .bss:00000000000000f0 uxMissedTicks
/var/tmp//ccY78ujo.s:3901   .bss:00000000000000f4 xMissedYield
/var/tmp//ccY78ujo.s:3904   .bss:00000000000000f8 xNumOfOverflows
/var/tmp//ccY78ujo.s:3907   .bss:00000000000000fc uxTCBNumber
/var/tmp//ccY78ujo.s:3910   .data:0000000000000000 $d
/var/tmp//ccY78ujo.s:3913   .data:0000000000000000 xNextTaskUnblockTime
/var/tmp//ccY78ujo.s:3917   .bss:0000000000000100 pcStatsString
/var/tmp//ccY78ujo.s:3920   .bss:0000000000000134 ulTaskSwitchedInTime
/var/tmp//ccY78ujo.s:3923   .text:0000000000000000 $t
/var/tmp//ccY78ujo.s:3928   .text:0000000000000000 xTaskGenericCreate
/var/tmp//ccY78ujo.s:6859   .text:00000000000014b4 prvAllocateTCBAndStack
/var/tmp//ccY78ujo.s:6545   .text:0000000000001268 prvInitialiseTCBVariables
/var/tmp//ccY78ujo.s:6626   .text:00000000000012ec prvInitialiseTaskLists
/var/tmp//ccY78ujo.s:4154   .text:00000000000001c0 vTaskDelete
/var/tmp//ccY78ujo.s:4256   .text:0000000000000280 vTaskDelayUntil
/var/tmp//ccY78ujo.s:5127   .text:000000000000082c vTaskSuspendAll
/var/tmp//ccY78ujo.s:6787   .text:0000000000001428 prvAddCurrentTaskToDelayedList
/var/tmp//ccY78ujo.s:5156   .text:0000000000000850 xTaskResumeAll
/var/tmp//ccY78ujo.s:4370   .text:000000000000033c vTaskDelay
/var/tmp//ccY78ujo.s:4431   .text:0000000000000398 uxTaskPriorityGet
/var/tmp//ccY78ujo.s:4477   .text:00000000000003d0 vTaskPrioritySet
/var/tmp//ccY78ujo.s:4651   .text:0000000000000500 vTaskSuspend
/var/tmp//ccY78ujo.s:5933   .text:0000000000000e50 vTaskSwitchContext
/var/tmp//ccY78ujo.s:4757   .text:00000000000005c0 xTaskIsTaskSuspended
/var/tmp//ccY78ujo.s:4814   .text:0000000000000610 vTaskResume
/var/tmp//ccY78ujo.s:4907   .text:00000000000006bc xTaskResumeFromISR
/var/tmp//ccY78ujo.s:5019   .rodata:0000000000000000 $d
/var/tmp//ccY78ujo.s:5020   .rodata:0000000000000000 .LC0
/var/tmp//ccY78ujo.s:5028   .text:0000000000000790 vTaskStartScheduler
/var/tmp//ccY78ujo.s:6522   .text:0000000000001258 prvIdleTask
/var/tmp//ccY78ujo.s:5095   .text:000000000000080c vTaskEndScheduler
/var/tmp//ccY78ujo.s:5735   .text:0000000000000c90 vTaskIncrementTick
/var/tmp//ccY78ujo.s:5324   .text:00000000000009a4 xTaskGetTickCount
/var/tmp//ccY78ujo.s:5358   .text:00000000000009cc xTaskGetTickCountFromISR
/var/tmp//ccY78ujo.s:5406   .text:0000000000000a04 uxTaskGetNumberOfTasks
/var/tmp//ccY78ujo.s:5429   .rodata:0000000000000008 .LC1
/var/tmp//ccY78ujo.s:5437   .text:0000000000000a1c vTaskList
/var/tmp//ccY78ujo.s:6938   .text:0000000000001528 prvListTaskWithinSingleList
/var/tmp//ccY78ujo.s:5580   .text:0000000000000b4c vTaskGetRunTimeStats
/var/tmp//ccY78ujo.s:7063   .text:00000000000015f4 prvGenerateRunTimeStatsForTasksInList
/var/tmp//ccY78ujo.s:7562   .rodata:0000000000000050 ucExpectedStackBytes.4784
/var/tmp//ccY78ujo.s:6111   .text:0000000000000fd8 vTaskPlaceOnEventList
/var/tmp//ccY78ujo.s:6176   .text:0000000000001050 xTaskRemoveFromEventList
/var/tmp//ccY78ujo.s:6280   .text:0000000000001114 vTaskSetTimeOutState
/var/tmp//ccY78ujo.s:6317   .text:0000000000001144 xTaskCheckForTimeOut
/var/tmp//ccY78ujo.s:6414   .text:00000000000011ec vTaskMissedYield
/var/tmp//ccY78ujo.s:6440   .text:0000000000001204 uxTaskGetTaskNumber
/var/tmp//ccY78ujo.s:6485   .text:0000000000001234 vTaskSetTaskNumber
/var/tmp//ccY78ujo.s:6704   .text:0000000000001390 prvCheckTasksWaitingTermination
/var/tmp//ccY78ujo.s:7304   .text:0000000000001774 prvDeleteTCB
/var/tmp//ccY78ujo.s:6931   .rodata:000000000000000c .LC2
/var/tmp//ccY78ujo.s:7209   .text:0000000000001700 usTaskCheckFreeStackSpace
/var/tmp//ccY78ujo.s:7556   .bss:0000000000000138 pcStatusString.5034
/var/tmp//ccY78ujo.s:7050   .rodata:0000000000000020 .LC3
/var/tmp//ccY78ujo.s:7053   .rodata:0000000000000030 .LC4
/var/tmp//ccY78ujo.s:7056   .rodata:0000000000000040 .LC5
/var/tmp//ccY78ujo.s:7258   .text:0000000000001738 uxTaskGetStackHighWaterMark
/var/tmp//ccY78ujo.s:7335   .text:0000000000001794 xTaskGetCurrentTaskHandle
/var/tmp//ccY78ujo.s:7367   .text:00000000000017b4 vTaskPriorityInherit
/var/tmp//ccY78ujo.s:7476   .text:000000000000188c vTaskPriorityDisinherit
/var/tmp//ccY78ujo.s:7596   .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
vConfigureTimerForRunTimeStats
xPortStartScheduler
vPortEndScheduler
strlen
memcpy
vApplicationStackOverflowHook
memcmp
vListInsert
strncpy
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
sprintf
strcat
