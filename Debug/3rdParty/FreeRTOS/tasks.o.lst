   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"tasks.c"
  23              	.Ltext0:
  24              		.file 1 "../3rdParty/FreeRTOS/tasks.c"
 4454              		.align	2
 4457              	pxCurrentTCB:
 4458 0000 00000000 		.space	4
 4459              		.align	2
 4460              	pxReadyTasksLists:
 4461 0004 00000000 		.space	100
 4461      00000000 
 4461      00000000 
 4461      00000000 
 4461      00000000 
 4462              		.align	2
 4463              	xDelayedTaskList1:
 4464 0068 00000000 		.space	20
 4464      00000000 
 4464      00000000 
 4464      00000000 
 4464      00000000 
 4465              		.align	2
 4466              	xDelayedTaskList2:
 4467 007c 00000000 		.space	20
 4467      00000000 
 4467      00000000 
 4467      00000000 
 4467      00000000 
 4468              		.align	2
 4469              	pxDelayedTaskList:
 4470 0090 00000000 		.space	4
 4471              		.align	2
 4472              	pxOverflowDelayedTaskList:
 4473 0094 00000000 		.space	4
 4474              		.align	2
 4475              	xPendingReadyList:
 4476 0098 00000000 		.space	20
 4476      00000000 
 4476      00000000 
 4476      00000000 
 4476      00000000 
 4477              		.align	2
 4478              	xTasksWaitingTermination:
 4479 00ac 00000000 		.space	20
 4479      00000000 
 4479      00000000 
 4479      00000000 
 4479      00000000 
 4480              		.align	2
 4481              	uxTasksDeleted:
 4482 00c0 00000000 		.space	4
 4483              		.align	2
 4484              	xSuspendedTaskList:
 4485 00c4 00000000 		.space	20
 4485      00000000 
 4485      00000000 
 4485      00000000 
 4485      00000000 
 4486              		.align	2
 4487              	uxCurrentNumberOfTasks:
 4488 00d8 00000000 		.space	4
 4489              		.align	2
 4490              	xTickCount:
 4491 00dc 00000000 		.space	4
 4492              		.align	2
 4493              	uxTopUsedPriority:
 4494 00e0 00000000 		.space	4
 4495              		.align	2
 4496              	uxTopReadyPriority:
 4497 00e4 00000000 		.space	4
 4498              		.align	2
 4499              	xSchedulerRunning:
 4500 00e8 00000000 		.space	4
 4501              		.align	2
 4502              	uxSchedulerSuspended:
 4503 00ec 00000000 		.space	4
 4504              		.align	2
 4505              	uxMissedTicks:
 4506 00f0 00000000 		.space	4
 4507              		.align	2
 4508              	xMissedYield:
 4509 00f4 00000000 		.space	4
 4510              		.align	2
 4511              	xNumOfOverflows:
 4512 00f8 00000000 		.space	4
 4513              		.align	2
 4514              	uxTCBNumber:
 4515 00fc 00000000 		.space	4
 4516              		.data
 4517              		.align	2
 4520              	xNextTaskUnblockTime:
 4521 0000 FFFFFFFF 		.word	-1
 4522              		.bss
 4523              		.align	2
 4524              	pcStatsString:
 4525 0100 00000000 		.space	50
 4525      00000000 
 4525      00000000 
 4525      00000000 
 4525      00000000 
 4526 0132 0000     		.align	2
 4527              	ulTaskSwitchedInTime:
 4528 0134 00000000 		.space	4
 4529              		.text
 4530              		.align	2
 4531              		.global	xTaskGenericCreate
 4532              		.thumb
 4533              		.thumb_func
 4535              	xTaskGenericCreate:
 4536              	.LFB29:
   1:../3rdParty/FreeRTOS/tasks.c **** /*
   2:../3rdParty/FreeRTOS/tasks.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../3rdParty/FreeRTOS/tasks.c **** 	
   4:../3rdParty/FreeRTOS/tasks.c **** 
   5:../3rdParty/FreeRTOS/tasks.c ****     ***************************************************************************
   6:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
   7:../3rdParty/FreeRTOS/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../3rdParty/FreeRTOS/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../3rdParty/FreeRTOS/tasks.c ****      *    available.                                                         *
  10:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
  11:../3rdParty/FreeRTOS/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../3rdParty/FreeRTOS/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../3rdParty/FreeRTOS/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../3rdParty/FreeRTOS/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../3rdParty/FreeRTOS/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../3rdParty/FreeRTOS/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
  18:../3rdParty/FreeRTOS/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
  20:../3rdParty/FreeRTOS/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
  22:../3rdParty/FreeRTOS/tasks.c ****     ***************************************************************************
  23:../3rdParty/FreeRTOS/tasks.c **** 
  24:../3rdParty/FreeRTOS/tasks.c **** 
  25:../3rdParty/FreeRTOS/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:../3rdParty/FreeRTOS/tasks.c **** 
  27:../3rdParty/FreeRTOS/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../3rdParty/FreeRTOS/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../3rdParty/FreeRTOS/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../3rdParty/FreeRTOS/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../3rdParty/FreeRTOS/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../3rdParty/FreeRTOS/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../3rdParty/FreeRTOS/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../3rdParty/FreeRTOS/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../3rdParty/FreeRTOS/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../3rdParty/FreeRTOS/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:../3rdParty/FreeRTOS/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../3rdParty/FreeRTOS/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../3rdParty/FreeRTOS/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../3rdParty/FreeRTOS/tasks.c ****     FreeRTOS WEB site.
  41:../3rdParty/FreeRTOS/tasks.c **** 
  42:../3rdParty/FreeRTOS/tasks.c ****     1 tab == 4 spaces!
  43:../3rdParty/FreeRTOS/tasks.c **** 
  44:../3rdParty/FreeRTOS/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../3rdParty/FreeRTOS/tasks.c ****     contact details.
  46:../3rdParty/FreeRTOS/tasks.c **** 
  47:../3rdParty/FreeRTOS/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../3rdParty/FreeRTOS/tasks.c ****     critical systems.
  49:../3rdParty/FreeRTOS/tasks.c **** 
  50:../3rdParty/FreeRTOS/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../3rdParty/FreeRTOS/tasks.c ****     licensing and training services.
  52:../3rdParty/FreeRTOS/tasks.c **** */
  53:../3rdParty/FreeRTOS/tasks.c **** 
  54:../3rdParty/FreeRTOS/tasks.c **** 
  55:../3rdParty/FreeRTOS/tasks.c **** #include <stdio.h>
  56:../3rdParty/FreeRTOS/tasks.c **** #include <stdlib.h>
  57:../3rdParty/FreeRTOS/tasks.c **** #include <string.h>
  58:../3rdParty/FreeRTOS/tasks.c **** 
  59:../3rdParty/FreeRTOS/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:../3rdParty/FreeRTOS/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:../3rdParty/FreeRTOS/tasks.c **** task.h is included from an application file. */
  62:../3rdParty/FreeRTOS/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:../3rdParty/FreeRTOS/tasks.c **** 
  64:../3rdParty/FreeRTOS/tasks.c **** #include "FreeRTOS.h"
  65:../3rdParty/FreeRTOS/tasks.c **** #include "task.h"
  66:../3rdParty/FreeRTOS/tasks.c **** #include "timers.h"
  67:../3rdParty/FreeRTOS/tasks.c **** #include "StackMacros.h"
  68:../3rdParty/FreeRTOS/tasks.c **** 
  69:../3rdParty/FreeRTOS/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../3rdParty/FreeRTOS/tasks.c **** 
  71:../3rdParty/FreeRTOS/tasks.c **** /*
  72:../3rdParty/FreeRTOS/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  73:../3rdParty/FreeRTOS/tasks.c ****  */
  74:../3rdParty/FreeRTOS/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  75:../3rdParty/FreeRTOS/tasks.c **** 
  76:../3rdParty/FreeRTOS/tasks.c **** /*
  77:../3rdParty/FreeRTOS/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  78:../3rdParty/FreeRTOS/tasks.c ****  * and stores the context of the task.
  79:../3rdParty/FreeRTOS/tasks.c ****  */
  80:../3rdParty/FreeRTOS/tasks.c **** typedef struct tskTaskControlBlock
  81:../3rdParty/FreeRTOS/tasks.c **** {
  82:../3rdParty/FreeRTOS/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  83:../3rdParty/FreeRTOS/tasks.c **** 
  84:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  85:../3rdParty/FreeRTOS/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  86:../3rdParty/FreeRTOS/tasks.c **** 	#endif	
  87:../3rdParty/FreeRTOS/tasks.c **** 	
  88:../3rdParty/FreeRTOS/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  89:../3rdParty/FreeRTOS/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  90:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  91:../3rdParty/FreeRTOS/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  92:../3rdParty/FreeRTOS/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  93:../3rdParty/FreeRTOS/tasks.c **** 
  94:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  95:../3rdParty/FreeRTOS/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  96:../3rdParty/FreeRTOS/tasks.c **** 	#endif
  97:../3rdParty/FreeRTOS/tasks.c **** 
  98:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  99:../3rdParty/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 100:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 101:../3rdParty/FreeRTOS/tasks.c **** 
 102:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 103:../3rdParty/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This stores a number that increments each time a TCB is c
 104:../3rdParty/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< This stores a number specifically for use by third part
 105:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 106:../3rdParty/FreeRTOS/tasks.c **** 
 107:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 108:../3rdParty/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 109:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 110:../3rdParty/FreeRTOS/tasks.c **** 
 111:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 112:../3rdParty/FreeRTOS/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 113:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 114:../3rdParty/FreeRTOS/tasks.c **** 
 115:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 116:../3rdParty/FreeRTOS/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 117:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 118:../3rdParty/FreeRTOS/tasks.c **** 
 119:../3rdParty/FreeRTOS/tasks.c **** } tskTCB;
 120:../3rdParty/FreeRTOS/tasks.c **** 
 121:../3rdParty/FreeRTOS/tasks.c **** 
 122:../3rdParty/FreeRTOS/tasks.c **** /*
 123:../3rdParty/FreeRTOS/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 124:../3rdParty/FreeRTOS/tasks.c ****  * than file scope.
 125:../3rdParty/FreeRTOS/tasks.c ****  */
 126:../3rdParty/FreeRTOS/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 127:../3rdParty/FreeRTOS/tasks.c **** 	#define static
 128:../3rdParty/FreeRTOS/tasks.c **** #endif
 129:../3rdParty/FreeRTOS/tasks.c **** 
 130:../3rdParty/FreeRTOS/tasks.c **** /*lint -e956 */
 131:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 132:../3rdParty/FreeRTOS/tasks.c **** 
 133:../3rdParty/FreeRTOS/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 134:../3rdParty/FreeRTOS/tasks.c **** 
 135:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 136:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 137:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 138:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 139:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 140:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 141:../3rdParty/FreeRTOS/tasks.c **** 
 142:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 143:../3rdParty/FreeRTOS/tasks.c **** 
 144:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 145:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 146:../3rdParty/FreeRTOS/tasks.c **** 
 147:../3rdParty/FreeRTOS/tasks.c **** #endif
 148:../3rdParty/FreeRTOS/tasks.c **** 
 149:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 150:../3rdParty/FreeRTOS/tasks.c **** 
 151:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 152:../3rdParty/FreeRTOS/tasks.c **** 
 153:../3rdParty/FreeRTOS/tasks.c **** #endif
 154:../3rdParty/FreeRTOS/tasks.c **** 
 155:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 156:../3rdParty/FreeRTOS/tasks.c **** 	
 157:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
 158:../3rdParty/FreeRTOS/tasks.c **** 	
 159:../3rdParty/FreeRTOS/tasks.c **** #endif
 160:../3rdParty/FreeRTOS/tasks.c **** 
 161:../3rdParty/FreeRTOS/tasks.c **** /* File private variables. --------------------------------*/
 162:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 163:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 164:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 165:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 166:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 167:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 168:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 169:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 170:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 171:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTCBNumber 						= ( unsigned portBASE_TYPE ) 0U;
 172:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
 173:../3rdParty/FreeRTOS/tasks.c **** 
 174:../3rdParty/FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 175:../3rdParty/FreeRTOS/tasks.c **** 
 176:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 177:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 178:../3rdParty/FreeRTOS/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 179:../3rdParty/FreeRTOS/tasks.c **** 
 180:../3rdParty/FreeRTOS/tasks.c **** #endif
 181:../3rdParty/FreeRTOS/tasks.c **** 
 182:../3rdParty/FreeRTOS/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 183:../3rdParty/FreeRTOS/tasks.c **** 
 184:../3rdParty/FreeRTOS/tasks.c **** /*
 185:../3rdParty/FreeRTOS/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 186:../3rdParty/FreeRTOS/tasks.c ****  * is used purely for checking the high water mark for tasks.
 187:../3rdParty/FreeRTOS/tasks.c ****  */
 188:../3rdParty/FreeRTOS/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 189:../3rdParty/FreeRTOS/tasks.c **** 
 190:../3rdParty/FreeRTOS/tasks.c **** /*
 191:../3rdParty/FreeRTOS/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 192:../3rdParty/FreeRTOS/tasks.c ****  */
 193:../3rdParty/FreeRTOS/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 194:../3rdParty/FreeRTOS/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 195:../3rdParty/FreeRTOS/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 196:../3rdParty/FreeRTOS/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 197:../3rdParty/FreeRTOS/tasks.c **** 
 198:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 199:../3rdParty/FreeRTOS/tasks.c **** 
 200:../3rdParty/FreeRTOS/tasks.c **** /*
 201:../3rdParty/FreeRTOS/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 202:../3rdParty/FreeRTOS/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 203:../3rdParty/FreeRTOS/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 204:../3rdParty/FreeRTOS/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 205:../3rdParty/FreeRTOS/tasks.c ****  * executing task has been rescheduled.
 206:../3rdParty/FreeRTOS/tasks.c ****  */
 207:../3rdParty/FreeRTOS/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																					\
 208:../3rdParty/FreeRTOS/tasks.c **** 	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
 209:../3rdParty/FreeRTOS/tasks.c **** 	{																													\
 210:../3rdParty/FreeRTOS/tasks.c **** 		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
 211:../3rdParty/FreeRTOS/tasks.c **** 	}																													\
 212:../3rdParty/FreeRTOS/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 213:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 214:../3rdParty/FreeRTOS/tasks.c **** 
 215:../3rdParty/FreeRTOS/tasks.c **** /*
 216:../3rdParty/FreeRTOS/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 217:../3rdParty/FreeRTOS/tasks.c ****  * any require waking.
 218:../3rdParty/FreeRTOS/tasks.c ****  *
 219:../3rdParty/FreeRTOS/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 220:../3rdParty/FreeRTOS/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 221:../3rdParty/FreeRTOS/tasks.c ****  * any further down the list.
 222:../3rdParty/FreeRTOS/tasks.c ****  */
 223:../3rdParty/FreeRTOS/tasks.c **** #define prvCheckDelayedTasks()															\
 224:../3rdParty/FreeRTOS/tasks.c **** {																						\
 225:../3rdParty/FreeRTOS/tasks.c **** portTickType xItemValue;																\
 226:../3rdParty/FreeRTOS/tasks.c **** 																						\
 227:../3rdParty/FreeRTOS/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 228:../3rdParty/FreeRTOS/tasks.c **** 	task referenced from the delayed tasks list? */										\
 229:../3rdParty/FreeRTOS/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 230:../3rdParty/FreeRTOS/tasks.c **** 	{																					\
 231:../3rdParty/FreeRTOS/tasks.c **** 		for( ;; )																		\
 232:../3rdParty/FreeRTOS/tasks.c **** 		{																				\
 233:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 234:../3rdParty/FreeRTOS/tasks.c **** 			{																			\
 235:../3rdParty/FreeRTOS/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 236:../3rdParty/FreeRTOS/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 237:../3rdParty/FreeRTOS/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 238:../3rdParty/FreeRTOS/tasks.c **** 				time through. */														\
 239:../3rdParty/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 240:../3rdParty/FreeRTOS/tasks.c **** 				break;																	\
 241:../3rdParty/FreeRTOS/tasks.c **** 			}																			\
 242:../3rdParty/FreeRTOS/tasks.c **** 			else																		\
 243:../3rdParty/FreeRTOS/tasks.c **** 			{																			\
 244:../3rdParty/FreeRTOS/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 245:../3rdParty/FreeRTOS/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 246:../3rdParty/FreeRTOS/tasks.c **** 				task at the head of the delayed list should be removed from				\
 247:../3rdParty/FreeRTOS/tasks.c **** 				the Blocked state. */													\
 248:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 249:../3rdParty/FreeRTOS/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 250:../3rdParty/FreeRTOS/tasks.c **** 																						\
 251:../3rdParty/FreeRTOS/tasks.c **** 				if( xTickCount < xItemValue )											\
 252:../3rdParty/FreeRTOS/tasks.c **** 				{																		\
 253:../3rdParty/FreeRTOS/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 254:../3rdParty/FreeRTOS/tasks.c **** 					value is the time at which the task at the head of the				\
 255:../3rdParty/FreeRTOS/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 256:../3rdParty/FreeRTOS/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 257:../3rdParty/FreeRTOS/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 258:../3rdParty/FreeRTOS/tasks.c **** 					break;																\
 259:../3rdParty/FreeRTOS/tasks.c **** 				}																		\
 260:../3rdParty/FreeRTOS/tasks.c **** 																						\
 261:../3rdParty/FreeRTOS/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 262:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );							\
 263:../3rdParty/FreeRTOS/tasks.c **** 																						\
 264:../3rdParty/FreeRTOS/tasks.c **** 				/* Is the task waiting on an event also? */								\
 265:../3rdParty/FreeRTOS/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 266:../3rdParty/FreeRTOS/tasks.c **** 				{																		\
 267:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );							\
 268:../3rdParty/FreeRTOS/tasks.c **** 				}																		\
 269:../3rdParty/FreeRTOS/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 270:../3rdParty/FreeRTOS/tasks.c **** 			}																			\
 271:../3rdParty/FreeRTOS/tasks.c **** 		}																				\
 272:../3rdParty/FreeRTOS/tasks.c **** 	}																					\
 273:../3rdParty/FreeRTOS/tasks.c **** }
 274:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 275:../3rdParty/FreeRTOS/tasks.c **** 
 276:../3rdParty/FreeRTOS/tasks.c **** /*
 277:../3rdParty/FreeRTOS/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 278:../3rdParty/FreeRTOS/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 279:../3rdParty/FreeRTOS/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 280:../3rdParty/FreeRTOS/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 281:../3rdParty/FreeRTOS/tasks.c ****  */
 282:../3rdParty/FreeRTOS/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 283:../3rdParty/FreeRTOS/tasks.c **** 
 284:../3rdParty/FreeRTOS/tasks.c **** /* Callback function prototypes. --------------------------*/
 285:../3rdParty/FreeRTOS/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
 286:../3rdParty/FreeRTOS/tasks.c **** extern void vApplicationTickHook( void );
 287:../3rdParty/FreeRTOS/tasks.c **** 		
 288:../3rdParty/FreeRTOS/tasks.c **** /* File private functions. --------------------------------*/
 289:../3rdParty/FreeRTOS/tasks.c **** 
 290:../3rdParty/FreeRTOS/tasks.c **** /*
 291:../3rdParty/FreeRTOS/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 292:../3rdParty/FreeRTOS/tasks.c ****  * into the TCB structure.
 293:../3rdParty/FreeRTOS/tasks.c ****  */
 294:../3rdParty/FreeRTOS/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 295:../3rdParty/FreeRTOS/tasks.c **** 
 296:../3rdParty/FreeRTOS/tasks.c **** /*
 297:../3rdParty/FreeRTOS/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 298:../3rdParty/FreeRTOS/tasks.c ****  * automatically upon the creation of the first task.
 299:../3rdParty/FreeRTOS/tasks.c ****  */
 300:../3rdParty/FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 301:../3rdParty/FreeRTOS/tasks.c **** 
 302:../3rdParty/FreeRTOS/tasks.c **** /*
 303:../3rdParty/FreeRTOS/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 304:../3rdParty/FreeRTOS/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 305:../3rdParty/FreeRTOS/tasks.c ****  * creation of the first user task.
 306:../3rdParty/FreeRTOS/tasks.c ****  *
 307:../3rdParty/FreeRTOS/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 308:../3rdParty/FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 309:../3rdParty/FreeRTOS/tasks.c ****  *
 310:../3rdParty/FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
 311:../3rdParty/FreeRTOS/tasks.c ****  *
 312:../3rdParty/FreeRTOS/tasks.c ****  */
 313:../3rdParty/FreeRTOS/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 314:../3rdParty/FreeRTOS/tasks.c **** 
 315:../3rdParty/FreeRTOS/tasks.c **** /*
 316:../3rdParty/FreeRTOS/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 317:../3rdParty/FreeRTOS/tasks.c ****  * including the stack pointed to by the TCB.
 318:../3rdParty/FreeRTOS/tasks.c ****  *
 319:../3rdParty/FreeRTOS/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 320:../3rdParty/FreeRTOS/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 321:../3rdParty/FreeRTOS/tasks.c ****  */
 322:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 323:../3rdParty/FreeRTOS/tasks.c **** 
 324:../3rdParty/FreeRTOS/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 325:../3rdParty/FreeRTOS/tasks.c **** 
 326:../3rdParty/FreeRTOS/tasks.c **** #endif
 327:../3rdParty/FreeRTOS/tasks.c **** 
 328:../3rdParty/FreeRTOS/tasks.c **** /*
 329:../3rdParty/FreeRTOS/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 330:../3rdParty/FreeRTOS/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 331:../3rdParty/FreeRTOS/tasks.c ****  * and its TCB deleted.
 332:../3rdParty/FreeRTOS/tasks.c ****  */
 333:../3rdParty/FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 334:../3rdParty/FreeRTOS/tasks.c **** 
 335:../3rdParty/FreeRTOS/tasks.c **** /*
 336:../3rdParty/FreeRTOS/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 337:../3rdParty/FreeRTOS/tasks.c ****  * either the current or the overflow delayed task list.
 338:../3rdParty/FreeRTOS/tasks.c ****  */
 339:../3rdParty/FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 340:../3rdParty/FreeRTOS/tasks.c **** 
 341:../3rdParty/FreeRTOS/tasks.c **** /*
 342:../3rdParty/FreeRTOS/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 343:../3rdParty/FreeRTOS/tasks.c ****  * allocation was successful.
 344:../3rdParty/FreeRTOS/tasks.c ****  */
 345:../3rdParty/FreeRTOS/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 346:../3rdParty/FreeRTOS/tasks.c **** 
 347:../3rdParty/FreeRTOS/tasks.c **** /*
 348:../3rdParty/FreeRTOS/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 349:../3rdParty/FreeRTOS/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 350:../3rdParty/FreeRTOS/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 351:../3rdParty/FreeRTOS/tasks.c ****  * within just that list.
 352:../3rdParty/FreeRTOS/tasks.c ****  *
 353:../3rdParty/FreeRTOS/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 354:../3rdParty/FreeRTOS/tasks.c ****  * NORMAL APPLICATION CODE.
 355:../3rdParty/FreeRTOS/tasks.c ****  */
 356:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 357:../3rdParty/FreeRTOS/tasks.c **** 
 358:../3rdParty/FreeRTOS/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 359:../3rdParty/FreeRTOS/tasks.c **** 
 360:../3rdParty/FreeRTOS/tasks.c **** #endif
 361:../3rdParty/FreeRTOS/tasks.c **** 
 362:../3rdParty/FreeRTOS/tasks.c **** /*
 363:../3rdParty/FreeRTOS/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 364:../3rdParty/FreeRTOS/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 365:../3rdParty/FreeRTOS/tasks.c ****  * determining how much of the stack remains at the original preset value.
 366:../3rdParty/FreeRTOS/tasks.c ****  */
 367:../3rdParty/FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 368:../3rdParty/FreeRTOS/tasks.c **** 
 369:../3rdParty/FreeRTOS/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 370:../3rdParty/FreeRTOS/tasks.c **** 
 371:../3rdParty/FreeRTOS/tasks.c **** #endif
 372:../3rdParty/FreeRTOS/tasks.c **** 
 373:../3rdParty/FreeRTOS/tasks.c **** 
 374:../3rdParty/FreeRTOS/tasks.c **** /*lint +e956 */
 375:../3rdParty/FreeRTOS/tasks.c **** 
 376:../3rdParty/FreeRTOS/tasks.c **** 
 377:../3rdParty/FreeRTOS/tasks.c **** 
 378:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
 379:../3rdParty/FreeRTOS/tasks.c ****  * TASK CREATION API documented in task.h
 380:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
 381:../3rdParty/FreeRTOS/tasks.c **** 
 382:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 383:../3rdParty/FreeRTOS/tasks.c **** {
 4537              		.loc 1 383 0
 4538              		.cfi_startproc
 4539              		@ args = 16, pretend = 0, frame = 32
 4540              		@ frame_needed = 1, uses_anonymous_args = 0
 4541 0000 80B5     		push	{r7, lr}
 4542              	.LCFI0:
 4543              		.cfi_def_cfa_offset 8
 4544 0002 8AB0     		sub	sp, sp, #40
 4545              	.LCFI1:
 4546              		.cfi_def_cfa_offset 48
 4547 0004 02AF     		add	r7, sp, #8
 4548              		.cfi_offset 14, -4
 4549              		.cfi_offset 7, -8
 4550              	.LCFI2:
 4551              		.cfi_def_cfa 7, 40
 4552 0006 F860     		str	r0, [r7, #12]
 4553 0008 B960     		str	r1, [r7, #8]
 4554 000a 3B60     		str	r3, [r7, #0]
 4555 000c 1346     		mov	r3, r2	@ movhi
 4556 000e FB80     		strh	r3, [r7, #6]	@ movhi
 384:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xReturn;
 385:../3rdParty/FreeRTOS/tasks.c **** tskTCB * pxNewTCB;
 386:../3rdParty/FreeRTOS/tasks.c **** 
 387:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxTaskCode );
 388:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
 389:../3rdParty/FreeRTOS/tasks.c **** 
 390:../3rdParty/FreeRTOS/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 391:../3rdParty/FreeRTOS/tasks.c **** 	checking that the allocation was successful. */
 392:../3rdParty/FreeRTOS/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 4557              		.loc 1 392 0
 4558 0010 FB88     		ldrh	r3, [r7, #6]
 4559 0012 1846     		mov	r0, r3
 4560 0014 396B     		ldr	r1, [r7, #48]
 4561 0016 01F0BDF8 		bl	prvAllocateTCBAndStack
 4562 001a B861     		str	r0, [r7, #24]
 393:../3rdParty/FreeRTOS/tasks.c **** 
 394:../3rdParty/FreeRTOS/tasks.c **** 	if( pxNewTCB != NULL )
 4563              		.loc 1 394 0
 4564 001c BB69     		ldr	r3, [r7, #24]
 4565 001e 002B     		cmp	r3, #0
 4566 0020 7CD0     		beq	.L2
 4567              	.LBB2:
 395:../3rdParty/FreeRTOS/tasks.c **** 	{
 396:../3rdParty/FreeRTOS/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 397:../3rdParty/FreeRTOS/tasks.c **** 
 398:../3rdParty/FreeRTOS/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 399:../3rdParty/FreeRTOS/tasks.c **** 			/* Should the task be created in privileged mode? */
 400:../3rdParty/FreeRTOS/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 401:../3rdParty/FreeRTOS/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 402:../3rdParty/FreeRTOS/tasks.c **** 			{
 403:../3rdParty/FreeRTOS/tasks.c **** 				xRunPrivileged = pdTRUE;
 404:../3rdParty/FreeRTOS/tasks.c **** 			}
 405:../3rdParty/FreeRTOS/tasks.c **** 			else
 406:../3rdParty/FreeRTOS/tasks.c **** 			{
 407:../3rdParty/FreeRTOS/tasks.c **** 				xRunPrivileged = pdFALSE;
 408:../3rdParty/FreeRTOS/tasks.c **** 			}
 409:../3rdParty/FreeRTOS/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 410:../3rdParty/FreeRTOS/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 411:../3rdParty/FreeRTOS/tasks.c **** 
 412:../3rdParty/FreeRTOS/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 413:../3rdParty/FreeRTOS/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 414:../3rdParty/FreeRTOS/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 415:../3rdParty/FreeRTOS/tasks.c **** 		required by the port. */
 416:../3rdParty/FreeRTOS/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 417:../3rdParty/FreeRTOS/tasks.c **** 		{
 418:../3rdParty/FreeRTOS/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 4568              		.loc 1 418 0
 4569 0022 BB69     		ldr	r3, [r7, #24]
 4570 0024 1A6B     		ldr	r2, [r3, #48]
 4571 0026 FB88     		ldrh	r3, [r7, #6]
 4572 0028 03F1FF33 		add	r3, r3, #-1
 4573 002c 4FEA8303 		lsl	r3, r3, #2
 4574 0030 D318     		adds	r3, r2, r3
 4575 0032 7B61     		str	r3, [r7, #20]
 419:../3rdParty/FreeRTOS/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 4576              		.loc 1 419 0
 4577 0034 7B69     		ldr	r3, [r7, #20]
 4578 0036 23F00703 		bic	r3, r3, #7
 4579 003a 7B61     		str	r3, [r7, #20]
 420:../3rdParty/FreeRTOS/tasks.c **** 
 421:../3rdParty/FreeRTOS/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 422:../3rdParty/FreeRTOS/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 423:../3rdParty/FreeRTOS/tasks.c **** 		}
 424:../3rdParty/FreeRTOS/tasks.c **** 		#else
 425:../3rdParty/FreeRTOS/tasks.c **** 		{
 426:../3rdParty/FreeRTOS/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 427:../3rdParty/FreeRTOS/tasks.c **** 			
 428:../3rdParty/FreeRTOS/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 429:../3rdParty/FreeRTOS/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 430:../3rdParty/FreeRTOS/tasks.c **** 
 431:../3rdParty/FreeRTOS/tasks.c **** 			/* If we want to use stack checking on architectures that use
 432:../3rdParty/FreeRTOS/tasks.c **** 			a positive stack growth direction then we also need to store the
 433:../3rdParty/FreeRTOS/tasks.c **** 			other extreme of the stack space. */
 434:../3rdParty/FreeRTOS/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 435:../3rdParty/FreeRTOS/tasks.c **** 		}
 436:../3rdParty/FreeRTOS/tasks.c **** 		#endif
 437:../3rdParty/FreeRTOS/tasks.c **** 
 438:../3rdParty/FreeRTOS/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 439:../3rdParty/FreeRTOS/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 4580              		.loc 1 439 0
 4581 003c FB88     		ldrh	r3, [r7, #6]
 4582 003e 0093     		str	r3, [sp, #0]
 4583 0040 B869     		ldr	r0, [r7, #24]
 4584 0042 B968     		ldr	r1, [r7, #8]
 4585 0044 BA6A     		ldr	r2, [r7, #40]
 4586 0046 7B6B     		ldr	r3, [r7, #52]
 4587 0048 00F0AAFF 		bl	prvInitialiseTCBVariables
 440:../3rdParty/FreeRTOS/tasks.c **** 
 441:../3rdParty/FreeRTOS/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 442:../3rdParty/FreeRTOS/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 443:../3rdParty/FreeRTOS/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 444:../3rdParty/FreeRTOS/tasks.c **** 		the	top of stack variable is updated. */
 445:../3rdParty/FreeRTOS/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 446:../3rdParty/FreeRTOS/tasks.c **** 		{
 447:../3rdParty/FreeRTOS/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 448:../3rdParty/FreeRTOS/tasks.c **** 		}
 449:../3rdParty/FreeRTOS/tasks.c **** 		#else
 450:../3rdParty/FreeRTOS/tasks.c **** 		{
 451:../3rdParty/FreeRTOS/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 4588              		.loc 1 451 0
 4589 004c 7869     		ldr	r0, [r7, #20]
 4590 004e F968     		ldr	r1, [r7, #12]
 4591 0050 3A68     		ldr	r2, [r7, #0]
 4592 0052 FFF7FEFF 		bl	pxPortInitialiseStack
 4593 0056 0346     		mov	r3, r0
 4594 0058 1A46     		mov	r2, r3
 4595 005a BB69     		ldr	r3, [r7, #24]
 4596 005c 1A60     		str	r2, [r3, #0]
 452:../3rdParty/FreeRTOS/tasks.c **** 		}
 453:../3rdParty/FreeRTOS/tasks.c **** 		#endif
 454:../3rdParty/FreeRTOS/tasks.c **** 
 455:../3rdParty/FreeRTOS/tasks.c **** 		/* Check the alignment of the initialised stack. */
 456:../3rdParty/FreeRTOS/tasks.c **** 		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long
 457:../3rdParty/FreeRTOS/tasks.c **** 
 458:../3rdParty/FreeRTOS/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 4597              		.loc 1 458 0
 4598 005e FB6A     		ldr	r3, [r7, #44]
 4599 0060 002B     		cmp	r3, #0
 4600 0062 02D0     		beq	.L3
 459:../3rdParty/FreeRTOS/tasks.c **** 		{
 460:../3rdParty/FreeRTOS/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 461:../3rdParty/FreeRTOS/tasks.c **** 			task can use this as a handle to delete the task later if
 462:../3rdParty/FreeRTOS/tasks.c **** 			required.*/
 463:../3rdParty/FreeRTOS/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 4601              		.loc 1 463 0
 4602 0064 FB6A     		ldr	r3, [r7, #44]
 4603 0066 BA69     		ldr	r2, [r7, #24]
 4604 0068 1A60     		str	r2, [r3, #0]
 4605              	.L3:
 464:../3rdParty/FreeRTOS/tasks.c **** 		}
 465:../3rdParty/FreeRTOS/tasks.c **** 		
 466:../3rdParty/FreeRTOS/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 467:../3rdParty/FreeRTOS/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 468:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 4606              		.loc 1 468 0
 4607 006a FFF7FEFF 		bl	vPortEnterCritical
 469:../3rdParty/FreeRTOS/tasks.c **** 		{
 470:../3rdParty/FreeRTOS/tasks.c **** 			uxCurrentNumberOfTasks++;
 4608              		.loc 1 470 0
 4609 006e 374B     		ldr	r3, .L10
 4610 0070 1B68     		ldr	r3, [r3, #0]
 4611 0072 03F10102 		add	r2, r3, #1
 4612 0076 354B     		ldr	r3, .L10
 4613 0078 1A60     		str	r2, [r3, #0]
 471:../3rdParty/FreeRTOS/tasks.c **** 			if( pxCurrentTCB == NULL )
 4614              		.loc 1 471 0
 4615 007a 354B     		ldr	r3, .L10+4
 4616 007c 1B68     		ldr	r3, [r3, #0]
 4617 007e 002B     		cmp	r3, #0
 4618 0080 09D1     		bne	.L4
 472:../3rdParty/FreeRTOS/tasks.c **** 			{
 473:../3rdParty/FreeRTOS/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 474:../3rdParty/FreeRTOS/tasks.c **** 				the suspended state - make this the current task. */
 475:../3rdParty/FreeRTOS/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 4619              		.loc 1 475 0
 4620 0082 334B     		ldr	r3, .L10+4
 4621 0084 BA69     		ldr	r2, [r7, #24]
 4622 0086 1A60     		str	r2, [r3, #0]
 476:../3rdParty/FreeRTOS/tasks.c **** 
 477:../3rdParty/FreeRTOS/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 4623              		.loc 1 477 0
 4624 0088 304B     		ldr	r3, .L10
 4625 008a 1B68     		ldr	r3, [r3, #0]
 4626 008c 012B     		cmp	r3, #1
 4627 008e 0FD1     		bne	.L5
 478:../3rdParty/FreeRTOS/tasks.c **** 				{
 479:../3rdParty/FreeRTOS/tasks.c **** 					/* This is the first task to be created so do the preliminary
 480:../3rdParty/FreeRTOS/tasks.c **** 					initialisation required.  We will not recover if this call
 481:../3rdParty/FreeRTOS/tasks.c **** 					fails, but we will report the failure. */
 482:../3rdParty/FreeRTOS/tasks.c **** 					prvInitialiseTaskLists();
 4628              		.loc 1 482 0
 4629 0090 00F0C8FF 		bl	prvInitialiseTaskLists
 4630 0094 0CE0     		b	.L5
 4631              	.L4:
 483:../3rdParty/FreeRTOS/tasks.c **** 				}
 484:../3rdParty/FreeRTOS/tasks.c **** 			}
 485:../3rdParty/FreeRTOS/tasks.c **** 			else
 486:../3rdParty/FreeRTOS/tasks.c **** 			{
 487:../3rdParty/FreeRTOS/tasks.c **** 				/* If the scheduler is not already running, make this task the
 488:../3rdParty/FreeRTOS/tasks.c **** 				current task if it is the highest priority task to be created
 489:../3rdParty/FreeRTOS/tasks.c **** 				so far. */
 490:../3rdParty/FreeRTOS/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 4632              		.loc 1 490 0
 4633 0096 2F4B     		ldr	r3, .L10+8
 4634 0098 1B68     		ldr	r3, [r3, #0]
 4635 009a 002B     		cmp	r3, #0
 4636 009c 08D1     		bne	.L5
 491:../3rdParty/FreeRTOS/tasks.c **** 				{
 492:../3rdParty/FreeRTOS/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 4637              		.loc 1 492 0
 4638 009e 2C4B     		ldr	r3, .L10+4
 4639 00a0 1B68     		ldr	r3, [r3, #0]
 4640 00a2 DA6A     		ldr	r2, [r3, #44]
 4641 00a4 BB6A     		ldr	r3, [r7, #40]
 4642 00a6 9A42     		cmp	r2, r3
 4643 00a8 02D8     		bhi	.L5
 493:../3rdParty/FreeRTOS/tasks.c **** 					{
 494:../3rdParty/FreeRTOS/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 4644              		.loc 1 494 0
 4645 00aa 294B     		ldr	r3, .L10+4
 4646 00ac BA69     		ldr	r2, [r7, #24]
 4647 00ae 1A60     		str	r2, [r3, #0]
 4648              	.L5:
 495:../3rdParty/FreeRTOS/tasks.c **** 					}
 496:../3rdParty/FreeRTOS/tasks.c **** 				}
 497:../3rdParty/FreeRTOS/tasks.c **** 			}
 498:../3rdParty/FreeRTOS/tasks.c **** 
 499:../3rdParty/FreeRTOS/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 500:../3rdParty/FreeRTOS/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 501:../3rdParty/FreeRTOS/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 4649              		.loc 1 501 0
 4650 00b0 BB69     		ldr	r3, [r7, #24]
 4651 00b2 DA6A     		ldr	r2, [r3, #44]
 4652 00b4 284B     		ldr	r3, .L10+12
 4653 00b6 1B68     		ldr	r3, [r3, #0]
 4654 00b8 9A42     		cmp	r2, r3
 4655 00ba 03D9     		bls	.L6
 502:../3rdParty/FreeRTOS/tasks.c **** 			{
 503:../3rdParty/FreeRTOS/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 4656              		.loc 1 503 0
 4657 00bc BB69     		ldr	r3, [r7, #24]
 4658 00be DA6A     		ldr	r2, [r3, #44]
 4659 00c0 254B     		ldr	r3, .L10+12
 4660 00c2 1A60     		str	r2, [r3, #0]
 4661              	.L6:
 504:../3rdParty/FreeRTOS/tasks.c **** 			}
 505:../3rdParty/FreeRTOS/tasks.c **** 
 506:../3rdParty/FreeRTOS/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 507:../3rdParty/FreeRTOS/tasks.c **** 			{
 508:../3rdParty/FreeRTOS/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 509:../3rdParty/FreeRTOS/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTCBNumber;
 4662              		.loc 1 509 0
 4663 00c4 254B     		ldr	r3, .L10+16
 4664 00c6 1A68     		ldr	r2, [r3, #0]
 4665 00c8 BB69     		ldr	r3, [r7, #24]
 4666 00ca 1A64     		str	r2, [r3, #64]
 510:../3rdParty/FreeRTOS/tasks.c **** 			}
 511:../3rdParty/FreeRTOS/tasks.c **** 			#endif
 512:../3rdParty/FreeRTOS/tasks.c **** 			uxTCBNumber++;
 4667              		.loc 1 512 0
 4668 00cc 234B     		ldr	r3, .L10+16
 4669 00ce 1B68     		ldr	r3, [r3, #0]
 4670 00d0 03F10102 		add	r2, r3, #1
 4671 00d4 214B     		ldr	r3, .L10+16
 4672 00d6 1A60     		str	r2, [r3, #0]
 513:../3rdParty/FreeRTOS/tasks.c **** 
 514:../3rdParty/FreeRTOS/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 4673              		.loc 1 514 0
 4674 00d8 BB69     		ldr	r3, [r7, #24]
 4675 00da DA6A     		ldr	r2, [r3, #44]
 4676 00dc 204B     		ldr	r3, .L10+20
 4677 00de 1B68     		ldr	r3, [r3, #0]
 4678 00e0 9A42     		cmp	r2, r3
 4679 00e2 03D9     		bls	.L7
 4680              		.loc 1 514 0 is_stmt 0 discriminator 1
 4681 00e4 BB69     		ldr	r3, [r7, #24]
 4682 00e6 DA6A     		ldr	r2, [r3, #44]
 4683 00e8 1D4B     		ldr	r3, .L10+20
 4684 00ea 1A60     		str	r2, [r3, #0]
 4685              	.L7:
 4686              		.loc 1 514 0 discriminator 2
 4687 00ec BB69     		ldr	r3, [r7, #24]
 4688 00ee DA6A     		ldr	r2, [r3, #44]
 4689 00f0 1346     		mov	r3, r2
 4690 00f2 4FEA8303 		lsl	r3, r3, #2
 4691 00f6 9B18     		adds	r3, r3, r2
 4692 00f8 4FEA8303 		lsl	r3, r3, #2
 4693 00fc 1A46     		mov	r2, r3
 4694 00fe 194B     		ldr	r3, .L10+24
 4695 0100 D218     		adds	r2, r2, r3
 4696 0102 BB69     		ldr	r3, [r7, #24]
 4697 0104 03F10403 		add	r3, r3, #4
 4698 0108 1046     		mov	r0, r2
 4699 010a 1946     		mov	r1, r3
 4700 010c FFF7FEFF 		bl	vListInsertEnd
 515:../3rdParty/FreeRTOS/tasks.c **** 
 516:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdPASS;
 4701              		.loc 1 516 0 is_stmt 1 discriminator 2
 4702 0110 4FF00103 		mov	r3, #1
 4703 0114 FB61     		str	r3, [r7, #28]
 517:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 518:../3rdParty/FreeRTOS/tasks.c **** 		}
 519:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 4704              		.loc 1 519 0 discriminator 2
 4705 0116 FFF7FEFF 		bl	vPortExitCritical
 4706 011a 02E0     		b	.L8
 4707              	.L2:
 4708              	.LBE2:
 520:../3rdParty/FreeRTOS/tasks.c **** 	}
 521:../3rdParty/FreeRTOS/tasks.c **** 	else
 522:../3rdParty/FreeRTOS/tasks.c **** 	{
 523:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 4709              		.loc 1 523 0
 4710 011c 4FF0FF33 		mov	r3, #-1
 4711 0120 FB61     		str	r3, [r7, #28]
 4712              	.L8:
 524:../3rdParty/FreeRTOS/tasks.c **** 		traceTASK_CREATE_FAILED();
 525:../3rdParty/FreeRTOS/tasks.c **** 	}
 526:../3rdParty/FreeRTOS/tasks.c **** 
 527:../3rdParty/FreeRTOS/tasks.c **** 	if( xReturn == pdPASS )
 4713              		.loc 1 527 0
 4714 0122 FB69     		ldr	r3, [r7, #28]
 4715 0124 012B     		cmp	r3, #1
 4716 0126 0BD1     		bne	.L9
 528:../3rdParty/FreeRTOS/tasks.c **** 	{
 529:../3rdParty/FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 4717              		.loc 1 529 0
 4718 0128 0A4B     		ldr	r3, .L10+8
 4719 012a 1B68     		ldr	r3, [r3, #0]
 4720 012c 002B     		cmp	r3, #0
 4721 012e 07D0     		beq	.L9
 530:../3rdParty/FreeRTOS/tasks.c **** 		{
 531:../3rdParty/FreeRTOS/tasks.c **** 			/* If the created task is of a higher priority than the current task
 532:../3rdParty/FreeRTOS/tasks.c **** 			then it should run now. */
 533:../3rdParty/FreeRTOS/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 4722              		.loc 1 533 0
 4723 0130 074B     		ldr	r3, .L10+4
 4724 0132 1B68     		ldr	r3, [r3, #0]
 4725 0134 DA6A     		ldr	r2, [r3, #44]
 4726 0136 BB6A     		ldr	r3, [r7, #40]
 4727 0138 9A42     		cmp	r2, r3
 4728 013a 01D2     		bcs	.L9
 534:../3rdParty/FreeRTOS/tasks.c **** 			{
 535:../3rdParty/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 4729              		.loc 1 535 0
 4730 013c FFF7FEFF 		bl	vPortYieldFromISR
 4731              	.L9:
 536:../3rdParty/FreeRTOS/tasks.c **** 			}
 537:../3rdParty/FreeRTOS/tasks.c **** 		}
 538:../3rdParty/FreeRTOS/tasks.c **** 	}
 539:../3rdParty/FreeRTOS/tasks.c **** 
 540:../3rdParty/FreeRTOS/tasks.c **** 	return xReturn;
 4732              		.loc 1 540 0
 4733 0140 FB69     		ldr	r3, [r7, #28]
 541:../3rdParty/FreeRTOS/tasks.c **** }
 4734              		.loc 1 541 0
 4735 0142 1846     		mov	r0, r3
 4736 0144 07F12007 		add	r7, r7, #32
 4737 0148 BD46     		mov	sp, r7
 4738 014a 80BD     		pop	{r7, pc}
 4739              	.L11:
 4740              		.align	2
 4741              	.L10:
 4742 014c D8000000 		.word	uxCurrentNumberOfTasks
 4743 0150 00000000 		.word	pxCurrentTCB
 4744 0154 E8000000 		.word	xSchedulerRunning
 4745 0158 E0000000 		.word	uxTopUsedPriority
 4746 015c FC000000 		.word	uxTCBNumber
 4747 0160 E4000000 		.word	uxTopReadyPriority
 4748 0164 04000000 		.word	pxReadyTasksLists
 4749              		.cfi_endproc
 4750              	.LFE29:
 4752              		.align	2
 4753              		.global	vTaskDelete
 4754              		.thumb
 4755              		.thumb_func
 4757              	vTaskDelete:
 4758              	.LFB30:
 542:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 543:../3rdParty/FreeRTOS/tasks.c **** 
 544:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 545:../3rdParty/FreeRTOS/tasks.c **** 
 546:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 547:../3rdParty/FreeRTOS/tasks.c **** 	{
 4759              		.loc 1 547 0
 4760              		.cfi_startproc
 4761              		@ args = 0, pretend = 0, frame = 16
 4762              		@ frame_needed = 1, uses_anonymous_args = 0
 4763 0168 80B5     		push	{r7, lr}
 4764              	.LCFI3:
 4765              		.cfi_def_cfa_offset 8
 4766 016a 84B0     		sub	sp, sp, #16
 4767              	.LCFI4:
 4768              		.cfi_def_cfa_offset 24
 4769 016c 00AF     		add	r7, sp, #0
 4770              		.cfi_offset 14, -4
 4771              		.cfi_offset 7, -8
 4772              	.LCFI5:
 4773              		.cfi_def_cfa_register 7
 4774 016e 7860     		str	r0, [r7, #4]
 548:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 549:../3rdParty/FreeRTOS/tasks.c **** 
 550:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 4775              		.loc 1 550 0
 4776 0170 FFF7FEFF 		bl	vPortEnterCritical
 551:../3rdParty/FreeRTOS/tasks.c **** 		{
 552:../3rdParty/FreeRTOS/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 553:../3rdParty/FreeRTOS/tasks.c **** 			deleted. */
 554:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 4777              		.loc 1 554 0
 4778 0174 204B     		ldr	r3, .L18
 4779 0176 1B68     		ldr	r3, [r3, #0]
 4780 0178 7A68     		ldr	r2, [r7, #4]
 4781 017a 9A42     		cmp	r2, r3
 4782 017c 02D1     		bne	.L13
 555:../3rdParty/FreeRTOS/tasks.c **** 			{
 556:../3rdParty/FreeRTOS/tasks.c **** 				pxTaskToDelete = NULL;
 4783              		.loc 1 556 0
 4784 017e 4FF00003 		mov	r3, #0
 4785 0182 7B60     		str	r3, [r7, #4]
 4786              	.L13:
 557:../3rdParty/FreeRTOS/tasks.c **** 			}
 558:../3rdParty/FreeRTOS/tasks.c **** 
 559:../3rdParty/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 560:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 4787              		.loc 1 560 0
 4788 0184 7B68     		ldr	r3, [r7, #4]
 4789 0186 002B     		cmp	r3, #0
 4790 0188 02D1     		bne	.L14
 4791              		.loc 1 560 0 is_stmt 0 discriminator 1
 4792 018a 1B4B     		ldr	r3, .L18
 4793 018c 1B68     		ldr	r3, [r3, #0]
 4794 018e 00E0     		b	.L15
 4795              	.L14:
 4796              		.loc 1 560 0 discriminator 2
 4797 0190 7B68     		ldr	r3, [r7, #4]
 4798              	.L15:
 4799              		.loc 1 560 0 discriminator 3
 4800 0192 FB60     		str	r3, [r7, #12]
 561:../3rdParty/FreeRTOS/tasks.c **** 
 562:../3rdParty/FreeRTOS/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 563:../3rdParty/FreeRTOS/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 564:../3rdParty/FreeRTOS/tasks.c **** 			the termination list and free up any memory allocated by the
 565:../3rdParty/FreeRTOS/tasks.c **** 			scheduler for the TCB and stack. */
 566:../3rdParty/FreeRTOS/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 4801              		.loc 1 566 0 is_stmt 1 discriminator 3
 4802 0194 FB68     		ldr	r3, [r7, #12]
 4803 0196 03F10403 		add	r3, r3, #4
 4804 019a 1846     		mov	r0, r3
 4805 019c FFF7FEFF 		bl	vListRemove
 567:../3rdParty/FreeRTOS/tasks.c **** 
 568:../3rdParty/FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
 569:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 4806              		.loc 1 569 0 discriminator 3
 4807 01a0 FB68     		ldr	r3, [r7, #12]
 4808 01a2 9B6A     		ldr	r3, [r3, #40]
 4809 01a4 002B     		cmp	r3, #0
 4810 01a6 05D0     		beq	.L16
 570:../3rdParty/FreeRTOS/tasks.c **** 			{
 571:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 4811              		.loc 1 571 0
 4812 01a8 FB68     		ldr	r3, [r7, #12]
 4813 01aa 03F11803 		add	r3, r3, #24
 4814 01ae 1846     		mov	r0, r3
 4815 01b0 FFF7FEFF 		bl	vListRemove
 4816              	.L16:
 572:../3rdParty/FreeRTOS/tasks.c **** 			}
 573:../3rdParty/FreeRTOS/tasks.c **** 
 574:../3rdParty/FreeRTOS/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 4817              		.loc 1 574 0
 4818 01b4 FB68     		ldr	r3, [r7, #12]
 4819 01b6 03F10403 		add	r3, r3, #4
 4820 01ba 1048     		ldr	r0, .L18+4
 4821 01bc 1946     		mov	r1, r3
 4822 01be FFF7FEFF 		bl	vListInsertEnd
 575:../3rdParty/FreeRTOS/tasks.c **** 
 576:../3rdParty/FreeRTOS/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 577:../3rdParty/FreeRTOS/tasks.c **** 			there is a task that has been deleted and that it should therefore
 578:../3rdParty/FreeRTOS/tasks.c **** 			check the xTasksWaitingTermination list. */
 579:../3rdParty/FreeRTOS/tasks.c **** 			++uxTasksDeleted;
 4823              		.loc 1 579 0
 4824 01c2 0F4B     		ldr	r3, .L18+8
 4825 01c4 1B68     		ldr	r3, [r3, #0]
 4826 01c6 03F10102 		add	r2, r3, #1
 4827 01ca 0D4B     		ldr	r3, .L18+8
 4828 01cc 1A60     		str	r2, [r3, #0]
 580:../3rdParty/FreeRTOS/tasks.c **** 
 581:../3rdParty/FreeRTOS/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 582:../3rdParty/FreeRTOS/tasks.c **** 			can detect that the task lists need re-generating. */
 583:../3rdParty/FreeRTOS/tasks.c **** 			uxTCBNumber++;
 4829              		.loc 1 583 0
 4830 01ce 0D4B     		ldr	r3, .L18+12
 4831 01d0 1B68     		ldr	r3, [r3, #0]
 4832 01d2 03F10102 		add	r2, r3, #1
 4833 01d6 0B4B     		ldr	r3, .L18+12
 4834 01d8 1A60     		str	r2, [r3, #0]
 584:../3rdParty/FreeRTOS/tasks.c **** 
 585:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_DELETE( pxTCB );
 586:../3rdParty/FreeRTOS/tasks.c **** 		}
 587:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 4835              		.loc 1 587 0
 4836 01da FFF7FEFF 		bl	vPortExitCritical
 588:../3rdParty/FreeRTOS/tasks.c **** 
 589:../3rdParty/FreeRTOS/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 590:../3rdParty/FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 4837              		.loc 1 590 0
 4838 01de 0A4B     		ldr	r3, .L18+16
 4839 01e0 1B68     		ldr	r3, [r3, #0]
 4840 01e2 002B     		cmp	r3, #0
 4841 01e4 04D0     		beq	.L12
 591:../3rdParty/FreeRTOS/tasks.c **** 		{
 592:../3rdParty/FreeRTOS/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 4842              		.loc 1 592 0
 4843 01e6 7B68     		ldr	r3, [r7, #4]
 4844 01e8 002B     		cmp	r3, #0
 4845 01ea 01D1     		bne	.L12
 593:../3rdParty/FreeRTOS/tasks.c **** 			{
 594:../3rdParty/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 4846              		.loc 1 594 0
 4847 01ec FFF7FEFF 		bl	vPortYieldFromISR
 4848              	.L12:
 595:../3rdParty/FreeRTOS/tasks.c **** 			}
 596:../3rdParty/FreeRTOS/tasks.c **** 		}
 597:../3rdParty/FreeRTOS/tasks.c **** 	}
 4849              		.loc 1 597 0
 4850 01f0 07F11007 		add	r7, r7, #16
 4851 01f4 BD46     		mov	sp, r7
 4852 01f6 80BD     		pop	{r7, pc}
 4853              	.L19:
 4854              		.align	2
 4855              	.L18:
 4856 01f8 00000000 		.word	pxCurrentTCB
 4857 01fc AC000000 		.word	xTasksWaitingTermination
 4858 0200 C0000000 		.word	uxTasksDeleted
 4859 0204 FC000000 		.word	uxTCBNumber
 4860 0208 E8000000 		.word	xSchedulerRunning
 4861              		.cfi_endproc
 4862              	.LFE30:
 4864              		.align	2
 4865              		.global	vTaskDelayUntil
 4866              		.thumb
 4867              		.thumb_func
 4869              	vTaskDelayUntil:
 4870              	.LFB31:
 598:../3rdParty/FreeRTOS/tasks.c **** 
 599:../3rdParty/FreeRTOS/tasks.c **** #endif
 600:../3rdParty/FreeRTOS/tasks.c **** 
 601:../3rdParty/FreeRTOS/tasks.c **** 
 602:../3rdParty/FreeRTOS/tasks.c **** 
 603:../3rdParty/FreeRTOS/tasks.c **** 
 604:../3rdParty/FreeRTOS/tasks.c **** 
 605:../3rdParty/FreeRTOS/tasks.c **** 
 606:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
 607:../3rdParty/FreeRTOS/tasks.c ****  * TASK CONTROL API documented in task.h
 608:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
 609:../3rdParty/FreeRTOS/tasks.c **** 
 610:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 611:../3rdParty/FreeRTOS/tasks.c **** 
 612:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 613:../3rdParty/FreeRTOS/tasks.c **** 	{
 4871              		.loc 1 613 0
 4872              		.cfi_startproc
 4873              		@ args = 0, pretend = 0, frame = 24
 4874              		@ frame_needed = 1, uses_anonymous_args = 0
 4875 020c 80B5     		push	{r7, lr}
 4876              	.LCFI6:
 4877              		.cfi_def_cfa_offset 8
 4878 020e 86B0     		sub	sp, sp, #24
 4879              	.LCFI7:
 4880              		.cfi_def_cfa_offset 32
 4881 0210 00AF     		add	r7, sp, #0
 4882              		.cfi_offset 14, -4
 4883              		.cfi_offset 7, -8
 4884              	.LCFI8:
 4885              		.cfi_def_cfa_register 7
 4886 0212 7860     		str	r0, [r7, #4]
 4887 0214 3960     		str	r1, [r7, #0]
 614:../3rdParty/FreeRTOS/tasks.c **** 	portTickType xTimeToWake;
 615:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 4888              		.loc 1 615 0
 4889 0216 4FF00003 		mov	r3, #0
 4890 021a 7B61     		str	r3, [r7, #20]
 616:../3rdParty/FreeRTOS/tasks.c **** 
 617:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 618:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 619:../3rdParty/FreeRTOS/tasks.c **** 
 620:../3rdParty/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
 4891              		.loc 1 620 0
 4892 021c FFF7FEFF 		bl	vTaskSuspendAll
 621:../3rdParty/FreeRTOS/tasks.c **** 		{
 622:../3rdParty/FreeRTOS/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 623:../3rdParty/FreeRTOS/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 4893              		.loc 1 623 0
 4894 0220 7B68     		ldr	r3, [r7, #4]
 4895 0222 1A68     		ldr	r2, [r3, #0]
 4896 0224 3B68     		ldr	r3, [r7, #0]
 4897 0226 D318     		adds	r3, r2, r3
 4898 0228 3B61     		str	r3, [r7, #16]
 624:../3rdParty/FreeRTOS/tasks.c **** 
 625:../3rdParty/FreeRTOS/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 4899              		.loc 1 625 0
 4900 022a 7B68     		ldr	r3, [r7, #4]
 4901 022c 1A68     		ldr	r2, [r3, #0]
 4902 022e 1D4B     		ldr	r3, .L26
 4903 0230 1B68     		ldr	r3, [r3, #0]
 4904 0232 9A42     		cmp	r2, r3
 4905 0234 0DD9     		bls	.L21
 626:../3rdParty/FreeRTOS/tasks.c **** 			{
 627:../3rdParty/FreeRTOS/tasks.c **** 				/* The tick count has overflowed since this function was
 628:../3rdParty/FreeRTOS/tasks.c **** 				lasted called.  In this case the only time we should ever
 629:../3rdParty/FreeRTOS/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 630:../3rdParty/FreeRTOS/tasks.c **** 				and the wake time is greater than the tick time.  When this
 631:../3rdParty/FreeRTOS/tasks.c **** 				is the case it is as if neither time had overflowed. */
 632:../3rdParty/FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 4906              		.loc 1 632 0
 4907 0236 7B68     		ldr	r3, [r7, #4]
 4908 0238 1A68     		ldr	r2, [r3, #0]
 4909 023a 3B69     		ldr	r3, [r7, #16]
 4910 023c 9A42     		cmp	r2, r3
 4911 023e 15D9     		bls	.L22
 4912              		.loc 1 632 0 is_stmt 0 discriminator 1
 4913 0240 184B     		ldr	r3, .L26
 4914 0242 1B68     		ldr	r3, [r3, #0]
 4915 0244 3A69     		ldr	r2, [r7, #16]
 4916 0246 9A42     		cmp	r2, r3
 4917 0248 10D9     		bls	.L22
 633:../3rdParty/FreeRTOS/tasks.c **** 				{
 634:../3rdParty/FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 4918              		.loc 1 634 0 is_stmt 1
 4919 024a 4FF00103 		mov	r3, #1
 4920 024e 7B61     		str	r3, [r7, #20]
 4921 0250 0CE0     		b	.L22
 4922              	.L21:
 635:../3rdParty/FreeRTOS/tasks.c **** 				}
 636:../3rdParty/FreeRTOS/tasks.c **** 			}
 637:../3rdParty/FreeRTOS/tasks.c **** 			else
 638:../3rdParty/FreeRTOS/tasks.c **** 			{
 639:../3rdParty/FreeRTOS/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 640:../3rdParty/FreeRTOS/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 641:../3rdParty/FreeRTOS/tasks.c **** 				tick time is less than the wake time. */
 642:../3rdParty/FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 4923              		.loc 1 642 0
 4924 0252 7B68     		ldr	r3, [r7, #4]
 4925 0254 1A68     		ldr	r2, [r3, #0]
 4926 0256 3B69     		ldr	r3, [r7, #16]
 4927 0258 9A42     		cmp	r2, r3
 4928 025a 04D8     		bhi	.L23
 4929              		.loc 1 642 0 is_stmt 0 discriminator 1
 4930 025c 114B     		ldr	r3, .L26
 4931 025e 1B68     		ldr	r3, [r3, #0]
 4932 0260 3A69     		ldr	r2, [r7, #16]
 4933 0262 9A42     		cmp	r2, r3
 4934 0264 02D9     		bls	.L22
 4935              	.L23:
 643:../3rdParty/FreeRTOS/tasks.c **** 				{
 644:../3rdParty/FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 4936              		.loc 1 644 0 is_stmt 1
 4937 0266 4FF00103 		mov	r3, #1
 4938 026a 7B61     		str	r3, [r7, #20]
 4939              	.L22:
 645:../3rdParty/FreeRTOS/tasks.c **** 				}
 646:../3rdParty/FreeRTOS/tasks.c **** 			}
 647:../3rdParty/FreeRTOS/tasks.c **** 
 648:../3rdParty/FreeRTOS/tasks.c **** 			/* Update the wake time ready for the next call. */
 649:../3rdParty/FreeRTOS/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 4940              		.loc 1 649 0
 4941 026c 7B68     		ldr	r3, [r7, #4]
 4942 026e 3A69     		ldr	r2, [r7, #16]
 4943 0270 1A60     		str	r2, [r3, #0]
 650:../3rdParty/FreeRTOS/tasks.c **** 
 651:../3rdParty/FreeRTOS/tasks.c **** 			if( xShouldDelay != pdFALSE )
 4944              		.loc 1 651 0
 4945 0272 7B69     		ldr	r3, [r7, #20]
 4946 0274 002B     		cmp	r3, #0
 4947 0276 09D0     		beq	.L24
 652:../3rdParty/FreeRTOS/tasks.c **** 			{
 653:../3rdParty/FreeRTOS/tasks.c **** 				traceTASK_DELAY_UNTIL();
 654:../3rdParty/FreeRTOS/tasks.c **** 
 655:../3rdParty/FreeRTOS/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 656:../3rdParty/FreeRTOS/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 657:../3rdParty/FreeRTOS/tasks.c **** 				both lists. */
 658:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 4948              		.loc 1 658 0
 4949 0278 0B4B     		ldr	r3, .L26+4
 4950 027a 1B68     		ldr	r3, [r3, #0]
 4951 027c 03F10403 		add	r3, r3, #4
 4952 0280 1846     		mov	r0, r3
 4953 0282 FFF7FEFF 		bl	vListRemove
 659:../3rdParty/FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 4954              		.loc 1 659 0
 4955 0286 3869     		ldr	r0, [r7, #16]
 4956 0288 00F04CFF 		bl	prvAddCurrentTaskToDelayedList
 4957              	.L24:
 660:../3rdParty/FreeRTOS/tasks.c **** 			}
 661:../3rdParty/FreeRTOS/tasks.c **** 		}
 662:../3rdParty/FreeRTOS/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 4958              		.loc 1 662 0
 4959 028c FFF7FEFF 		bl	xTaskResumeAll
 4960 0290 F860     		str	r0, [r7, #12]
 663:../3rdParty/FreeRTOS/tasks.c **** 
 664:../3rdParty/FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 665:../3rdParty/FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
 666:../3rdParty/FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 4961              		.loc 1 666 0
 4962 0292 FB68     		ldr	r3, [r7, #12]
 4963 0294 002B     		cmp	r3, #0
 4964 0296 01D1     		bne	.L20
 667:../3rdParty/FreeRTOS/tasks.c **** 		{
 668:../3rdParty/FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
 4965              		.loc 1 668 0
 4966 0298 FFF7FEFF 		bl	vPortYieldFromISR
 4967              	.L20:
 669:../3rdParty/FreeRTOS/tasks.c **** 		}
 670:../3rdParty/FreeRTOS/tasks.c **** 	}
 4968              		.loc 1 670 0
 4969 029c 07F11807 		add	r7, r7, #24
 4970 02a0 BD46     		mov	sp, r7
 4971 02a2 80BD     		pop	{r7, pc}
 4972              	.L27:
 4973              		.align	2
 4974              	.L26:
 4975 02a4 DC000000 		.word	xTickCount
 4976 02a8 00000000 		.word	pxCurrentTCB
 4977              		.cfi_endproc
 4978              	.LFE31:
 4980              		.align	2
 4981              		.global	vTaskDelay
 4982              		.thumb
 4983              		.thumb_func
 4985              	vTaskDelay:
 4986              	.LFB32:
 671:../3rdParty/FreeRTOS/tasks.c **** 
 672:../3rdParty/FreeRTOS/tasks.c **** #endif
 673:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 674:../3rdParty/FreeRTOS/tasks.c **** 
 675:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 676:../3rdParty/FreeRTOS/tasks.c **** 
 677:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 678:../3rdParty/FreeRTOS/tasks.c **** 	{
 4987              		.loc 1 678 0
 4988              		.cfi_startproc
 4989              		@ args = 0, pretend = 0, frame = 16
 4990              		@ frame_needed = 1, uses_anonymous_args = 0
 4991 02ac 80B5     		push	{r7, lr}
 4992              	.LCFI9:
 4993              		.cfi_def_cfa_offset 8
 4994 02ae 84B0     		sub	sp, sp, #16
 4995              	.LCFI10:
 4996              		.cfi_def_cfa_offset 24
 4997 02b0 00AF     		add	r7, sp, #0
 4998              		.cfi_offset 14, -4
 4999              		.cfi_offset 7, -8
 5000              	.LCFI11:
 5001              		.cfi_def_cfa_register 7
 5002 02b2 7860     		str	r0, [r7, #4]
 679:../3rdParty/FreeRTOS/tasks.c **** 	portTickType xTimeToWake;
 680:../3rdParty/FreeRTOS/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 5003              		.loc 1 680 0
 5004 02b4 4FF00003 		mov	r3, #0
 5005 02b8 FB60     		str	r3, [r7, #12]
 681:../3rdParty/FreeRTOS/tasks.c **** 
 682:../3rdParty/FreeRTOS/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 683:../3rdParty/FreeRTOS/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 5006              		.loc 1 683 0
 5007 02ba 7B68     		ldr	r3, [r7, #4]
 5008 02bc 002B     		cmp	r3, #0
 5009 02be 13D0     		beq	.L29
 684:../3rdParty/FreeRTOS/tasks.c **** 		{
 685:../3rdParty/FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 5010              		.loc 1 685 0
 5011 02c0 FFF7FEFF 		bl	vTaskSuspendAll
 686:../3rdParty/FreeRTOS/tasks.c **** 			{
 687:../3rdParty/FreeRTOS/tasks.c **** 				traceTASK_DELAY();
 688:../3rdParty/FreeRTOS/tasks.c **** 
 689:../3rdParty/FreeRTOS/tasks.c **** 				/* A task that is removed from the event list while the
 690:../3rdParty/FreeRTOS/tasks.c **** 				scheduler is suspended will not get placed in the ready
 691:../3rdParty/FreeRTOS/tasks.c **** 				list or removed from the blocked list until the scheduler
 692:../3rdParty/FreeRTOS/tasks.c **** 				is resumed.
 693:../3rdParty/FreeRTOS/tasks.c **** 
 694:../3rdParty/FreeRTOS/tasks.c **** 				This task cannot be in an event list as it is the currently
 695:../3rdParty/FreeRTOS/tasks.c **** 				executing task. */
 696:../3rdParty/FreeRTOS/tasks.c **** 
 697:../3rdParty/FreeRTOS/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 698:../3rdParty/FreeRTOS/tasks.c **** 				not a problem. */
 699:../3rdParty/FreeRTOS/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 5012              		.loc 1 699 0
 5013 02c4 0D4B     		ldr	r3, .L31
 5014 02c6 1A68     		ldr	r2, [r3, #0]
 5015 02c8 7B68     		ldr	r3, [r7, #4]
 5016 02ca D318     		adds	r3, r2, r3
 5017 02cc BB60     		str	r3, [r7, #8]
 700:../3rdParty/FreeRTOS/tasks.c **** 
 701:../3rdParty/FreeRTOS/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 702:../3rdParty/FreeRTOS/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 703:../3rdParty/FreeRTOS/tasks.c **** 				both lists. */
 704:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 5018              		.loc 1 704 0
 5019 02ce 0C4B     		ldr	r3, .L31+4
 5020 02d0 1B68     		ldr	r3, [r3, #0]
 5021 02d2 03F10403 		add	r3, r3, #4
 5022 02d6 1846     		mov	r0, r3
 5023 02d8 FFF7FEFF 		bl	vListRemove
 705:../3rdParty/FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 5024              		.loc 1 705 0
 5025 02dc B868     		ldr	r0, [r7, #8]
 5026 02de 00F021FF 		bl	prvAddCurrentTaskToDelayedList
 706:../3rdParty/FreeRTOS/tasks.c **** 			}
 707:../3rdParty/FreeRTOS/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 5027              		.loc 1 707 0
 5028 02e2 FFF7FEFF 		bl	xTaskResumeAll
 5029 02e6 F860     		str	r0, [r7, #12]
 5030              	.L29:
 708:../3rdParty/FreeRTOS/tasks.c **** 		}
 709:../3rdParty/FreeRTOS/tasks.c **** 
 710:../3rdParty/FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 711:../3rdParty/FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
 712:../3rdParty/FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 5031              		.loc 1 712 0
 5032 02e8 FB68     		ldr	r3, [r7, #12]
 5033 02ea 002B     		cmp	r3, #0
 5034 02ec 01D1     		bne	.L28
 713:../3rdParty/FreeRTOS/tasks.c **** 		{
 714:../3rdParty/FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
 5035              		.loc 1 714 0
 5036 02ee FFF7FEFF 		bl	vPortYieldFromISR
 5037              	.L28:
 715:../3rdParty/FreeRTOS/tasks.c **** 		}
 716:../3rdParty/FreeRTOS/tasks.c **** 	}
 5038              		.loc 1 716 0
 5039 02f2 07F11007 		add	r7, r7, #16
 5040 02f6 BD46     		mov	sp, r7
 5041 02f8 80BD     		pop	{r7, pc}
 5042              	.L32:
 5043 02fa 00BF     		.align	2
 5044              	.L31:
 5045 02fc DC000000 		.word	xTickCount
 5046 0300 00000000 		.word	pxCurrentTCB
 5047              		.cfi_endproc
 5048              	.LFE32:
 5050              		.align	2
 5051              		.global	uxTaskPriorityGet
 5052              		.thumb
 5053              		.thumb_func
 5055              	uxTaskPriorityGet:
 5056              	.LFB33:
 717:../3rdParty/FreeRTOS/tasks.c **** 
 718:../3rdParty/FreeRTOS/tasks.c **** #endif
 719:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 720:../3rdParty/FreeRTOS/tasks.c **** 
 721:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 722:../3rdParty/FreeRTOS/tasks.c **** 
 723:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 724:../3rdParty/FreeRTOS/tasks.c **** 	{
 5057              		.loc 1 724 0
 5058              		.cfi_startproc
 5059              		@ args = 0, pretend = 0, frame = 16
 5060              		@ frame_needed = 1, uses_anonymous_args = 0
 5061 0304 80B5     		push	{r7, lr}
 5062              	.LCFI12:
 5063              		.cfi_def_cfa_offset 8
 5064 0306 84B0     		sub	sp, sp, #16
 5065              	.LCFI13:
 5066              		.cfi_def_cfa_offset 24
 5067 0308 00AF     		add	r7, sp, #0
 5068              		.cfi_offset 14, -4
 5069              		.cfi_offset 7, -8
 5070              	.LCFI14:
 5071              		.cfi_def_cfa_register 7
 5072 030a 7860     		str	r0, [r7, #4]
 725:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 726:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 727:../3rdParty/FreeRTOS/tasks.c **** 
 728:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 5073              		.loc 1 728 0
 5074 030c FFF7FEFF 		bl	vPortEnterCritical
 729:../3rdParty/FreeRTOS/tasks.c **** 		{
 730:../3rdParty/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are changing the
 731:../3rdParty/FreeRTOS/tasks.c **** 			priority of the calling function. */
 732:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 5075              		.loc 1 732 0
 5076 0310 7B68     		ldr	r3, [r7, #4]
 5077 0312 002B     		cmp	r3, #0
 5078 0314 02D1     		bne	.L34
 5079              		.loc 1 732 0 is_stmt 0 discriminator 1
 5080 0316 084B     		ldr	r3, .L36
 5081 0318 1B68     		ldr	r3, [r3, #0]
 5082 031a 00E0     		b	.L35
 5083              	.L34:
 5084              		.loc 1 732 0 discriminator 2
 5085 031c 7B68     		ldr	r3, [r7, #4]
 5086              	.L35:
 5087              		.loc 1 732 0 discriminator 3
 5088 031e FB60     		str	r3, [r7, #12]
 733:../3rdParty/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 5089              		.loc 1 733 0 is_stmt 1 discriminator 3
 5090 0320 FB68     		ldr	r3, [r7, #12]
 5091 0322 DB6A     		ldr	r3, [r3, #44]
 5092 0324 BB60     		str	r3, [r7, #8]
 734:../3rdParty/FreeRTOS/tasks.c **** 		}
 735:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 5093              		.loc 1 735 0 discriminator 3
 5094 0326 FFF7FEFF 		bl	vPortExitCritical
 736:../3rdParty/FreeRTOS/tasks.c **** 
 737:../3rdParty/FreeRTOS/tasks.c **** 		return uxReturn;
 5095              		.loc 1 737 0 discriminator 3
 5096 032a BB68     		ldr	r3, [r7, #8]
 738:../3rdParty/FreeRTOS/tasks.c **** 	}
 5097              		.loc 1 738 0 discriminator 3
 5098 032c 1846     		mov	r0, r3
 5099 032e 07F11007 		add	r7, r7, #16
 5100 0332 BD46     		mov	sp, r7
 5101 0334 80BD     		pop	{r7, pc}
 5102              	.L37:
 5103 0336 00BF     		.align	2
 5104              	.L36:
 5105 0338 00000000 		.word	pxCurrentTCB
 5106              		.cfi_endproc
 5107              	.LFE33:
 5109              		.align	2
 5110              		.global	vTaskPrioritySet
 5111              		.thumb
 5112              		.thumb_func
 5114              	vTaskPrioritySet:
 5115              	.LFB34:
 739:../3rdParty/FreeRTOS/tasks.c **** 
 740:../3rdParty/FreeRTOS/tasks.c **** #endif
 741:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 742:../3rdParty/FreeRTOS/tasks.c **** 
 743:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 744:../3rdParty/FreeRTOS/tasks.c **** 
 745:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 746:../3rdParty/FreeRTOS/tasks.c **** 	{
 5116              		.loc 1 746 0
 5117              		.cfi_startproc
 5118              		@ args = 0, pretend = 0, frame = 24
 5119              		@ frame_needed = 1, uses_anonymous_args = 0
 5120 033c 80B5     		push	{r7, lr}
 5121              	.LCFI15:
 5122              		.cfi_def_cfa_offset 8
 5123 033e 86B0     		sub	sp, sp, #24
 5124              	.LCFI16:
 5125              		.cfi_def_cfa_offset 32
 5126 0340 00AF     		add	r7, sp, #0
 5127              		.cfi_offset 14, -4
 5128              		.cfi_offset 7, -8
 5129              	.LCFI17:
 5130              		.cfi_def_cfa_register 7
 5131 0342 7860     		str	r0, [r7, #4]
 5132 0344 3960     		str	r1, [r7, #0]
 747:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 748:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority;
 749:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 5133              		.loc 1 749 0
 5134 0346 4FF00003 		mov	r3, #0
 5135 034a 7B61     		str	r3, [r7, #20]
 750:../3rdParty/FreeRTOS/tasks.c **** 
 751:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 752:../3rdParty/FreeRTOS/tasks.c **** 
 753:../3rdParty/FreeRTOS/tasks.c **** 		/* Ensure the new priority is valid. */
 754:../3rdParty/FreeRTOS/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 5136              		.loc 1 754 0
 5137 034c 3B68     		ldr	r3, [r7, #0]
 5138 034e 042B     		cmp	r3, #4
 5139 0350 02D9     		bls	.L39
 755:../3rdParty/FreeRTOS/tasks.c **** 		{
 756:../3rdParty/FreeRTOS/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 5140              		.loc 1 756 0
 5141 0352 4FF00403 		mov	r3, #4
 5142 0356 3B60     		str	r3, [r7, #0]
 5143              	.L39:
 757:../3rdParty/FreeRTOS/tasks.c **** 		}
 758:../3rdParty/FreeRTOS/tasks.c **** 
 759:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 5144              		.loc 1 759 0
 5145 0358 FFF7FEFF 		bl	vPortEnterCritical
 760:../3rdParty/FreeRTOS/tasks.c **** 		{
 761:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTask == pxCurrentTCB )
 5146              		.loc 1 761 0
 5147 035c 394B     		ldr	r3, .L49
 5148 035e 1B68     		ldr	r3, [r3, #0]
 5149 0360 7A68     		ldr	r2, [r7, #4]
 5150 0362 9A42     		cmp	r2, r3
 5151 0364 02D1     		bne	.L40
 762:../3rdParty/FreeRTOS/tasks.c **** 			{
 763:../3rdParty/FreeRTOS/tasks.c **** 				pxTask = NULL;
 5152              		.loc 1 763 0
 5153 0366 4FF00003 		mov	r3, #0
 5154 036a 7B60     		str	r3, [r7, #4]
 5155              	.L40:
 764:../3rdParty/FreeRTOS/tasks.c **** 			}
 765:../3rdParty/FreeRTOS/tasks.c **** 
 766:../3rdParty/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are changing the
 767:../3rdParty/FreeRTOS/tasks.c **** 			priority of the calling function. */
 768:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 5156              		.loc 1 768 0
 5157 036c 7B68     		ldr	r3, [r7, #4]
 5158 036e 002B     		cmp	r3, #0
 5159 0370 02D1     		bne	.L41
 5160              		.loc 1 768 0 is_stmt 0 discriminator 1
 5161 0372 344B     		ldr	r3, .L49
 5162 0374 1B68     		ldr	r3, [r3, #0]
 5163 0376 00E0     		b	.L42
 5164              	.L41:
 5165              		.loc 1 768 0 discriminator 2
 5166 0378 7B68     		ldr	r3, [r7, #4]
 5167              	.L42:
 5168              		.loc 1 768 0 discriminator 3
 5169 037a 3B61     		str	r3, [r7, #16]
 769:../3rdParty/FreeRTOS/tasks.c **** 
 770:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 771:../3rdParty/FreeRTOS/tasks.c **** 
 772:../3rdParty/FreeRTOS/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 773:../3rdParty/FreeRTOS/tasks.c **** 			{
 774:../3rdParty/FreeRTOS/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 5170              		.loc 1 774 0 is_stmt 1 discriminator 3
 5171 037c 3B69     		ldr	r3, [r7, #16]
 5172 037e 9B6C     		ldr	r3, [r3, #72]
 5173 0380 FB60     		str	r3, [r7, #12]
 775:../3rdParty/FreeRTOS/tasks.c **** 			}
 776:../3rdParty/FreeRTOS/tasks.c **** 			#else
 777:../3rdParty/FreeRTOS/tasks.c **** 			{
 778:../3rdParty/FreeRTOS/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 779:../3rdParty/FreeRTOS/tasks.c **** 			}
 780:../3rdParty/FreeRTOS/tasks.c **** 			#endif
 781:../3rdParty/FreeRTOS/tasks.c **** 
 782:../3rdParty/FreeRTOS/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 5174              		.loc 1 782 0 discriminator 3
 5175 0382 FA68     		ldr	r2, [r7, #12]
 5176 0384 3B68     		ldr	r3, [r7, #0]
 5177 0386 9A42     		cmp	r2, r3
 5178 0388 56D0     		beq	.L43
 783:../3rdParty/FreeRTOS/tasks.c **** 			{
 784:../3rdParty/FreeRTOS/tasks.c **** 				/* The priority change may have readied a task of higher
 785:../3rdParty/FreeRTOS/tasks.c **** 				priority than the calling task. */
 786:../3rdParty/FreeRTOS/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 5179              		.loc 1 786 0
 5180 038a 3A68     		ldr	r2, [r7, #0]
 5181 038c FB68     		ldr	r3, [r7, #12]
 5182 038e 9A42     		cmp	r2, r3
 5183 0390 06D9     		bls	.L44
 787:../3rdParty/FreeRTOS/tasks.c **** 				{
 788:../3rdParty/FreeRTOS/tasks.c **** 					if( pxTask != NULL )
 5184              		.loc 1 788 0
 5185 0392 7B68     		ldr	r3, [r7, #4]
 5186 0394 002B     		cmp	r3, #0
 5187 0396 09D0     		beq	.L45
 789:../3rdParty/FreeRTOS/tasks.c **** 					{
 790:../3rdParty/FreeRTOS/tasks.c **** 						/* The priority of another task is being raised.  If we
 791:../3rdParty/FreeRTOS/tasks.c **** 						were raising the priority of the currently running task
 792:../3rdParty/FreeRTOS/tasks.c **** 						there would be no need to switch as it must have already
 793:../3rdParty/FreeRTOS/tasks.c **** 						been the highest priority task. */
 794:../3rdParty/FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 5188              		.loc 1 794 0
 5189 0398 4FF00103 		mov	r3, #1
 5190 039c 7B61     		str	r3, [r7, #20]
 5191 039e 05E0     		b	.L45
 5192              	.L44:
 795:../3rdParty/FreeRTOS/tasks.c **** 					}
 796:../3rdParty/FreeRTOS/tasks.c **** 				}
 797:../3rdParty/FreeRTOS/tasks.c **** 				else if( pxTask == NULL )
 5193              		.loc 1 797 0
 5194 03a0 7B68     		ldr	r3, [r7, #4]
 5195 03a2 002B     		cmp	r3, #0
 5196 03a4 02D1     		bne	.L45
 798:../3rdParty/FreeRTOS/tasks.c **** 				{
 799:../3rdParty/FreeRTOS/tasks.c **** 					/* Setting our own priority down means there may now be another
 800:../3rdParty/FreeRTOS/tasks.c **** 					task of higher priority that is ready to execute. */
 801:../3rdParty/FreeRTOS/tasks.c **** 					xYieldRequired = pdTRUE;
 5197              		.loc 1 801 0
 5198 03a6 4FF00103 		mov	r3, #1
 5199 03aa 7B61     		str	r3, [r7, #20]
 5200              	.L45:
 802:../3rdParty/FreeRTOS/tasks.c **** 				}
 803:../3rdParty/FreeRTOS/tasks.c **** 
 804:../3rdParty/FreeRTOS/tasks.c **** 
 805:../3rdParty/FreeRTOS/tasks.c **** 
 806:../3rdParty/FreeRTOS/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 807:../3rdParty/FreeRTOS/tasks.c **** 				{
 808:../3rdParty/FreeRTOS/tasks.c **** 					/* Only change the priority being used if the task is not
 809:../3rdParty/FreeRTOS/tasks.c **** 					currently using an inherited priority. */
 810:../3rdParty/FreeRTOS/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 5201              		.loc 1 810 0
 5202 03ac 3B69     		ldr	r3, [r7, #16]
 5203 03ae 9A6C     		ldr	r2, [r3, #72]
 5204 03b0 3B69     		ldr	r3, [r7, #16]
 5205 03b2 DB6A     		ldr	r3, [r3, #44]
 5206 03b4 9A42     		cmp	r2, r3
 5207 03b6 02D1     		bne	.L46
 811:../3rdParty/FreeRTOS/tasks.c **** 					{
 812:../3rdParty/FreeRTOS/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 5208              		.loc 1 812 0
 5209 03b8 3B69     		ldr	r3, [r7, #16]
 5210 03ba 3A68     		ldr	r2, [r7, #0]
 5211 03bc DA62     		str	r2, [r3, #44]
 5212              	.L46:
 813:../3rdParty/FreeRTOS/tasks.c **** 					}
 814:../3rdParty/FreeRTOS/tasks.c **** 
 815:../3rdParty/FreeRTOS/tasks.c **** 					/* The base priority gets set whatever. */
 816:../3rdParty/FreeRTOS/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 5213              		.loc 1 816 0
 5214 03be 3B69     		ldr	r3, [r7, #16]
 5215 03c0 3A68     		ldr	r2, [r7, #0]
 5216 03c2 9A64     		str	r2, [r3, #72]
 817:../3rdParty/FreeRTOS/tasks.c **** 				}
 818:../3rdParty/FreeRTOS/tasks.c **** 				#else
 819:../3rdParty/FreeRTOS/tasks.c **** 				{
 820:../3rdParty/FreeRTOS/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 821:../3rdParty/FreeRTOS/tasks.c **** 				}
 822:../3rdParty/FreeRTOS/tasks.c **** 				#endif
 823:../3rdParty/FreeRTOS/tasks.c **** 
 824:../3rdParty/FreeRTOS/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 5217              		.loc 1 824 0
 5218 03c4 3B68     		ldr	r3, [r7, #0]
 5219 03c6 C3F10502 		rsb	r2, r3, #5
 5220 03ca 3B69     		ldr	r3, [r7, #16]
 5221 03cc 9A61     		str	r2, [r3, #24]
 825:../3rdParty/FreeRTOS/tasks.c **** 
 826:../3rdParty/FreeRTOS/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 827:../3rdParty/FreeRTOS/tasks.c **** 				nothing more than change it's priority variable. However, if
 828:../3rdParty/FreeRTOS/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 829:../3rdParty/FreeRTOS/tasks.c **** 				in the queue appropriate to its new priority. */
 830:../3rdParty/FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 5222              		.loc 1 830 0
 5223 03ce 3B69     		ldr	r3, [r7, #16]
 5224 03d0 5969     		ldr	r1, [r3, #20]
 5225 03d2 FA68     		ldr	r2, [r7, #12]
 5226 03d4 1346     		mov	r3, r2
 5227 03d6 4FEA8303 		lsl	r3, r3, #2
 5228 03da 9B18     		adds	r3, r3, r2
 5229 03dc 4FEA8303 		lsl	r3, r3, #2
 5230 03e0 1A46     		mov	r2, r3
 5231 03e2 194B     		ldr	r3, .L49+4
 5232 03e4 D318     		adds	r3, r2, r3
 5233 03e6 9942     		cmp	r1, r3
 5234 03e8 21D1     		bne	.L47
 831:../3rdParty/FreeRTOS/tasks.c **** 				{
 832:../3rdParty/FreeRTOS/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 833:../3rdParty/FreeRTOS/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 834:../3rdParty/FreeRTOS/tasks.c **** 					can do this even if the scheduler is suspended. */
 835:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 5235              		.loc 1 835 0
 5236 03ea 3B69     		ldr	r3, [r7, #16]
 5237 03ec 03F10403 		add	r3, r3, #4
 5238 03f0 1846     		mov	r0, r3
 5239 03f2 FFF7FEFF 		bl	vListRemove
 836:../3rdParty/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 5240              		.loc 1 836 0
 5241 03f6 3B69     		ldr	r3, [r7, #16]
 5242 03f8 DA6A     		ldr	r2, [r3, #44]
 5243 03fa 144B     		ldr	r3, .L49+8
 5244 03fc 1B68     		ldr	r3, [r3, #0]
 5245 03fe 9A42     		cmp	r2, r3
 5246 0400 03D9     		bls	.L48
 5247              		.loc 1 836 0 is_stmt 0 discriminator 1
 5248 0402 3B69     		ldr	r3, [r7, #16]
 5249 0404 DA6A     		ldr	r2, [r3, #44]
 5250 0406 114B     		ldr	r3, .L49+8
 5251 0408 1A60     		str	r2, [r3, #0]
 5252              	.L48:
 5253              		.loc 1 836 0 discriminator 2
 5254 040a 3B69     		ldr	r3, [r7, #16]
 5255 040c DA6A     		ldr	r2, [r3, #44]
 5256 040e 1346     		mov	r3, r2
 5257 0410 4FEA8303 		lsl	r3, r3, #2
 5258 0414 9B18     		adds	r3, r3, r2
 5259 0416 4FEA8303 		lsl	r3, r3, #2
 5260 041a 1A46     		mov	r2, r3
 5261 041c 0A4B     		ldr	r3, .L49+4
 5262 041e D218     		adds	r2, r2, r3
 5263 0420 3B69     		ldr	r3, [r7, #16]
 5264 0422 03F10403 		add	r3, r3, #4
 5265 0426 1046     		mov	r0, r2
 5266 0428 1946     		mov	r1, r3
 5267 042a FFF7FEFF 		bl	vListInsertEnd
 5268              	.L47:
 837:../3rdParty/FreeRTOS/tasks.c **** 				}
 838:../3rdParty/FreeRTOS/tasks.c **** 
 839:../3rdParty/FreeRTOS/tasks.c **** 				if( xYieldRequired == pdTRUE )
 5269              		.loc 1 839 0 is_stmt 1
 5270 042e 7B69     		ldr	r3, [r7, #20]
 5271 0430 012B     		cmp	r3, #1
 5272 0432 01D1     		bne	.L43
 840:../3rdParty/FreeRTOS/tasks.c **** 				{
 841:../3rdParty/FreeRTOS/tasks.c **** 					portYIELD_WITHIN_API();
 5273              		.loc 1 841 0
 5274 0434 FFF7FEFF 		bl	vPortYieldFromISR
 5275              	.L43:
 842:../3rdParty/FreeRTOS/tasks.c **** 				}
 843:../3rdParty/FreeRTOS/tasks.c **** 			}
 844:../3rdParty/FreeRTOS/tasks.c **** 		}
 845:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 5276              		.loc 1 845 0
 5277 0438 FFF7FEFF 		bl	vPortExitCritical
 846:../3rdParty/FreeRTOS/tasks.c **** 	}
 5278              		.loc 1 846 0
 5279 043c 07F11807 		add	r7, r7, #24
 5280 0440 BD46     		mov	sp, r7
 5281 0442 80BD     		pop	{r7, pc}
 5282              	.L50:
 5283              		.align	2
 5284              	.L49:
 5285 0444 00000000 		.word	pxCurrentTCB
 5286 0448 04000000 		.word	pxReadyTasksLists
 5287 044c E4000000 		.word	uxTopReadyPriority
 5288              		.cfi_endproc
 5289              	.LFE34:
 5291              		.align	2
 5292              		.global	vTaskSuspend
 5293              		.thumb
 5294              		.thumb_func
 5296              	vTaskSuspend:
 5297              	.LFB35:
 847:../3rdParty/FreeRTOS/tasks.c **** 
 848:../3rdParty/FreeRTOS/tasks.c **** #endif
 849:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 850:../3rdParty/FreeRTOS/tasks.c **** 
 851:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 852:../3rdParty/FreeRTOS/tasks.c **** 
 853:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 854:../3rdParty/FreeRTOS/tasks.c **** 	{
 5298              		.loc 1 854 0
 5299              		.cfi_startproc
 5300              		@ args = 0, pretend = 0, frame = 16
 5301              		@ frame_needed = 1, uses_anonymous_args = 0
 5302 0450 80B5     		push	{r7, lr}
 5303              	.LCFI18:
 5304              		.cfi_def_cfa_offset 8
 5305 0452 84B0     		sub	sp, sp, #16
 5306              	.LCFI19:
 5307              		.cfi_def_cfa_offset 24
 5308 0454 00AF     		add	r7, sp, #0
 5309              		.cfi_offset 14, -4
 5310              		.cfi_offset 7, -8
 5311              	.LCFI20:
 5312              		.cfi_def_cfa_register 7
 5313 0456 7860     		str	r0, [r7, #4]
 855:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 856:../3rdParty/FreeRTOS/tasks.c **** 
 857:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 5314              		.loc 1 857 0
 5315 0458 FFF7FEFF 		bl	vPortEnterCritical
 858:../3rdParty/FreeRTOS/tasks.c **** 		{
 859:../3rdParty/FreeRTOS/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 860:../3rdParty/FreeRTOS/tasks.c **** 			suspended. */
 861:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 5316              		.loc 1 861 0
 5317 045c 214B     		ldr	r3, .L59
 5318 045e 1B68     		ldr	r3, [r3, #0]
 5319 0460 7A68     		ldr	r2, [r7, #4]
 5320 0462 9A42     		cmp	r2, r3
 5321 0464 02D1     		bne	.L52
 862:../3rdParty/FreeRTOS/tasks.c **** 			{
 863:../3rdParty/FreeRTOS/tasks.c **** 				pxTaskToSuspend = NULL;
 5322              		.loc 1 863 0
 5323 0466 4FF00003 		mov	r3, #0
 5324 046a 7B60     		str	r3, [r7, #4]
 5325              	.L52:
 864:../3rdParty/FreeRTOS/tasks.c **** 			}
 865:../3rdParty/FreeRTOS/tasks.c **** 
 866:../3rdParty/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 867:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 5326              		.loc 1 867 0
 5327 046c 7B68     		ldr	r3, [r7, #4]
 5328 046e 002B     		cmp	r3, #0
 5329 0470 02D1     		bne	.L53
 5330              		.loc 1 867 0 is_stmt 0 discriminator 1
 5331 0472 1C4B     		ldr	r3, .L59
 5332 0474 1B68     		ldr	r3, [r3, #0]
 5333 0476 00E0     		b	.L54
 5334              	.L53:
 5335              		.loc 1 867 0 discriminator 2
 5336 0478 7B68     		ldr	r3, [r7, #4]
 5337              	.L54:
 5338              		.loc 1 867 0 discriminator 3
 5339 047a FB60     		str	r3, [r7, #12]
 868:../3rdParty/FreeRTOS/tasks.c **** 
 869:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 870:../3rdParty/FreeRTOS/tasks.c **** 
 871:../3rdParty/FreeRTOS/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 872:../3rdParty/FreeRTOS/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 5340              		.loc 1 872 0 is_stmt 1 discriminator 3
 5341 047c FB68     		ldr	r3, [r7, #12]
 5342 047e 03F10403 		add	r3, r3, #4
 5343 0482 1846     		mov	r0, r3
 5344 0484 FFF7FEFF 		bl	vListRemove
 873:../3rdParty/FreeRTOS/tasks.c **** 
 874:../3rdParty/FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
 875:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 5345              		.loc 1 875 0 discriminator 3
 5346 0488 FB68     		ldr	r3, [r7, #12]
 5347 048a 9B6A     		ldr	r3, [r3, #40]
 5348 048c 002B     		cmp	r3, #0
 5349 048e 05D0     		beq	.L55
 876:../3rdParty/FreeRTOS/tasks.c **** 			{
 877:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 5350              		.loc 1 877 0
 5351 0490 FB68     		ldr	r3, [r7, #12]
 5352 0492 03F11803 		add	r3, r3, #24
 5353 0496 1846     		mov	r0, r3
 5354 0498 FFF7FEFF 		bl	vListRemove
 5355              	.L55:
 878:../3rdParty/FreeRTOS/tasks.c **** 			}
 879:../3rdParty/FreeRTOS/tasks.c **** 
 880:../3rdParty/FreeRTOS/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 5356              		.loc 1 880 0
 5357 049c FB68     		ldr	r3, [r7, #12]
 5358 049e 03F10403 		add	r3, r3, #4
 5359 04a2 1148     		ldr	r0, .L59+4
 5360 04a4 1946     		mov	r1, r3
 5361 04a6 FFF7FEFF 		bl	vListInsertEnd
 881:../3rdParty/FreeRTOS/tasks.c **** 		}
 882:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 5362              		.loc 1 882 0
 5363 04aa FFF7FEFF 		bl	vPortExitCritical
 883:../3rdParty/FreeRTOS/tasks.c **** 
 884:../3rdParty/FreeRTOS/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 5364              		.loc 1 884 0
 5365 04ae 7B68     		ldr	r3, [r7, #4]
 5366 04b0 002B     		cmp	r3, #0
 5367 04b2 13D1     		bne	.L51
 885:../3rdParty/FreeRTOS/tasks.c **** 		{
 886:../3rdParty/FreeRTOS/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 5368              		.loc 1 886 0
 5369 04b4 0D4B     		ldr	r3, .L59+8
 5370 04b6 1B68     		ldr	r3, [r3, #0]
 5371 04b8 002B     		cmp	r3, #0
 5372 04ba 02D0     		beq	.L57
 887:../3rdParty/FreeRTOS/tasks.c **** 			{
 888:../3rdParty/FreeRTOS/tasks.c **** 				/* We have just suspended the current task. */
 889:../3rdParty/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 5373              		.loc 1 889 0
 5374 04bc FFF7FEFF 		bl	vPortYieldFromISR
 5375 04c0 0CE0     		b	.L51
 5376              	.L57:
 890:../3rdParty/FreeRTOS/tasks.c **** 			}
 891:../3rdParty/FreeRTOS/tasks.c **** 			else
 892:../3rdParty/FreeRTOS/tasks.c **** 			{
 893:../3rdParty/FreeRTOS/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 894:../3rdParty/FreeRTOS/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 895:../3rdParty/FreeRTOS/tasks.c **** 				must be adjusted to point to a different task. */
 896:../3rdParty/FreeRTOS/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 5377              		.loc 1 896 0
 5378 04c2 094B     		ldr	r3, .L59+4
 5379 04c4 1A68     		ldr	r2, [r3, #0]
 5380 04c6 0A4B     		ldr	r3, .L59+12
 5381 04c8 1B68     		ldr	r3, [r3, #0]
 5382 04ca 9A42     		cmp	r2, r3
 5383 04cc 04D1     		bne	.L58
 897:../3rdParty/FreeRTOS/tasks.c **** 				{
 898:../3rdParty/FreeRTOS/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
 899:../3rdParty/FreeRTOS/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 900:../3rdParty/FreeRTOS/tasks.c **** 					be set to point to it no matter what its relative priority
 901:../3rdParty/FreeRTOS/tasks.c **** 					is. */
 902:../3rdParty/FreeRTOS/tasks.c **** 					pxCurrentTCB = NULL;
 5384              		.loc 1 902 0
 5385 04ce 054B     		ldr	r3, .L59
 5386 04d0 4FF00002 		mov	r2, #0
 5387 04d4 1A60     		str	r2, [r3, #0]
 5388 04d6 01E0     		b	.L51
 5389              	.L58:
 903:../3rdParty/FreeRTOS/tasks.c **** 				}
 904:../3rdParty/FreeRTOS/tasks.c **** 				else
 905:../3rdParty/FreeRTOS/tasks.c **** 				{
 906:../3rdParty/FreeRTOS/tasks.c **** 					vTaskSwitchContext();
 5390              		.loc 1 906 0
 5391 04d8 FFF7FEFF 		bl	vTaskSwitchContext
 5392              	.L51:
 907:../3rdParty/FreeRTOS/tasks.c **** 				}
 908:../3rdParty/FreeRTOS/tasks.c **** 			}
 909:../3rdParty/FreeRTOS/tasks.c **** 		}
 910:../3rdParty/FreeRTOS/tasks.c **** 	}
 5393              		.loc 1 910 0
 5394 04dc 07F11007 		add	r7, r7, #16
 5395 04e0 BD46     		mov	sp, r7
 5396 04e2 80BD     		pop	{r7, pc}
 5397              	.L60:
 5398              		.align	2
 5399              	.L59:
 5400 04e4 00000000 		.word	pxCurrentTCB
 5401 04e8 C4000000 		.word	xSuspendedTaskList
 5402 04ec E8000000 		.word	xSchedulerRunning
 5403 04f0 D8000000 		.word	uxCurrentNumberOfTasks
 5404              		.cfi_endproc
 5405              	.LFE35:
 5407              		.align	2
 5408              		.global	xTaskIsTaskSuspended
 5409              		.thumb
 5410              		.thumb_func
 5412              	xTaskIsTaskSuspended:
 5413              	.LFB36:
 911:../3rdParty/FreeRTOS/tasks.c **** 
 912:../3rdParty/FreeRTOS/tasks.c **** #endif
 913:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 914:../3rdParty/FreeRTOS/tasks.c **** 
 915:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 916:../3rdParty/FreeRTOS/tasks.c **** 
 917:../3rdParty/FreeRTOS/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 918:../3rdParty/FreeRTOS/tasks.c **** 	{
 5414              		.loc 1 918 0
 5415              		.cfi_startproc
 5416              		@ args = 0, pretend = 0, frame = 16
 5417              		@ frame_needed = 1, uses_anonymous_args = 0
 5418              		@ link register save eliminated.
 5419 04f4 80B4     		push	{r7}
 5420              	.LCFI21:
 5421              		.cfi_def_cfa_offset 4
 5422 04f6 85B0     		sub	sp, sp, #20
 5423              	.LCFI22:
 5424              		.cfi_def_cfa_offset 24
 5425 04f8 00AF     		add	r7, sp, #0
 5426              		.cfi_offset 7, -4
 5427              	.LCFI23:
 5428              		.cfi_def_cfa_register 7
 5429 04fa 7860     		str	r0, [r7, #4]
 919:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 5430              		.loc 1 919 0
 5431 04fc 4FF00003 		mov	r3, #0
 5432 0500 FB60     		str	r3, [r7, #12]
 920:../3rdParty/FreeRTOS/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 5433              		.loc 1 920 0
 5434 0502 7B68     		ldr	r3, [r7, #4]
 5435 0504 BB60     		str	r3, [r7, #8]
 921:../3rdParty/FreeRTOS/tasks.c **** 
 922:../3rdParty/FreeRTOS/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
 923:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( xTask );
 924:../3rdParty/FreeRTOS/tasks.c **** 
 925:../3rdParty/FreeRTOS/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 926:../3rdParty/FreeRTOS/tasks.c **** 		suspended list? */
 927:../3rdParty/FreeRTOS/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 5436              		.loc 1 927 0
 5437 0506 BB68     		ldr	r3, [r7, #8]
 5438 0508 5A69     		ldr	r2, [r3, #20]
 5439 050a 0B4B     		ldr	r3, .L63
 5440 050c 9A42     		cmp	r2, r3
 5441 050e 0BD1     		bne	.L62
 928:../3rdParty/FreeRTOS/tasks.c **** 		{
 929:../3rdParty/FreeRTOS/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 930:../3rdParty/FreeRTOS/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 5442              		.loc 1 930 0
 5443 0510 BB68     		ldr	r3, [r7, #8]
 5444 0512 9A6A     		ldr	r2, [r3, #40]
 5445 0514 094B     		ldr	r3, .L63+4
 5446 0516 9A42     		cmp	r2, r3
 5447 0518 06D0     		beq	.L62
 931:../3rdParty/FreeRTOS/tasks.c **** 			{
 932:../3rdParty/FreeRTOS/tasks.c **** 				/* Is it in the suspended list because it is in the
 933:../3rdParty/FreeRTOS/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 934:../3rdParty/FreeRTOS/tasks.c **** 				list because it is blocked on a task with no timeout
 935:../3rdParty/FreeRTOS/tasks.c **** 				specified. */
 936:../3rdParty/FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 5448              		.loc 1 936 0
 5449 051a BB68     		ldr	r3, [r7, #8]
 5450 051c 9B6A     		ldr	r3, [r3, #40]
 5451 051e 002B     		cmp	r3, #0
 5452 0520 02D1     		bne	.L62
 937:../3rdParty/FreeRTOS/tasks.c **** 				{
 938:../3rdParty/FreeRTOS/tasks.c **** 					xReturn = pdTRUE;
 5453              		.loc 1 938 0
 5454 0522 4FF00103 		mov	r3, #1
 5455 0526 FB60     		str	r3, [r7, #12]
 5456              	.L62:
 939:../3rdParty/FreeRTOS/tasks.c **** 				}
 940:../3rdParty/FreeRTOS/tasks.c **** 			}
 941:../3rdParty/FreeRTOS/tasks.c **** 		}
 942:../3rdParty/FreeRTOS/tasks.c **** 
 943:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
 5457              		.loc 1 943 0
 5458 0528 FB68     		ldr	r3, [r7, #12]
 944:../3rdParty/FreeRTOS/tasks.c **** 	}
 5459              		.loc 1 944 0
 5460 052a 1846     		mov	r0, r3
 5461 052c 07F11407 		add	r7, r7, #20
 5462 0530 BD46     		mov	sp, r7
 5463 0532 80BC     		pop	{r7}
 5464 0534 7047     		bx	lr
 5465              	.L64:
 5466 0536 00BF     		.align	2
 5467              	.L63:
 5468 0538 C4000000 		.word	xSuspendedTaskList
 5469 053c 98000000 		.word	xPendingReadyList
 5470              		.cfi_endproc
 5471              	.LFE36:
 5473              		.align	2
 5474              		.global	vTaskResume
 5475              		.thumb
 5476              		.thumb_func
 5478              	vTaskResume:
 5479              	.LFB37:
 945:../3rdParty/FreeRTOS/tasks.c **** 
 946:../3rdParty/FreeRTOS/tasks.c **** #endif
 947:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 948:../3rdParty/FreeRTOS/tasks.c **** 
 949:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 950:../3rdParty/FreeRTOS/tasks.c **** 
 951:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 952:../3rdParty/FreeRTOS/tasks.c **** 	{
 5480              		.loc 1 952 0
 5481              		.cfi_startproc
 5482              		@ args = 0, pretend = 0, frame = 16
 5483              		@ frame_needed = 1, uses_anonymous_args = 0
 5484 0540 80B5     		push	{r7, lr}
 5485              	.LCFI24:
 5486              		.cfi_def_cfa_offset 8
 5487 0542 84B0     		sub	sp, sp, #16
 5488              	.LCFI25:
 5489              		.cfi_def_cfa_offset 24
 5490 0544 00AF     		add	r7, sp, #0
 5491              		.cfi_offset 14, -4
 5492              		.cfi_offset 7, -8
 5493              	.LCFI26:
 5494              		.cfi_def_cfa_register 7
 5495 0546 7860     		str	r0, [r7, #4]
 953:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 954:../3rdParty/FreeRTOS/tasks.c **** 
 955:../3rdParty/FreeRTOS/tasks.c **** 		/* It does not make sense to resume the calling task. */
 956:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxTaskToResume );
 957:../3rdParty/FreeRTOS/tasks.c **** 
 958:../3rdParty/FreeRTOS/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
 959:../3rdParty/FreeRTOS/tasks.c **** 		it in the ready list. */
 960:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 5496              		.loc 1 960 0
 5497 0548 7B68     		ldr	r3, [r7, #4]
 5498 054a FB60     		str	r3, [r7, #12]
 961:../3rdParty/FreeRTOS/tasks.c **** 
 962:../3rdParty/FreeRTOS/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
 963:../3rdParty/FreeRTOS/tasks.c **** 		currently executing task. */
 964:../3rdParty/FreeRTOS/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 5499              		.loc 1 964 0
 5500 054c FB68     		ldr	r3, [r7, #12]
 5501 054e 002B     		cmp	r3, #0
 5502 0550 39D0     		beq	.L65
 5503              		.loc 1 964 0 is_stmt 0 discriminator 1
 5504 0552 1F4B     		ldr	r3, .L69
 5505 0554 1B68     		ldr	r3, [r3, #0]
 5506 0556 FA68     		ldr	r2, [r7, #12]
 5507 0558 9A42     		cmp	r2, r3
 5508 055a 34D0     		beq	.L65
 965:../3rdParty/FreeRTOS/tasks.c **** 		{
 966:../3rdParty/FreeRTOS/tasks.c **** 			taskENTER_CRITICAL();
 5509              		.loc 1 966 0 is_stmt 1
 5510 055c FFF7FEFF 		bl	vPortEnterCritical
 967:../3rdParty/FreeRTOS/tasks.c **** 			{
 968:../3rdParty/FreeRTOS/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 5511              		.loc 1 968 0
 5512 0560 F868     		ldr	r0, [r7, #12]
 5513 0562 FFF7FEFF 		bl	xTaskIsTaskSuspended
 5514 0566 0346     		mov	r3, r0
 5515 0568 012B     		cmp	r3, #1
 5516 056a 2AD1     		bne	.L67
 969:../3rdParty/FreeRTOS/tasks.c **** 				{
 970:../3rdParty/FreeRTOS/tasks.c **** 					traceTASK_RESUME( pxTCB );
 971:../3rdParty/FreeRTOS/tasks.c **** 
 972:../3rdParty/FreeRTOS/tasks.c **** 					/* As we are in a critical section we can access the ready
 973:../3rdParty/FreeRTOS/tasks.c **** 					lists even if the scheduler is suspended. */
 974:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 5517              		.loc 1 974 0
 5518 056c FB68     		ldr	r3, [r7, #12]
 5519 056e 03F10403 		add	r3, r3, #4
 5520 0572 1846     		mov	r0, r3
 5521 0574 FFF7FEFF 		bl	vListRemove
 975:../3rdParty/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 5522              		.loc 1 975 0
 5523 0578 FB68     		ldr	r3, [r7, #12]
 5524 057a DA6A     		ldr	r2, [r3, #44]
 5525 057c 154B     		ldr	r3, .L69+4
 5526 057e 1B68     		ldr	r3, [r3, #0]
 5527 0580 9A42     		cmp	r2, r3
 5528 0582 03D9     		bls	.L68
 5529              		.loc 1 975 0 is_stmt 0 discriminator 1
 5530 0584 FB68     		ldr	r3, [r7, #12]
 5531 0586 DA6A     		ldr	r2, [r3, #44]
 5532 0588 124B     		ldr	r3, .L69+4
 5533 058a 1A60     		str	r2, [r3, #0]
 5534              	.L68:
 5535              		.loc 1 975 0 discriminator 2
 5536 058c FB68     		ldr	r3, [r7, #12]
 5537 058e DA6A     		ldr	r2, [r3, #44]
 5538 0590 1346     		mov	r3, r2
 5539 0592 4FEA8303 		lsl	r3, r3, #2
 5540 0596 9B18     		adds	r3, r3, r2
 5541 0598 4FEA8303 		lsl	r3, r3, #2
 5542 059c 1A46     		mov	r2, r3
 5543 059e 0E4B     		ldr	r3, .L69+8
 5544 05a0 D218     		adds	r2, r2, r3
 5545 05a2 FB68     		ldr	r3, [r7, #12]
 5546 05a4 03F10403 		add	r3, r3, #4
 5547 05a8 1046     		mov	r0, r2
 5548 05aa 1946     		mov	r1, r3
 5549 05ac FFF7FEFF 		bl	vListInsertEnd
 976:../3rdParty/FreeRTOS/tasks.c **** 
 977:../3rdParty/FreeRTOS/tasks.c **** 					/* We may have just resumed a higher priority task. */
 978:../3rdParty/FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 5550              		.loc 1 978 0 is_stmt 1 discriminator 2
 5551 05b0 FB68     		ldr	r3, [r7, #12]
 5552 05b2 DA6A     		ldr	r2, [r3, #44]
 5553 05b4 064B     		ldr	r3, .L69
 5554 05b6 1B68     		ldr	r3, [r3, #0]
 5555 05b8 DB6A     		ldr	r3, [r3, #44]
 5556 05ba 9A42     		cmp	r2, r3
 5557 05bc 01D3     		bcc	.L67
 979:../3rdParty/FreeRTOS/tasks.c **** 					{
 980:../3rdParty/FreeRTOS/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
 981:../3rdParty/FreeRTOS/tasks.c **** 						will leave the lists in the correct state for the next yield. */
 982:../3rdParty/FreeRTOS/tasks.c **** 						portYIELD_WITHIN_API();
 5558              		.loc 1 982 0
 5559 05be FFF7FEFF 		bl	vPortYieldFromISR
 5560              	.L67:
 983:../3rdParty/FreeRTOS/tasks.c **** 					}
 984:../3rdParty/FreeRTOS/tasks.c **** 				}
 985:../3rdParty/FreeRTOS/tasks.c **** 			}
 986:../3rdParty/FreeRTOS/tasks.c **** 			taskEXIT_CRITICAL();
 5561              		.loc 1 986 0
 5562 05c2 FFF7FEFF 		bl	vPortExitCritical
 5563              	.L65:
 987:../3rdParty/FreeRTOS/tasks.c **** 		}
 988:../3rdParty/FreeRTOS/tasks.c **** 	}
 5564              		.loc 1 988 0
 5565 05c6 07F11007 		add	r7, r7, #16
 5566 05ca BD46     		mov	sp, r7
 5567 05cc 80BD     		pop	{r7, pc}
 5568              	.L70:
 5569 05ce 00BF     		.align	2
 5570              	.L69:
 5571 05d0 00000000 		.word	pxCurrentTCB
 5572 05d4 E4000000 		.word	uxTopReadyPriority
 5573 05d8 04000000 		.word	pxReadyTasksLists
 5574              		.cfi_endproc
 5575              	.LFE37:
 5577              		.align	2
 5578              		.global	xTaskResumeFromISR
 5579              		.thumb
 5580              		.thumb_func
 5582              	xTaskResumeFromISR:
 5583              	.LFB38:
 989:../3rdParty/FreeRTOS/tasks.c **** 
 990:../3rdParty/FreeRTOS/tasks.c **** #endif
 991:../3rdParty/FreeRTOS/tasks.c **** 
 992:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 993:../3rdParty/FreeRTOS/tasks.c **** 
 994:../3rdParty/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
 995:../3rdParty/FreeRTOS/tasks.c **** 
 996:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
 997:../3rdParty/FreeRTOS/tasks.c **** 	{
 5584              		.loc 1 997 0
 5585              		.cfi_startproc
 5586              		@ args = 0, pretend = 0, frame = 24
 5587              		@ frame_needed = 1, uses_anonymous_args = 0
 5588 05dc 80B5     		push	{r7, lr}
 5589              	.LCFI27:
 5590              		.cfi_def_cfa_offset 8
 5591 05de 86B0     		sub	sp, sp, #24
 5592              	.LCFI28:
 5593              		.cfi_def_cfa_offset 32
 5594 05e0 00AF     		add	r7, sp, #0
 5595              		.cfi_offset 14, -4
 5596              		.cfi_offset 7, -8
 5597              	.LCFI29:
 5598              		.cfi_def_cfa_register 7
 5599 05e2 7860     		str	r0, [r7, #4]
 998:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 5600              		.loc 1 998 0
 5601 05e4 4FF00003 		mov	r3, #0
 5602 05e8 7B61     		str	r3, [r7, #20]
 999:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1000:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1001:../3rdParty/FreeRTOS/tasks.c **** 
1002:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxTaskToResume );
1003:../3rdParty/FreeRTOS/tasks.c **** 
1004:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 5603              		.loc 1 1004 0
 5604 05ea 7B68     		ldr	r3, [r7, #4]
 5605 05ec 3B61     		str	r3, [r7, #16]
1005:../3rdParty/FreeRTOS/tasks.c **** 
1006:../3rdParty/FreeRTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 5606              		.loc 1 1006 0
 5607 05ee 4FF00003 		mov	r3, #0
 5608 05f2 FB60     		str	r3, [r7, #12]
 5609              	@ 1006 "../3rdParty/FreeRTOS/tasks.c" 1
 5610 05f4 4FF02800 			mov r0, #40								
 5611 05f8 80F31188 		msr basepri, r0							
 5612              	
 5613              	@ 0 "" 2
1007:../3rdParty/FreeRTOS/tasks.c **** 		{
1008:../3rdParty/FreeRTOS/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 5614              		.loc 1 1008 0
 5615              		.thumb
 5616 05fc 3869     		ldr	r0, [r7, #16]
 5617 05fe FFF7FEFF 		bl	xTaskIsTaskSuspended
 5618 0602 0346     		mov	r3, r0
 5619 0604 012B     		cmp	r3, #1
 5620 0606 37D1     		bne	.L72
1009:../3rdParty/FreeRTOS/tasks.c **** 			{
1010:../3rdParty/FreeRTOS/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1011:../3rdParty/FreeRTOS/tasks.c **** 
1012:../3rdParty/FreeRTOS/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 5621              		.loc 1 1012 0
 5622 0608 204B     		ldr	r3, .L75
 5623 060a 1B68     		ldr	r3, [r3, #0]
 5624 060c 002B     		cmp	r3, #0
 5625 060e 2CD1     		bne	.L73
1013:../3rdParty/FreeRTOS/tasks.c **** 				{
1014:../3rdParty/FreeRTOS/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 5626              		.loc 1 1014 0
 5627 0610 3B69     		ldr	r3, [r7, #16]
 5628 0612 DA6A     		ldr	r2, [r3, #44]
 5629 0614 1E4B     		ldr	r3, .L75+4
 5630 0616 1B68     		ldr	r3, [r3, #0]
 5631 0618 DB6A     		ldr	r3, [r3, #44]
 5632 061a 9A42     		cmp	r2, r3
 5633 061c 34BF     		ite	cc
 5634 061e 0023     		movcc	r3, #0
 5635 0620 0123     		movcs	r3, #1
 5636 0622 7B61     		str	r3, [r7, #20]
1015:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 5637              		.loc 1 1015 0
 5638 0624 3B69     		ldr	r3, [r7, #16]
 5639 0626 03F10403 		add	r3, r3, #4
 5640 062a 1846     		mov	r0, r3
 5641 062c FFF7FEFF 		bl	vListRemove
1016:../3rdParty/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 5642              		.loc 1 1016 0
 5643 0630 3B69     		ldr	r3, [r7, #16]
 5644 0632 DA6A     		ldr	r2, [r3, #44]
 5645 0634 174B     		ldr	r3, .L75+8
 5646 0636 1B68     		ldr	r3, [r3, #0]
 5647 0638 9A42     		cmp	r2, r3
 5648 063a 03D9     		bls	.L74
 5649              		.loc 1 1016 0 is_stmt 0 discriminator 1
 5650 063c 3B69     		ldr	r3, [r7, #16]
 5651 063e DA6A     		ldr	r2, [r3, #44]
 5652 0640 144B     		ldr	r3, .L75+8
 5653 0642 1A60     		str	r2, [r3, #0]
 5654              	.L74:
 5655              		.loc 1 1016 0 discriminator 2
 5656 0644 3B69     		ldr	r3, [r7, #16]
 5657 0646 DA6A     		ldr	r2, [r3, #44]
 5658 0648 1346     		mov	r3, r2
 5659 064a 4FEA8303 		lsl	r3, r3, #2
 5660 064e 9B18     		adds	r3, r3, r2
 5661 0650 4FEA8303 		lsl	r3, r3, #2
 5662 0654 1A46     		mov	r2, r3
 5663 0656 104B     		ldr	r3, .L75+12
 5664 0658 D218     		adds	r2, r2, r3
 5665 065a 3B69     		ldr	r3, [r7, #16]
 5666 065c 03F10403 		add	r3, r3, #4
 5667 0660 1046     		mov	r0, r2
 5668 0662 1946     		mov	r1, r3
 5669 0664 FFF7FEFF 		bl	vListInsertEnd
 5670 0668 06E0     		b	.L72
 5671              	.L73:
1017:../3rdParty/FreeRTOS/tasks.c **** 				}
1018:../3rdParty/FreeRTOS/tasks.c **** 				else
1019:../3rdParty/FreeRTOS/tasks.c **** 				{
1020:../3rdParty/FreeRTOS/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1021:../3rdParty/FreeRTOS/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1022:../3rdParty/FreeRTOS/tasks.c **** 					yield will be performed if necessary. */
1023:../3rdParty/FreeRTOS/tasks.c **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 5672              		.loc 1 1023 0 is_stmt 1
 5673 066a 3B69     		ldr	r3, [r7, #16]
 5674 066c 03F11803 		add	r3, r3, #24
 5675 0670 0A48     		ldr	r0, .L75+16
 5676 0672 1946     		mov	r1, r3
 5677 0674 FFF7FEFF 		bl	vListInsertEnd
 5678              	.L72:
1024:../3rdParty/FreeRTOS/tasks.c **** 				}
1025:../3rdParty/FreeRTOS/tasks.c **** 			}
1026:../3rdParty/FreeRTOS/tasks.c **** 		}
1027:../3rdParty/FreeRTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 5679              		.loc 1 1027 0
 5680              	@ 1027 "../3rdParty/FreeRTOS/tasks.c" 1
 5681 0678 4FF00000 			mov r0, #0					
 5682 067c 80F31188 		msr basepri, r0				
 5683              	
 5684              	@ 0 "" 2
1028:../3rdParty/FreeRTOS/tasks.c **** 
1029:../3rdParty/FreeRTOS/tasks.c **** 		return xYieldRequired;
 5685              		.loc 1 1029 0
 5686              		.thumb
 5687 0680 7B69     		ldr	r3, [r7, #20]
1030:../3rdParty/FreeRTOS/tasks.c **** 	}
 5688              		.loc 1 1030 0
 5689 0682 1846     		mov	r0, r3
 5690 0684 07F11807 		add	r7, r7, #24
 5691 0688 BD46     		mov	sp, r7
 5692 068a 80BD     		pop	{r7, pc}
 5693              	.L76:
 5694              		.align	2
 5695              	.L75:
 5696 068c EC000000 		.word	uxSchedulerSuspended
 5697 0690 00000000 		.word	pxCurrentTCB
 5698 0694 E4000000 		.word	uxTopReadyPriority
 5699 0698 04000000 		.word	pxReadyTasksLists
 5700 069c 98000000 		.word	xPendingReadyList
 5701              		.cfi_endproc
 5702              	.LFE38:
 5704              		.section	.rodata
 5705              		.align	2
 5706              	.LC0:
 5707 0000 49444C45 		.ascii	"IDLE\000"
 5707      00
 5708              		.text
 5709              		.align	2
 5710              		.global	vTaskStartScheduler
 5711              		.thumb
 5712              		.thumb_func
 5714              	vTaskStartScheduler:
 5715              	.LFB39:
1031:../3rdParty/FreeRTOS/tasks.c **** 
1032:../3rdParty/FreeRTOS/tasks.c **** #endif
1033:../3rdParty/FreeRTOS/tasks.c **** 
1034:../3rdParty/FreeRTOS/tasks.c **** 
1035:../3rdParty/FreeRTOS/tasks.c **** 
1036:../3rdParty/FreeRTOS/tasks.c **** 
1037:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1038:../3rdParty/FreeRTOS/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1039:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1040:../3rdParty/FreeRTOS/tasks.c **** 
1041:../3rdParty/FreeRTOS/tasks.c **** 
1042:../3rdParty/FreeRTOS/tasks.c **** void vTaskStartScheduler( void )
1043:../3rdParty/FreeRTOS/tasks.c **** {
 5716              		.loc 1 1043 0
 5717              		.cfi_startproc
 5718              		@ args = 0, pretend = 0, frame = 8
 5719              		@ frame_needed = 1, uses_anonymous_args = 0
 5720 06a0 80B5     		push	{r7, lr}
 5721              	.LCFI30:
 5722              		.cfi_def_cfa_offset 8
 5723 06a2 86B0     		sub	sp, sp, #24
 5724              	.LCFI31:
 5725              		.cfi_def_cfa_offset 32
 5726 06a4 04AF     		add	r7, sp, #16
 5727              		.cfi_offset 14, -4
 5728              		.cfi_offset 7, -8
 5729              	.LCFI32:
 5730              		.cfi_def_cfa 7, 16
1044:../3rdParty/FreeRTOS/tasks.c **** portBASE_TYPE xReturn;
1045:../3rdParty/FreeRTOS/tasks.c **** 
1046:../3rdParty/FreeRTOS/tasks.c **** 	/* Add the idle task at the lowest priority. */
1047:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1048:../3rdParty/FreeRTOS/tasks.c **** 	{
1049:../3rdParty/FreeRTOS/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1050:../3rdParty/FreeRTOS/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1051:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1052:../3rdParty/FreeRTOS/tasks.c **** 	}
1053:../3rdParty/FreeRTOS/tasks.c **** 	#else
1054:../3rdParty/FreeRTOS/tasks.c **** 	{
1055:../3rdParty/FreeRTOS/tasks.c **** 		/* Create the idle task without storing its handle. */
1056:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 5731              		.loc 1 1056 0
 5732 06a6 164B     		ldr	r3, .L79
 5733 06a8 4FF00002 		mov	r2, #0
 5734 06ac 0092     		str	r2, [sp, #0]
 5735 06ae 4FF00002 		mov	r2, #0
 5736 06b2 0192     		str	r2, [sp, #4]
 5737 06b4 4FF00002 		mov	r2, #0
 5738 06b8 0292     		str	r2, [sp, #8]
 5739 06ba 4FF00002 		mov	r2, #0
 5740 06be 0392     		str	r2, [sp, #12]
 5741 06c0 1048     		ldr	r0, .L79+4
 5742 06c2 1946     		mov	r1, r3
 5743 06c4 4FF05002 		mov	r2, #80
 5744 06c8 4FF00003 		mov	r3, #0
 5745 06cc FFF7FEFF 		bl	xTaskGenericCreate
 5746 06d0 7860     		str	r0, [r7, #4]
1057:../3rdParty/FreeRTOS/tasks.c **** 	}
1058:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1059:../3rdParty/FreeRTOS/tasks.c **** 
1060:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1061:../3rdParty/FreeRTOS/tasks.c **** 	{
1062:../3rdParty/FreeRTOS/tasks.c **** 		if( xReturn == pdPASS )
1063:../3rdParty/FreeRTOS/tasks.c **** 		{
1064:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1065:../3rdParty/FreeRTOS/tasks.c **** 		}
1066:../3rdParty/FreeRTOS/tasks.c **** 	}
1067:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1068:../3rdParty/FreeRTOS/tasks.c **** 
1069:../3rdParty/FreeRTOS/tasks.c **** 	if( xReturn == pdPASS )
 5747              		.loc 1 1069 0
 5748 06d2 7B68     		ldr	r3, [r7, #4]
 5749 06d4 012B     		cmp	r3, #1
 5750 06d6 0FD1     		bne	.L77
1070:../3rdParty/FreeRTOS/tasks.c **** 	{
1071:../3rdParty/FreeRTOS/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1072:../3rdParty/FreeRTOS/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1073:../3rdParty/FreeRTOS/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1074:../3rdParty/FreeRTOS/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1075:../3rdParty/FreeRTOS/tasks.c **** 		starts to run.
1076:../3rdParty/FreeRTOS/tasks.c **** 
1077:../3rdParty/FreeRTOS/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1078:../3rdParty/FreeRTOS/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1079:../3rdParty/FreeRTOS/tasks.c **** 		portDISABLE_INTERRUPTS();
 5751              		.loc 1 1079 0
 5752              	@ 1079 "../3rdParty/FreeRTOS/tasks.c" 1
 5753 06d8 4FF02800 			mov r0, #40								
 5754 06dc 80F31188 		msr basepri, r0							
 5755              	
 5756              	@ 0 "" 2
1080:../3rdParty/FreeRTOS/tasks.c **** 
1081:../3rdParty/FreeRTOS/tasks.c **** 		xSchedulerRunning = pdTRUE;
 5757              		.loc 1 1081 0
 5758              		.thumb
 5759 06e0 094B     		ldr	r3, .L79+8
 5760 06e2 4FF00102 		mov	r2, #1
 5761 06e6 1A60     		str	r2, [r3, #0]
1082:../3rdParty/FreeRTOS/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 5762              		.loc 1 1082 0
 5763 06e8 084B     		ldr	r3, .L79+12
 5764 06ea 4FF00002 		mov	r2, #0
 5765 06ee 1A60     		str	r2, [r3, #0]
1083:../3rdParty/FreeRTOS/tasks.c **** 
1084:../3rdParty/FreeRTOS/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1085:../3rdParty/FreeRTOS/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1086:../3rdParty/FreeRTOS/tasks.c **** 		the run time counter time base. */
1087:../3rdParty/FreeRTOS/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 5766              		.loc 1 1087 0
 5767 06f0 FFF7FEFF 		bl	vConfigureTimerForRunTimeStats
1088:../3rdParty/FreeRTOS/tasks.c **** 		
1089:../3rdParty/FreeRTOS/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1090:../3rdParty/FreeRTOS/tasks.c **** 		portable interface. */
1091:../3rdParty/FreeRTOS/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 5768              		.loc 1 1091 0
 5769 06f4 FFF7FEFF 		bl	xPortStartScheduler
 5770              	.L77:
1092:../3rdParty/FreeRTOS/tasks.c **** 		{
1093:../3rdParty/FreeRTOS/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1094:../3rdParty/FreeRTOS/tasks.c **** 			function will not return. */
1095:../3rdParty/FreeRTOS/tasks.c **** 		}
1096:../3rdParty/FreeRTOS/tasks.c **** 		else
1097:../3rdParty/FreeRTOS/tasks.c **** 		{
1098:../3rdParty/FreeRTOS/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1099:../3rdParty/FreeRTOS/tasks.c **** 		}
1100:../3rdParty/FreeRTOS/tasks.c **** 	}
1101:../3rdParty/FreeRTOS/tasks.c **** 
1102:../3rdParty/FreeRTOS/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1103:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( xReturn );
1104:../3rdParty/FreeRTOS/tasks.c **** }
 5771              		.loc 1 1104 0
 5772 06f8 07F10807 		add	r7, r7, #8
 5773 06fc BD46     		mov	sp, r7
 5774 06fe 80BD     		pop	{r7, pc}
 5775              	.L80:
 5776              		.align	2
 5777              	.L79:
 5778 0700 00000000 		.word	.LC0
 5779 0704 00000000 		.word	prvIdleTask
 5780 0708 E8000000 		.word	xSchedulerRunning
 5781 070c DC000000 		.word	xTickCount
 5782              		.cfi_endproc
 5783              	.LFE39:
 5785              		.align	2
 5786              		.global	vTaskEndScheduler
 5787              		.thumb
 5788              		.thumb_func
 5790              	vTaskEndScheduler:
 5791              	.LFB40:
1105:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1106:../3rdParty/FreeRTOS/tasks.c **** 
1107:../3rdParty/FreeRTOS/tasks.c **** void vTaskEndScheduler( void )
1108:../3rdParty/FreeRTOS/tasks.c **** {
 5792              		.loc 1 1108 0
 5793              		.cfi_startproc
 5794              		@ args = 0, pretend = 0, frame = 0
 5795              		@ frame_needed = 1, uses_anonymous_args = 0
 5796 0710 80B5     		push	{r7, lr}
 5797              	.LCFI33:
 5798              		.cfi_def_cfa_offset 8
 5799 0712 00AF     		add	r7, sp, #0
 5800              		.cfi_offset 14, -4
 5801              		.cfi_offset 7, -8
 5802              	.LCFI34:
 5803              		.cfi_def_cfa_register 7
1109:../3rdParty/FreeRTOS/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1110:../3rdParty/FreeRTOS/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1111:../3rdParty/FreeRTOS/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1112:../3rdParty/FreeRTOS/tasks.c **** 	portDISABLE_INTERRUPTS();
 5804              		.loc 1 1112 0
 5805              	@ 1112 "../3rdParty/FreeRTOS/tasks.c" 1
 5806 0714 4FF02800 			mov r0, #40								
 5807 0718 80F31188 		msr basepri, r0							
 5808              	
 5809              	@ 0 "" 2
1113:../3rdParty/FreeRTOS/tasks.c **** 	xSchedulerRunning = pdFALSE;
 5810              		.loc 1 1113 0
 5811              		.thumb
 5812 071c 034B     		ldr	r3, .L82
 5813 071e 4FF00002 		mov	r2, #0
 5814 0722 1A60     		str	r2, [r3, #0]
1114:../3rdParty/FreeRTOS/tasks.c **** 	vPortEndScheduler();
 5815              		.loc 1 1114 0
 5816 0724 FFF7FEFF 		bl	vPortEndScheduler
1115:../3rdParty/FreeRTOS/tasks.c **** }
 5817              		.loc 1 1115 0
 5818 0728 80BD     		pop	{r7, pc}
 5819              	.L83:
 5820 072a 00BF     		.align	2
 5821              	.L82:
 5822 072c E8000000 		.word	xSchedulerRunning
 5823              		.cfi_endproc
 5824              	.LFE40:
 5826              		.align	2
 5827              		.global	vTaskSuspendAll
 5828              		.thumb
 5829              		.thumb_func
 5831              	vTaskSuspendAll:
 5832              	.LFB41:
1116:../3rdParty/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1117:../3rdParty/FreeRTOS/tasks.c **** 
1118:../3rdParty/FreeRTOS/tasks.c **** void vTaskSuspendAll( void )
1119:../3rdParty/FreeRTOS/tasks.c **** {
 5833              		.loc 1 1119 0
 5834              		.cfi_startproc
 5835              		@ args = 0, pretend = 0, frame = 0
 5836              		@ frame_needed = 1, uses_anonymous_args = 0
 5837              		@ link register save eliminated.
 5838 0730 80B4     		push	{r7}
 5839              	.LCFI35:
 5840              		.cfi_def_cfa_offset 4
 5841 0732 00AF     		add	r7, sp, #0
 5842              		.cfi_offset 7, -4
 5843              	.LCFI36:
 5844              		.cfi_def_cfa_register 7
1120:../3rdParty/FreeRTOS/tasks.c **** 	/* A critical section is not required as the variable is of type
1121:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE. */
1122:../3rdParty/FreeRTOS/tasks.c **** 	++uxSchedulerSuspended;
 5845              		.loc 1 1122 0
 5846 0734 044B     		ldr	r3, .L85
 5847 0736 1B68     		ldr	r3, [r3, #0]
 5848 0738 03F10102 		add	r2, r3, #1
 5849 073c 024B     		ldr	r3, .L85
 5850 073e 1A60     		str	r2, [r3, #0]
1123:../3rdParty/FreeRTOS/tasks.c **** }
 5851              		.loc 1 1123 0
 5852 0740 BD46     		mov	sp, r7
 5853 0742 80BC     		pop	{r7}
 5854 0744 7047     		bx	lr
 5855              	.L86:
 5856 0746 00BF     		.align	2
 5857              	.L85:
 5858 0748 EC000000 		.word	uxSchedulerSuspended
 5859              		.cfi_endproc
 5860              	.LFE41:
 5862              		.align	2
 5863              		.global	xTaskResumeAll
 5864              		.thumb
 5865              		.thumb_func
 5867              	xTaskResumeAll:
 5868              	.LFB42:
1124:../3rdParty/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1125:../3rdParty/FreeRTOS/tasks.c **** 
1126:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1127:../3rdParty/FreeRTOS/tasks.c **** {
 5869              		.loc 1 1127 0
 5870              		.cfi_startproc
 5871              		@ args = 0, pretend = 0, frame = 8
 5872              		@ frame_needed = 1, uses_anonymous_args = 0
 5873 074c 90B5     		push	{r4, r7, lr}
 5874              	.LCFI37:
 5875              		.cfi_def_cfa_offset 12
 5876 074e 83B0     		sub	sp, sp, #12
 5877              	.LCFI38:
 5878              		.cfi_def_cfa_offset 24
 5879 0750 00AF     		add	r7, sp, #0
 5880              		.cfi_offset 14, -4
 5881              		.cfi_offset 7, -8
 5882              		.cfi_offset 4, -12
 5883              	.LCFI39:
 5884              		.cfi_def_cfa_register 7
1128:../3rdParty/FreeRTOS/tasks.c **** register tskTCB *pxTCB;
1129:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 5885              		.loc 1 1129 0
 5886 0752 4FF00003 		mov	r3, #0
 5887 0756 7B60     		str	r3, [r7, #4]
1130:../3rdParty/FreeRTOS/tasks.c **** 
1131:../3rdParty/FreeRTOS/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1132:../3rdParty/FreeRTOS/tasks.c **** 	previous call to vTaskSuspendAll(). */
1133:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1134:../3rdParty/FreeRTOS/tasks.c **** 
1135:../3rdParty/FreeRTOS/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1136:../3rdParty/FreeRTOS/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1137:../3rdParty/FreeRTOS/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1138:../3rdParty/FreeRTOS/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1139:../3rdParty/FreeRTOS/tasks.c **** 	tasks from this list into their appropriate ready list. */
1140:../3rdParty/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 5888              		.loc 1 1140 0
 5889 0758 FFF7FEFF 		bl	vPortEnterCritical
1141:../3rdParty/FreeRTOS/tasks.c **** 	{
1142:../3rdParty/FreeRTOS/tasks.c **** 		--uxSchedulerSuspended;
 5890              		.loc 1 1142 0
 5891 075c 384B     		ldr	r3, .L96
 5892 075e 1B68     		ldr	r3, [r3, #0]
 5893 0760 03F1FF32 		add	r2, r3, #-1
 5894 0764 364B     		ldr	r3, .L96
 5895 0766 1A60     		str	r2, [r3, #0]
1143:../3rdParty/FreeRTOS/tasks.c **** 
1144:../3rdParty/FreeRTOS/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 5896              		.loc 1 1144 0
 5897 0768 354B     		ldr	r3, .L96
 5898 076a 1B68     		ldr	r3, [r3, #0]
 5899 076c 002B     		cmp	r3, #0
 5900 076e 5ED1     		bne	.L88
1145:../3rdParty/FreeRTOS/tasks.c **** 		{
1146:../3rdParty/FreeRTOS/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 5901              		.loc 1 1146 0
 5902 0770 344B     		ldr	r3, .L96+4
 5903 0772 1B68     		ldr	r3, [r3, #0]
 5904 0774 002B     		cmp	r3, #0
 5905 0776 5AD0     		beq	.L88
 5906              	.LBB3:
1147:../3rdParty/FreeRTOS/tasks.c **** 			{
1148:../3rdParty/FreeRTOS/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 5907              		.loc 1 1148 0
 5908 0778 4FF00003 		mov	r3, #0
 5909 077c 3B60     		str	r3, [r7, #0]
1149:../3rdParty/FreeRTOS/tasks.c **** 
1150:../3rdParty/FreeRTOS/tasks.c **** 				/* Move any readied tasks from the pending list into the
1151:../3rdParty/FreeRTOS/tasks.c **** 				appropriate ready list. */
1152:../3rdParty/FreeRTOS/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 5910              		.loc 1 1152 0
 5911 077e 2EE0     		b	.L89
 5912              	.L91:
1153:../3rdParty/FreeRTOS/tasks.c **** 				{
1154:../3rdParty/FreeRTOS/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 5913              		.loc 1 1154 0
 5914 0780 314B     		ldr	r3, .L96+8
 5915 0782 DB68     		ldr	r3, [r3, #12]
 5916 0784 DB68     		ldr	r3, [r3, #12]
 5917 0786 1C46     		mov	r4, r3
1155:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 5918              		.loc 1 1155 0
 5919 0788 04F11803 		add	r3, r4, #24
 5920 078c 1846     		mov	r0, r3
 5921 078e FFF7FEFF 		bl	vListRemove
1156:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 5922              		.loc 1 1156 0
 5923 0792 04F10403 		add	r3, r4, #4
 5924 0796 1846     		mov	r0, r3
 5925 0798 FFF7FEFF 		bl	vListRemove
1157:../3rdParty/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 5926              		.loc 1 1157 0
 5927 079c E26A     		ldr	r2, [r4, #44]
 5928 079e 2B4B     		ldr	r3, .L96+12
 5929 07a0 1B68     		ldr	r3, [r3, #0]
 5930 07a2 9A42     		cmp	r2, r3
 5931 07a4 02D9     		bls	.L90
 5932              		.loc 1 1157 0 is_stmt 0 discriminator 1
 5933 07a6 E26A     		ldr	r2, [r4, #44]
 5934 07a8 284B     		ldr	r3, .L96+12
 5935 07aa 1A60     		str	r2, [r3, #0]
 5936              	.L90:
 5937              		.loc 1 1157 0 discriminator 2
 5938 07ac E26A     		ldr	r2, [r4, #44]
 5939 07ae 1346     		mov	r3, r2
 5940 07b0 4FEA8303 		lsl	r3, r3, #2
 5941 07b4 9B18     		adds	r3, r3, r2
 5942 07b6 4FEA8303 		lsl	r3, r3, #2
 5943 07ba 1A46     		mov	r2, r3
 5944 07bc 244B     		ldr	r3, .L96+16
 5945 07be D218     		adds	r2, r2, r3
 5946 07c0 04F10403 		add	r3, r4, #4
 5947 07c4 1046     		mov	r0, r2
 5948 07c6 1946     		mov	r1, r3
 5949 07c8 FFF7FEFF 		bl	vListInsertEnd
1158:../3rdParty/FreeRTOS/tasks.c **** 
1159:../3rdParty/FreeRTOS/tasks.c **** 					/* If we have moved a task that has a priority higher than
1160:../3rdParty/FreeRTOS/tasks.c **** 					the current task then we should yield. */
1161:../3rdParty/FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 5950              		.loc 1 1161 0 is_stmt 1 discriminator 2
 5951 07cc E26A     		ldr	r2, [r4, #44]
 5952 07ce 214B     		ldr	r3, .L96+20
 5953 07d0 1B68     		ldr	r3, [r3, #0]
 5954 07d2 DB6A     		ldr	r3, [r3, #44]
 5955 07d4 9A42     		cmp	r2, r3
 5956 07d6 02D3     		bcc	.L89
1162:../3rdParty/FreeRTOS/tasks.c **** 					{
1163:../3rdParty/FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 5957              		.loc 1 1163 0
 5958 07d8 4FF00103 		mov	r3, #1
 5959 07dc 3B60     		str	r3, [r7, #0]
 5960              	.L89:
1152:../3rdParty/FreeRTOS/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 5961              		.loc 1 1152 0 discriminator 1
 5962 07de 1A4B     		ldr	r3, .L96+8
 5963 07e0 1B68     		ldr	r3, [r3, #0]
 5964 07e2 002B     		cmp	r3, #0
 5965 07e4 CCD1     		bne	.L91
1164:../3rdParty/FreeRTOS/tasks.c **** 					}
1165:../3rdParty/FreeRTOS/tasks.c **** 				}
1166:../3rdParty/FreeRTOS/tasks.c **** 
1167:../3rdParty/FreeRTOS/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1168:../3rdParty/FreeRTOS/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1169:../3rdParty/FreeRTOS/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1170:../3rdParty/FreeRTOS/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 5966              		.loc 1 1170 0
 5967 07e6 1C4B     		ldr	r3, .L96+24
 5968 07e8 1B68     		ldr	r3, [r3, #0]
 5969 07ea 002B     		cmp	r3, #0
 5970 07ec 0FD0     		beq	.L92
1171:../3rdParty/FreeRTOS/tasks.c **** 				{
1172:../3rdParty/FreeRTOS/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 5971              		.loc 1 1172 0
 5972 07ee 07E0     		b	.L93
 5973              	.L94:
1173:../3rdParty/FreeRTOS/tasks.c **** 					{
1174:../3rdParty/FreeRTOS/tasks.c **** 						vTaskIncrementTick();
 5974              		.loc 1 1174 0
 5975 07f0 FFF7FEFF 		bl	vTaskIncrementTick
1175:../3rdParty/FreeRTOS/tasks.c **** 						--uxMissedTicks;
 5976              		.loc 1 1175 0
 5977 07f4 184B     		ldr	r3, .L96+24
 5978 07f6 1B68     		ldr	r3, [r3, #0]
 5979 07f8 03F1FF32 		add	r2, r3, #-1
 5980 07fc 164B     		ldr	r3, .L96+24
 5981 07fe 1A60     		str	r2, [r3, #0]
 5982              	.L93:
1172:../3rdParty/FreeRTOS/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 5983              		.loc 1 1172 0 discriminator 1
 5984 0800 154B     		ldr	r3, .L96+24
 5985 0802 1B68     		ldr	r3, [r3, #0]
 5986 0804 002B     		cmp	r3, #0
 5987 0806 F3D1     		bne	.L94
1176:../3rdParty/FreeRTOS/tasks.c **** 					}
1177:../3rdParty/FreeRTOS/tasks.c **** 
1178:../3rdParty/FreeRTOS/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1179:../3rdParty/FreeRTOS/tasks.c **** 					to ensure the highest priority task that is ready to run is
1180:../3rdParty/FreeRTOS/tasks.c **** 					the task actually running. */
1181:../3rdParty/FreeRTOS/tasks.c **** 					#if configUSE_PREEMPTION == 1
1182:../3rdParty/FreeRTOS/tasks.c **** 					{
1183:../3rdParty/FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 5988              		.loc 1 1183 0
 5989 0808 4FF00103 		mov	r3, #1
 5990 080c 3B60     		str	r3, [r7, #0]
 5991              	.L92:
1184:../3rdParty/FreeRTOS/tasks.c **** 					}
1185:../3rdParty/FreeRTOS/tasks.c **** 					#endif
1186:../3rdParty/FreeRTOS/tasks.c **** 				}
1187:../3rdParty/FreeRTOS/tasks.c **** 
1188:../3rdParty/FreeRTOS/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 5992              		.loc 1 1188 0
 5993 080e 3B68     		ldr	r3, [r7, #0]
 5994 0810 012B     		cmp	r3, #1
 5995 0812 03D0     		beq	.L95
 5996              		.loc 1 1188 0 is_stmt 0 discriminator 1
 5997 0814 114B     		ldr	r3, .L96+28
 5998 0816 1B68     		ldr	r3, [r3, #0]
 5999 0818 012B     		cmp	r3, #1
 6000 081a 08D1     		bne	.L88
 6001              	.L95:
1189:../3rdParty/FreeRTOS/tasks.c **** 				{
1190:../3rdParty/FreeRTOS/tasks.c **** 					xAlreadyYielded = pdTRUE;
 6002              		.loc 1 1190 0 is_stmt 1
 6003 081c 4FF00103 		mov	r3, #1
 6004 0820 7B60     		str	r3, [r7, #4]
1191:../3rdParty/FreeRTOS/tasks.c **** 					xMissedYield = pdFALSE;
 6005              		.loc 1 1191 0
 6006 0822 0E4B     		ldr	r3, .L96+28
 6007 0824 4FF00002 		mov	r2, #0
 6008 0828 1A60     		str	r2, [r3, #0]
1192:../3rdParty/FreeRTOS/tasks.c **** 					portYIELD_WITHIN_API();
 6009              		.loc 1 1192 0
 6010 082a FFF7FEFF 		bl	vPortYieldFromISR
 6011              	.L88:
 6012              	.LBE3:
1193:../3rdParty/FreeRTOS/tasks.c **** 				}
1194:../3rdParty/FreeRTOS/tasks.c **** 			}
1195:../3rdParty/FreeRTOS/tasks.c **** 		}
1196:../3rdParty/FreeRTOS/tasks.c **** 	}
1197:../3rdParty/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 6013              		.loc 1 1197 0
 6014 082e FFF7FEFF 		bl	vPortExitCritical
1198:../3rdParty/FreeRTOS/tasks.c **** 
1199:../3rdParty/FreeRTOS/tasks.c **** 	return xAlreadyYielded;
 6015              		.loc 1 1199 0
 6016 0832 7B68     		ldr	r3, [r7, #4]
1200:../3rdParty/FreeRTOS/tasks.c **** }
 6017              		.loc 1 1200 0
 6018 0834 1846     		mov	r0, r3
 6019 0836 07F10C07 		add	r7, r7, #12
 6020 083a BD46     		mov	sp, r7
 6021 083c 90BD     		pop	{r4, r7, pc}
 6022              	.L97:
 6023 083e 00BF     		.align	2
 6024              	.L96:
 6025 0840 EC000000 		.word	uxSchedulerSuspended
 6026 0844 D8000000 		.word	uxCurrentNumberOfTasks
 6027 0848 98000000 		.word	xPendingReadyList
 6028 084c E4000000 		.word	uxTopReadyPriority
 6029 0850 04000000 		.word	pxReadyTasksLists
 6030 0854 00000000 		.word	pxCurrentTCB
 6031 0858 F0000000 		.word	uxMissedTicks
 6032 085c F4000000 		.word	xMissedYield
 6033              		.cfi_endproc
 6034              	.LFE42:
 6036              		.align	2
 6037              		.global	xTaskGetTickCount
 6038              		.thumb
 6039              		.thumb_func
 6041              	xTaskGetTickCount:
 6042              	.LFB43:
1201:../3rdParty/FreeRTOS/tasks.c **** 
1202:../3rdParty/FreeRTOS/tasks.c **** 
1203:../3rdParty/FreeRTOS/tasks.c **** 
1204:../3rdParty/FreeRTOS/tasks.c **** 
1205:../3rdParty/FreeRTOS/tasks.c **** 
1206:../3rdParty/FreeRTOS/tasks.c **** 
1207:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1208:../3rdParty/FreeRTOS/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1209:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1210:../3rdParty/FreeRTOS/tasks.c **** 
1211:../3rdParty/FreeRTOS/tasks.c **** 
1212:../3rdParty/FreeRTOS/tasks.c **** 
1213:../3rdParty/FreeRTOS/tasks.c **** portTickType xTaskGetTickCount( void )
1214:../3rdParty/FreeRTOS/tasks.c **** {
 6043              		.loc 1 1214 0
 6044              		.cfi_startproc
 6045              		@ args = 0, pretend = 0, frame = 8
 6046              		@ frame_needed = 1, uses_anonymous_args = 0
 6047 0860 80B5     		push	{r7, lr}
 6048              	.LCFI40:
 6049              		.cfi_def_cfa_offset 8
 6050 0862 82B0     		sub	sp, sp, #8
 6051              	.LCFI41:
 6052              		.cfi_def_cfa_offset 16
 6053 0864 00AF     		add	r7, sp, #0
 6054              		.cfi_offset 14, -4
 6055              		.cfi_offset 7, -8
 6056              	.LCFI42:
 6057              		.cfi_def_cfa_register 7
1215:../3rdParty/FreeRTOS/tasks.c **** portTickType xTicks;
1216:../3rdParty/FreeRTOS/tasks.c **** 
1217:../3rdParty/FreeRTOS/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1218:../3rdParty/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 6058              		.loc 1 1218 0
 6059 0866 FFF7FEFF 		bl	vPortEnterCritical
1219:../3rdParty/FreeRTOS/tasks.c **** 	{
1220:../3rdParty/FreeRTOS/tasks.c **** 		xTicks = xTickCount;
 6060              		.loc 1 1220 0
 6061 086a 054B     		ldr	r3, .L99
 6062 086c 1B68     		ldr	r3, [r3, #0]
 6063 086e 7B60     		str	r3, [r7, #4]
1221:../3rdParty/FreeRTOS/tasks.c **** 	}
1222:../3rdParty/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 6064              		.loc 1 1222 0
 6065 0870 FFF7FEFF 		bl	vPortExitCritical
1223:../3rdParty/FreeRTOS/tasks.c **** 
1224:../3rdParty/FreeRTOS/tasks.c **** 	return xTicks;
 6066              		.loc 1 1224 0
 6067 0874 7B68     		ldr	r3, [r7, #4]
1225:../3rdParty/FreeRTOS/tasks.c **** }
 6068              		.loc 1 1225 0
 6069 0876 1846     		mov	r0, r3
 6070 0878 07F10807 		add	r7, r7, #8
 6071 087c BD46     		mov	sp, r7
 6072 087e 80BD     		pop	{r7, pc}
 6073              	.L100:
 6074              		.align	2
 6075              	.L99:
 6076 0880 DC000000 		.word	xTickCount
 6077              		.cfi_endproc
 6078              	.LFE43:
 6080              		.align	2
 6081              		.global	xTaskGetTickCountFromISR
 6082              		.thumb
 6083              		.thumb_func
 6085              	xTaskGetTickCountFromISR:
 6086              	.LFB44:
1226:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1227:../3rdParty/FreeRTOS/tasks.c **** 
1228:../3rdParty/FreeRTOS/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1229:../3rdParty/FreeRTOS/tasks.c **** {
 6087              		.loc 1 1229 0
 6088              		.cfi_startproc
 6089              		@ args = 0, pretend = 0, frame = 8
 6090              		@ frame_needed = 1, uses_anonymous_args = 0
 6091              		@ link register save eliminated.
 6092 0884 80B4     		push	{r7}
 6093              	.LCFI43:
 6094              		.cfi_def_cfa_offset 4
 6095 0886 83B0     		sub	sp, sp, #12
 6096              	.LCFI44:
 6097              		.cfi_def_cfa_offset 16
 6098 0888 00AF     		add	r7, sp, #0
 6099              		.cfi_offset 7, -4
 6100              	.LCFI45:
 6101              		.cfi_def_cfa_register 7
1230:../3rdParty/FreeRTOS/tasks.c **** portTickType xReturn;
1231:../3rdParty/FreeRTOS/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1232:../3rdParty/FreeRTOS/tasks.c **** 
1233:../3rdParty/FreeRTOS/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 6102              		.loc 1 1233 0
 6103 088a 4FF00003 		mov	r3, #0
 6104 088e 7B60     		str	r3, [r7, #4]
 6105              	@ 1233 "../3rdParty/FreeRTOS/tasks.c" 1
 6106 0890 4FF02800 			mov r0, #40								
 6107 0894 80F31188 		msr basepri, r0							
 6108              	
 6109              	@ 0 "" 2
1234:../3rdParty/FreeRTOS/tasks.c **** 	xReturn = xTickCount;
 6110              		.loc 1 1234 0
 6111              		.thumb
 6112 0898 064B     		ldr	r3, .L102
 6113 089a 1B68     		ldr	r3, [r3, #0]
 6114 089c 3B60     		str	r3, [r7, #0]
1235:../3rdParty/FreeRTOS/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 6115              		.loc 1 1235 0
 6116              	@ 1235 "../3rdParty/FreeRTOS/tasks.c" 1
 6117 089e 4FF00000 			mov r0, #0					
 6118 08a2 80F31188 		msr basepri, r0				
 6119              	
 6120              	@ 0 "" 2
1236:../3rdParty/FreeRTOS/tasks.c **** 
1237:../3rdParty/FreeRTOS/tasks.c **** 	return xReturn;
 6121              		.loc 1 1237 0
 6122              		.thumb
 6123 08a6 3B68     		ldr	r3, [r7, #0]
1238:../3rdParty/FreeRTOS/tasks.c **** }
 6124              		.loc 1 1238 0
 6125 08a8 1846     		mov	r0, r3
 6126 08aa 07F10C07 		add	r7, r7, #12
 6127 08ae BD46     		mov	sp, r7
 6128 08b0 80BC     		pop	{r7}
 6129 08b2 7047     		bx	lr
 6130              	.L103:
 6131              		.align	2
 6132              	.L102:
 6133 08b4 DC000000 		.word	xTickCount
 6134              		.cfi_endproc
 6135              	.LFE44:
 6137              		.align	2
 6138              		.global	uxTaskGetNumberOfTasks
 6139              		.thumb
 6140              		.thumb_func
 6142              	uxTaskGetNumberOfTasks:
 6143              	.LFB45:
1239:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1240:../3rdParty/FreeRTOS/tasks.c **** 
1241:../3rdParty/FreeRTOS/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1242:../3rdParty/FreeRTOS/tasks.c **** {
 6144              		.loc 1 1242 0
 6145              		.cfi_startproc
 6146              		@ args = 0, pretend = 0, frame = 0
 6147              		@ frame_needed = 1, uses_anonymous_args = 0
 6148              		@ link register save eliminated.
 6149 08b8 80B4     		push	{r7}
 6150              	.LCFI46:
 6151              		.cfi_def_cfa_offset 4
 6152 08ba 00AF     		add	r7, sp, #0
 6153              		.cfi_offset 7, -4
 6154              	.LCFI47:
 6155              		.cfi_def_cfa_register 7
1243:../3rdParty/FreeRTOS/tasks.c **** 	/* A critical section is not required because the variables are of type
1244:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE. */
1245:../3rdParty/FreeRTOS/tasks.c **** 	return uxCurrentNumberOfTasks;
 6156              		.loc 1 1245 0
 6157 08bc 024B     		ldr	r3, .L105
 6158 08be 1B68     		ldr	r3, [r3, #0]
1246:../3rdParty/FreeRTOS/tasks.c **** }
 6159              		.loc 1 1246 0
 6160 08c0 1846     		mov	r0, r3
 6161 08c2 BD46     		mov	sp, r7
 6162 08c4 80BC     		pop	{r7}
 6163 08c6 7047     		bx	lr
 6164              	.L106:
 6165              		.align	2
 6166              	.L105:
 6167 08c8 D8000000 		.word	uxCurrentNumberOfTasks
 6168              		.cfi_endproc
 6169              	.LFE45:
 6171              		.section	.rodata
 6172 0005 000000   		.align	2
 6173              	.LC1:
 6174 0008 0D0A00   		.ascii	"\015\012\000"
 6175              		.text
 6176              		.align	2
 6177              		.global	vTaskList
 6178              		.thumb
 6179              		.thumb_func
 6181              	vTaskList:
 6182              	.LFB46:
1247:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1248:../3rdParty/FreeRTOS/tasks.c **** 
1249:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1250:../3rdParty/FreeRTOS/tasks.c **** 
1251:../3rdParty/FreeRTOS/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1252:../3rdParty/FreeRTOS/tasks.c **** 	{
1253:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1254:../3rdParty/FreeRTOS/tasks.c **** 
1255:../3rdParty/FreeRTOS/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1256:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1257:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxTCB );
1258:../3rdParty/FreeRTOS/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1259:../3rdParty/FreeRTOS/tasks.c **** 	}
1260:../3rdParty/FreeRTOS/tasks.c **** 
1261:../3rdParty/FreeRTOS/tasks.c **** #endif
1262:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1263:../3rdParty/FreeRTOS/tasks.c **** 
1264:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1265:../3rdParty/FreeRTOS/tasks.c **** 
1266:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1267:../3rdParty/FreeRTOS/tasks.c **** 	{
 6183              		.loc 1 1267 0
 6184              		.cfi_startproc
 6185              		@ args = 0, pretend = 0, frame = 16
 6186              		@ frame_needed = 1, uses_anonymous_args = 0
 6187 08cc 90B5     		push	{r4, r7, lr}
 6188              	.LCFI48:
 6189              		.cfi_def_cfa_offset 12
 6190 08ce 85B0     		sub	sp, sp, #20
 6191              	.LCFI49:
 6192              		.cfi_def_cfa_offset 32
 6193 08d0 00AF     		add	r7, sp, #0
 6194              		.cfi_offset 14, -4
 6195              		.cfi_offset 7, -8
 6196              		.cfi_offset 4, -12
 6197              	.LCFI50:
 6198              		.cfi_def_cfa_register 7
 6199 08d2 7860     		str	r0, [r7, #4]
1268:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1269:../3rdParty/FreeRTOS/tasks.c **** 
1270:../3rdParty/FreeRTOS/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1271:../3rdParty/FreeRTOS/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1272:../3rdParty/FreeRTOS/tasks.c **** 
1273:../3rdParty/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
 6200              		.loc 1 1273 0
 6201 08d4 FFF7FEFF 		bl	vTaskSuspendAll
1274:../3rdParty/FreeRTOS/tasks.c **** 		{
1275:../3rdParty/FreeRTOS/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1276:../3rdParty/FreeRTOS/tasks.c **** 			report the task name, state and stack high water mark. */
1277:../3rdParty/FreeRTOS/tasks.c **** 
1278:../3rdParty/FreeRTOS/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
 6202              		.loc 1 1278 0
 6203 08d8 7B68     		ldr	r3, [r7, #4]
 6204 08da 4FF00002 		mov	r2, #0
 6205 08de 1A70     		strb	r2, [r3, #0]
1279:../3rdParty/FreeRTOS/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 6206              		.loc 1 1279 0
 6207 08e0 7C68     		ldr	r4, [r7, #4]
 6208 08e2 2046     		mov	r0, r4
 6209 08e4 FFF7FEFF 		bl	strlen
 6210 08e8 0346     		mov	r3, r0
 6211 08ea E318     		adds	r3, r4, r3
 6212 08ec 1846     		mov	r0, r3
 6213 08ee 3149     		ldr	r1, .L114
 6214 08f0 4FF00302 		mov	r2, #3
 6215 08f4 FFF7FEFF 		bl	memcpy
1280:../3rdParty/FreeRTOS/tasks.c **** 
1281:../3rdParty/FreeRTOS/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 6216              		.loc 1 1281 0
 6217 08f8 2F4B     		ldr	r3, .L114+4
 6218 08fa 1B68     		ldr	r3, [r3, #0]
 6219 08fc 03F10103 		add	r3, r3, #1
 6220 0900 FB60     		str	r3, [r7, #12]
 6221              	.L109:
1282:../3rdParty/FreeRTOS/tasks.c **** 
1283:../3rdParty/FreeRTOS/tasks.c **** 			do
1284:../3rdParty/FreeRTOS/tasks.c **** 			{
1285:../3rdParty/FreeRTOS/tasks.c **** 				uxQueue--;
 6222              		.loc 1 1285 0
 6223 0902 FB68     		ldr	r3, [r7, #12]
 6224 0904 03F1FF33 		add	r3, r3, #-1
 6225 0908 FB60     		str	r3, [r7, #12]
1286:../3rdParty/FreeRTOS/tasks.c **** 
1287:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 6226              		.loc 1 1287 0
 6227 090a FA68     		ldr	r2, [r7, #12]
 6228 090c 1346     		mov	r3, r2
 6229 090e 4FEA8303 		lsl	r3, r3, #2
 6230 0912 9B18     		adds	r3, r3, r2
 6231 0914 4FEA8303 		lsl	r3, r3, #2
 6232 0918 1A46     		mov	r2, r3
 6233 091a 284B     		ldr	r3, .L114+8
 6234 091c D318     		adds	r3, r2, r3
 6235 091e 1B68     		ldr	r3, [r3, #0]
 6236 0920 002B     		cmp	r3, #0
 6237 0922 0FD0     		beq	.L108
1288:../3rdParty/FreeRTOS/tasks.c **** 				{
1289:../3rdParty/FreeRTOS/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
 6238              		.loc 1 1289 0
 6239 0924 FA68     		ldr	r2, [r7, #12]
 6240 0926 1346     		mov	r3, r2
 6241 0928 4FEA8303 		lsl	r3, r3, #2
 6242 092c 9B18     		adds	r3, r3, r2
 6243 092e 4FEA8303 		lsl	r3, r3, #2
 6244 0932 1A46     		mov	r2, r3
 6245 0934 214B     		ldr	r3, .L114+8
 6246 0936 D318     		adds	r3, r2, r3
 6247 0938 7868     		ldr	r0, [r7, #4]
 6248 093a 1946     		mov	r1, r3
 6249 093c 4FF05202 		mov	r2, #82
 6250 0940 00F062FC 		bl	prvListTaskWithinSingleList
 6251              	.L108:
1290:../3rdParty/FreeRTOS/tasks.c **** 				}
1291:../3rdParty/FreeRTOS/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 6252              		.loc 1 1291 0
 6253 0944 FB68     		ldr	r3, [r7, #12]
 6254 0946 002B     		cmp	r3, #0
 6255 0948 DBD1     		bne	.L109
1292:../3rdParty/FreeRTOS/tasks.c **** 
1293:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 6256              		.loc 1 1293 0
 6257 094a 1D4B     		ldr	r3, .L114+12
 6258 094c 1B68     		ldr	r3, [r3, #0]
 6259 094e 1B68     		ldr	r3, [r3, #0]
 6260 0950 002B     		cmp	r3, #0
 6261 0952 07D0     		beq	.L110
1294:../3rdParty/FreeRTOS/tasks.c **** 			{
1295:../3rdParty/FreeRTOS/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
 6262              		.loc 1 1295 0
 6263 0954 1A4B     		ldr	r3, .L114+12
 6264 0956 1B68     		ldr	r3, [r3, #0]
 6265 0958 7868     		ldr	r0, [r7, #4]
 6266 095a 1946     		mov	r1, r3
 6267 095c 4FF04202 		mov	r2, #66
 6268 0960 00F052FC 		bl	prvListTaskWithinSingleList
 6269              	.L110:
1296:../3rdParty/FreeRTOS/tasks.c **** 			}
1297:../3rdParty/FreeRTOS/tasks.c **** 
1298:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 6270              		.loc 1 1298 0
 6271 0964 174B     		ldr	r3, .L114+16
 6272 0966 1B68     		ldr	r3, [r3, #0]
 6273 0968 1B68     		ldr	r3, [r3, #0]
 6274 096a 002B     		cmp	r3, #0
 6275 096c 07D0     		beq	.L111
1299:../3rdParty/FreeRTOS/tasks.c **** 			{
1300:../3rdParty/FreeRTOS/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
 6276              		.loc 1 1300 0
 6277 096e 154B     		ldr	r3, .L114+16
 6278 0970 1B68     		ldr	r3, [r3, #0]
 6279 0972 7868     		ldr	r0, [r7, #4]
 6280 0974 1946     		mov	r1, r3
 6281 0976 4FF04202 		mov	r2, #66
 6282 097a 00F045FC 		bl	prvListTaskWithinSingleList
 6283              	.L111:
1301:../3rdParty/FreeRTOS/tasks.c **** 			}
1302:../3rdParty/FreeRTOS/tasks.c **** 
1303:../3rdParty/FreeRTOS/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1304:../3rdParty/FreeRTOS/tasks.c **** 			{
1305:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 6284              		.loc 1 1305 0
 6285 097e 124B     		ldr	r3, .L114+20
 6286 0980 1B68     		ldr	r3, [r3, #0]
 6287 0982 002B     		cmp	r3, #0
 6288 0984 05D0     		beq	.L112
1306:../3rdParty/FreeRTOS/tasks.c **** 				{
1307:../3rdParty/FreeRTOS/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
 6289              		.loc 1 1307 0
 6290 0986 7868     		ldr	r0, [r7, #4]
 6291 0988 0F49     		ldr	r1, .L114+20
 6292 098a 4FF04402 		mov	r2, #68
 6293 098e 00F03BFC 		bl	prvListTaskWithinSingleList
 6294              	.L112:
1308:../3rdParty/FreeRTOS/tasks.c **** 				}
1309:../3rdParty/FreeRTOS/tasks.c **** 			}
1310:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1311:../3rdParty/FreeRTOS/tasks.c **** 
1312:../3rdParty/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1313:../3rdParty/FreeRTOS/tasks.c **** 			{
1314:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 6295              		.loc 1 1314 0
 6296 0992 0E4B     		ldr	r3, .L114+24
 6297 0994 1B68     		ldr	r3, [r3, #0]
 6298 0996 002B     		cmp	r3, #0
 6299 0998 05D0     		beq	.L113
1315:../3rdParty/FreeRTOS/tasks.c **** 				{
1316:../3rdParty/FreeRTOS/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
 6300              		.loc 1 1316 0
 6301 099a 7868     		ldr	r0, [r7, #4]
 6302 099c 0B49     		ldr	r1, .L114+24
 6303 099e 4FF05302 		mov	r2, #83
 6304 09a2 00F031FC 		bl	prvListTaskWithinSingleList
 6305              	.L113:
1317:../3rdParty/FreeRTOS/tasks.c **** 				}
1318:../3rdParty/FreeRTOS/tasks.c **** 			}
1319:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1320:../3rdParty/FreeRTOS/tasks.c **** 		}
1321:../3rdParty/FreeRTOS/tasks.c **** 		xTaskResumeAll();
 6306              		.loc 1 1321 0
 6307 09a6 FFF7FEFF 		bl	xTaskResumeAll
1322:../3rdParty/FreeRTOS/tasks.c **** 	}
 6308              		.loc 1 1322 0
 6309 09aa 07F11407 		add	r7, r7, #20
 6310 09ae BD46     		mov	sp, r7
 6311 09b0 90BD     		pop	{r4, r7, pc}
 6312              	.L115:
 6313 09b2 00BF     		.align	2
 6314              	.L114:
 6315 09b4 08000000 		.word	.LC1
 6316 09b8 E0000000 		.word	uxTopUsedPriority
 6317 09bc 04000000 		.word	pxReadyTasksLists
 6318 09c0 90000000 		.word	pxDelayedTaskList
 6319 09c4 94000000 		.word	pxOverflowDelayedTaskList
 6320 09c8 AC000000 		.word	xTasksWaitingTermination
 6321 09cc C4000000 		.word	xSuspendedTaskList
 6322              		.cfi_endproc
 6323              	.LFE46:
 6325              		.align	2
 6326              		.global	vTaskGetRunTimeStats
 6327              		.thumb
 6328              		.thumb_func
 6330              	vTaskGetRunTimeStats:
 6331              	.LFB47:
1323:../3rdParty/FreeRTOS/tasks.c **** 
1324:../3rdParty/FreeRTOS/tasks.c **** #endif
1325:../3rdParty/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1326:../3rdParty/FreeRTOS/tasks.c **** 
1327:../3rdParty/FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1328:../3rdParty/FreeRTOS/tasks.c **** 
1329:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1330:../3rdParty/FreeRTOS/tasks.c **** 	{
 6332              		.loc 1 1330 0
 6333              		.cfi_startproc
 6334              		@ args = 0, pretend = 0, frame = 16
 6335              		@ frame_needed = 1, uses_anonymous_args = 0
 6336 09d0 90B5     		push	{r4, r7, lr}
 6337              	.LCFI51:
 6338              		.cfi_def_cfa_offset 12
 6339 09d2 85B0     		sub	sp, sp, #20
 6340              	.LCFI52:
 6341              		.cfi_def_cfa_offset 32
 6342 09d4 00AF     		add	r7, sp, #0
 6343              		.cfi_offset 14, -4
 6344              		.cfi_offset 7, -8
 6345              		.cfi_offset 4, -12
 6346              	.LCFI53:
 6347              		.cfi_def_cfa_register 7
 6348 09d6 7860     		str	r0, [r7, #4]
1331:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1332:../3rdParty/FreeRTOS/tasks.c **** 	unsigned long ulTotalRunTime;
1333:../3rdParty/FreeRTOS/tasks.c **** 
1334:../3rdParty/FreeRTOS/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1335:../3rdParty/FreeRTOS/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1336:../3rdParty/FreeRTOS/tasks.c **** 
1337:../3rdParty/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
 6349              		.loc 1 1337 0
 6350 09d8 FFF7FEFF 		bl	vTaskSuspendAll
1338:../3rdParty/FreeRTOS/tasks.c **** 		{
1339:../3rdParty/FreeRTOS/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1340:../3rdParty/FreeRTOS/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1341:../3rdParty/FreeRTOS/tasks.c **** 			#else
1342:../3rdParty/FreeRTOS/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 6351              		.loc 1 1342 0
 6352 09dc 4FF04023 		mov	r3, #1073758208
 6353 09e0 9B68     		ldr	r3, [r3, #8]
 6354 09e2 BB60     		str	r3, [r7, #8]
1343:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1344:../3rdParty/FreeRTOS/tasks.c **** 
1345:../3rdParty/FreeRTOS/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1346:../3rdParty/FreeRTOS/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1347:../3rdParty/FreeRTOS/tasks.c **** 			ulTotalRunTime /= 100UL;
 6355              		.loc 1 1347 0
 6356 09e4 BA68     		ldr	r2, [r7, #8]
 6357 09e6 374B     		ldr	r3, .L123
 6358 09e8 A3FB0213 		umull	r1, r3, r3, r2
 6359 09ec 4FEA5313 		lsr	r3, r3, #5
 6360 09f0 BB60     		str	r3, [r7, #8]
1348:../3rdParty/FreeRTOS/tasks.c **** 			
1349:../3rdParty/FreeRTOS/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1350:../3rdParty/FreeRTOS/tasks.c **** 			generating a table of run timer percentages in the provided
1351:../3rdParty/FreeRTOS/tasks.c **** 			buffer. */
1352:../3rdParty/FreeRTOS/tasks.c **** 
1353:../3rdParty/FreeRTOS/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
 6361              		.loc 1 1353 0
 6362 09f2 7B68     		ldr	r3, [r7, #4]
 6363 09f4 4FF00002 		mov	r2, #0
 6364 09f8 1A70     		strb	r2, [r3, #0]
1354:../3rdParty/FreeRTOS/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 6365              		.loc 1 1354 0
 6366 09fa 7C68     		ldr	r4, [r7, #4]
 6367 09fc 2046     		mov	r0, r4
 6368 09fe FFF7FEFF 		bl	strlen
 6369 0a02 0346     		mov	r3, r0
 6370 0a04 E318     		adds	r3, r4, r3
 6371 0a06 1846     		mov	r0, r3
 6372 0a08 2F49     		ldr	r1, .L123+4
 6373 0a0a 4FF00302 		mov	r2, #3
 6374 0a0e FFF7FEFF 		bl	memcpy
1355:../3rdParty/FreeRTOS/tasks.c **** 
1356:../3rdParty/FreeRTOS/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 6375              		.loc 1 1356 0
 6376 0a12 2E4B     		ldr	r3, .L123+8
 6377 0a14 1B68     		ldr	r3, [r3, #0]
 6378 0a16 03F10103 		add	r3, r3, #1
 6379 0a1a FB60     		str	r3, [r7, #12]
 6380              	.L118:
1357:../3rdParty/FreeRTOS/tasks.c **** 
1358:../3rdParty/FreeRTOS/tasks.c **** 			do
1359:../3rdParty/FreeRTOS/tasks.c **** 			{
1360:../3rdParty/FreeRTOS/tasks.c **** 				uxQueue--;
 6381              		.loc 1 1360 0
 6382 0a1c FB68     		ldr	r3, [r7, #12]
 6383 0a1e 03F1FF33 		add	r3, r3, #-1
 6384 0a22 FB60     		str	r3, [r7, #12]
1361:../3rdParty/FreeRTOS/tasks.c **** 
1362:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 6385              		.loc 1 1362 0
 6386 0a24 FA68     		ldr	r2, [r7, #12]
 6387 0a26 1346     		mov	r3, r2
 6388 0a28 4FEA8303 		lsl	r3, r3, #2
 6389 0a2c 9B18     		adds	r3, r3, r2
 6390 0a2e 4FEA8303 		lsl	r3, r3, #2
 6391 0a32 1A46     		mov	r2, r3
 6392 0a34 264B     		ldr	r3, .L123+12
 6393 0a36 D318     		adds	r3, r2, r3
 6394 0a38 1B68     		ldr	r3, [r3, #0]
 6395 0a3a 002B     		cmp	r3, #0
 6396 0a3c 0ED0     		beq	.L117
1363:../3rdParty/FreeRTOS/tasks.c **** 				{
1364:../3rdParty/FreeRTOS/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
 6397              		.loc 1 1364 0
 6398 0a3e FA68     		ldr	r2, [r7, #12]
 6399 0a40 1346     		mov	r3, r2
 6400 0a42 4FEA8303 		lsl	r3, r3, #2
 6401 0a46 9B18     		adds	r3, r3, r2
 6402 0a48 4FEA8303 		lsl	r3, r3, #2
 6403 0a4c 1A46     		mov	r2, r3
 6404 0a4e 204B     		ldr	r3, .L123+12
 6405 0a50 D318     		adds	r3, r2, r3
 6406 0a52 7868     		ldr	r0, [r7, #4]
 6407 0a54 1946     		mov	r1, r3
 6408 0a56 BA68     		ldr	r2, [r7, #8]
 6409 0a58 00F034FC 		bl	prvGenerateRunTimeStatsForTasksInList
 6410              	.L117:
1365:../3rdParty/FreeRTOS/tasks.c **** 				}
1366:../3rdParty/FreeRTOS/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 6411              		.loc 1 1366 0
 6412 0a5c FB68     		ldr	r3, [r7, #12]
 6413 0a5e 002B     		cmp	r3, #0
 6414 0a60 DCD1     		bne	.L118
1367:../3rdParty/FreeRTOS/tasks.c **** 
1368:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 6415              		.loc 1 1368 0
 6416 0a62 1C4B     		ldr	r3, .L123+16
 6417 0a64 1B68     		ldr	r3, [r3, #0]
 6418 0a66 1B68     		ldr	r3, [r3, #0]
 6419 0a68 002B     		cmp	r3, #0
 6420 0a6a 06D0     		beq	.L119
1369:../3rdParty/FreeRTOS/tasks.c **** 			{
1370:../3rdParty/FreeRTOS/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
 6421              		.loc 1 1370 0
 6422 0a6c 194B     		ldr	r3, .L123+16
 6423 0a6e 1B68     		ldr	r3, [r3, #0]
 6424 0a70 7868     		ldr	r0, [r7, #4]
 6425 0a72 1946     		mov	r1, r3
 6426 0a74 BA68     		ldr	r2, [r7, #8]
 6427 0a76 00F025FC 		bl	prvGenerateRunTimeStatsForTasksInList
 6428              	.L119:
1371:../3rdParty/FreeRTOS/tasks.c **** 			}
1372:../3rdParty/FreeRTOS/tasks.c **** 
1373:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 6429              		.loc 1 1373 0
 6430 0a7a 174B     		ldr	r3, .L123+20
 6431 0a7c 1B68     		ldr	r3, [r3, #0]
 6432 0a7e 1B68     		ldr	r3, [r3, #0]
 6433 0a80 002B     		cmp	r3, #0
 6434 0a82 06D0     		beq	.L120
1374:../3rdParty/FreeRTOS/tasks.c **** 			{
1375:../3rdParty/FreeRTOS/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
 6435              		.loc 1 1375 0
 6436 0a84 144B     		ldr	r3, .L123+20
 6437 0a86 1B68     		ldr	r3, [r3, #0]
 6438 0a88 7868     		ldr	r0, [r7, #4]
 6439 0a8a 1946     		mov	r1, r3
 6440 0a8c BA68     		ldr	r2, [r7, #8]
 6441 0a8e 00F019FC 		bl	prvGenerateRunTimeStatsForTasksInList
 6442              	.L120:
1376:../3rdParty/FreeRTOS/tasks.c **** 			}
1377:../3rdParty/FreeRTOS/tasks.c **** 
1378:../3rdParty/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1379:../3rdParty/FreeRTOS/tasks.c **** 			{
1380:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 6443              		.loc 1 1380 0
 6444 0a92 124B     		ldr	r3, .L123+24
 6445 0a94 1B68     		ldr	r3, [r3, #0]
 6446 0a96 002B     		cmp	r3, #0
 6447 0a98 04D0     		beq	.L121
1381:../3rdParty/FreeRTOS/tasks.c **** 				{
1382:../3rdParty/FreeRTOS/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
 6448              		.loc 1 1382 0
 6449 0a9a 7868     		ldr	r0, [r7, #4]
 6450 0a9c 0F49     		ldr	r1, .L123+24
 6451 0a9e BA68     		ldr	r2, [r7, #8]
 6452 0aa0 00F010FC 		bl	prvGenerateRunTimeStatsForTasksInList
 6453              	.L121:
1383:../3rdParty/FreeRTOS/tasks.c **** 				}
1384:../3rdParty/FreeRTOS/tasks.c **** 			}
1385:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1386:../3rdParty/FreeRTOS/tasks.c **** 
1387:../3rdParty/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1388:../3rdParty/FreeRTOS/tasks.c **** 			{
1389:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 6454              		.loc 1 1389 0
 6455 0aa4 0E4B     		ldr	r3, .L123+28
 6456 0aa6 1B68     		ldr	r3, [r3, #0]
 6457 0aa8 002B     		cmp	r3, #0
 6458 0aaa 04D0     		beq	.L122
1390:../3rdParty/FreeRTOS/tasks.c **** 				{
1391:../3rdParty/FreeRTOS/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
 6459              		.loc 1 1391 0
 6460 0aac 7868     		ldr	r0, [r7, #4]
 6461 0aae 0C49     		ldr	r1, .L123+28
 6462 0ab0 BA68     		ldr	r2, [r7, #8]
 6463 0ab2 00F007FC 		bl	prvGenerateRunTimeStatsForTasksInList
 6464              	.L122:
1392:../3rdParty/FreeRTOS/tasks.c **** 				}
1393:../3rdParty/FreeRTOS/tasks.c **** 			}
1394:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1395:../3rdParty/FreeRTOS/tasks.c **** 		}
1396:../3rdParty/FreeRTOS/tasks.c **** 		xTaskResumeAll();
 6465              		.loc 1 1396 0
 6466 0ab6 FFF7FEFF 		bl	xTaskResumeAll
1397:../3rdParty/FreeRTOS/tasks.c **** 	}
 6467              		.loc 1 1397 0
 6468 0aba 07F11407 		add	r7, r7, #20
 6469 0abe BD46     		mov	sp, r7
 6470 0ac0 90BD     		pop	{r4, r7, pc}
 6471              	.L124:
 6472 0ac2 00BF     		.align	2
 6473              	.L123:
 6474 0ac4 1F85EB51 		.word	1374389535
 6475 0ac8 08000000 		.word	.LC1
 6476 0acc E0000000 		.word	uxTopUsedPriority
 6477 0ad0 04000000 		.word	pxReadyTasksLists
 6478 0ad4 90000000 		.word	pxDelayedTaskList
 6479 0ad8 94000000 		.word	pxOverflowDelayedTaskList
 6480 0adc AC000000 		.word	xTasksWaitingTermination
 6481 0ae0 C4000000 		.word	xSuspendedTaskList
 6482              		.cfi_endproc
 6483              	.LFE47:
 6485              		.align	2
 6486              		.global	vTaskIncrementTick
 6487              		.thumb
 6488              		.thumb_func
 6490              	vTaskIncrementTick:
 6491              	.LFB48:
1398:../3rdParty/FreeRTOS/tasks.c **** 
1399:../3rdParty/FreeRTOS/tasks.c **** #endif
1400:../3rdParty/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1401:../3rdParty/FreeRTOS/tasks.c **** 
1402:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1403:../3rdParty/FreeRTOS/tasks.c **** 
1404:../3rdParty/FreeRTOS/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1405:../3rdParty/FreeRTOS/tasks.c **** 	{
1406:../3rdParty/FreeRTOS/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1407:../3rdParty/FreeRTOS/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1408:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1409:../3rdParty/FreeRTOS/tasks.c **** 		return xIdleTaskHandle;
1410:../3rdParty/FreeRTOS/tasks.c **** 	}
1411:../3rdParty/FreeRTOS/tasks.c **** 	
1412:../3rdParty/FreeRTOS/tasks.c **** #endif
1413:../3rdParty/FreeRTOS/tasks.c **** 
1414:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1415:../3rdParty/FreeRTOS/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1416:../3rdParty/FreeRTOS/tasks.c ****  * documented in task.h
1417:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1418:../3rdParty/FreeRTOS/tasks.c **** 
1419:../3rdParty/FreeRTOS/tasks.c **** void vTaskIncrementTick( void )
1420:../3rdParty/FreeRTOS/tasks.c **** {
 6492              		.loc 1 1420 0
 6493              		.cfi_startproc
 6494              		@ args = 0, pretend = 0, frame = 16
 6495              		@ frame_needed = 1, uses_anonymous_args = 0
 6496 0ae4 80B5     		push	{r7, lr}
 6497              	.LCFI54:
 6498              		.cfi_def_cfa_offset 8
 6499 0ae6 84B0     		sub	sp, sp, #16
 6500              	.LCFI55:
 6501              		.cfi_def_cfa_offset 24
 6502 0ae8 00AF     		add	r7, sp, #0
 6503              		.cfi_offset 14, -4
 6504              		.cfi_offset 7, -8
 6505              	.LCFI56:
 6506              		.cfi_def_cfa_register 7
1421:../3rdParty/FreeRTOS/tasks.c **** tskTCB * pxTCB;
1422:../3rdParty/FreeRTOS/tasks.c **** 
1423:../3rdParty/FreeRTOS/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1424:../3rdParty/FreeRTOS/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1425:../3rdParty/FreeRTOS/tasks.c **** 	tasks to be unblocked. */
1426:../3rdParty/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 6507              		.loc 1 1426 0
 6508 0aea 454B     		ldr	r3, .L136
 6509 0aec 1B68     		ldr	r3, [r3, #0]
 6510 0aee 002B     		cmp	r3, #0
 6511 0af0 7AD1     		bne	.L126
1427:../3rdParty/FreeRTOS/tasks.c **** 	{
1428:../3rdParty/FreeRTOS/tasks.c **** 		++xTickCount;
 6512              		.loc 1 1428 0
 6513 0af2 444B     		ldr	r3, .L136+4
 6514 0af4 1B68     		ldr	r3, [r3, #0]
 6515 0af6 03F10102 		add	r2, r3, #1
 6516 0afa 424B     		ldr	r3, .L136+4
 6517 0afc 1A60     		str	r2, [r3, #0]
1429:../3rdParty/FreeRTOS/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 6518              		.loc 1 1429 0
 6519 0afe 414B     		ldr	r3, .L136+4
 6520 0b00 1B68     		ldr	r3, [r3, #0]
 6521 0b02 002B     		cmp	r3, #0
 6522 0b04 22D1     		bne	.L127
 6523              	.LBB4:
1430:../3rdParty/FreeRTOS/tasks.c **** 		{
1431:../3rdParty/FreeRTOS/tasks.c **** 			xList *pxTemp;
1432:../3rdParty/FreeRTOS/tasks.c **** 
1433:../3rdParty/FreeRTOS/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1434:../3rdParty/FreeRTOS/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1435:../3rdParty/FreeRTOS/tasks.c **** 			an error! */
1436:../3rdParty/FreeRTOS/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1437:../3rdParty/FreeRTOS/tasks.c **** 			
1438:../3rdParty/FreeRTOS/tasks.c **** 			pxTemp = pxDelayedTaskList;
 6524              		.loc 1 1438 0
 6525 0b06 404B     		ldr	r3, .L136+8
 6526 0b08 1B68     		ldr	r3, [r3, #0]
 6527 0b0a FB60     		str	r3, [r7, #12]
1439:../3rdParty/FreeRTOS/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 6528              		.loc 1 1439 0
 6529 0b0c 3F4B     		ldr	r3, .L136+12
 6530 0b0e 1A68     		ldr	r2, [r3, #0]
 6531 0b10 3D4B     		ldr	r3, .L136+8
 6532 0b12 1A60     		str	r2, [r3, #0]
1440:../3rdParty/FreeRTOS/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 6533              		.loc 1 1440 0
 6534 0b14 3D4B     		ldr	r3, .L136+12
 6535 0b16 FA68     		ldr	r2, [r7, #12]
 6536 0b18 1A60     		str	r2, [r3, #0]
1441:../3rdParty/FreeRTOS/tasks.c **** 			xNumOfOverflows++;
 6537              		.loc 1 1441 0
 6538 0b1a 3D4B     		ldr	r3, .L136+16
 6539 0b1c 1B68     		ldr	r3, [r3, #0]
 6540 0b1e 03F10102 		add	r2, r3, #1
 6541 0b22 3B4B     		ldr	r3, .L136+16
 6542 0b24 1A60     		str	r2, [r3, #0]
1442:../3rdParty/FreeRTOS/tasks.c **** 	
1443:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 6543              		.loc 1 1443 0
 6544 0b26 384B     		ldr	r3, .L136+8
 6545 0b28 1B68     		ldr	r3, [r3, #0]
 6546 0b2a 1B68     		ldr	r3, [r3, #0]
 6547 0b2c 002B     		cmp	r3, #0
 6548 0b2e 04D1     		bne	.L128
1444:../3rdParty/FreeRTOS/tasks.c **** 			{
1445:../3rdParty/FreeRTOS/tasks.c **** 				/* The new current delayed list is empty.  Set
1446:../3rdParty/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1447:../3rdParty/FreeRTOS/tasks.c **** 				extremely unlikely that the	
1448:../3rdParty/FreeRTOS/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1449:../3rdParty/FreeRTOS/tasks.c **** 				there is an item in the delayed list. */
1450:../3rdParty/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 6549              		.loc 1 1450 0
 6550 0b30 384B     		ldr	r3, .L136+20
 6551 0b32 4FF0FF32 		mov	r2, #-1
 6552 0b36 1A60     		str	r2, [r3, #0]
 6553 0b38 08E0     		b	.L127
 6554              	.L128:
1451:../3rdParty/FreeRTOS/tasks.c **** 			}
1452:../3rdParty/FreeRTOS/tasks.c **** 			else
1453:../3rdParty/FreeRTOS/tasks.c **** 			{
1454:../3rdParty/FreeRTOS/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1455:../3rdParty/FreeRTOS/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1456:../3rdParty/FreeRTOS/tasks.c **** 				which the task at the head of the delayed list should be removed
1457:../3rdParty/FreeRTOS/tasks.c **** 				from the Blocked state. */
1458:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 6555              		.loc 1 1458 0
 6556 0b3a 334B     		ldr	r3, .L136+8
 6557 0b3c 1B68     		ldr	r3, [r3, #0]
 6558 0b3e DB68     		ldr	r3, [r3, #12]
 6559 0b40 DB68     		ldr	r3, [r3, #12]
 6560 0b42 BB60     		str	r3, [r7, #8]
1459:../3rdParty/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 6561              		.loc 1 1459 0
 6562 0b44 BB68     		ldr	r3, [r7, #8]
 6563 0b46 5A68     		ldr	r2, [r3, #4]
 6564 0b48 324B     		ldr	r3, .L136+20
 6565 0b4a 1A60     		str	r2, [r3, #0]
 6566              	.L127:
 6567              	.LBE4:
 6568              	.LBB5:
1460:../3rdParty/FreeRTOS/tasks.c **** 			}
1461:../3rdParty/FreeRTOS/tasks.c **** 		}
1462:../3rdParty/FreeRTOS/tasks.c **** 
1463:../3rdParty/FreeRTOS/tasks.c **** 		/* See if this tick has made a timeout expire. */
1464:../3rdParty/FreeRTOS/tasks.c **** 		prvCheckDelayedTasks();
 6569              		.loc 1 1464 0
 6570 0b4c 2D4B     		ldr	r3, .L136+4
 6571 0b4e 1A68     		ldr	r2, [r3, #0]
 6572 0b50 304B     		ldr	r3, .L136+20
 6573 0b52 1B68     		ldr	r3, [r3, #0]
 6574 0b54 9A42     		cmp	r2, r3
 6575 0b56 4DD3     		bcc	.L135
 6576              	.L134:
 6577              		.loc 1 1464 0 is_stmt 0 discriminator 1
 6578 0b58 2B4B     		ldr	r3, .L136+8
 6579 0b5a 1B68     		ldr	r3, [r3, #0]
 6580 0b5c 1B68     		ldr	r3, [r3, #0]
 6581 0b5e 002B     		cmp	r3, #0
 6582 0b60 04D1     		bne	.L130
 6583              		.loc 1 1464 0 discriminator 2
 6584 0b62 2C4B     		ldr	r3, .L136+20
 6585 0b64 4FF0FF32 		mov	r2, #-1
 6586 0b68 1A60     		str	r2, [r3, #0]
 6587 0b6a 43E0     		b	.L135
 6588              	.L130:
 6589              		.loc 1 1464 0 discriminator 3
 6590 0b6c 264B     		ldr	r3, .L136+8
 6591 0b6e 1B68     		ldr	r3, [r3, #0]
 6592 0b70 DB68     		ldr	r3, [r3, #12]
 6593 0b72 DB68     		ldr	r3, [r3, #12]
 6594 0b74 BB60     		str	r3, [r7, #8]
 6595 0b76 BB68     		ldr	r3, [r7, #8]
 6596 0b78 5B68     		ldr	r3, [r3, #4]
 6597 0b7a 7B60     		str	r3, [r7, #4]
 6598 0b7c 214B     		ldr	r3, .L136+4
 6599 0b7e 1A68     		ldr	r2, [r3, #0]
 6600 0b80 7B68     		ldr	r3, [r7, #4]
 6601 0b82 9A42     		cmp	r2, r3
 6602 0b84 03D2     		bcs	.L131
 6603              		.loc 1 1464 0 discriminator 4
 6604 0b86 234B     		ldr	r3, .L136+20
 6605 0b88 7A68     		ldr	r2, [r7, #4]
 6606 0b8a 1A60     		str	r2, [r3, #0]
 6607 0b8c 32E0     		b	.L135
 6608              	.L131:
 6609              		.loc 1 1464 0 discriminator 5
 6610 0b8e BB68     		ldr	r3, [r7, #8]
 6611 0b90 03F10403 		add	r3, r3, #4
 6612 0b94 1846     		mov	r0, r3
 6613 0b96 FFF7FEFF 		bl	vListRemove
 6614 0b9a BB68     		ldr	r3, [r7, #8]
 6615 0b9c 9B6A     		ldr	r3, [r3, #40]
 6616 0b9e 002B     		cmp	r3, #0
 6617 0ba0 05D0     		beq	.L132
 6618              		.loc 1 1464 0 discriminator 6
 6619 0ba2 BB68     		ldr	r3, [r7, #8]
 6620 0ba4 03F11803 		add	r3, r3, #24
 6621 0ba8 1846     		mov	r0, r3
 6622 0baa FFF7FEFF 		bl	vListRemove
 6623              	.L132:
 6624              		.loc 1 1464 0 discriminator 7
 6625 0bae BB68     		ldr	r3, [r7, #8]
 6626 0bb0 DA6A     		ldr	r2, [r3, #44]
 6627 0bb2 194B     		ldr	r3, .L136+24
 6628 0bb4 1B68     		ldr	r3, [r3, #0]
 6629 0bb6 9A42     		cmp	r2, r3
 6630 0bb8 03D9     		bls	.L133
 6631              		.loc 1 1464 0 discriminator 8
 6632 0bba BB68     		ldr	r3, [r7, #8]
 6633 0bbc DA6A     		ldr	r2, [r3, #44]
 6634 0bbe 164B     		ldr	r3, .L136+24
 6635 0bc0 1A60     		str	r2, [r3, #0]
 6636              	.L133:
 6637              		.loc 1 1464 0 discriminator 9
 6638 0bc2 BB68     		ldr	r3, [r7, #8]
 6639 0bc4 DA6A     		ldr	r2, [r3, #44]
 6640 0bc6 1346     		mov	r3, r2
 6641 0bc8 4FEA8303 		lsl	r3, r3, #2
 6642 0bcc 9B18     		adds	r3, r3, r2
 6643 0bce 4FEA8303 		lsl	r3, r3, #2
 6644 0bd2 1A46     		mov	r2, r3
 6645 0bd4 114B     		ldr	r3, .L136+28
 6646 0bd6 D218     		adds	r2, r2, r3
 6647 0bd8 BB68     		ldr	r3, [r7, #8]
 6648 0bda 03F10403 		add	r3, r3, #4
 6649 0bde 1046     		mov	r0, r2
 6650 0be0 1946     		mov	r1, r3
 6651 0be2 FFF7FEFF 		bl	vListInsertEnd
 6652 0be6 B7E7     		b	.L134
 6653              	.L126:
 6654              	.LBE5:
1465:../3rdParty/FreeRTOS/tasks.c **** 	}
1466:../3rdParty/FreeRTOS/tasks.c **** 	else
1467:../3rdParty/FreeRTOS/tasks.c **** 	{
1468:../3rdParty/FreeRTOS/tasks.c **** 		++uxMissedTicks;
 6655              		.loc 1 1468 0 is_stmt 1
 6656 0be8 0D4B     		ldr	r3, .L136+32
 6657 0bea 1B68     		ldr	r3, [r3, #0]
 6658 0bec 03F10102 		add	r2, r3, #1
 6659 0bf0 0B4B     		ldr	r3, .L136+32
 6660 0bf2 1A60     		str	r2, [r3, #0]
 6661              	.L135:
1469:../3rdParty/FreeRTOS/tasks.c **** 
1470:../3rdParty/FreeRTOS/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1471:../3rdParty/FreeRTOS/tasks.c **** 		scheduler is locked. */
1472:../3rdParty/FreeRTOS/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1473:../3rdParty/FreeRTOS/tasks.c **** 		{
1474:../3rdParty/FreeRTOS/tasks.c **** 			//vApplicationTickHook();
1475:../3rdParty/FreeRTOS/tasks.c **** 		}
1476:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1477:../3rdParty/FreeRTOS/tasks.c **** 	}
1478:../3rdParty/FreeRTOS/tasks.c **** 
1479:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1480:../3rdParty/FreeRTOS/tasks.c **** 	{
1481:../3rdParty/FreeRTOS/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1482:../3rdParty/FreeRTOS/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1483:../3rdParty/FreeRTOS/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
 6662              		.loc 1 1483 0
 6663 0bf4 0A4B     		ldr	r3, .L136+32
 6664 0bf6 1B68     		ldr	r3, [r3, #0]
1484:../3rdParty/FreeRTOS/tasks.c **** 		{
1485:../3rdParty/FreeRTOS/tasks.c **** 			//vApplicationTickHook();
1486:../3rdParty/FreeRTOS/tasks.c **** 		}
1487:../3rdParty/FreeRTOS/tasks.c **** 	}
1488:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1489:../3rdParty/FreeRTOS/tasks.c **** 
1490:../3rdParty/FreeRTOS/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1491:../3rdParty/FreeRTOS/tasks.c **** }
 6665              		.loc 1 1491 0
 6666 0bf8 07F11007 		add	r7, r7, #16
 6667 0bfc BD46     		mov	sp, r7
 6668 0bfe 80BD     		pop	{r7, pc}
 6669              	.L137:
 6670              		.align	2
 6671              	.L136:
 6672 0c00 EC000000 		.word	uxSchedulerSuspended
 6673 0c04 DC000000 		.word	xTickCount
 6674 0c08 90000000 		.word	pxDelayedTaskList
 6675 0c0c 94000000 		.word	pxOverflowDelayedTaskList
 6676 0c10 F8000000 		.word	xNumOfOverflows
 6677 0c14 00000000 		.word	xNextTaskUnblockTime
 6678 0c18 E4000000 		.word	uxTopReadyPriority
 6679 0c1c 04000000 		.word	pxReadyTasksLists
 6680 0c20 F0000000 		.word	uxMissedTicks
 6681              		.cfi_endproc
 6682              	.LFE48:
 6684              		.align	2
 6685              		.global	vTaskSwitchContext
 6686              		.thumb
 6687              		.thumb_func
 6689              	vTaskSwitchContext:
 6690              	.LFB49:
1492:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1493:../3rdParty/FreeRTOS/tasks.c **** 
1494:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1495:../3rdParty/FreeRTOS/tasks.c **** 
1496:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1497:../3rdParty/FreeRTOS/tasks.c **** 	{
1498:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *xTCB;
1499:../3rdParty/FreeRTOS/tasks.c **** 
1500:../3rdParty/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1501:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask == NULL )
1502:../3rdParty/FreeRTOS/tasks.c **** 		{
1503:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1504:../3rdParty/FreeRTOS/tasks.c **** 		}
1505:../3rdParty/FreeRTOS/tasks.c **** 		else
1506:../3rdParty/FreeRTOS/tasks.c **** 		{
1507:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1508:../3rdParty/FreeRTOS/tasks.c **** 		}
1509:../3rdParty/FreeRTOS/tasks.c **** 
1510:../3rdParty/FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1511:../3rdParty/FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
1512:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
1513:../3rdParty/FreeRTOS/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1514:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
1515:../3rdParty/FreeRTOS/tasks.c **** 	}
1516:../3rdParty/FreeRTOS/tasks.c **** 
1517:../3rdParty/FreeRTOS/tasks.c **** #endif
1518:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1519:../3rdParty/FreeRTOS/tasks.c **** 
1520:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1521:../3rdParty/FreeRTOS/tasks.c **** 
1522:../3rdParty/FreeRTOS/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1523:../3rdParty/FreeRTOS/tasks.c **** 	{
1524:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *xTCB;
1525:../3rdParty/FreeRTOS/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1526:../3rdParty/FreeRTOS/tasks.c **** 
1527:../3rdParty/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1528:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask == NULL )
1529:../3rdParty/FreeRTOS/tasks.c **** 		{
1530:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1531:../3rdParty/FreeRTOS/tasks.c **** 		}
1532:../3rdParty/FreeRTOS/tasks.c **** 		else
1533:../3rdParty/FreeRTOS/tasks.c **** 		{
1534:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1535:../3rdParty/FreeRTOS/tasks.c **** 		}
1536:../3rdParty/FreeRTOS/tasks.c **** 
1537:../3rdParty/FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1538:../3rdParty/FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
1539:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
1540:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1541:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
1542:../3rdParty/FreeRTOS/tasks.c **** 
1543:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
1544:../3rdParty/FreeRTOS/tasks.c **** 	}
1545:../3rdParty/FreeRTOS/tasks.c **** 
1546:../3rdParty/FreeRTOS/tasks.c **** #endif
1547:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1548:../3rdParty/FreeRTOS/tasks.c **** 
1549:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1550:../3rdParty/FreeRTOS/tasks.c **** 
1551:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1552:../3rdParty/FreeRTOS/tasks.c **** 	{
1553:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *xTCB;
1554:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xReturn;
1555:../3rdParty/FreeRTOS/tasks.c **** 
1556:../3rdParty/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1557:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask == NULL )
1558:../3rdParty/FreeRTOS/tasks.c **** 		{
1559:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1560:../3rdParty/FreeRTOS/tasks.c **** 		}
1561:../3rdParty/FreeRTOS/tasks.c **** 		else
1562:../3rdParty/FreeRTOS/tasks.c **** 		{
1563:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1564:../3rdParty/FreeRTOS/tasks.c **** 		}
1565:../3rdParty/FreeRTOS/tasks.c **** 
1566:../3rdParty/FreeRTOS/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1567:../3rdParty/FreeRTOS/tasks.c **** 		{
1568:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1569:../3rdParty/FreeRTOS/tasks.c **** 		}
1570:../3rdParty/FreeRTOS/tasks.c **** 		else
1571:../3rdParty/FreeRTOS/tasks.c **** 		{
1572:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdFAIL;
1573:../3rdParty/FreeRTOS/tasks.c **** 		}
1574:../3rdParty/FreeRTOS/tasks.c **** 
1575:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
1576:../3rdParty/FreeRTOS/tasks.c **** 	}
1577:../3rdParty/FreeRTOS/tasks.c **** 
1578:../3rdParty/FreeRTOS/tasks.c **** #endif
1579:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1580:../3rdParty/FreeRTOS/tasks.c **** 
1581:../3rdParty/FreeRTOS/tasks.c **** void vTaskSwitchContext( void )
1582:../3rdParty/FreeRTOS/tasks.c **** {
 6691              		.loc 1 1582 0
 6692              		.cfi_startproc
 6693              		@ args = 0, pretend = 0, frame = 8
 6694              		@ frame_needed = 1, uses_anonymous_args = 0
 6695 0c24 80B5     		push	{r7, lr}
 6696              	.LCFI57:
 6697              		.cfi_def_cfa_offset 8
 6698 0c26 82B0     		sub	sp, sp, #8
 6699              	.LCFI58:
 6700              		.cfi_def_cfa_offset 16
 6701 0c28 00AF     		add	r7, sp, #0
 6702              		.cfi_offset 14, -4
 6703              		.cfi_offset 7, -8
 6704              	.LCFI59:
 6705              		.cfi_def_cfa_register 7
1583:../3rdParty/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 6706              		.loc 1 1583 0
 6707 0c2a 404B     		ldr	r3, .L147
 6708 0c2c 1B68     		ldr	r3, [r3, #0]
 6709 0c2e 002B     		cmp	r3, #0
 6710 0c30 04D0     		beq	.L139
1584:../3rdParty/FreeRTOS/tasks.c **** 	{
1585:../3rdParty/FreeRTOS/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1586:../3rdParty/FreeRTOS/tasks.c **** 		switch. */
1587:../3rdParty/FreeRTOS/tasks.c **** 		xMissedYield = pdTRUE;
 6711              		.loc 1 1587 0
 6712 0c32 3F4B     		ldr	r3, .L147+4
 6713 0c34 4FF00102 		mov	r2, #1
 6714 0c38 1A60     		str	r2, [r3, #0]
 6715 0c3a 73E0     		b	.L138
 6716              	.L139:
 6717              	.LBB6:
1588:../3rdParty/FreeRTOS/tasks.c **** 	}
1589:../3rdParty/FreeRTOS/tasks.c **** 	else
1590:../3rdParty/FreeRTOS/tasks.c **** 	{
1591:../3rdParty/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_OUT();
1592:../3rdParty/FreeRTOS/tasks.c **** 	
1593:../3rdParty/FreeRTOS/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1594:../3rdParty/FreeRTOS/tasks.c **** 		{
1595:../3rdParty/FreeRTOS/tasks.c **** 			unsigned long ulTempCounter;
1596:../3rdParty/FreeRTOS/tasks.c **** 			
1597:../3rdParty/FreeRTOS/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1598:../3rdParty/FreeRTOS/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1599:../3rdParty/FreeRTOS/tasks.c **** 				#else
1600:../3rdParty/FreeRTOS/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 6718              		.loc 1 1600 0
 6719 0c3c 4FF04023 		mov	r3, #1073758208
 6720 0c40 9B68     		ldr	r3, [r3, #8]
 6721 0c42 7B60     		str	r3, [r7, #4]
1601:../3rdParty/FreeRTOS/tasks.c **** 				#endif
1602:../3rdParty/FreeRTOS/tasks.c **** 	
1603:../3rdParty/FreeRTOS/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1604:../3rdParty/FreeRTOS/tasks.c **** 				time so far.  The time the task started running was stored in
1605:../3rdParty/FreeRTOS/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1606:../3rdParty/FreeRTOS/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1607:../3rdParty/FreeRTOS/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1608:../3rdParty/FreeRTOS/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 6722              		.loc 1 1608 0
 6723 0c44 3B4B     		ldr	r3, .L147+8
 6724 0c46 1B68     		ldr	r3, [r3, #0]
 6725 0c48 D96C     		ldr	r1, [r3, #76]
 6726 0c4a 3B4A     		ldr	r2, .L147+12
 6727 0c4c 1268     		ldr	r2, [r2, #0]
 6728 0c4e 7868     		ldr	r0, [r7, #4]
 6729 0c50 821A     		subs	r2, r0, r2
 6730 0c52 8A18     		adds	r2, r1, r2
 6731 0c54 DA64     		str	r2, [r3, #76]
1609:../3rdParty/FreeRTOS/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
 6732              		.loc 1 1609 0
 6733 0c56 384B     		ldr	r3, .L147+12
 6734 0c58 7A68     		ldr	r2, [r7, #4]
 6735 0c5a 1A60     		str	r2, [r3, #0]
 6736              	.LBE6:
1610:../3rdParty/FreeRTOS/tasks.c **** 		}
1611:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1612:../3rdParty/FreeRTOS/tasks.c **** 	
1613:../3rdParty/FreeRTOS/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 6737              		.loc 1 1613 0
 6738 0c5c 354B     		ldr	r3, .L147+8
 6739 0c5e 1B68     		ldr	r3, [r3, #0]
 6740 0c60 1A68     		ldr	r2, [r3, #0]
 6741 0c62 344B     		ldr	r3, .L147+8
 6742 0c64 1B68     		ldr	r3, [r3, #0]
 6743 0c66 1B6B     		ldr	r3, [r3, #48]
 6744 0c68 9A42     		cmp	r2, r3
 6745 0c6a 0AD8     		bhi	.L141
 6746              		.loc 1 1613 0 is_stmt 0 discriminator 1
 6747 0c6c 314B     		ldr	r3, .L147+8
 6748 0c6e 1B68     		ldr	r3, [r3, #0]
 6749 0c70 1A46     		mov	r2, r3
 6750 0c72 304B     		ldr	r3, .L147+8
 6751 0c74 1B68     		ldr	r3, [r3, #0]
 6752 0c76 03F13403 		add	r3, r3, #52
 6753 0c7a 1046     		mov	r0, r2
 6754 0c7c 1946     		mov	r1, r3
 6755 0c7e FFF7FEFF 		bl	vApplicationStackOverflowHook
 6756              	.L141:
 6757              	.LBB7:
1614:../3rdParty/FreeRTOS/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 6758              		.loc 1 1614 0 is_stmt 1
 6759 0c82 2C4B     		ldr	r3, .L147+8
 6760 0c84 1B68     		ldr	r3, [r3, #0]
 6761 0c86 1B6B     		ldr	r3, [r3, #48]
 6762 0c88 1846     		mov	r0, r3
 6763 0c8a 2C49     		ldr	r1, .L147+16
 6764 0c8c 4FF01402 		mov	r2, #20
 6765 0c90 FFF7FEFF 		bl	memcmp
 6766 0c94 0346     		mov	r3, r0
 6767 0c96 002B     		cmp	r3, #0
 6768 0c98 12D0     		beq	.L146
 6769              		.loc 1 1614 0 is_stmt 0 discriminator 1
 6770 0c9a 264B     		ldr	r3, .L147+8
 6771 0c9c 1B68     		ldr	r3, [r3, #0]
 6772 0c9e 1A46     		mov	r2, r3
 6773 0ca0 244B     		ldr	r3, .L147+8
 6774 0ca2 1B68     		ldr	r3, [r3, #0]
 6775 0ca4 03F13403 		add	r3, r3, #52
 6776 0ca8 1046     		mov	r0, r2
 6777 0caa 1946     		mov	r1, r3
 6778 0cac FFF7FEFF 		bl	vApplicationStackOverflowHook
 6779              	.LBE7:
1615:../3rdParty/FreeRTOS/tasks.c **** 	
1616:../3rdParty/FreeRTOS/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */
1617:../3rdParty/FreeRTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 6780              		.loc 1 1617 0 is_stmt 1 discriminator 1
 6781 0cb0 07E0     		b	.L143
 6782              	.L144:
1618:../3rdParty/FreeRTOS/tasks.c **** 		{
1619:../3rdParty/FreeRTOS/tasks.c **** 			configASSERT( uxTopReadyPriority );
1620:../3rdParty/FreeRTOS/tasks.c **** 			--uxTopReadyPriority;
 6783              		.loc 1 1620 0
 6784 0cb2 234B     		ldr	r3, .L147+20
 6785 0cb4 1B68     		ldr	r3, [r3, #0]
 6786 0cb6 03F1FF32 		add	r2, r3, #-1
 6787 0cba 214B     		ldr	r3, .L147+20
 6788 0cbc 1A60     		str	r2, [r3, #0]
 6789 0cbe 00E0     		b	.L143
 6790              	.L146:
1617:../3rdParty/FreeRTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 6791              		.loc 1 1617 0
 6792 0cc0 00BF     		nop
 6793              	.L143:
1617:../3rdParty/FreeRTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 6794              		.loc 1 1617 0 is_stmt 0 discriminator 1
 6795 0cc2 1F4B     		ldr	r3, .L147+20
 6796 0cc4 1A68     		ldr	r2, [r3, #0]
 6797 0cc6 1346     		mov	r3, r2
 6798 0cc8 4FEA8303 		lsl	r3, r3, #2
 6799 0ccc 9B18     		adds	r3, r3, r2
 6800 0cce 4FEA8303 		lsl	r3, r3, #2
 6801 0cd2 1A46     		mov	r2, r3
 6802 0cd4 1B4B     		ldr	r3, .L147+24
 6803 0cd6 D318     		adds	r3, r2, r3
 6804 0cd8 1B68     		ldr	r3, [r3, #0]
 6805 0cda 002B     		cmp	r3, #0
 6806 0cdc E9D0     		beq	.L144
 6807              	.LBB8:
1621:../3rdParty/FreeRTOS/tasks.c **** 		}
1622:../3rdParty/FreeRTOS/tasks.c **** 	
1623:../3rdParty/FreeRTOS/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1624:../3rdParty/FreeRTOS/tasks.c **** 		same priority get an equal share of the processor time. */
1625:../3rdParty/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 6808              		.loc 1 1625 0 is_stmt 1
 6809 0cde 184B     		ldr	r3, .L147+20
 6810 0ce0 1A68     		ldr	r2, [r3, #0]
 6811 0ce2 1346     		mov	r3, r2
 6812 0ce4 4FEA8303 		lsl	r3, r3, #2
 6813 0ce8 9B18     		adds	r3, r3, r2
 6814 0cea 4FEA8303 		lsl	r3, r3, #2
 6815 0cee 1A46     		mov	r2, r3
 6816 0cf0 144B     		ldr	r3, .L147+24
 6817 0cf2 D318     		adds	r3, r2, r3
 6818 0cf4 3B60     		str	r3, [r7, #0]
 6819 0cf6 3B68     		ldr	r3, [r7, #0]
 6820 0cf8 5B68     		ldr	r3, [r3, #4]
 6821 0cfa 5A68     		ldr	r2, [r3, #4]
 6822 0cfc 3B68     		ldr	r3, [r7, #0]
 6823 0cfe 5A60     		str	r2, [r3, #4]
 6824 0d00 3B68     		ldr	r3, [r7, #0]
 6825 0d02 5A68     		ldr	r2, [r3, #4]
 6826 0d04 3B68     		ldr	r3, [r7, #0]
 6827 0d06 03F10803 		add	r3, r3, #8
 6828 0d0a 9A42     		cmp	r2, r3
 6829 0d0c 04D1     		bne	.L145
 6830              		.loc 1 1625 0 is_stmt 0 discriminator 1
 6831 0d0e 3B68     		ldr	r3, [r7, #0]
 6832 0d10 5B68     		ldr	r3, [r3, #4]
 6833 0d12 5A68     		ldr	r2, [r3, #4]
 6834 0d14 3B68     		ldr	r3, [r7, #0]
 6835 0d16 5A60     		str	r2, [r3, #4]
 6836              	.L145:
 6837              		.loc 1 1625 0 discriminator 2
 6838 0d18 3B68     		ldr	r3, [r7, #0]
 6839 0d1a 5B68     		ldr	r3, [r3, #4]
 6840 0d1c DB68     		ldr	r3, [r3, #12]
 6841 0d1e 1A46     		mov	r2, r3
 6842 0d20 044B     		ldr	r3, .L147+8
 6843 0d22 1A60     		str	r2, [r3, #0]
 6844              	.L138:
 6845              	.LBE8:
1626:../3rdParty/FreeRTOS/tasks.c **** 	
1627:../3rdParty/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
1628:../3rdParty/FreeRTOS/tasks.c **** 	}
1629:../3rdParty/FreeRTOS/tasks.c **** }
 6846              		.loc 1 1629 0 is_stmt 1
 6847 0d24 07F10807 		add	r7, r7, #8
 6848 0d28 BD46     		mov	sp, r7
 6849 0d2a 80BD     		pop	{r7, pc}
 6850              	.L148:
 6851              		.align	2
 6852              	.L147:
 6853 0d2c EC000000 		.word	uxSchedulerSuspended
 6854 0d30 F4000000 		.word	xMissedYield
 6855 0d34 00000000 		.word	pxCurrentTCB
 6856 0d38 34010000 		.word	ulTaskSwitchedInTime
 6857 0d3c 50000000 		.word	ucExpectedStackBytes.6806
 6858 0d40 E4000000 		.word	uxTopReadyPriority
 6859 0d44 04000000 		.word	pxReadyTasksLists
 6860              		.cfi_endproc
 6861              	.LFE49:
 6863              		.align	2
 6864              		.global	vTaskPlaceOnEventList
 6865              		.thumb
 6866              		.thumb_func
 6868              	vTaskPlaceOnEventList:
 6869              	.LFB50:
1630:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1631:../3rdParty/FreeRTOS/tasks.c **** 
1632:../3rdParty/FreeRTOS/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1633:../3rdParty/FreeRTOS/tasks.c **** {
 6870              		.loc 1 1633 0
 6871              		.cfi_startproc
 6872              		@ args = 0, pretend = 0, frame = 16
 6873              		@ frame_needed = 1, uses_anonymous_args = 0
 6874 0d48 80B5     		push	{r7, lr}
 6875              	.LCFI60:
 6876              		.cfi_def_cfa_offset 8
 6877 0d4a 84B0     		sub	sp, sp, #16
 6878              	.LCFI61:
 6879              		.cfi_def_cfa_offset 24
 6880 0d4c 00AF     		add	r7, sp, #0
 6881              		.cfi_offset 14, -4
 6882              		.cfi_offset 7, -8
 6883              	.LCFI62:
 6884              		.cfi_def_cfa_register 7
 6885 0d4e 7860     		str	r0, [r7, #4]
 6886 0d50 3960     		str	r1, [r7, #0]
1634:../3rdParty/FreeRTOS/tasks.c **** portTickType xTimeToWake;
1635:../3rdParty/FreeRTOS/tasks.c **** 
1636:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxEventList );
1637:../3rdParty/FreeRTOS/tasks.c **** 
1638:../3rdParty/FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1639:../3rdParty/FreeRTOS/tasks.c **** 	SCHEDULER SUSPENDED. */
1640:../3rdParty/FreeRTOS/tasks.c **** 
1641:../3rdParty/FreeRTOS/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1642:../3rdParty/FreeRTOS/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1643:../3rdParty/FreeRTOS/tasks.c **** 	is the first to be woken by the event. */
1644:../3rdParty/FreeRTOS/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 6887              		.loc 1 1644 0
 6888 0d52 144B     		ldr	r3, .L152
 6889 0d54 1B68     		ldr	r3, [r3, #0]
 6890 0d56 03F11803 		add	r3, r3, #24
 6891 0d5a 7868     		ldr	r0, [r7, #4]
 6892 0d5c 1946     		mov	r1, r3
 6893 0d5e FFF7FEFF 		bl	vListInsert
1645:../3rdParty/FreeRTOS/tasks.c **** 
1646:../3rdParty/FreeRTOS/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1647:../3rdParty/FreeRTOS/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1648:../3rdParty/FreeRTOS/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1649:../3rdParty/FreeRTOS/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 6894              		.loc 1 1649 0
 6895 0d62 104B     		ldr	r3, .L152
 6896 0d64 1B68     		ldr	r3, [r3, #0]
 6897 0d66 03F10403 		add	r3, r3, #4
 6898 0d6a 1846     		mov	r0, r3
 6899 0d6c FFF7FEFF 		bl	vListRemove
1650:../3rdParty/FreeRTOS/tasks.c **** 
1651:../3rdParty/FreeRTOS/tasks.c **** 
1652:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1653:../3rdParty/FreeRTOS/tasks.c **** 	{
1654:../3rdParty/FreeRTOS/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 6900              		.loc 1 1654 0
 6901 0d70 3B68     		ldr	r3, [r7, #0]
 6902 0d72 B3F1FF3F 		cmp	r3, #-1
 6903 0d76 08D1     		bne	.L150
1655:../3rdParty/FreeRTOS/tasks.c **** 		{
1656:../3rdParty/FreeRTOS/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1657:../3rdParty/FreeRTOS/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1658:../3rdParty/FreeRTOS/tasks.c **** 			indefinitely. */
1659:../3rdParty/FreeRTOS/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 6904              		.loc 1 1659 0
 6905 0d78 0A4B     		ldr	r3, .L152
 6906 0d7a 1B68     		ldr	r3, [r3, #0]
 6907 0d7c 03F10403 		add	r3, r3, #4
 6908 0d80 0948     		ldr	r0, .L152+4
 6909 0d82 1946     		mov	r1, r3
 6910 0d84 FFF7FEFF 		bl	vListInsertEnd
 6911 0d88 07E0     		b	.L149
 6912              	.L150:
1660:../3rdParty/FreeRTOS/tasks.c **** 		}
1661:../3rdParty/FreeRTOS/tasks.c **** 		else
1662:../3rdParty/FreeRTOS/tasks.c **** 		{
1663:../3rdParty/FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1664:../3rdParty/FreeRTOS/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1665:../3rdParty/FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 6913              		.loc 1 1665 0
 6914 0d8a 084B     		ldr	r3, .L152+8
 6915 0d8c 1A68     		ldr	r2, [r3, #0]
 6916 0d8e 3B68     		ldr	r3, [r7, #0]
 6917 0d90 D318     		adds	r3, r2, r3
 6918 0d92 FB60     		str	r3, [r7, #12]
1666:../3rdParty/FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 6919              		.loc 1 1666 0
 6920 0d94 F868     		ldr	r0, [r7, #12]
 6921 0d96 00F0C5F9 		bl	prvAddCurrentTaskToDelayedList
 6922              	.L149:
1667:../3rdParty/FreeRTOS/tasks.c **** 		}
1668:../3rdParty/FreeRTOS/tasks.c **** 	}
1669:../3rdParty/FreeRTOS/tasks.c **** 	#else
1670:../3rdParty/FreeRTOS/tasks.c **** 	{
1671:../3rdParty/FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1672:../3rdParty/FreeRTOS/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1673:../3rdParty/FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1674:../3rdParty/FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1675:../3rdParty/FreeRTOS/tasks.c **** 	}
1676:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1677:../3rdParty/FreeRTOS/tasks.c **** }
 6923              		.loc 1 1677 0
 6924 0d9a 07F11007 		add	r7, r7, #16
 6925 0d9e BD46     		mov	sp, r7
 6926 0da0 80BD     		pop	{r7, pc}
 6927              	.L153:
 6928 0da2 00BF     		.align	2
 6929              	.L152:
 6930 0da4 00000000 		.word	pxCurrentTCB
 6931 0da8 C4000000 		.word	xSuspendedTaskList
 6932 0dac DC000000 		.word	xTickCount
 6933              		.cfi_endproc
 6934              	.LFE50:
 6936              		.align	2
 6937              		.global	xTaskRemoveFromEventList
 6938              		.thumb
 6939              		.thumb_func
 6941              	xTaskRemoveFromEventList:
 6942              	.LFB51:
1678:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1679:../3rdParty/FreeRTOS/tasks.c **** 
1680:../3rdParty/FreeRTOS/tasks.c **** #if configUSE_TIMERS == 1
1681:../3rdParty/FreeRTOS/tasks.c **** 
1682:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1683:../3rdParty/FreeRTOS/tasks.c **** 	{
1684:../3rdParty/FreeRTOS/tasks.c **** 	portTickType xTimeToWake;
1685:../3rdParty/FreeRTOS/tasks.c **** 
1686:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxEventList );
1687:../3rdParty/FreeRTOS/tasks.c **** 
1688:../3rdParty/FreeRTOS/tasks.c **** 		/* This function should not be called by application code hence the
1689:../3rdParty/FreeRTOS/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1690:../3rdParty/FreeRTOS/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1691:../3rdParty/FreeRTOS/tasks.c **** 		it should be called from a critical section. */
1692:../3rdParty/FreeRTOS/tasks.c **** 
1693:../3rdParty/FreeRTOS/tasks.c **** 	
1694:../3rdParty/FreeRTOS/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1695:../3rdParty/FreeRTOS/tasks.c **** 		In this case it is assume that this is the only task that is going to
1696:../3rdParty/FreeRTOS/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1697:../3rdParty/FreeRTOS/tasks.c **** 		can be used in place of vListInsert. */
1698:../3rdParty/FreeRTOS/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1699:../3rdParty/FreeRTOS/tasks.c **** 
1700:../3rdParty/FreeRTOS/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1701:../3rdParty/FreeRTOS/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1702:../3rdParty/FreeRTOS/tasks.c **** 		function is called form a critical section. */
1703:../3rdParty/FreeRTOS/tasks.c **** 		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1704:../3rdParty/FreeRTOS/tasks.c **** 
1705:../3rdParty/FreeRTOS/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1706:../3rdParty/FreeRTOS/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1707:../3rdParty/FreeRTOS/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1708:../3rdParty/FreeRTOS/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1709:../3rdParty/FreeRTOS/tasks.c **** 	}
1710:../3rdParty/FreeRTOS/tasks.c **** 	
1711:../3rdParty/FreeRTOS/tasks.c **** #endif /* configUSE_TIMERS */
1712:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1713:../3rdParty/FreeRTOS/tasks.c **** 
1714:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1715:../3rdParty/FreeRTOS/tasks.c **** {
 6943              		.loc 1 1715 0
 6944              		.cfi_startproc
 6945              		@ args = 0, pretend = 0, frame = 16
 6946              		@ frame_needed = 1, uses_anonymous_args = 0
 6947 0db0 80B5     		push	{r7, lr}
 6948              	.LCFI63:
 6949              		.cfi_def_cfa_offset 8
 6950 0db2 84B0     		sub	sp, sp, #16
 6951              	.LCFI64:
 6952              		.cfi_def_cfa_offset 24
 6953 0db4 00AF     		add	r7, sp, #0
 6954              		.cfi_offset 14, -4
 6955              		.cfi_offset 7, -8
 6956              	.LCFI65:
 6957              		.cfi_def_cfa_register 7
 6958 0db6 7860     		str	r0, [r7, #4]
1716:../3rdParty/FreeRTOS/tasks.c **** tskTCB *pxUnblockedTCB;
1717:../3rdParty/FreeRTOS/tasks.c **** portBASE_TYPE xReturn;
1718:../3rdParty/FreeRTOS/tasks.c **** 
1719:../3rdParty/FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1720:../3rdParty/FreeRTOS/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1721:../3rdParty/FreeRTOS/tasks.c **** 
1722:../3rdParty/FreeRTOS/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1723:../3rdParty/FreeRTOS/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1724:../3rdParty/FreeRTOS/tasks.c **** 	it to the ready list.
1725:../3rdParty/FreeRTOS/tasks.c **** 
1726:../3rdParty/FreeRTOS/tasks.c **** 	If an event is for a queue that is locked then this function will never
1727:../3rdParty/FreeRTOS/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1728:../3rdParty/FreeRTOS/tasks.c **** 	means we can always expect exclusive access to the event list here.
1729:../3rdParty/FreeRTOS/tasks.c **** 	
1730:../3rdParty/FreeRTOS/tasks.c **** 	This function assumes that a check has already been made to ensure that
1731:../3rdParty/FreeRTOS/tasks.c **** 	pxEventList is not empty. */
1732:../3rdParty/FreeRTOS/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 6959              		.loc 1 1732 0
 6960 0db8 7B68     		ldr	r3, [r7, #4]
 6961 0dba DB68     		ldr	r3, [r3, #12]
 6962 0dbc DB68     		ldr	r3, [r3, #12]
 6963 0dbe BB60     		str	r3, [r7, #8]
1733:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
1734:../3rdParty/FreeRTOS/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 6964              		.loc 1 1734 0
 6965 0dc0 BB68     		ldr	r3, [r7, #8]
 6966 0dc2 03F11803 		add	r3, r3, #24
 6967 0dc6 1846     		mov	r0, r3
 6968 0dc8 FFF7FEFF 		bl	vListRemove
1735:../3rdParty/FreeRTOS/tasks.c **** 
1736:../3rdParty/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 6969              		.loc 1 1736 0
 6970 0dcc 204B     		ldr	r3, .L160
 6971 0dce 1B68     		ldr	r3, [r3, #0]
 6972 0dd0 002B     		cmp	r3, #0
 6973 0dd2 22D1     		bne	.L155
1737:../3rdParty/FreeRTOS/tasks.c **** 	{
1738:../3rdParty/FreeRTOS/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 6974              		.loc 1 1738 0
 6975 0dd4 BB68     		ldr	r3, [r7, #8]
 6976 0dd6 03F10403 		add	r3, r3, #4
 6977 0dda 1846     		mov	r0, r3
 6978 0ddc FFF7FEFF 		bl	vListRemove
1739:../3rdParty/FreeRTOS/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 6979              		.loc 1 1739 0
 6980 0de0 BB68     		ldr	r3, [r7, #8]
 6981 0de2 DA6A     		ldr	r2, [r3, #44]
 6982 0de4 1B4B     		ldr	r3, .L160+4
 6983 0de6 1B68     		ldr	r3, [r3, #0]
 6984 0de8 9A42     		cmp	r2, r3
 6985 0dea 03D9     		bls	.L156
 6986              		.loc 1 1739 0 is_stmt 0 discriminator 1
 6987 0dec BB68     		ldr	r3, [r7, #8]
 6988 0dee DA6A     		ldr	r2, [r3, #44]
 6989 0df0 184B     		ldr	r3, .L160+4
 6990 0df2 1A60     		str	r2, [r3, #0]
 6991              	.L156:
 6992              		.loc 1 1739 0 discriminator 2
 6993 0df4 BB68     		ldr	r3, [r7, #8]
 6994 0df6 DA6A     		ldr	r2, [r3, #44]
 6995 0df8 1346     		mov	r3, r2
 6996 0dfa 4FEA8303 		lsl	r3, r3, #2
 6997 0dfe 9B18     		adds	r3, r3, r2
 6998 0e00 4FEA8303 		lsl	r3, r3, #2
 6999 0e04 1A46     		mov	r2, r3
 7000 0e06 144B     		ldr	r3, .L160+8
 7001 0e08 D218     		adds	r2, r2, r3
 7002 0e0a BB68     		ldr	r3, [r7, #8]
 7003 0e0c 03F10403 		add	r3, r3, #4
 7004 0e10 1046     		mov	r0, r2
 7005 0e12 1946     		mov	r1, r3
 7006 0e14 FFF7FEFF 		bl	vListInsertEnd
 7007 0e18 06E0     		b	.L157
 7008              	.L155:
1740:../3rdParty/FreeRTOS/tasks.c **** 	}
1741:../3rdParty/FreeRTOS/tasks.c **** 	else
1742:../3rdParty/FreeRTOS/tasks.c **** 	{
1743:../3rdParty/FreeRTOS/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1744:../3rdParty/FreeRTOS/tasks.c **** 		task pending until the scheduler is resumed. */
1745:../3rdParty/FreeRTOS/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 7009              		.loc 1 1745 0 is_stmt 1
 7010 0e1a BB68     		ldr	r3, [r7, #8]
 7011 0e1c 03F11803 		add	r3, r3, #24
 7012 0e20 0E48     		ldr	r0, .L160+12
 7013 0e22 1946     		mov	r1, r3
 7014 0e24 FFF7FEFF 		bl	vListInsertEnd
 7015              	.L157:
1746:../3rdParty/FreeRTOS/tasks.c **** 	}
1747:../3rdParty/FreeRTOS/tasks.c **** 
1748:../3rdParty/FreeRTOS/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 7016              		.loc 1 1748 0
 7017 0e28 BB68     		ldr	r3, [r7, #8]
 7018 0e2a DA6A     		ldr	r2, [r3, #44]
 7019 0e2c 0C4B     		ldr	r3, .L160+16
 7020 0e2e 1B68     		ldr	r3, [r3, #0]
 7021 0e30 DB6A     		ldr	r3, [r3, #44]
 7022 0e32 9A42     		cmp	r2, r3
 7023 0e34 03D3     		bcc	.L158
1749:../3rdParty/FreeRTOS/tasks.c **** 	{
1750:../3rdParty/FreeRTOS/tasks.c **** 		/* Return true if the task removed from the event list has
1751:../3rdParty/FreeRTOS/tasks.c **** 		a higher priority than the calling task.  This allows
1752:../3rdParty/FreeRTOS/tasks.c **** 		the calling task to know if it should force a context
1753:../3rdParty/FreeRTOS/tasks.c **** 		switch now. */
1754:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = pdTRUE;
 7024              		.loc 1 1754 0
 7025 0e36 4FF00103 		mov	r3, #1
 7026 0e3a FB60     		str	r3, [r7, #12]
 7027 0e3c 02E0     		b	.L159
 7028              	.L158:
1755:../3rdParty/FreeRTOS/tasks.c **** 	}
1756:../3rdParty/FreeRTOS/tasks.c **** 	else
1757:../3rdParty/FreeRTOS/tasks.c **** 	{
1758:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = pdFALSE;
 7029              		.loc 1 1758 0
 7030 0e3e 4FF00003 		mov	r3, #0
 7031 0e42 FB60     		str	r3, [r7, #12]
 7032              	.L159:
1759:../3rdParty/FreeRTOS/tasks.c **** 	}
1760:../3rdParty/FreeRTOS/tasks.c **** 
1761:../3rdParty/FreeRTOS/tasks.c **** 	return xReturn;
 7033              		.loc 1 1761 0
 7034 0e44 FB68     		ldr	r3, [r7, #12]
1762:../3rdParty/FreeRTOS/tasks.c **** }
 7035              		.loc 1 1762 0
 7036 0e46 1846     		mov	r0, r3
 7037 0e48 07F11007 		add	r7, r7, #16
 7038 0e4c BD46     		mov	sp, r7
 7039 0e4e 80BD     		pop	{r7, pc}
 7040              	.L161:
 7041              		.align	2
 7042              	.L160:
 7043 0e50 EC000000 		.word	uxSchedulerSuspended
 7044 0e54 E4000000 		.word	uxTopReadyPriority
 7045 0e58 04000000 		.word	pxReadyTasksLists
 7046 0e5c 98000000 		.word	xPendingReadyList
 7047 0e60 00000000 		.word	pxCurrentTCB
 7048              		.cfi_endproc
 7049              	.LFE51:
 7051              		.align	2
 7052              		.global	vTaskSetTimeOutState
 7053              		.thumb
 7054              		.thumb_func
 7056              	vTaskSetTimeOutState:
 7057              	.LFB52:
1763:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1764:../3rdParty/FreeRTOS/tasks.c **** 
1765:../3rdParty/FreeRTOS/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1766:../3rdParty/FreeRTOS/tasks.c **** {
 7058              		.loc 1 1766 0
 7059              		.cfi_startproc
 7060              		@ args = 0, pretend = 0, frame = 8
 7061              		@ frame_needed = 1, uses_anonymous_args = 0
 7062              		@ link register save eliminated.
 7063 0e64 80B4     		push	{r7}
 7064              	.LCFI66:
 7065              		.cfi_def_cfa_offset 4
 7066 0e66 83B0     		sub	sp, sp, #12
 7067              	.LCFI67:
 7068              		.cfi_def_cfa_offset 16
 7069 0e68 00AF     		add	r7, sp, #0
 7070              		.cfi_offset 7, -4
 7071              	.LCFI68:
 7072              		.cfi_def_cfa_register 7
 7073 0e6a 7860     		str	r0, [r7, #4]
1767:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
1768:../3rdParty/FreeRTOS/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 7074              		.loc 1 1768 0
 7075 0e6c 064B     		ldr	r3, .L163
 7076 0e6e 1A68     		ldr	r2, [r3, #0]
 7077 0e70 7B68     		ldr	r3, [r7, #4]
 7078 0e72 1A60     		str	r2, [r3, #0]
1769:../3rdParty/FreeRTOS/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 7079              		.loc 1 1769 0
 7080 0e74 054B     		ldr	r3, .L163+4
 7081 0e76 1A68     		ldr	r2, [r3, #0]
 7082 0e78 7B68     		ldr	r3, [r7, #4]
 7083 0e7a 5A60     		str	r2, [r3, #4]
1770:../3rdParty/FreeRTOS/tasks.c **** }
 7084              		.loc 1 1770 0
 7085 0e7c 07F10C07 		add	r7, r7, #12
 7086 0e80 BD46     		mov	sp, r7
 7087 0e82 80BC     		pop	{r7}
 7088 0e84 7047     		bx	lr
 7089              	.L164:
 7090 0e86 00BF     		.align	2
 7091              	.L163:
 7092 0e88 F8000000 		.word	xNumOfOverflows
 7093 0e8c DC000000 		.word	xTickCount
 7094              		.cfi_endproc
 7095              	.LFE52:
 7097              		.align	2
 7098              		.global	xTaskCheckForTimeOut
 7099              		.thumb
 7100              		.thumb_func
 7102              	xTaskCheckForTimeOut:
 7103              	.LFB53:
1771:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1772:../3rdParty/FreeRTOS/tasks.c **** 
1773:../3rdParty/FreeRTOS/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1774:../3rdParty/FreeRTOS/tasks.c **** {
 7104              		.loc 1 1774 0
 7105              		.cfi_startproc
 7106              		@ args = 0, pretend = 0, frame = 16
 7107              		@ frame_needed = 1, uses_anonymous_args = 0
 7108 0e90 80B5     		push	{r7, lr}
 7109              	.LCFI69:
 7110              		.cfi_def_cfa_offset 8
 7111 0e92 84B0     		sub	sp, sp, #16
 7112              	.LCFI70:
 7113              		.cfi_def_cfa_offset 24
 7114 0e94 00AF     		add	r7, sp, #0
 7115              		.cfi_offset 14, -4
 7116              		.cfi_offset 7, -8
 7117              	.LCFI71:
 7118              		.cfi_def_cfa_register 7
 7119 0e96 7860     		str	r0, [r7, #4]
 7120 0e98 3960     		str	r1, [r7, #0]
1775:../3rdParty/FreeRTOS/tasks.c **** portBASE_TYPE xReturn;
1776:../3rdParty/FreeRTOS/tasks.c **** 
1777:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
1778:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxTicksToWait );
1779:../3rdParty/FreeRTOS/tasks.c **** 
1780:../3rdParty/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 7121              		.loc 1 1780 0
 7122 0e9a FFF7FEFF 		bl	vPortEnterCritical
1781:../3rdParty/FreeRTOS/tasks.c **** 	{
1782:../3rdParty/FreeRTOS/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1783:../3rdParty/FreeRTOS/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1784:../3rdParty/FreeRTOS/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1785:../3rdParty/FreeRTOS/tasks.c **** 			therefore never time out. */
1786:../3rdParty/FreeRTOS/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 7123              		.loc 1 1786 0
 7124 0e9e 3B68     		ldr	r3, [r7, #0]
 7125 0ea0 1B68     		ldr	r3, [r3, #0]
 7126 0ea2 B3F1FF3F 		cmp	r3, #-1
 7127 0ea6 03D1     		bne	.L166
1787:../3rdParty/FreeRTOS/tasks.c **** 			{
1788:../3rdParty/FreeRTOS/tasks.c **** 				xReturn = pdFALSE;
 7128              		.loc 1 1788 0
 7129 0ea8 4FF00003 		mov	r3, #0
 7130 0eac FB60     		str	r3, [r7, #12]
 7131 0eae 2CE0     		b	.L167
 7132              	.L166:
1789:../3rdParty/FreeRTOS/tasks.c **** 			}
1790:../3rdParty/FreeRTOS/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1791:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1792:../3rdParty/FreeRTOS/tasks.c **** 
1793:../3rdParty/FreeRTOS/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 7133              		.loc 1 1793 0
 7134 0eb0 7B68     		ldr	r3, [r7, #4]
 7135 0eb2 1A68     		ldr	r2, [r3, #0]
 7136 0eb4 194B     		ldr	r3, .L170
 7137 0eb6 1B68     		ldr	r3, [r3, #0]
 7138 0eb8 9A42     		cmp	r2, r3
 7139 0eba 09D0     		beq	.L168
 7140              		.loc 1 1793 0 is_stmt 0 discriminator 1
 7141 0ebc 7B68     		ldr	r3, [r7, #4]
 7142 0ebe 5A68     		ldr	r2, [r3, #4]
 7143 0ec0 174B     		ldr	r3, .L170+4
 7144 0ec2 1B68     		ldr	r3, [r3, #0]
 7145 0ec4 9A42     		cmp	r2, r3
 7146 0ec6 03D8     		bhi	.L168
1794:../3rdParty/FreeRTOS/tasks.c **** 		{
1795:../3rdParty/FreeRTOS/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1796:../3rdParty/FreeRTOS/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1797:../3rdParty/FreeRTOS/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1798:../3rdParty/FreeRTOS/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1799:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
 7147              		.loc 1 1799 0 is_stmt 1
 7148 0ec8 4FF00103 		mov	r3, #1
 7149 0ecc FB60     		str	r3, [r7, #12]
 7150 0ece 1CE0     		b	.L167
 7151              	.L168:
1800:../3rdParty/FreeRTOS/tasks.c **** 		}
1801:../3rdParty/FreeRTOS/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 7152              		.loc 1 1801 0
 7153 0ed0 134B     		ldr	r3, .L170+4
 7154 0ed2 1A68     		ldr	r2, [r3, #0]
 7155 0ed4 7B68     		ldr	r3, [r7, #4]
 7156 0ed6 5B68     		ldr	r3, [r3, #4]
 7157 0ed8 D21A     		subs	r2, r2, r3
 7158 0eda 3B68     		ldr	r3, [r7, #0]
 7159 0edc 1B68     		ldr	r3, [r3, #0]
 7160 0ede 9A42     		cmp	r2, r3
 7161 0ee0 10D2     		bcs	.L169
1802:../3rdParty/FreeRTOS/tasks.c **** 		{
1803:../3rdParty/FreeRTOS/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1804:../3rdParty/FreeRTOS/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 7162              		.loc 1 1804 0
 7163 0ee2 3B68     		ldr	r3, [r7, #0]
 7164 0ee4 1A68     		ldr	r2, [r3, #0]
 7165 0ee6 7B68     		ldr	r3, [r7, #4]
 7166 0ee8 5968     		ldr	r1, [r3, #4]
 7167 0eea 0D4B     		ldr	r3, .L170+4
 7168 0eec 1B68     		ldr	r3, [r3, #0]
 7169 0eee CB1A     		subs	r3, r1, r3
 7170 0ef0 D218     		adds	r2, r2, r3
 7171 0ef2 3B68     		ldr	r3, [r7, #0]
 7172 0ef4 1A60     		str	r2, [r3, #0]
1805:../3rdParty/FreeRTOS/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 7173              		.loc 1 1805 0
 7174 0ef6 7868     		ldr	r0, [r7, #4]
 7175 0ef8 FFF7FEFF 		bl	vTaskSetTimeOutState
1806:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdFALSE;
 7176              		.loc 1 1806 0
 7177 0efc 4FF00003 		mov	r3, #0
 7178 0f00 FB60     		str	r3, [r7, #12]
 7179 0f02 02E0     		b	.L167
 7180              	.L169:
1807:../3rdParty/FreeRTOS/tasks.c **** 		}
1808:../3rdParty/FreeRTOS/tasks.c **** 		else
1809:../3rdParty/FreeRTOS/tasks.c **** 		{
1810:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
 7181              		.loc 1 1810 0
 7182 0f04 4FF00103 		mov	r3, #1
 7183 0f08 FB60     		str	r3, [r7, #12]
 7184              	.L167:
1811:../3rdParty/FreeRTOS/tasks.c **** 		}
1812:../3rdParty/FreeRTOS/tasks.c **** 	}
1813:../3rdParty/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 7185              		.loc 1 1813 0
 7186 0f0a FFF7FEFF 		bl	vPortExitCritical
1814:../3rdParty/FreeRTOS/tasks.c **** 
1815:../3rdParty/FreeRTOS/tasks.c **** 	return xReturn;
 7187              		.loc 1 1815 0
 7188 0f0e FB68     		ldr	r3, [r7, #12]
1816:../3rdParty/FreeRTOS/tasks.c **** }
 7189              		.loc 1 1816 0
 7190 0f10 1846     		mov	r0, r3
 7191 0f12 07F11007 		add	r7, r7, #16
 7192 0f16 BD46     		mov	sp, r7
 7193 0f18 80BD     		pop	{r7, pc}
 7194              	.L171:
 7195 0f1a 00BF     		.align	2
 7196              	.L170:
 7197 0f1c F8000000 		.word	xNumOfOverflows
 7198 0f20 DC000000 		.word	xTickCount
 7199              		.cfi_endproc
 7200              	.LFE53:
 7202              		.align	2
 7203              		.global	vTaskMissedYield
 7204              		.thumb
 7205              		.thumb_func
 7207              	vTaskMissedYield:
 7208              	.LFB54:
1817:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1818:../3rdParty/FreeRTOS/tasks.c **** 
1819:../3rdParty/FreeRTOS/tasks.c **** void vTaskMissedYield( void )
1820:../3rdParty/FreeRTOS/tasks.c **** {
 7209              		.loc 1 1820 0
 7210              		.cfi_startproc
 7211              		@ args = 0, pretend = 0, frame = 0
 7212              		@ frame_needed = 1, uses_anonymous_args = 0
 7213              		@ link register save eliminated.
 7214 0f24 80B4     		push	{r7}
 7215              	.LCFI72:
 7216              		.cfi_def_cfa_offset 4
 7217 0f26 00AF     		add	r7, sp, #0
 7218              		.cfi_offset 7, -4
 7219              	.LCFI73:
 7220              		.cfi_def_cfa_register 7
1821:../3rdParty/FreeRTOS/tasks.c **** 	xMissedYield = pdTRUE;
 7221              		.loc 1 1821 0
 7222 0f28 034B     		ldr	r3, .L173
 7223 0f2a 4FF00102 		mov	r2, #1
 7224 0f2e 1A60     		str	r2, [r3, #0]
1822:../3rdParty/FreeRTOS/tasks.c **** }
 7225              		.loc 1 1822 0
 7226 0f30 BD46     		mov	sp, r7
 7227 0f32 80BC     		pop	{r7}
 7228 0f34 7047     		bx	lr
 7229              	.L174:
 7230 0f36 00BF     		.align	2
 7231              	.L173:
 7232 0f38 F4000000 		.word	xMissedYield
 7233              		.cfi_endproc
 7234              	.LFE54:
 7236              		.align	2
 7237              		.global	uxTaskGetTaskNumber
 7238              		.thumb
 7239              		.thumb_func
 7241              	uxTaskGetTaskNumber:
 7242              	.LFB55:
1823:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1824:../3rdParty/FreeRTOS/tasks.c **** 
1825:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1826:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
1827:../3rdParty/FreeRTOS/tasks.c **** 	{
 7243              		.loc 1 1827 0
 7244              		.cfi_startproc
 7245              		@ args = 0, pretend = 0, frame = 16
 7246              		@ frame_needed = 1, uses_anonymous_args = 0
 7247              		@ link register save eliminated.
 7248 0f3c 80B4     		push	{r7}
 7249              	.LCFI74:
 7250              		.cfi_def_cfa_offset 4
 7251 0f3e 85B0     		sub	sp, sp, #20
 7252              	.LCFI75:
 7253              		.cfi_def_cfa_offset 24
 7254 0f40 00AF     		add	r7, sp, #0
 7255              		.cfi_offset 7, -4
 7256              	.LCFI76:
 7257              		.cfi_def_cfa_register 7
 7258 0f42 7860     		str	r0, [r7, #4]
1828:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
1829:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1830:../3rdParty/FreeRTOS/tasks.c **** 	
1831:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask != NULL )
 7259              		.loc 1 1831 0
 7260 0f44 7B68     		ldr	r3, [r7, #4]
 7261 0f46 002B     		cmp	r3, #0
 7262 0f48 05D0     		beq	.L176
1832:../3rdParty/FreeRTOS/tasks.c **** 		{
1833:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
 7263              		.loc 1 1833 0
 7264 0f4a 7B68     		ldr	r3, [r7, #4]
 7265 0f4c BB60     		str	r3, [r7, #8]
1834:../3rdParty/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
 7266              		.loc 1 1834 0
 7267 0f4e BB68     		ldr	r3, [r7, #8]
 7268 0f50 5B6C     		ldr	r3, [r3, #68]
 7269 0f52 FB60     		str	r3, [r7, #12]
 7270 0f54 02E0     		b	.L177
 7271              	.L176:
1835:../3rdParty/FreeRTOS/tasks.c **** 		}
1836:../3rdParty/FreeRTOS/tasks.c **** 		else
1837:../3rdParty/FreeRTOS/tasks.c **** 		{
1838:../3rdParty/FreeRTOS/tasks.c **** 			uxReturn = 0U;
 7272              		.loc 1 1838 0
 7273 0f56 4FF00003 		mov	r3, #0
 7274 0f5a FB60     		str	r3, [r7, #12]
 7275              	.L177:
1839:../3rdParty/FreeRTOS/tasks.c **** 		}
1840:../3rdParty/FreeRTOS/tasks.c **** 		
1841:../3rdParty/FreeRTOS/tasks.c **** 		return uxReturn;
 7276              		.loc 1 1841 0
 7277 0f5c FB68     		ldr	r3, [r7, #12]
1842:../3rdParty/FreeRTOS/tasks.c **** 	}
 7278              		.loc 1 1842 0
 7279 0f5e 1846     		mov	r0, r3
 7280 0f60 07F11407 		add	r7, r7, #20
 7281 0f64 BD46     		mov	sp, r7
 7282 0f66 80BC     		pop	{r7}
 7283 0f68 7047     		bx	lr
 7284              		.cfi_endproc
 7285              	.LFE55:
 7287 0f6a 00BF     		.align	2
 7288              		.global	vTaskSetTaskNumber
 7289              		.thumb
 7290              		.thumb_func
 7292              	vTaskSetTaskNumber:
 7293              	.LFB56:
1843:../3rdParty/FreeRTOS/tasks.c **** #endif
1844:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1845:../3rdParty/FreeRTOS/tasks.c **** 
1846:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1847:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
1848:../3rdParty/FreeRTOS/tasks.c **** 	{
 7294              		.loc 1 1848 0
 7295              		.cfi_startproc
 7296              		@ args = 0, pretend = 0, frame = 16
 7297              		@ frame_needed = 1, uses_anonymous_args = 0
 7298              		@ link register save eliminated.
 7299 0f6c 80B4     		push	{r7}
 7300              	.LCFI77:
 7301              		.cfi_def_cfa_offset 4
 7302 0f6e 85B0     		sub	sp, sp, #20
 7303              	.LCFI78:
 7304              		.cfi_def_cfa_offset 24
 7305 0f70 00AF     		add	r7, sp, #0
 7306              		.cfi_offset 7, -4
 7307              	.LCFI79:
 7308              		.cfi_def_cfa_register 7
 7309 0f72 7860     		str	r0, [r7, #4]
 7310 0f74 3960     		str	r1, [r7, #0]
1849:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1850:../3rdParty/FreeRTOS/tasks.c **** 	
1851:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask != NULL )
 7311              		.loc 1 1851 0
 7312 0f76 7B68     		ldr	r3, [r7, #4]
 7313 0f78 002B     		cmp	r3, #0
 7314 0f7a 04D0     		beq	.L178
1852:../3rdParty/FreeRTOS/tasks.c **** 		{
1853:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
 7315              		.loc 1 1853 0
 7316 0f7c 7B68     		ldr	r3, [r7, #4]
 7317 0f7e FB60     		str	r3, [r7, #12]
1854:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
 7318              		.loc 1 1854 0
 7319 0f80 FB68     		ldr	r3, [r7, #12]
 7320 0f82 3A68     		ldr	r2, [r7, #0]
 7321 0f84 5A64     		str	r2, [r3, #68]
 7322              	.L178:
1855:../3rdParty/FreeRTOS/tasks.c **** 		}
1856:../3rdParty/FreeRTOS/tasks.c **** 	}
 7323              		.loc 1 1856 0
 7324 0f86 07F11407 		add	r7, r7, #20
 7325 0f8a BD46     		mov	sp, r7
 7326 0f8c 80BC     		pop	{r7}
 7327 0f8e 7047     		bx	lr
 7328              		.cfi_endproc
 7329              	.LFE56:
 7331              		.align	2
 7332              		.thumb
 7333              		.thumb_func
 7335              	prvIdleTask:
 7336              	.LFB57:
1857:../3rdParty/FreeRTOS/tasks.c **** #endif
1858:../3rdParty/FreeRTOS/tasks.c **** 
1859:../3rdParty/FreeRTOS/tasks.c **** 
1860:../3rdParty/FreeRTOS/tasks.c **** /*
1861:../3rdParty/FreeRTOS/tasks.c ****  * -----------------------------------------------------------
1862:../3rdParty/FreeRTOS/tasks.c ****  * The Idle task.
1863:../3rdParty/FreeRTOS/tasks.c ****  * ----------------------------------------------------------
1864:../3rdParty/FreeRTOS/tasks.c ****  *
1865:../3rdParty/FreeRTOS/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1866:../3rdParty/FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1867:../3rdParty/FreeRTOS/tasks.c ****  *
1868:../3rdParty/FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
1869:../3rdParty/FreeRTOS/tasks.c ****  *
1870:../3rdParty/FreeRTOS/tasks.c ****  */
1871:../3rdParty/FreeRTOS/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1872:../3rdParty/FreeRTOS/tasks.c **** {
 7337              		.loc 1 1872 0
 7338              		.cfi_startproc
 7339              		@ args = 0, pretend = 0, frame = 8
 7340              		@ frame_needed = 1, uses_anonymous_args = 0
 7341 0f90 80B5     		push	{r7, lr}
 7342              	.LCFI80:
 7343              		.cfi_def_cfa_offset 8
 7344 0f92 82B0     		sub	sp, sp, #8
 7345              	.LCFI81:
 7346              		.cfi_def_cfa_offset 16
 7347 0f94 00AF     		add	r7, sp, #0
 7348              		.cfi_offset 14, -4
 7349              		.cfi_offset 7, -8
 7350              	.LCFI82:
 7351              		.cfi_def_cfa_register 7
 7352 0f96 7860     		str	r0, [r7, #4]
 7353              	.L181:
1873:../3rdParty/FreeRTOS/tasks.c **** 	/* Stop warnings. */
1874:../3rdParty/FreeRTOS/tasks.c **** 	( void ) pvParameters;
1875:../3rdParty/FreeRTOS/tasks.c **** 
1876:../3rdParty/FreeRTOS/tasks.c **** 	for( ;; )
1877:../3rdParty/FreeRTOS/tasks.c **** 	{
1878:../3rdParty/FreeRTOS/tasks.c **** 		/* See if any tasks have been deleted. */
1879:../3rdParty/FreeRTOS/tasks.c **** 		prvCheckTasksWaitingTermination();
 7354              		.loc 1 1879 0 discriminator 1
 7355 0f98 00F088F8 		bl	prvCheckTasksWaitingTermination
1880:../3rdParty/FreeRTOS/tasks.c **** 
1881:../3rdParty/FreeRTOS/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1882:../3rdParty/FreeRTOS/tasks.c **** 		{
1883:../3rdParty/FreeRTOS/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1884:../3rdParty/FreeRTOS/tasks.c **** 			see if any other task has become available.  If we are using
1885:../3rdParty/FreeRTOS/tasks.c **** 			preemption we don't need to do this as any task becoming available
1886:../3rdParty/FreeRTOS/tasks.c **** 			will automatically get the processor anyway. */
1887:../3rdParty/FreeRTOS/tasks.c **** 			taskYIELD();
1888:../3rdParty/FreeRTOS/tasks.c **** 		}
1889:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1890:../3rdParty/FreeRTOS/tasks.c **** 
1891:../3rdParty/FreeRTOS/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1892:../3rdParty/FreeRTOS/tasks.c **** 		{
1893:../3rdParty/FreeRTOS/tasks.c **** 			/* When using preemption tasks of equal priority will be
1894:../3rdParty/FreeRTOS/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1895:../3rdParty/FreeRTOS/tasks.c **** 			to run then the idle task should yield before the end of the
1896:../3rdParty/FreeRTOS/tasks.c **** 			timeslice.
1897:../3rdParty/FreeRTOS/tasks.c **** 
1898:../3rdParty/FreeRTOS/tasks.c **** 			A critical region is not required here as we are just reading from
1899:../3rdParty/FreeRTOS/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1900:../3rdParty/FreeRTOS/tasks.c **** 			the ready list at the idle priority contains more than one task
1901:../3rdParty/FreeRTOS/tasks.c **** 			then a task other than the idle task is ready to execute. */
1902:../3rdParty/FreeRTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1903:../3rdParty/FreeRTOS/tasks.c **** 			{
1904:../3rdParty/FreeRTOS/tasks.c **** 				taskYIELD();
1905:../3rdParty/FreeRTOS/tasks.c **** 			}
1906:../3rdParty/FreeRTOS/tasks.c **** 		}
1907:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1908:../3rdParty/FreeRTOS/tasks.c **** 
1909:../3rdParty/FreeRTOS/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1910:../3rdParty/FreeRTOS/tasks.c **** 		{
1911:../3rdParty/FreeRTOS/tasks.c **** 			extern void vApplicationIdleHook( void );
1912:../3rdParty/FreeRTOS/tasks.c **** 
1913:../3rdParty/FreeRTOS/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1914:../3rdParty/FreeRTOS/tasks.c **** 			allows the application designer to add background functionality
1915:../3rdParty/FreeRTOS/tasks.c **** 			without the overhead of a separate task.
1916:../3rdParty/FreeRTOS/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1917:../3rdParty/FreeRTOS/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1918:../3rdParty/FreeRTOS/tasks.c **** 			vApplicationIdleHook();
1919:../3rdParty/FreeRTOS/tasks.c **** 		}
1920:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1921:../3rdParty/FreeRTOS/tasks.c **** 	}
 7356              		.loc 1 1921 0 discriminator 1
 7357 0f9c FCE7     		b	.L181
 7358              		.cfi_endproc
 7359              	.LFE57:
 7361 0f9e 00BF     		.align	2
 7362              		.thumb
 7363              		.thumb_func
 7365              	prvInitialiseTCBVariables:
 7366              	.LFB58:
1922:../3rdParty/FreeRTOS/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1923:../3rdParty/FreeRTOS/tasks.c **** 
1924:../3rdParty/FreeRTOS/tasks.c **** 
1925:../3rdParty/FreeRTOS/tasks.c **** 
1926:../3rdParty/FreeRTOS/tasks.c **** 
1927:../3rdParty/FreeRTOS/tasks.c **** 
1928:../3rdParty/FreeRTOS/tasks.c **** 
1929:../3rdParty/FreeRTOS/tasks.c **** 
1930:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1931:../3rdParty/FreeRTOS/tasks.c ****  * File private functions documented at the top of the file.
1932:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1933:../3rdParty/FreeRTOS/tasks.c **** 
1934:../3rdParty/FreeRTOS/tasks.c **** 
1935:../3rdParty/FreeRTOS/tasks.c **** 
1936:../3rdParty/FreeRTOS/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1937:../3rdParty/FreeRTOS/tasks.c **** {
 7367              		.loc 1 1937 0
 7368              		.cfi_startproc
 7369              		@ args = 4, pretend = 0, frame = 16
 7370              		@ frame_needed = 1, uses_anonymous_args = 0
 7371 0fa0 80B5     		push	{r7, lr}
 7372              	.LCFI83:
 7373              		.cfi_def_cfa_offset 8
 7374 0fa2 84B0     		sub	sp, sp, #16
 7375              	.LCFI84:
 7376              		.cfi_def_cfa_offset 24
 7377 0fa4 00AF     		add	r7, sp, #0
 7378              		.cfi_offset 14, -4
 7379              		.cfi_offset 7, -8
 7380              	.LCFI85:
 7381              		.cfi_def_cfa_register 7
 7382 0fa6 F860     		str	r0, [r7, #12]
 7383 0fa8 B960     		str	r1, [r7, #8]
 7384 0faa 7A60     		str	r2, [r7, #4]
 7385 0fac 3B60     		str	r3, [r7, #0]
1938:../3rdParty/FreeRTOS/tasks.c **** 	/* Store the function name in the TCB. */
1939:../3rdParty/FreeRTOS/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1940:../3rdParty/FreeRTOS/tasks.c **** 	{
1941:../3rdParty/FreeRTOS/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1942:../3rdParty/FreeRTOS/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 7386              		.loc 1 1942 0
 7387 0fae FB68     		ldr	r3, [r7, #12]
 7388 0fb0 03F13403 		add	r3, r3, #52
 7389 0fb4 1A46     		mov	r2, r3
 7390 0fb6 BB68     		ldr	r3, [r7, #8]
 7391 0fb8 1046     		mov	r0, r2
 7392 0fba 1946     		mov	r1, r3
 7393 0fbc 4FF00C02 		mov	r2, #12
 7394 0fc0 FFF7FEFF 		bl	strncpy
1943:../3rdParty/FreeRTOS/tasks.c **** 	}
1944:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1945:../3rdParty/FreeRTOS/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 7395              		.loc 1 1945 0
 7396 0fc4 FB68     		ldr	r3, [r7, #12]
 7397 0fc6 4FF00002 		mov	r2, #0
 7398 0fca 83F83F20 		strb	r2, [r3, #63]
1946:../3rdParty/FreeRTOS/tasks.c **** 
1947:../3rdParty/FreeRTOS/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1948:../3rdParty/FreeRTOS/tasks.c **** 	remove the privilege bit if one is present. */
1949:../3rdParty/FreeRTOS/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 7399              		.loc 1 1949 0
 7400 0fce 7B68     		ldr	r3, [r7, #4]
 7401 0fd0 042B     		cmp	r3, #4
 7402 0fd2 02D9     		bls	.L183
1950:../3rdParty/FreeRTOS/tasks.c **** 	{
1951:../3rdParty/FreeRTOS/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 7403              		.loc 1 1951 0
 7404 0fd4 4FF00403 		mov	r3, #4
 7405 0fd8 7B60     		str	r3, [r7, #4]
 7406              	.L183:
1952:../3rdParty/FreeRTOS/tasks.c **** 	}
1953:../3rdParty/FreeRTOS/tasks.c **** 
1954:../3rdParty/FreeRTOS/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 7407              		.loc 1 1954 0
 7408 0fda FB68     		ldr	r3, [r7, #12]
 7409 0fdc 7A68     		ldr	r2, [r7, #4]
 7410 0fde DA62     		str	r2, [r3, #44]
1955:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
1956:../3rdParty/FreeRTOS/tasks.c **** 	{
1957:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 7411              		.loc 1 1957 0
 7412 0fe0 FB68     		ldr	r3, [r7, #12]
 7413 0fe2 7A68     		ldr	r2, [r7, #4]
 7414 0fe4 9A64     		str	r2, [r3, #72]
1958:../3rdParty/FreeRTOS/tasks.c **** 	}
1959:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1960:../3rdParty/FreeRTOS/tasks.c **** 
1961:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 7415              		.loc 1 1961 0
 7416 0fe6 FB68     		ldr	r3, [r7, #12]
 7417 0fe8 03F10403 		add	r3, r3, #4
 7418 0fec 1846     		mov	r0, r3
 7419 0fee FFF7FEFF 		bl	vListInitialiseItem
1962:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 7420              		.loc 1 1962 0
 7421 0ff2 FB68     		ldr	r3, [r7, #12]
 7422 0ff4 03F11803 		add	r3, r3, #24
 7423 0ff8 1846     		mov	r0, r3
 7424 0ffa FFF7FEFF 		bl	vListInitialiseItem
1963:../3rdParty/FreeRTOS/tasks.c **** 
1964:../3rdParty/FreeRTOS/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1965:../3rdParty/FreeRTOS/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
1966:../3rdParty/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 7425              		.loc 1 1966 0
 7426 0ffe FB68     		ldr	r3, [r7, #12]
 7427 1000 FA68     		ldr	r2, [r7, #12]
 7428 1002 1A61     		str	r2, [r3, #16]
1967:../3rdParty/FreeRTOS/tasks.c **** 
1968:../3rdParty/FreeRTOS/tasks.c **** 	/* Event lists are always in priority order. */
1969:../3rdParty/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 7429              		.loc 1 1969 0
 7430 1004 7B68     		ldr	r3, [r7, #4]
 7431 1006 C3F10502 		rsb	r2, r3, #5
 7432 100a FB68     		ldr	r3, [r7, #12]
 7433 100c 9A61     		str	r2, [r3, #24]
1970:../3rdParty/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 7434              		.loc 1 1970 0
 7435 100e FB68     		ldr	r3, [r7, #12]
 7436 1010 FA68     		ldr	r2, [r7, #12]
 7437 1012 5A62     		str	r2, [r3, #36]
1971:../3rdParty/FreeRTOS/tasks.c **** 
1972:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1973:../3rdParty/FreeRTOS/tasks.c **** 	{
1974:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
1975:../3rdParty/FreeRTOS/tasks.c **** 	}
1976:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1977:../3rdParty/FreeRTOS/tasks.c **** 
1978:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1979:../3rdParty/FreeRTOS/tasks.c **** 	{
1980:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB->pxTaskTag = NULL;
1981:../3rdParty/FreeRTOS/tasks.c **** 	}
1982:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1983:../3rdParty/FreeRTOS/tasks.c **** 
1984:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1985:../3rdParty/FreeRTOS/tasks.c **** 	{
1986:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
 7438              		.loc 1 1986 0
 7439 1014 FB68     		ldr	r3, [r7, #12]
 7440 1016 4FF00002 		mov	r2, #0
 7441 101a DA64     		str	r2, [r3, #76]
1987:../3rdParty/FreeRTOS/tasks.c **** 	}
1988:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1989:../3rdParty/FreeRTOS/tasks.c **** 
1990:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1991:../3rdParty/FreeRTOS/tasks.c **** 	{
1992:../3rdParty/FreeRTOS/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1993:../3rdParty/FreeRTOS/tasks.c **** 	}
1994:../3rdParty/FreeRTOS/tasks.c **** 	#else
1995:../3rdParty/FreeRTOS/tasks.c **** 	{
1996:../3rdParty/FreeRTOS/tasks.c **** 		( void ) xRegions;
1997:../3rdParty/FreeRTOS/tasks.c **** 		( void ) usStackDepth;
1998:../3rdParty/FreeRTOS/tasks.c **** 	}
1999:../3rdParty/FreeRTOS/tasks.c **** 	#endif
2000:../3rdParty/FreeRTOS/tasks.c **** }
 7442              		.loc 1 2000 0
 7443 101c 07F11007 		add	r7, r7, #16
 7444 1020 BD46     		mov	sp, r7
 7445 1022 80BD     		pop	{r7, pc}
 7446              		.cfi_endproc
 7447              	.LFE58:
 7449              		.align	2
 7450              		.thumb
 7451              		.thumb_func
 7453              	prvInitialiseTaskLists:
 7454              	.LFB59:
2001:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2002:../3rdParty/FreeRTOS/tasks.c **** 
2003:../3rdParty/FreeRTOS/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2004:../3rdParty/FreeRTOS/tasks.c **** 
2005:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2006:../3rdParty/FreeRTOS/tasks.c **** 	{
2007:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
2008:../3rdParty/FreeRTOS/tasks.c **** 	
2009:../3rdParty/FreeRTOS/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2010:../3rdParty/FreeRTOS/tasks.c **** 		{
2011:../3rdParty/FreeRTOS/tasks.c **** 			xTaskToModify = NULL;
2012:../3rdParty/FreeRTOS/tasks.c **** 		}
2013:../3rdParty/FreeRTOS/tasks.c **** 
2014:../3rdParty/FreeRTOS/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2015:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2016:../3rdParty/FreeRTOS/tasks.c **** 
2017:../3rdParty/FreeRTOS/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2018:../3rdParty/FreeRTOS/tasks.c **** 	}
2019:../3rdParty/FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
2020:../3rdParty/FreeRTOS/tasks.c **** #endif
2021:../3rdParty/FreeRTOS/tasks.c **** 
2022:../3rdParty/FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void )
2023:../3rdParty/FreeRTOS/tasks.c **** {
 7455              		.loc 1 2023 0
 7456              		.cfi_startproc
 7457              		@ args = 0, pretend = 0, frame = 8
 7458              		@ frame_needed = 1, uses_anonymous_args = 0
 7459 1024 80B5     		push	{r7, lr}
 7460              	.LCFI86:
 7461              		.cfi_def_cfa_offset 8
 7462 1026 82B0     		sub	sp, sp, #8
 7463              	.LCFI87:
 7464              		.cfi_def_cfa_offset 16
 7465 1028 00AF     		add	r7, sp, #0
 7466              		.cfi_offset 14, -4
 7467              		.cfi_offset 7, -8
 7468              	.LCFI88:
 7469              		.cfi_def_cfa_register 7
2024:../3rdParty/FreeRTOS/tasks.c **** unsigned portBASE_TYPE uxPriority;
2025:../3rdParty/FreeRTOS/tasks.c **** 
2026:../3rdParty/FreeRTOS/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 7470              		.loc 1 2026 0
 7471 102a 4FF00003 		mov	r3, #0
 7472 102e 7B60     		str	r3, [r7, #4]
 7473 1030 10E0     		b	.L185
 7474              	.L186:
2027:../3rdParty/FreeRTOS/tasks.c **** 	{
2028:../3rdParty/FreeRTOS/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 7475              		.loc 1 2028 0 discriminator 2
 7476 1032 7A68     		ldr	r2, [r7, #4]
 7477 1034 1346     		mov	r3, r2
 7478 1036 4FEA8303 		lsl	r3, r3, #2
 7479 103a 9B18     		adds	r3, r3, r2
 7480 103c 4FEA8303 		lsl	r3, r3, #2
 7481 1040 1A46     		mov	r2, r3
 7482 1042 124B     		ldr	r3, .L187
 7483 1044 D318     		adds	r3, r2, r3
 7484 1046 1846     		mov	r0, r3
 7485 1048 FFF7FEFF 		bl	vListInitialise
2026:../3rdParty/FreeRTOS/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 7486              		.loc 1 2026 0 discriminator 2
 7487 104c 7B68     		ldr	r3, [r7, #4]
 7488 104e 03F10103 		add	r3, r3, #1
 7489 1052 7B60     		str	r3, [r7, #4]
 7490              	.L185:
2026:../3rdParty/FreeRTOS/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 7491              		.loc 1 2026 0 is_stmt 0 discriminator 1
 7492 1054 7B68     		ldr	r3, [r7, #4]
 7493 1056 042B     		cmp	r3, #4
 7494 1058 EBD9     		bls	.L186
2029:../3rdParty/FreeRTOS/tasks.c **** 	}
2030:../3rdParty/FreeRTOS/tasks.c **** 
2031:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 7495              		.loc 1 2031 0 is_stmt 1
 7496 105a 0D48     		ldr	r0, .L187+4
 7497 105c FFF7FEFF 		bl	vListInitialise
2032:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 7498              		.loc 1 2032 0
 7499 1060 0C48     		ldr	r0, .L187+8
 7500 1062 FFF7FEFF 		bl	vListInitialise
2033:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 7501              		.loc 1 2033 0
 7502 1066 0C48     		ldr	r0, .L187+12
 7503 1068 FFF7FEFF 		bl	vListInitialise
2034:../3rdParty/FreeRTOS/tasks.c **** 
2035:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2036:../3rdParty/FreeRTOS/tasks.c **** 	{
2037:../3rdParty/FreeRTOS/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 7504              		.loc 1 2037 0
 7505 106c 0B48     		ldr	r0, .L187+16
 7506 106e FFF7FEFF 		bl	vListInitialise
2038:../3rdParty/FreeRTOS/tasks.c **** 	}
2039:../3rdParty/FreeRTOS/tasks.c **** 	#endif
2040:../3rdParty/FreeRTOS/tasks.c **** 
2041:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2042:../3rdParty/FreeRTOS/tasks.c **** 	{
2043:../3rdParty/FreeRTOS/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 7507              		.loc 1 2043 0
 7508 1072 0B48     		ldr	r0, .L187+20
 7509 1074 FFF7FEFF 		bl	vListInitialise
2044:../3rdParty/FreeRTOS/tasks.c **** 	}
2045:../3rdParty/FreeRTOS/tasks.c **** 	#endif
2046:../3rdParty/FreeRTOS/tasks.c **** 
2047:../3rdParty/FreeRTOS/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2048:../3rdParty/FreeRTOS/tasks.c **** 	using list2. */
2049:../3rdParty/FreeRTOS/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 7510              		.loc 1 2049 0
 7511 1078 0A4B     		ldr	r3, .L187+24
 7512 107a 054A     		ldr	r2, .L187+4
 7513 107c 1A60     		str	r2, [r3, #0]
2050:../3rdParty/FreeRTOS/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 7514              		.loc 1 2050 0
 7515 107e 0A4B     		ldr	r3, .L187+28
 7516 1080 044A     		ldr	r2, .L187+8
 7517 1082 1A60     		str	r2, [r3, #0]
2051:../3rdParty/FreeRTOS/tasks.c **** }
 7518              		.loc 1 2051 0
 7519 1084 07F10807 		add	r7, r7, #8
 7520 1088 BD46     		mov	sp, r7
 7521 108a 80BD     		pop	{r7, pc}
 7522              	.L188:
 7523              		.align	2
 7524              	.L187:
 7525 108c 04000000 		.word	pxReadyTasksLists
 7526 1090 68000000 		.word	xDelayedTaskList1
 7527 1094 7C000000 		.word	xDelayedTaskList2
 7528 1098 98000000 		.word	xPendingReadyList
 7529 109c AC000000 		.word	xTasksWaitingTermination
 7530 10a0 C4000000 		.word	xSuspendedTaskList
 7531 10a4 90000000 		.word	pxDelayedTaskList
 7532 10a8 94000000 		.word	pxOverflowDelayedTaskList
 7533              		.cfi_endproc
 7534              	.LFE59:
 7536              		.align	2
 7537              		.thumb
 7538              		.thumb_func
 7540              	prvCheckTasksWaitingTermination:
 7541              	.LFB60:
2052:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2053:../3rdParty/FreeRTOS/tasks.c **** 
2054:../3rdParty/FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2055:../3rdParty/FreeRTOS/tasks.c **** {
 7542              		.loc 1 2055 0
 7543              		.cfi_startproc
 7544              		@ args = 0, pretend = 0, frame = 8
 7545              		@ frame_needed = 1, uses_anonymous_args = 0
 7546 10ac 80B5     		push	{r7, lr}
 7547              	.LCFI89:
 7548              		.cfi_def_cfa_offset 8
 7549 10ae 82B0     		sub	sp, sp, #8
 7550              	.LCFI90:
 7551              		.cfi_def_cfa_offset 16
 7552 10b0 00AF     		add	r7, sp, #0
 7553              		.cfi_offset 14, -4
 7554              		.cfi_offset 7, -8
 7555              	.LCFI91:
 7556              		.cfi_def_cfa_register 7
 7557              	.LBB9:
2056:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2057:../3rdParty/FreeRTOS/tasks.c **** 	{
2058:../3rdParty/FreeRTOS/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2059:../3rdParty/FreeRTOS/tasks.c **** 
2060:../3rdParty/FreeRTOS/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2061:../3rdParty/FreeRTOS/tasks.c **** 		too often in the idle task. */
2062:../3rdParty/FreeRTOS/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 7558              		.loc 1 2062 0
 7559 10b2 194B     		ldr	r3, .L191
 7560 10b4 1B68     		ldr	r3, [r3, #0]
 7561 10b6 002B     		cmp	r3, #0
 7562 10b8 2AD0     		beq	.L189
2063:../3rdParty/FreeRTOS/tasks.c **** 		{
2064:../3rdParty/FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 7563              		.loc 1 2064 0
 7564 10ba FFF7FEFF 		bl	vTaskSuspendAll
2065:../3rdParty/FreeRTOS/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 7565              		.loc 1 2065 0
 7566 10be 174B     		ldr	r3, .L191+4
 7567 10c0 1B68     		ldr	r3, [r3, #0]
 7568 10c2 002B     		cmp	r3, #0
 7569 10c4 14BF     		ite	ne
 7570 10c6 0023     		movne	r3, #0
 7571 10c8 0123     		moveq	r3, #1
 7572 10ca 7B60     		str	r3, [r7, #4]
2066:../3rdParty/FreeRTOS/tasks.c **** 			xTaskResumeAll();
 7573              		.loc 1 2066 0
 7574 10cc FFF7FEFF 		bl	xTaskResumeAll
2067:../3rdParty/FreeRTOS/tasks.c **** 
2068:../3rdParty/FreeRTOS/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 7575              		.loc 1 2068 0
 7576 10d0 7B68     		ldr	r3, [r7, #4]
 7577 10d2 002B     		cmp	r3, #0
 7578 10d4 1CD1     		bne	.L189
 7579              	.LBB10:
2069:../3rdParty/FreeRTOS/tasks.c **** 			{
2070:../3rdParty/FreeRTOS/tasks.c **** 				tskTCB *pxTCB;
2071:../3rdParty/FreeRTOS/tasks.c **** 
2072:../3rdParty/FreeRTOS/tasks.c **** 				taskENTER_CRITICAL();
 7580              		.loc 1 2072 0
 7581 10d6 FFF7FEFF 		bl	vPortEnterCritical
2073:../3rdParty/FreeRTOS/tasks.c **** 				{
2074:../3rdParty/FreeRTOS/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 7582              		.loc 1 2074 0
 7583 10da 104B     		ldr	r3, .L191+4
 7584 10dc DB68     		ldr	r3, [r3, #12]
 7585 10de DB68     		ldr	r3, [r3, #12]
 7586 10e0 3B60     		str	r3, [r7, #0]
2075:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 7587              		.loc 1 2075 0
 7588 10e2 3B68     		ldr	r3, [r7, #0]
 7589 10e4 03F10403 		add	r3, r3, #4
 7590 10e8 1846     		mov	r0, r3
 7591 10ea FFF7FEFF 		bl	vListRemove
2076:../3rdParty/FreeRTOS/tasks.c **** 					--uxCurrentNumberOfTasks;
 7592              		.loc 1 2076 0
 7593 10ee 0C4B     		ldr	r3, .L191+8
 7594 10f0 1B68     		ldr	r3, [r3, #0]
 7595 10f2 03F1FF32 		add	r2, r3, #-1
 7596 10f6 0A4B     		ldr	r3, .L191+8
 7597 10f8 1A60     		str	r2, [r3, #0]
2077:../3rdParty/FreeRTOS/tasks.c **** 					--uxTasksDeleted;
 7598              		.loc 1 2077 0
 7599 10fa 074B     		ldr	r3, .L191
 7600 10fc 1B68     		ldr	r3, [r3, #0]
 7601 10fe 03F1FF32 		add	r2, r3, #-1
 7602 1102 054B     		ldr	r3, .L191
 7603 1104 1A60     		str	r2, [r3, #0]
2078:../3rdParty/FreeRTOS/tasks.c **** 				}
2079:../3rdParty/FreeRTOS/tasks.c **** 				taskEXIT_CRITICAL();
 7604              		.loc 1 2079 0
 7605 1106 FFF7FEFF 		bl	vPortExitCritical
2080:../3rdParty/FreeRTOS/tasks.c **** 
2081:../3rdParty/FreeRTOS/tasks.c **** 				prvDeleteTCB( pxTCB );
 7606              		.loc 1 2081 0
 7607 110a 3868     		ldr	r0, [r7, #0]
 7608 110c 00F08AF9 		bl	prvDeleteTCB
 7609              	.L189:
 7610              	.LBE10:
 7611              	.LBE9:
2082:../3rdParty/FreeRTOS/tasks.c **** 			}
2083:../3rdParty/FreeRTOS/tasks.c **** 		}
2084:../3rdParty/FreeRTOS/tasks.c **** 	}
2085:../3rdParty/FreeRTOS/tasks.c **** 	#endif
2086:../3rdParty/FreeRTOS/tasks.c **** }
 7612              		.loc 1 2086 0
 7613 1110 07F10807 		add	r7, r7, #8
 7614 1114 BD46     		mov	sp, r7
 7615 1116 80BD     		pop	{r7, pc}
 7616              	.L192:
 7617              		.align	2
 7618              	.L191:
 7619 1118 C0000000 		.word	uxTasksDeleted
 7620 111c AC000000 		.word	xTasksWaitingTermination
 7621 1120 D8000000 		.word	uxCurrentNumberOfTasks
 7622              		.cfi_endproc
 7623              	.LFE60:
 7625              		.align	2
 7626              		.thumb
 7627              		.thumb_func
 7629              	prvAddCurrentTaskToDelayedList:
 7630              	.LFB61:
2087:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2088:../3rdParty/FreeRTOS/tasks.c **** 
2089:../3rdParty/FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2090:../3rdParty/FreeRTOS/tasks.c **** {
 7631              		.loc 1 2090 0
 7632              		.cfi_startproc
 7633              		@ args = 0, pretend = 0, frame = 8
 7634              		@ frame_needed = 1, uses_anonymous_args = 0
 7635 1124 80B5     		push	{r7, lr}
 7636              	.LCFI92:
 7637              		.cfi_def_cfa_offset 8
 7638 1126 82B0     		sub	sp, sp, #8
 7639              	.LCFI93:
 7640              		.cfi_def_cfa_offset 16
 7641 1128 00AF     		add	r7, sp, #0
 7642              		.cfi_offset 14, -4
 7643              		.cfi_offset 7, -8
 7644              	.LCFI94:
 7645              		.cfi_def_cfa_register 7
 7646 112a 7860     		str	r0, [r7, #4]
2091:../3rdParty/FreeRTOS/tasks.c **** 	/* The list item will be inserted in wake time order. */
2092:../3rdParty/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 7647              		.loc 1 2092 0
 7648 112c 144B     		ldr	r3, .L196
 7649 112e 1B68     		ldr	r3, [r3, #0]
 7650 1130 7A68     		ldr	r2, [r7, #4]
 7651 1132 5A60     		str	r2, [r3, #4]
2093:../3rdParty/FreeRTOS/tasks.c **** 
2094:../3rdParty/FreeRTOS/tasks.c **** 	if( xTimeToWake < xTickCount )
 7652              		.loc 1 2094 0
 7653 1134 134B     		ldr	r3, .L196+4
 7654 1136 1B68     		ldr	r3, [r3, #0]
 7655 1138 7A68     		ldr	r2, [r7, #4]
 7656 113a 9A42     		cmp	r2, r3
 7657 113c 0AD2     		bcs	.L194
2095:../3rdParty/FreeRTOS/tasks.c **** 	{
2096:../3rdParty/FreeRTOS/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2097:../3rdParty/FreeRTOS/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 7658              		.loc 1 2097 0
 7659 113e 124B     		ldr	r3, .L196+8
 7660 1140 1A68     		ldr	r2, [r3, #0]
 7661 1142 0F4B     		ldr	r3, .L196
 7662 1144 1B68     		ldr	r3, [r3, #0]
 7663 1146 03F10403 		add	r3, r3, #4
 7664 114a 1046     		mov	r0, r2
 7665 114c 1946     		mov	r1, r3
 7666 114e FFF7FEFF 		bl	vListInsert
 7667 1152 11E0     		b	.L193
 7668              	.L194:
2098:../3rdParty/FreeRTOS/tasks.c **** 	}
2099:../3rdParty/FreeRTOS/tasks.c **** 	else
2100:../3rdParty/FreeRTOS/tasks.c **** 	{
2101:../3rdParty/FreeRTOS/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2102:../3rdParty/FreeRTOS/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 7669              		.loc 1 2102 0
 7670 1154 0D4B     		ldr	r3, .L196+12
 7671 1156 1A68     		ldr	r2, [r3, #0]
 7672 1158 094B     		ldr	r3, .L196
 7673 115a 1B68     		ldr	r3, [r3, #0]
 7674 115c 03F10403 		add	r3, r3, #4
 7675 1160 1046     		mov	r0, r2
 7676 1162 1946     		mov	r1, r3
 7677 1164 FFF7FEFF 		bl	vListInsert
2103:../3rdParty/FreeRTOS/tasks.c **** 
2104:../3rdParty/FreeRTOS/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2105:../3rdParty/FreeRTOS/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2106:../3rdParty/FreeRTOS/tasks.c **** 		too. */
2107:../3rdParty/FreeRTOS/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 7678              		.loc 1 2107 0
 7679 1168 094B     		ldr	r3, .L196+16
 7680 116a 1B68     		ldr	r3, [r3, #0]
 7681 116c 7A68     		ldr	r2, [r7, #4]
 7682 116e 9A42     		cmp	r2, r3
 7683 1170 02D2     		bcs	.L193
2108:../3rdParty/FreeRTOS/tasks.c **** 		{
2109:../3rdParty/FreeRTOS/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 7684              		.loc 1 2109 0
 7685 1172 074B     		ldr	r3, .L196+16
 7686 1174 7A68     		ldr	r2, [r7, #4]
 7687 1176 1A60     		str	r2, [r3, #0]
 7688              	.L193:
2110:../3rdParty/FreeRTOS/tasks.c **** 		}
2111:../3rdParty/FreeRTOS/tasks.c **** 	}
2112:../3rdParty/FreeRTOS/tasks.c **** }
 7689              		.loc 1 2112 0
 7690 1178 07F10807 		add	r7, r7, #8
 7691 117c BD46     		mov	sp, r7
 7692 117e 80BD     		pop	{r7, pc}
 7693              	.L197:
 7694              		.align	2
 7695              	.L196:
 7696 1180 00000000 		.word	pxCurrentTCB
 7697 1184 DC000000 		.word	xTickCount
 7698 1188 94000000 		.word	pxOverflowDelayedTaskList
 7699 118c 90000000 		.word	pxDelayedTaskList
 7700 1190 00000000 		.word	xNextTaskUnblockTime
 7701              		.cfi_endproc
 7702              	.LFE61:
 7704              		.align	2
 7705              		.thumb
 7706              		.thumb_func
 7708              	prvAllocateTCBAndStack:
 7709              	.LFB62:
2113:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2114:../3rdParty/FreeRTOS/tasks.c **** 
2115:../3rdParty/FreeRTOS/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2116:../3rdParty/FreeRTOS/tasks.c **** {
 7710              		.loc 1 2116 0
 7711              		.cfi_startproc
 7712              		@ args = 0, pretend = 0, frame = 16
 7713              		@ frame_needed = 1, uses_anonymous_args = 0
 7714 1194 80B5     		push	{r7, lr}
 7715              	.LCFI95:
 7716              		.cfi_def_cfa_offset 8
 7717 1196 84B0     		sub	sp, sp, #16
 7718              	.LCFI96:
 7719              		.cfi_def_cfa_offset 24
 7720 1198 00AF     		add	r7, sp, #0
 7721              		.cfi_offset 14, -4
 7722              		.cfi_offset 7, -8
 7723              	.LCFI97:
 7724              		.cfi_def_cfa_register 7
 7725 119a 0346     		mov	r3, r0
 7726 119c 3960     		str	r1, [r7, #0]
 7727 119e FB80     		strh	r3, [r7, #6]	@ movhi
2117:../3rdParty/FreeRTOS/tasks.c **** tskTCB *pxNewTCB;
2118:../3rdParty/FreeRTOS/tasks.c **** 
2119:../3rdParty/FreeRTOS/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2120:../3rdParty/FreeRTOS/tasks.c **** 	the implementation of the port malloc function. */
2121:../3rdParty/FreeRTOS/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 7728              		.loc 1 2121 0
 7729 11a0 4FF05000 		mov	r0, #80
 7730 11a4 FFF7FEFF 		bl	pvPortMalloc
 7731 11a8 0346     		mov	r3, r0
 7732 11aa FB60     		str	r3, [r7, #12]
2122:../3rdParty/FreeRTOS/tasks.c **** 
2123:../3rdParty/FreeRTOS/tasks.c **** 	if( pxNewTCB != NULL )
 7733              		.loc 1 2123 0
 7734 11ac FB68     		ldr	r3, [r7, #12]
 7735 11ae 002B     		cmp	r3, #0
 7736 11b0 23D0     		beq	.L199
2124:../3rdParty/FreeRTOS/tasks.c **** 	{
2125:../3rdParty/FreeRTOS/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2126:../3rdParty/FreeRTOS/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2127:../3rdParty/FreeRTOS/tasks.c **** 		be deleted later if required. */
2128:../3rdParty/FreeRTOS/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 7737              		.loc 1 2128 0
 7738 11b2 3B68     		ldr	r3, [r7, #0]
 7739 11b4 002B     		cmp	r3, #0
 7740 11b6 07D1     		bne	.L200
 7741              		.loc 1 2128 0 is_stmt 0 discriminator 1
 7742 11b8 FB88     		ldrh	r3, [r7, #6]
 7743 11ba 4FEA8303 		lsl	r3, r3, #2
 7744 11be 1846     		mov	r0, r3
 7745 11c0 FFF7FEFF 		bl	pvPortMalloc
 7746 11c4 0346     		mov	r3, r0
 7747 11c6 00E0     		b	.L201
 7748              	.L200:
 7749              		.loc 1 2128 0 discriminator 2
 7750 11c8 3B68     		ldr	r3, [r7, #0]
 7751              	.L201:
 7752              		.loc 1 2128 0 discriminator 3
 7753 11ca FA68     		ldr	r2, [r7, #12]
 7754 11cc 1363     		str	r3, [r2, #48]
2129:../3rdParty/FreeRTOS/tasks.c **** 
2130:../3rdParty/FreeRTOS/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 7755              		.loc 1 2130 0 is_stmt 1 discriminator 3
 7756 11ce FB68     		ldr	r3, [r7, #12]
 7757 11d0 1B6B     		ldr	r3, [r3, #48]
 7758 11d2 002B     		cmp	r3, #0
 7759 11d4 06D1     		bne	.L202
2131:../3rdParty/FreeRTOS/tasks.c **** 		{
2132:../3rdParty/FreeRTOS/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2133:../3rdParty/FreeRTOS/tasks.c **** 			vPortFree( pxNewTCB );
 7760              		.loc 1 2133 0
 7761 11d6 F868     		ldr	r0, [r7, #12]
 7762 11d8 FFF7FEFF 		bl	vPortFree
2134:../3rdParty/FreeRTOS/tasks.c **** 			pxNewTCB = NULL;
 7763              		.loc 1 2134 0
 7764 11dc 4FF00003 		mov	r3, #0
 7765 11e0 FB60     		str	r3, [r7, #12]
 7766 11e2 0AE0     		b	.L199
 7767              	.L202:
2135:../3rdParty/FreeRTOS/tasks.c **** 		}
2136:../3rdParty/FreeRTOS/tasks.c **** 		else
2137:../3rdParty/FreeRTOS/tasks.c **** 		{
2138:../3rdParty/FreeRTOS/tasks.c **** 			/* Just to help debugging. */
2139:../3rdParty/FreeRTOS/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 7768              		.loc 1 2139 0
 7769 11e4 FB68     		ldr	r3, [r7, #12]
 7770 11e6 1A6B     		ldr	r2, [r3, #48]
 7771 11e8 FB88     		ldrh	r3, [r7, #6]
 7772 11ea 4FEA8303 		lsl	r3, r3, #2
 7773 11ee 1046     		mov	r0, r2
 7774 11f0 4FF0A501 		mov	r1, #165
 7775 11f4 1A46     		mov	r2, r3
 7776 11f6 FFF7FEFF 		bl	memset
 7777              	.L199:
2140:../3rdParty/FreeRTOS/tasks.c **** 		}
2141:../3rdParty/FreeRTOS/tasks.c **** 	}
2142:../3rdParty/FreeRTOS/tasks.c **** 
2143:../3rdParty/FreeRTOS/tasks.c **** 	return pxNewTCB;
 7778              		.loc 1 2143 0
 7779 11fa FB68     		ldr	r3, [r7, #12]
2144:../3rdParty/FreeRTOS/tasks.c **** }
 7780              		.loc 1 2144 0
 7781 11fc 1846     		mov	r0, r3
 7782 11fe 07F11007 		add	r7, r7, #16
 7783 1202 BD46     		mov	sp, r7
 7784 1204 80BD     		pop	{r7, pc}
 7785              		.cfi_endproc
 7786              	.LFE62:
 7788              		.section	.rodata
 7789 000b 00       		.align	2
 7790              	.LC2:
 7791 000c 25730909 		.ascii	"%s\011\011%c\011%u\011%u\011%u\015\012\000"
 7791      25630925 
 7791      75092575 
 7791      0925750D 
 7791      0A00
 7792              		.text
 7793 1206 00BF     		.align	2
 7794              		.thumb
 7795              		.thumb_func
 7797              	prvListTaskWithinSingleList:
 7798              	.LFB63:
2145:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2146:../3rdParty/FreeRTOS/tasks.c **** 
2147:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2148:../3rdParty/FreeRTOS/tasks.c **** 
2149:../3rdParty/FreeRTOS/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2150:../3rdParty/FreeRTOS/tasks.c **** 	{
 7799              		.loc 1 2150 0
 7800              		.cfi_startproc
 7801              		@ args = 0, pretend = 0, frame = 40
 7802              		@ frame_needed = 1, uses_anonymous_args = 0
 7803 1208 90B5     		push	{r4, r7, lr}
 7804              	.LCFI98:
 7805              		.cfi_def_cfa_offset 12
 7806 120a 8FB0     		sub	sp, sp, #60
 7807              	.LCFI99:
 7808              		.cfi_def_cfa_offset 72
 7809 120c 04AF     		add	r7, sp, #16
 7810              		.cfi_offset 14, -4
 7811              		.cfi_offset 7, -8
 7812              		.cfi_offset 4, -12
 7813              	.LCFI100:
 7814              		.cfi_def_cfa 7, 56
 7815 120e F860     		str	r0, [r7, #12]
 7816 1210 B960     		str	r1, [r7, #8]
 7817 1212 1346     		mov	r3, r2
 7818 1214 FB71     		strb	r3, [r7, #7]
 7819              	.LBB11:
2151:../3rdParty/FreeRTOS/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2152:../3rdParty/FreeRTOS/tasks.c **** 	unsigned short usStackRemaining;
2153:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
2154:../3rdParty/FreeRTOS/tasks.c **** 
2155:../3rdParty/FreeRTOS/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2156:../3rdParty/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 7820              		.loc 1 2156 0
 7821 1216 BB68     		ldr	r3, [r7, #8]
 7822 1218 7B62     		str	r3, [r7, #36]
 7823 121a 7B6A     		ldr	r3, [r7, #36]
 7824 121c 5B68     		ldr	r3, [r3, #4]
 7825 121e 5A68     		ldr	r2, [r3, #4]
 7826 1220 7B6A     		ldr	r3, [r7, #36]
 7827 1222 5A60     		str	r2, [r3, #4]
 7828 1224 7B6A     		ldr	r3, [r7, #36]
 7829 1226 5A68     		ldr	r2, [r3, #4]
 7830 1228 7B6A     		ldr	r3, [r7, #36]
 7831 122a 03F10803 		add	r3, r3, #8
 7832 122e 9A42     		cmp	r2, r3
 7833 1230 04D1     		bne	.L204
 7834              		.loc 1 2156 0 is_stmt 0 discriminator 1
 7835 1232 7B6A     		ldr	r3, [r7, #36]
 7836 1234 5B68     		ldr	r3, [r3, #4]
 7837 1236 5A68     		ldr	r2, [r3, #4]
 7838 1238 7B6A     		ldr	r3, [r7, #36]
 7839 123a 5A60     		str	r2, [r3, #4]
 7840              	.L204:
 7841              		.loc 1 2156 0 discriminator 2
 7842 123c 7B6A     		ldr	r3, [r7, #36]
 7843 123e 5B68     		ldr	r3, [r3, #4]
 7844 1240 DB68     		ldr	r3, [r3, #12]
 7845 1242 3B62     		str	r3, [r7, #32]
 7846              	.L206:
 7847              	.LBE11:
 7848              	.LBB12:
2157:../3rdParty/FreeRTOS/tasks.c **** 		do
2158:../3rdParty/FreeRTOS/tasks.c **** 		{
2159:../3rdParty/FreeRTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 7849              		.loc 1 2159 0 is_stmt 1
 7850 1244 BB68     		ldr	r3, [r7, #8]
 7851 1246 FB61     		str	r3, [r7, #28]
 7852 1248 FB69     		ldr	r3, [r7, #28]
 7853 124a 5B68     		ldr	r3, [r3, #4]
 7854 124c 5A68     		ldr	r2, [r3, #4]
 7855 124e FB69     		ldr	r3, [r7, #28]
 7856 1250 5A60     		str	r2, [r3, #4]
 7857 1252 FB69     		ldr	r3, [r7, #28]
 7858 1254 5A68     		ldr	r2, [r3, #4]
 7859 1256 FB69     		ldr	r3, [r7, #28]
 7860 1258 03F10803 		add	r3, r3, #8
 7861 125c 9A42     		cmp	r2, r3
 7862 125e 04D1     		bne	.L205
 7863              		.loc 1 2159 0 is_stmt 0 discriminator 1
 7864 1260 FB69     		ldr	r3, [r7, #28]
 7865 1262 5B68     		ldr	r3, [r3, #4]
 7866 1264 5A68     		ldr	r2, [r3, #4]
 7867 1266 FB69     		ldr	r3, [r7, #28]
 7868 1268 5A60     		str	r2, [r3, #4]
 7869              	.L205:
 7870              		.loc 1 2159 0 discriminator 2
 7871 126a FB69     		ldr	r3, [r7, #28]
 7872 126c 5B68     		ldr	r3, [r3, #4]
 7873 126e DB68     		ldr	r3, [r3, #12]
 7874 1270 BB61     		str	r3, [r7, #24]
 7875              	.LBE12:
2160:../3rdParty/FreeRTOS/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2161:../3rdParty/FreeRTOS/tasks.c **** 			{
2162:../3rdParty/FreeRTOS/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2163:../3rdParty/FreeRTOS/tasks.c **** 			}
2164:../3rdParty/FreeRTOS/tasks.c **** 			#else
2165:../3rdParty/FreeRTOS/tasks.c **** 			{
2166:../3rdParty/FreeRTOS/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
 7876              		.loc 1 2166 0 is_stmt 1 discriminator 2
 7877 1272 BB69     		ldr	r3, [r7, #24]
 7878 1274 1B6B     		ldr	r3, [r3, #48]
 7879 1276 1846     		mov	r0, r3
 7880 1278 00F09CF8 		bl	usTaskCheckFreeStackSpace
 7881 127c 0346     		mov	r3, r0
 7882 127e FB82     		strh	r3, [r7, #22]	@ movhi
2167:../3rdParty/FreeRTOS/tasks.c **** 			}
2168:../3rdParty/FreeRTOS/tasks.c **** 			#endif			
2169:../3rdParty/FreeRTOS/tasks.c **** 			
2170:../3rdParty/FreeRTOS/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 7883              		.loc 1 2170 0 discriminator 2
 7884 1280 BB69     		ldr	r3, [r7, #24]
 7885 1282 03F13402 		add	r2, r3, #52
 7886 1286 97F90730 		ldrsb	r3, [r7, #7]
 7887 128a B969     		ldr	r1, [r7, #24]
 7888 128c CC6A     		ldr	r4, [r1, #44]
 7889 128e F88A     		ldrh	r0, [r7, #22]
 7890 1290 B969     		ldr	r1, [r7, #24]
 7891 1292 096C     		ldr	r1, [r1, #64]
 7892 1294 0094     		str	r4, [sp, #0]
 7893 1296 0190     		str	r0, [sp, #4]
 7894 1298 0291     		str	r1, [sp, #8]
 7895 129a 0848     		ldr	r0, .L207
 7896 129c 0849     		ldr	r1, .L207+4
 7897 129e FFF7FEFF 		bl	sprintf
2171:../3rdParty/FreeRTOS/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
 7898              		.loc 1 2171 0 discriminator 2
 7899 12a2 FB68     		ldr	r3, [r7, #12]
 7900 12a4 1846     		mov	r0, r3
 7901 12a6 0549     		ldr	r1, .L207
 7902 12a8 FFF7FEFF 		bl	strcat
2172:../3rdParty/FreeRTOS/tasks.c **** 
2173:../3rdParty/FreeRTOS/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 7903              		.loc 1 2173 0 discriminator 2
 7904 12ac BA69     		ldr	r2, [r7, #24]
 7905 12ae 3B6A     		ldr	r3, [r7, #32]
 7906 12b0 9A42     		cmp	r2, r3
 7907 12b2 C7D1     		bne	.L206
2174:../3rdParty/FreeRTOS/tasks.c **** 	}
 7908              		.loc 1 2174 0
 7909 12b4 07F12C07 		add	r7, r7, #44
 7910 12b8 BD46     		mov	sp, r7
 7911 12ba 90BD     		pop	{r4, r7, pc}
 7912              	.L208:
 7913              		.align	2
 7914              	.L207:
 7915 12bc 38010000 		.word	pcStatusString.6881
 7916 12c0 0C000000 		.word	.LC2
 7917              		.cfi_endproc
 7918              	.LFE63:
 7920              		.section	.rodata
 7921 001e 0000     		.align	2
 7922              	.LC3:
 7923 0020 25730909 		.ascii	"%s\011\0110\011\0110%%\015\012\000"
 7923      30090930 
 7923      25250D0A 
 7923      00
 7924 002d 000000   		.align	2
 7925              	.LC4:
 7926 0030 25730909 		.ascii	"%s\011\011%u\011\011%u%%\015\012\000"
 7926      25750909 
 7926      25752525 
 7926      0D0A00
 7927 003f 00       		.align	2
 7928              	.LC5:
 7929 0040 25730909 		.ascii	"%s\011\011%u\011\011<1%%\015\012\000"
 7929      25750909 
 7929      3C312525 
 7929      0D0A00
 7930              		.text
 7931              		.align	2
 7932              		.thumb
 7933              		.thumb_func
 7935              	prvGenerateRunTimeStatsForTasksInList:
 7936              	.LFB64:
2175:../3rdParty/FreeRTOS/tasks.c **** 
2176:../3rdParty/FreeRTOS/tasks.c **** #endif
2177:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2178:../3rdParty/FreeRTOS/tasks.c **** 
2179:../3rdParty/FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2180:../3rdParty/FreeRTOS/tasks.c **** 
2181:../3rdParty/FreeRTOS/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2182:../3rdParty/FreeRTOS/tasks.c **** 	{
 7937              		.loc 1 2182 0
 7938              		.cfi_startproc
 7939              		@ args = 0, pretend = 0, frame = 40
 7940              		@ frame_needed = 1, uses_anonymous_args = 0
 7941 12c4 80B5     		push	{r7, lr}
 7942              	.LCFI101:
 7943              		.cfi_def_cfa_offset 8
 7944 12c6 8CB0     		sub	sp, sp, #48
 7945              	.LCFI102:
 7946              		.cfi_def_cfa_offset 56
 7947 12c8 02AF     		add	r7, sp, #8
 7948              		.cfi_offset 14, -4
 7949              		.cfi_offset 7, -8
 7950              	.LCFI103:
 7951              		.cfi_def_cfa 7, 48
 7952 12ca F860     		str	r0, [r7, #12]
 7953 12cc B960     		str	r1, [r7, #8]
 7954 12ce 7A60     		str	r2, [r7, #4]
 7955              	.LBB13:
2183:../3rdParty/FreeRTOS/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2184:../3rdParty/FreeRTOS/tasks.c **** 	unsigned long ulStatsAsPercentage;
2185:../3rdParty/FreeRTOS/tasks.c **** 
2186:../3rdParty/FreeRTOS/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2187:../3rdParty/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 7956              		.loc 1 2187 0
 7957 12d0 BB68     		ldr	r3, [r7, #8]
 7958 12d2 7B62     		str	r3, [r7, #36]
 7959 12d4 7B6A     		ldr	r3, [r7, #36]
 7960 12d6 5B68     		ldr	r3, [r3, #4]
 7961 12d8 5A68     		ldr	r2, [r3, #4]
 7962 12da 7B6A     		ldr	r3, [r7, #36]
 7963 12dc 5A60     		str	r2, [r3, #4]
 7964 12de 7B6A     		ldr	r3, [r7, #36]
 7965 12e0 5A68     		ldr	r2, [r3, #4]
 7966 12e2 7B6A     		ldr	r3, [r7, #36]
 7967 12e4 03F10803 		add	r3, r3, #8
 7968 12e8 9A42     		cmp	r2, r3
 7969 12ea 04D1     		bne	.L210
 7970              		.loc 1 2187 0 is_stmt 0 discriminator 1
 7971 12ec 7B6A     		ldr	r3, [r7, #36]
 7972 12ee 5B68     		ldr	r3, [r3, #4]
 7973 12f0 5A68     		ldr	r2, [r3, #4]
 7974 12f2 7B6A     		ldr	r3, [r7, #36]
 7975 12f4 5A60     		str	r2, [r3, #4]
 7976              	.L210:
 7977              		.loc 1 2187 0 discriminator 2
 7978 12f6 7B6A     		ldr	r3, [r7, #36]
 7979 12f8 5B68     		ldr	r3, [r3, #4]
 7980 12fa DB68     		ldr	r3, [r3, #12]
 7981 12fc 3B62     		str	r3, [r7, #32]
 7982              	.L216:
 7983              	.LBE13:
 7984              	.LBB14:
2188:../3rdParty/FreeRTOS/tasks.c **** 		do
2189:../3rdParty/FreeRTOS/tasks.c **** 		{
2190:../3rdParty/FreeRTOS/tasks.c **** 			/* Get next TCB in from the list. */
2191:../3rdParty/FreeRTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 7985              		.loc 1 2191 0 is_stmt 1
 7986 12fe BB68     		ldr	r3, [r7, #8]
 7987 1300 FB61     		str	r3, [r7, #28]
 7988 1302 FB69     		ldr	r3, [r7, #28]
 7989 1304 5B68     		ldr	r3, [r3, #4]
 7990 1306 5A68     		ldr	r2, [r3, #4]
 7991 1308 FB69     		ldr	r3, [r7, #28]
 7992 130a 5A60     		str	r2, [r3, #4]
 7993 130c FB69     		ldr	r3, [r7, #28]
 7994 130e 5A68     		ldr	r2, [r3, #4]
 7995 1310 FB69     		ldr	r3, [r7, #28]
 7996 1312 03F10803 		add	r3, r3, #8
 7997 1316 9A42     		cmp	r2, r3
 7998 1318 04D1     		bne	.L211
 7999              		.loc 1 2191 0 is_stmt 0 discriminator 1
 8000 131a FB69     		ldr	r3, [r7, #28]
 8001 131c 5B68     		ldr	r3, [r3, #4]
 8002 131e 5A68     		ldr	r2, [r3, #4]
 8003 1320 FB69     		ldr	r3, [r7, #28]
 8004 1322 5A60     		str	r2, [r3, #4]
 8005              	.L211:
 8006              		.loc 1 2191 0 discriminator 2
 8007 1324 FB69     		ldr	r3, [r7, #28]
 8008 1326 5B68     		ldr	r3, [r3, #4]
 8009 1328 DB68     		ldr	r3, [r3, #12]
 8010 132a BB61     		str	r3, [r7, #24]
 8011              	.LBE14:
2192:../3rdParty/FreeRTOS/tasks.c **** 
2193:../3rdParty/FreeRTOS/tasks.c **** 			/* Divide by zero check. */
2194:../3rdParty/FreeRTOS/tasks.c **** 			if( ulTotalRunTime > 0UL )
 8012              		.loc 1 2194 0 is_stmt 1 discriminator 2
 8013 132c 7B68     		ldr	r3, [r7, #4]
 8014 132e 002B     		cmp	r3, #0
 8015 1330 2FD0     		beq	.L212
2195:../3rdParty/FreeRTOS/tasks.c **** 			{
2196:../3rdParty/FreeRTOS/tasks.c **** 				/* Has the task run at all? */
2197:../3rdParty/FreeRTOS/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
 8016              		.loc 1 2197 0
 8017 1332 BB69     		ldr	r3, [r7, #24]
 8018 1334 DB6C     		ldr	r3, [r3, #76]
 8019 1336 002B     		cmp	r3, #0
 8020 1338 08D1     		bne	.L213
2198:../3rdParty/FreeRTOS/tasks.c **** 				{
2199:../3rdParty/FreeRTOS/tasks.c **** 					/* The task has used no CPU time at all. */
2200:../3rdParty/FreeRTOS/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
 8021              		.loc 1 2200 0
 8022 133a BB69     		ldr	r3, [r7, #24]
 8023 133c 03F13403 		add	r3, r3, #52
 8024 1340 1848     		ldr	r0, .L217
 8025 1342 1949     		ldr	r1, .L217+4
 8026 1344 1A46     		mov	r2, r3
 8027 1346 FFF7FEFF 		bl	sprintf
 8028 134a 1DE0     		b	.L214
 8029              	.L213:
2201:../3rdParty/FreeRTOS/tasks.c **** 				}
2202:../3rdParty/FreeRTOS/tasks.c **** 				else
2203:../3rdParty/FreeRTOS/tasks.c **** 				{
2204:../3rdParty/FreeRTOS/tasks.c **** 					/* What percentage of the total run time has the task used?
2205:../3rdParty/FreeRTOS/tasks.c **** 					This will always be rounded down to the nearest integer.
2206:../3rdParty/FreeRTOS/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2207:../3rdParty/FreeRTOS/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
 8030              		.loc 1 2207 0
 8031 134c BB69     		ldr	r3, [r7, #24]
 8032 134e DA6C     		ldr	r2, [r3, #76]
 8033 1350 7B68     		ldr	r3, [r7, #4]
 8034 1352 B2FBF3F3 		udiv	r3, r2, r3
 8035 1356 7B61     		str	r3, [r7, #20]
2208:../3rdParty/FreeRTOS/tasks.c **** 
2209:../3rdParty/FreeRTOS/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
 8036              		.loc 1 2209 0
 8037 1358 7B69     		ldr	r3, [r7, #20]
 8038 135a 002B     		cmp	r3, #0
 8039 135c 0BD0     		beq	.L215
2210:../3rdParty/FreeRTOS/tasks.c **** 					{
2211:../3rdParty/FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2212:../3rdParty/FreeRTOS/tasks.c **** 						{
2213:../3rdParty/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2214:../3rdParty/FreeRTOS/tasks.c **** 						}
2215:../3rdParty/FreeRTOS/tasks.c **** 						#else
2216:../3rdParty/FreeRTOS/tasks.c **** 						{
2217:../3rdParty/FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2218:../3rdParty/FreeRTOS/tasks.c **** 							printf() library can be used. */
2219:../3rdParty/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned
 8040              		.loc 1 2219 0
 8041 135e BB69     		ldr	r3, [r7, #24]
 8042 1360 03F13402 		add	r2, r3, #52
 8043 1364 BB69     		ldr	r3, [r7, #24]
 8044 1366 DB6C     		ldr	r3, [r3, #76]
 8045 1368 7969     		ldr	r1, [r7, #20]
 8046 136a 0091     		str	r1, [sp, #0]
 8047 136c 0D48     		ldr	r0, .L217
 8048 136e 0F49     		ldr	r1, .L217+8
 8049 1370 FFF7FEFF 		bl	sprintf
 8050 1374 08E0     		b	.L214
 8051              	.L215:
2220:../3rdParty/FreeRTOS/tasks.c **** 						}
2221:../3rdParty/FreeRTOS/tasks.c **** 						#endif
2222:../3rdParty/FreeRTOS/tasks.c **** 					}
2223:../3rdParty/FreeRTOS/tasks.c **** 					else
2224:../3rdParty/FreeRTOS/tasks.c **** 					{
2225:../3rdParty/FreeRTOS/tasks.c **** 						/* If the percentage is zero here then the task has
2226:../3rdParty/FreeRTOS/tasks.c **** 						consumed less than 1% of the total run time. */
2227:../3rdParty/FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2228:../3rdParty/FreeRTOS/tasks.c **** 						{
2229:../3rdParty/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2230:../3rdParty/FreeRTOS/tasks.c **** 						}
2231:../3rdParty/FreeRTOS/tasks.c **** 						#else
2232:../3rdParty/FreeRTOS/tasks.c **** 						{
2233:../3rdParty/FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2234:../3rdParty/FreeRTOS/tasks.c **** 							printf() library can be used. */
2235:../3rdParty/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned
 8052              		.loc 1 2235 0
 8053 1376 BB69     		ldr	r3, [r7, #24]
 8054 1378 03F13402 		add	r2, r3, #52
 8055 137c BB69     		ldr	r3, [r7, #24]
 8056 137e DB6C     		ldr	r3, [r3, #76]
 8057 1380 0848     		ldr	r0, .L217
 8058 1382 0B49     		ldr	r1, .L217+12
 8059 1384 FFF7FEFF 		bl	sprintf
 8060              	.L214:
2236:../3rdParty/FreeRTOS/tasks.c **** 						}
2237:../3rdParty/FreeRTOS/tasks.c **** 						#endif
2238:../3rdParty/FreeRTOS/tasks.c **** 					}
2239:../3rdParty/FreeRTOS/tasks.c **** 				}
2240:../3rdParty/FreeRTOS/tasks.c **** 
2241:../3rdParty/FreeRTOS/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
 8061              		.loc 1 2241 0
 8062 1388 FB68     		ldr	r3, [r7, #12]
 8063 138a 1846     		mov	r0, r3
 8064 138c 0549     		ldr	r1, .L217
 8065 138e FFF7FEFF 		bl	strcat
 8066              	.L212:
2242:../3rdParty/FreeRTOS/tasks.c **** 			}
2243:../3rdParty/FreeRTOS/tasks.c **** 
2244:../3rdParty/FreeRTOS/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 8067              		.loc 1 2244 0
 8068 1392 BA69     		ldr	r2, [r7, #24]
 8069 1394 3B6A     		ldr	r3, [r7, #32]
 8070 1396 9A42     		cmp	r2, r3
 8071 1398 B1D1     		bne	.L216
2245:../3rdParty/FreeRTOS/tasks.c **** 	}
 8072              		.loc 1 2245 0
 8073 139a 07F12807 		add	r7, r7, #40
 8074 139e BD46     		mov	sp, r7
 8075 13a0 80BD     		pop	{r7, pc}
 8076              	.L218:
 8077 13a2 00BF     		.align	2
 8078              	.L217:
 8079 13a4 00010000 		.word	pcStatsString
 8080 13a8 20000000 		.word	.LC3
 8081 13ac 30000000 		.word	.LC4
 8082 13b0 40000000 		.word	.LC5
 8083              		.cfi_endproc
 8084              	.LFE64:
 8086              		.align	2
 8087              		.thumb
 8088              		.thumb_func
 8090              	usTaskCheckFreeStackSpace:
 8091              	.LFB65:
2246:../3rdParty/FreeRTOS/tasks.c **** 
2247:../3rdParty/FreeRTOS/tasks.c **** #endif
2248:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2249:../3rdParty/FreeRTOS/tasks.c **** 
2250:../3rdParty/FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2251:../3rdParty/FreeRTOS/tasks.c **** 
2252:../3rdParty/FreeRTOS/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2253:../3rdParty/FreeRTOS/tasks.c **** 	{
 8092              		.loc 1 2253 0
 8093              		.cfi_startproc
 8094              		@ args = 0, pretend = 0, frame = 8
 8095              		@ frame_needed = 1, uses_anonymous_args = 0
 8096              		@ link register save eliminated.
 8097 13b4 90B4     		push	{r4, r7}
 8098              	.LCFI104:
 8099              		.cfi_def_cfa_offset 8
 8100 13b6 82B0     		sub	sp, sp, #8
 8101              	.LCFI105:
 8102              		.cfi_def_cfa_offset 16
 8103 13b8 00AF     		add	r7, sp, #0
 8104              		.cfi_offset 7, -4
 8105              		.cfi_offset 4, -8
 8106              	.LCFI106:
 8107              		.cfi_def_cfa_register 7
 8108 13ba 7860     		str	r0, [r7, #4]
2254:../3rdParty/FreeRTOS/tasks.c **** 	register unsigned short usCount = 0U;
 8109              		.loc 1 2254 0
 8110 13bc 4FF00004 		mov	r4, #0
2255:../3rdParty/FreeRTOS/tasks.c **** 
2256:../3rdParty/FreeRTOS/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 8111              		.loc 1 2256 0
 8112 13c0 06E0     		b	.L220
 8113              	.L221:
2257:../3rdParty/FreeRTOS/tasks.c **** 		{
2258:../3rdParty/FreeRTOS/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 8114              		.loc 1 2258 0
 8115 13c2 7B68     		ldr	r3, [r7, #4]
 8116 13c4 03F10103 		add	r3, r3, #1
 8117 13c8 7B60     		str	r3, [r7, #4]
2259:../3rdParty/FreeRTOS/tasks.c **** 			usCount++;
 8118              		.loc 1 2259 0
 8119 13ca 04F10103 		add	r3, r4, #1
 8120 13ce 9CB2     		uxth	r4, r3
 8121              	.L220:
2256:../3rdParty/FreeRTOS/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 8122              		.loc 1 2256 0 discriminator 1
 8123 13d0 7B68     		ldr	r3, [r7, #4]
 8124 13d2 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 8125 13d4 A52B     		cmp	r3, #165
 8126 13d6 F4D0     		beq	.L221
2260:../3rdParty/FreeRTOS/tasks.c **** 		}
2261:../3rdParty/FreeRTOS/tasks.c **** 
2262:../3rdParty/FreeRTOS/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
 8127              		.loc 1 2262 0
 8128 13d8 4FEA9403 		lsr	r3, r4, #2
 8129 13dc 9CB2     		uxth	r4, r3
2263:../3rdParty/FreeRTOS/tasks.c **** 
2264:../3rdParty/FreeRTOS/tasks.c **** 		return usCount;
 8130              		.loc 1 2264 0
 8131 13de 2346     		mov	r3, r4
2265:../3rdParty/FreeRTOS/tasks.c **** 	}
 8132              		.loc 1 2265 0
 8133 13e0 1846     		mov	r0, r3
 8134 13e2 07F10807 		add	r7, r7, #8
 8135 13e6 BD46     		mov	sp, r7
 8136 13e8 90BC     		pop	{r4, r7}
 8137 13ea 7047     		bx	lr
 8138              		.cfi_endproc
 8139              	.LFE65:
 8141              		.align	2
 8142              		.global	uxTaskGetStackHighWaterMark
 8143              		.thumb
 8144              		.thumb_func
 8146              	uxTaskGetStackHighWaterMark:
 8147              	.LFB66:
2266:../3rdParty/FreeRTOS/tasks.c **** 
2267:../3rdParty/FreeRTOS/tasks.c **** #endif
2268:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2269:../3rdParty/FreeRTOS/tasks.c **** 
2270:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2271:../3rdParty/FreeRTOS/tasks.c **** 
2272:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2273:../3rdParty/FreeRTOS/tasks.c **** 	{
 8148              		.loc 1 2273 0
 8149              		.cfi_startproc
 8150              		@ args = 0, pretend = 0, frame = 24
 8151              		@ frame_needed = 1, uses_anonymous_args = 0
 8152 13ec 80B5     		push	{r7, lr}
 8153              	.LCFI107:
 8154              		.cfi_def_cfa_offset 8
 8155 13ee 86B0     		sub	sp, sp, #24
 8156              	.LCFI108:
 8157              		.cfi_def_cfa_offset 32
 8158 13f0 00AF     		add	r7, sp, #0
 8159              		.cfi_offset 14, -4
 8160              		.cfi_offset 7, -8
 8161              	.LCFI109:
 8162              		.cfi_def_cfa_register 7
 8163 13f2 7860     		str	r0, [r7, #4]
2274:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
2275:../3rdParty/FreeRTOS/tasks.c **** 	unsigned char *pcEndOfStack;
2276:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2277:../3rdParty/FreeRTOS/tasks.c **** 
2278:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 8164              		.loc 1 2278 0
 8165 13f4 7B68     		ldr	r3, [r7, #4]
 8166 13f6 002B     		cmp	r3, #0
 8167 13f8 02D1     		bne	.L223
 8168              		.loc 1 2278 0 is_stmt 0 discriminator 1
 8169 13fa 094B     		ldr	r3, .L225
 8170 13fc 1B68     		ldr	r3, [r3, #0]
 8171 13fe 00E0     		b	.L224
 8172              	.L223:
 8173              		.loc 1 2278 0 discriminator 2
 8174 1400 7B68     		ldr	r3, [r7, #4]
 8175              	.L224:
 8176              		.loc 1 2278 0 discriminator 3
 8177 1402 7B61     		str	r3, [r7, #20]
2279:../3rdParty/FreeRTOS/tasks.c **** 
2280:../3rdParty/FreeRTOS/tasks.c **** 		#if portSTACK_GROWTH < 0
2281:../3rdParty/FreeRTOS/tasks.c **** 		{
2282:../3rdParty/FreeRTOS/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
 8178              		.loc 1 2282 0 is_stmt 1 discriminator 3
 8179 1404 7B69     		ldr	r3, [r7, #20]
 8180 1406 1B6B     		ldr	r3, [r3, #48]
 8181 1408 3B61     		str	r3, [r7, #16]
2283:../3rdParty/FreeRTOS/tasks.c **** 		}
2284:../3rdParty/FreeRTOS/tasks.c **** 		#else
2285:../3rdParty/FreeRTOS/tasks.c **** 		{
2286:../3rdParty/FreeRTOS/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2287:../3rdParty/FreeRTOS/tasks.c **** 		}
2288:../3rdParty/FreeRTOS/tasks.c **** 		#endif
2289:../3rdParty/FreeRTOS/tasks.c **** 
2290:../3rdParty/FreeRTOS/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
 8182              		.loc 1 2290 0 discriminator 3
 8183 140a 3869     		ldr	r0, [r7, #16]
 8184 140c FFF7D2FF 		bl	usTaskCheckFreeStackSpace
 8185 1410 0346     		mov	r3, r0
 8186 1412 FB60     		str	r3, [r7, #12]
2291:../3rdParty/FreeRTOS/tasks.c **** 
2292:../3rdParty/FreeRTOS/tasks.c **** 		return uxReturn;
 8187              		.loc 1 2292 0 discriminator 3
 8188 1414 FB68     		ldr	r3, [r7, #12]
2293:../3rdParty/FreeRTOS/tasks.c **** 	}
 8189              		.loc 1 2293 0 discriminator 3
 8190 1416 1846     		mov	r0, r3
 8191 1418 07F11807 		add	r7, r7, #24
 8192 141c BD46     		mov	sp, r7
 8193 141e 80BD     		pop	{r7, pc}
 8194              	.L226:
 8195              		.align	2
 8196              	.L225:
 8197 1420 00000000 		.word	pxCurrentTCB
 8198              		.cfi_endproc
 8199              	.LFE66:
 8201              		.align	2
 8202              		.thumb
 8203              		.thumb_func
 8205              	prvDeleteTCB:
 8206              	.LFB67:
2294:../3rdParty/FreeRTOS/tasks.c **** 
2295:../3rdParty/FreeRTOS/tasks.c **** #endif
2296:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2297:../3rdParty/FreeRTOS/tasks.c **** 
2298:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2299:../3rdParty/FreeRTOS/tasks.c **** 
2300:../3rdParty/FreeRTOS/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2301:../3rdParty/FreeRTOS/tasks.c **** 	{
 8207              		.loc 1 2301 0
 8208              		.cfi_startproc
 8209              		@ args = 0, pretend = 0, frame = 8
 8210              		@ frame_needed = 1, uses_anonymous_args = 0
 8211 1424 80B5     		push	{r7, lr}
 8212              	.LCFI110:
 8213              		.cfi_def_cfa_offset 8
 8214 1426 82B0     		sub	sp, sp, #8
 8215              	.LCFI111:
 8216              		.cfi_def_cfa_offset 16
 8217 1428 00AF     		add	r7, sp, #0
 8218              		.cfi_offset 14, -4
 8219              		.cfi_offset 7, -8
 8220              	.LCFI112:
 8221              		.cfi_def_cfa_register 7
 8222 142a 7860     		str	r0, [r7, #4]
2302:../3rdParty/FreeRTOS/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2303:../3rdParty/FreeRTOS/tasks.c **** 		above the vPortFree() calls. */
2304:../3rdParty/FreeRTOS/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2305:../3rdParty/FreeRTOS/tasks.c **** 
2306:../3rdParty/FreeRTOS/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2307:../3rdParty/FreeRTOS/tasks.c **** 		the task to free any memory allocated at the application level. */
2308:../3rdParty/FreeRTOS/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 8223              		.loc 1 2308 0
 8224 142c 7B68     		ldr	r3, [r7, #4]
 8225 142e 1B6B     		ldr	r3, [r3, #48]
 8226 1430 1846     		mov	r0, r3
 8227 1432 FFF7FEFF 		bl	vPortFree
2309:../3rdParty/FreeRTOS/tasks.c **** 		vPortFree( pxTCB );
 8228              		.loc 1 2309 0
 8229 1436 7868     		ldr	r0, [r7, #4]
 8230 1438 FFF7FEFF 		bl	vPortFree
2310:../3rdParty/FreeRTOS/tasks.c **** 	}
 8231              		.loc 1 2310 0
 8232 143c 07F10807 		add	r7, r7, #8
 8233 1440 BD46     		mov	sp, r7
 8234 1442 80BD     		pop	{r7, pc}
 8235              		.cfi_endproc
 8236              	.LFE67:
 8238              		.align	2
 8239              		.global	xTaskGetCurrentTaskHandle
 8240              		.thumb
 8241              		.thumb_func
 8243              	xTaskGetCurrentTaskHandle:
 8244              	.LFB68:
2311:../3rdParty/FreeRTOS/tasks.c **** 
2312:../3rdParty/FreeRTOS/tasks.c **** #endif
2313:../3rdParty/FreeRTOS/tasks.c **** 
2314:../3rdParty/FreeRTOS/tasks.c **** 
2315:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2316:../3rdParty/FreeRTOS/tasks.c **** 
2317:../3rdParty/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2318:../3rdParty/FreeRTOS/tasks.c **** 
2319:../3rdParty/FreeRTOS/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2320:../3rdParty/FreeRTOS/tasks.c **** 	{
 8245              		.loc 1 2320 0
 8246              		.cfi_startproc
 8247              		@ args = 0, pretend = 0, frame = 8
 8248              		@ frame_needed = 1, uses_anonymous_args = 0
 8249              		@ link register save eliminated.
 8250 1444 80B4     		push	{r7}
 8251              	.LCFI113:
 8252              		.cfi_def_cfa_offset 4
 8253 1446 83B0     		sub	sp, sp, #12
 8254              	.LCFI114:
 8255              		.cfi_def_cfa_offset 16
 8256 1448 00AF     		add	r7, sp, #0
 8257              		.cfi_offset 7, -4
 8258              	.LCFI115:
 8259              		.cfi_def_cfa_register 7
2321:../3rdParty/FreeRTOS/tasks.c **** 	xTaskHandle xReturn;
2322:../3rdParty/FreeRTOS/tasks.c **** 
2323:../3rdParty/FreeRTOS/tasks.c **** 		/* A critical section is not required as this is not called from
2324:../3rdParty/FreeRTOS/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2325:../3rdParty/FreeRTOS/tasks.c **** 		individual execution thread. */
2326:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = pxCurrentTCB;
 8260              		.loc 1 2326 0
 8261 144a 054B     		ldr	r3, .L229
 8262 144c 1B68     		ldr	r3, [r3, #0]
 8263 144e 7B60     		str	r3, [r7, #4]
2327:../3rdParty/FreeRTOS/tasks.c **** 
2328:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
 8264              		.loc 1 2328 0
 8265 1450 7B68     		ldr	r3, [r7, #4]
2329:../3rdParty/FreeRTOS/tasks.c **** 	}
 8266              		.loc 1 2329 0
 8267 1452 1846     		mov	r0, r3
 8268 1454 07F10C07 		add	r7, r7, #12
 8269 1458 BD46     		mov	sp, r7
 8270 145a 80BC     		pop	{r7}
 8271 145c 7047     		bx	lr
 8272              	.L230:
 8273 145e 00BF     		.align	2
 8274              	.L229:
 8275 1460 00000000 		.word	pxCurrentTCB
 8276              		.cfi_endproc
 8277              	.LFE68:
 8279              		.align	2
 8280              		.global	vTaskPriorityInherit
 8281              		.thumb
 8282              		.thumb_func
 8284              	vTaskPriorityInherit:
 8285              	.LFB69:
2330:../3rdParty/FreeRTOS/tasks.c **** 
2331:../3rdParty/FreeRTOS/tasks.c **** #endif
2332:../3rdParty/FreeRTOS/tasks.c **** 
2333:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2334:../3rdParty/FreeRTOS/tasks.c **** 
2335:../3rdParty/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2336:../3rdParty/FreeRTOS/tasks.c **** 
2337:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2338:../3rdParty/FreeRTOS/tasks.c **** 	{
2339:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xReturn;
2340:../3rdParty/FreeRTOS/tasks.c **** 
2341:../3rdParty/FreeRTOS/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
2342:../3rdParty/FreeRTOS/tasks.c **** 		{
2343:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2344:../3rdParty/FreeRTOS/tasks.c **** 		}
2345:../3rdParty/FreeRTOS/tasks.c **** 		else
2346:../3rdParty/FreeRTOS/tasks.c **** 		{
2347:../3rdParty/FreeRTOS/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2348:../3rdParty/FreeRTOS/tasks.c **** 			{
2349:../3rdParty/FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
2350:../3rdParty/FreeRTOS/tasks.c **** 			}
2351:../3rdParty/FreeRTOS/tasks.c **** 			else
2352:../3rdParty/FreeRTOS/tasks.c **** 			{
2353:../3rdParty/FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2354:../3rdParty/FreeRTOS/tasks.c **** 			}
2355:../3rdParty/FreeRTOS/tasks.c **** 		}
2356:../3rdParty/FreeRTOS/tasks.c **** 
2357:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
2358:../3rdParty/FreeRTOS/tasks.c **** 	}
2359:../3rdParty/FreeRTOS/tasks.c **** 
2360:../3rdParty/FreeRTOS/tasks.c **** #endif
2361:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2362:../3rdParty/FreeRTOS/tasks.c **** 
2363:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2364:../3rdParty/FreeRTOS/tasks.c **** 
2365:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2366:../3rdParty/FreeRTOS/tasks.c **** 	{
 8286              		.loc 1 2366 0
 8287              		.cfi_startproc
 8288              		@ args = 0, pretend = 0, frame = 16
 8289              		@ frame_needed = 1, uses_anonymous_args = 0
 8290 1464 80B5     		push	{r7, lr}
 8291              	.LCFI116:
 8292              		.cfi_def_cfa_offset 8
 8293 1466 84B0     		sub	sp, sp, #16
 8294              	.LCFI117:
 8295              		.cfi_def_cfa_offset 24
 8296 1468 00AF     		add	r7, sp, #0
 8297              		.cfi_offset 14, -4
 8298              		.cfi_offset 7, -8
 8299              	.LCFI118:
 8300              		.cfi_def_cfa_register 7
 8301 146a 7860     		str	r0, [r7, #4]
2367:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 8302              		.loc 1 2367 0
 8303 146c 7B68     		ldr	r3, [r7, #4]
 8304 146e FB60     		str	r3, [r7, #12]
2368:../3rdParty/FreeRTOS/tasks.c **** 
2369:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxMutexHolder );
2370:../3rdParty/FreeRTOS/tasks.c **** 
2371:../3rdParty/FreeRTOS/tasks.c **** 		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8305              		.loc 1 2371 0
 8306 1470 FB68     		ldr	r3, [r7, #12]
 8307 1472 DA6A     		ldr	r2, [r3, #44]
 8308 1474 254B     		ldr	r3, .L235
 8309 1476 1B68     		ldr	r3, [r3, #0]
 8310 1478 DB6A     		ldr	r3, [r3, #44]
 8311 147a 9A42     		cmp	r2, r3
 8312 147c 42D2     		bcs	.L231
2372:../3rdParty/FreeRTOS/tasks.c **** 		{
2373:../3rdParty/FreeRTOS/tasks.c **** 			/* Adjust the mutex holder state to account for its new priority. */
2374:../3rdParty/FreeRTOS/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 8313              		.loc 1 2374 0
 8314 147e 234B     		ldr	r3, .L235
 8315 1480 1B68     		ldr	r3, [r3, #0]
 8316 1482 DB6A     		ldr	r3, [r3, #44]
 8317 1484 C3F10502 		rsb	r2, r3, #5
 8318 1488 FB68     		ldr	r3, [r7, #12]
 8319 148a 9A61     		str	r2, [r3, #24]
2375:../3rdParty/FreeRTOS/tasks.c **** 
2376:../3rdParty/FreeRTOS/tasks.c **** 			/* If the task being modified is in the ready state it will need to
2377:../3rdParty/FreeRTOS/tasks.c **** 			be moved in to a new list. */
2378:../3rdParty/FreeRTOS/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 8320              		.loc 1 2378 0
 8321 148c FB68     		ldr	r3, [r7, #12]
 8322 148e 5969     		ldr	r1, [r3, #20]
 8323 1490 FB68     		ldr	r3, [r7, #12]
 8324 1492 DA6A     		ldr	r2, [r3, #44]
 8325 1494 1346     		mov	r3, r2
 8326 1496 4FEA8303 		lsl	r3, r3, #2
 8327 149a 9B18     		adds	r3, r3, r2
 8328 149c 4FEA8303 		lsl	r3, r3, #2
 8329 14a0 1A46     		mov	r2, r3
 8330 14a2 1B4B     		ldr	r3, .L235+4
 8331 14a4 D318     		adds	r3, r2, r3
 8332 14a6 9942     		cmp	r1, r3
 8333 14a8 27D1     		bne	.L233
2379:../3rdParty/FreeRTOS/tasks.c **** 			{
2380:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 8334              		.loc 1 2380 0
 8335 14aa FB68     		ldr	r3, [r7, #12]
 8336 14ac 03F10403 		add	r3, r3, #4
 8337 14b0 1846     		mov	r0, r3
 8338 14b2 FFF7FEFF 		bl	vListRemove
2381:../3rdParty/FreeRTOS/tasks.c **** 
2382:../3rdParty/FreeRTOS/tasks.c **** 				/* Inherit the priority before being moved into the new list. */
2383:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8339              		.loc 1 2383 0
 8340 14b6 154B     		ldr	r3, .L235
 8341 14b8 1B68     		ldr	r3, [r3, #0]
 8342 14ba DA6A     		ldr	r2, [r3, #44]
 8343 14bc FB68     		ldr	r3, [r7, #12]
 8344 14be DA62     		str	r2, [r3, #44]
2384:../3rdParty/FreeRTOS/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 8345              		.loc 1 2384 0
 8346 14c0 FB68     		ldr	r3, [r7, #12]
 8347 14c2 DA6A     		ldr	r2, [r3, #44]
 8348 14c4 134B     		ldr	r3, .L235+8
 8349 14c6 1B68     		ldr	r3, [r3, #0]
 8350 14c8 9A42     		cmp	r2, r3
 8351 14ca 03D9     		bls	.L234
 8352              		.loc 1 2384 0 is_stmt 0 discriminator 1
 8353 14cc FB68     		ldr	r3, [r7, #12]
 8354 14ce DA6A     		ldr	r2, [r3, #44]
 8355 14d0 104B     		ldr	r3, .L235+8
 8356 14d2 1A60     		str	r2, [r3, #0]
 8357              	.L234:
 8358              		.loc 1 2384 0 discriminator 2
 8359 14d4 FB68     		ldr	r3, [r7, #12]
 8360 14d6 DA6A     		ldr	r2, [r3, #44]
 8361 14d8 1346     		mov	r3, r2
 8362 14da 4FEA8303 		lsl	r3, r3, #2
 8363 14de 9B18     		adds	r3, r3, r2
 8364 14e0 4FEA8303 		lsl	r3, r3, #2
 8365 14e4 1A46     		mov	r2, r3
 8366 14e6 0A4B     		ldr	r3, .L235+4
 8367 14e8 D218     		adds	r2, r2, r3
 8368 14ea FB68     		ldr	r3, [r7, #12]
 8369 14ec 03F10403 		add	r3, r3, #4
 8370 14f0 1046     		mov	r0, r2
 8371 14f2 1946     		mov	r1, r3
 8372 14f4 FFF7FEFF 		bl	vListInsertEnd
 8373 14f8 04E0     		b	.L231
 8374              	.L233:
2385:../3rdParty/FreeRTOS/tasks.c **** 			}
2386:../3rdParty/FreeRTOS/tasks.c **** 			else
2387:../3rdParty/FreeRTOS/tasks.c **** 			{
2388:../3rdParty/FreeRTOS/tasks.c **** 				/* Just inherit the priority. */
2389:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8375              		.loc 1 2389 0 is_stmt 1
 8376 14fa 044B     		ldr	r3, .L235
 8377 14fc 1B68     		ldr	r3, [r3, #0]
 8378 14fe DA6A     		ldr	r2, [r3, #44]
 8379 1500 FB68     		ldr	r3, [r7, #12]
 8380 1502 DA62     		str	r2, [r3, #44]
 8381              	.L231:
2390:../3rdParty/FreeRTOS/tasks.c **** 			}
2391:../3rdParty/FreeRTOS/tasks.c **** 
2392:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2393:../3rdParty/FreeRTOS/tasks.c **** 		}
2394:../3rdParty/FreeRTOS/tasks.c **** 	}
 8382              		.loc 1 2394 0
 8383 1504 07F11007 		add	r7, r7, #16
 8384 1508 BD46     		mov	sp, r7
 8385 150a 80BD     		pop	{r7, pc}
 8386              	.L236:
 8387              		.align	2
 8388              	.L235:
 8389 150c 00000000 		.word	pxCurrentTCB
 8390 1510 04000000 		.word	pxReadyTasksLists
 8391 1514 E4000000 		.word	uxTopReadyPriority
 8392              		.cfi_endproc
 8393              	.LFE69:
 8395              		.align	2
 8396              		.global	vTaskPriorityDisinherit
 8397              		.thumb
 8398              		.thumb_func
 8400              	vTaskPriorityDisinherit:
 8401              	.LFB70:
2395:../3rdParty/FreeRTOS/tasks.c **** 
2396:../3rdParty/FreeRTOS/tasks.c **** #endif
2397:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2398:../3rdParty/FreeRTOS/tasks.c **** 
2399:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2400:../3rdParty/FreeRTOS/tasks.c **** 
2401:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2402:../3rdParty/FreeRTOS/tasks.c **** 	{
 8402              		.loc 1 2402 0
 8403              		.cfi_startproc
 8404              		@ args = 0, pretend = 0, frame = 16
 8405              		@ frame_needed = 1, uses_anonymous_args = 0
 8406 1518 80B5     		push	{r7, lr}
 8407              	.LCFI119:
 8408              		.cfi_def_cfa_offset 8
 8409 151a 84B0     		sub	sp, sp, #16
 8410              	.LCFI120:
 8411              		.cfi_def_cfa_offset 24
 8412 151c 00AF     		add	r7, sp, #0
 8413              		.cfi_offset 14, -4
 8414              		.cfi_offset 7, -8
 8415              	.LCFI121:
 8416              		.cfi_def_cfa_register 7
 8417 151e 7860     		str	r0, [r7, #4]
2403:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 8418              		.loc 1 2403 0
 8419 1520 7B68     		ldr	r3, [r7, #4]
 8420 1522 FB60     		str	r3, [r7, #12]
2404:../3rdParty/FreeRTOS/tasks.c **** 
2405:../3rdParty/FreeRTOS/tasks.c **** 		if( pxMutexHolder != NULL )
 8421              		.loc 1 2405 0
 8422 1524 7B68     		ldr	r3, [r7, #4]
 8423 1526 002B     		cmp	r3, #0
 8424 1528 31D0     		beq	.L237
2406:../3rdParty/FreeRTOS/tasks.c **** 		{
2407:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8425              		.loc 1 2407 0
 8426 152a FB68     		ldr	r3, [r7, #12]
 8427 152c DA6A     		ldr	r2, [r3, #44]
 8428 152e FB68     		ldr	r3, [r7, #12]
 8429 1530 9B6C     		ldr	r3, [r3, #72]
 8430 1532 9A42     		cmp	r2, r3
 8431 1534 2BD0     		beq	.L237
2408:../3rdParty/FreeRTOS/tasks.c **** 			{
2409:../3rdParty/FreeRTOS/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2410:../3rdParty/FreeRTOS/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2411:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 8432              		.loc 1 2411 0
 8433 1536 FB68     		ldr	r3, [r7, #12]
 8434 1538 03F10403 		add	r3, r3, #4
 8435 153c 1846     		mov	r0, r3
 8436 153e FFF7FEFF 		bl	vListRemove
2412:../3rdParty/FreeRTOS/tasks.c **** 
2413:../3rdParty/FreeRTOS/tasks.c **** 				/* Disinherit the priority before adding the task into the new
2414:../3rdParty/FreeRTOS/tasks.c **** 				ready list. */
2415:../3rdParty/FreeRTOS/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2416:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 8437              		.loc 1 2416 0
 8438 1542 FB68     		ldr	r3, [r7, #12]
 8439 1544 9A6C     		ldr	r2, [r3, #72]
 8440 1546 FB68     		ldr	r3, [r7, #12]
 8441 1548 DA62     		str	r2, [r3, #44]
2417:../3rdParty/FreeRTOS/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 8442              		.loc 1 2417 0
 8443 154a FB68     		ldr	r3, [r7, #12]
 8444 154c DB6A     		ldr	r3, [r3, #44]
 8445 154e C3F10502 		rsb	r2, r3, #5
 8446 1552 FB68     		ldr	r3, [r7, #12]
 8447 1554 9A61     		str	r2, [r3, #24]
2418:../3rdParty/FreeRTOS/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 8448              		.loc 1 2418 0
 8449 1556 FB68     		ldr	r3, [r7, #12]
 8450 1558 DA6A     		ldr	r2, [r3, #44]
 8451 155a 0F4B     		ldr	r3, .L240
 8452 155c 1B68     		ldr	r3, [r3, #0]
 8453 155e 9A42     		cmp	r2, r3
 8454 1560 03D9     		bls	.L239
 8455              		.loc 1 2418 0 is_stmt 0 discriminator 1
 8456 1562 FB68     		ldr	r3, [r7, #12]
 8457 1564 DA6A     		ldr	r2, [r3, #44]
 8458 1566 0C4B     		ldr	r3, .L240
 8459 1568 1A60     		str	r2, [r3, #0]
 8460              	.L239:
 8461              		.loc 1 2418 0 discriminator 2
 8462 156a FB68     		ldr	r3, [r7, #12]
 8463 156c DA6A     		ldr	r2, [r3, #44]
 8464 156e 1346     		mov	r3, r2
 8465 1570 4FEA8303 		lsl	r3, r3, #2
 8466 1574 9B18     		adds	r3, r3, r2
 8467 1576 4FEA8303 		lsl	r3, r3, #2
 8468 157a 1A46     		mov	r2, r3
 8469 157c 074B     		ldr	r3, .L240+4
 8470 157e D218     		adds	r2, r2, r3
 8471 1580 FB68     		ldr	r3, [r7, #12]
 8472 1582 03F10403 		add	r3, r3, #4
 8473 1586 1046     		mov	r0, r2
 8474 1588 1946     		mov	r1, r3
 8475 158a FFF7FEFF 		bl	vListInsertEnd
 8476              	.L237:
2419:../3rdParty/FreeRTOS/tasks.c **** 			}
2420:../3rdParty/FreeRTOS/tasks.c **** 		}
2421:../3rdParty/FreeRTOS/tasks.c **** 	}
 8477              		.loc 1 2421 0 is_stmt 1
 8478 158e 07F11007 		add	r7, r7, #16
 8479 1592 BD46     		mov	sp, r7
 8480 1594 80BD     		pop	{r7, pc}
 8481              	.L241:
 8482 1596 00BF     		.align	2
 8483              	.L240:
 8484 1598 E4000000 		.word	uxTopReadyPriority
 8485 159c 04000000 		.word	pxReadyTasksLists
 8486              		.cfi_endproc
 8487              	.LFE70:
 8489              		.bss
 8490              		.align	2
 8491              	pcStatusString.6881:
 8492 0138 00000000 		.space	50
 8492      00000000 
 8492      00000000 
 8492      00000000 
 8492      00000000 
 8493 016a 0000     		.section	.rodata
 8494 004f 00       		.align	2
 8497              	ucExpectedStackBytes.6806:
 8498 0050 A5       		.byte	-91
 8499 0051 A5       		.byte	-91
 8500 0052 A5       		.byte	-91
 8501 0053 A5       		.byte	-91
 8502 0054 A5       		.byte	-91
 8503 0055 A5       		.byte	-91
 8504 0056 A5       		.byte	-91
 8505 0057 A5       		.byte	-91
 8506 0058 A5       		.byte	-91
 8507 0059 A5       		.byte	-91
 8508 005a A5       		.byte	-91
 8509 005b A5       		.byte	-91
 8510 005c A5       		.byte	-91
 8511 005d A5       		.byte	-91
 8512 005e A5       		.byte	-91
 8513 005f A5       		.byte	-91
 8514 0060 A5       		.byte	-91
 8515 0061 A5       		.byte	-91
 8516 0062 A5       		.byte	-91
 8517 0063 A5       		.byte	-91
 8518              		.text
 8519              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/cc2Qam1Y.s:4457   .bss:00000000 pxCurrentTCB
     /tmp/cc2Qam1Y.s:4454   .bss:00000000 $d
     /tmp/cc2Qam1Y.s:4460   .bss:00000004 pxReadyTasksLists
     /tmp/cc2Qam1Y.s:4463   .bss:00000068 xDelayedTaskList1
     /tmp/cc2Qam1Y.s:4466   .bss:0000007c xDelayedTaskList2
     /tmp/cc2Qam1Y.s:4469   .bss:00000090 pxDelayedTaskList
     /tmp/cc2Qam1Y.s:4472   .bss:00000094 pxOverflowDelayedTaskList
     /tmp/cc2Qam1Y.s:4475   .bss:00000098 xPendingReadyList
     /tmp/cc2Qam1Y.s:4478   .bss:000000ac xTasksWaitingTermination
     /tmp/cc2Qam1Y.s:4481   .bss:000000c0 uxTasksDeleted
     /tmp/cc2Qam1Y.s:4484   .bss:000000c4 xSuspendedTaskList
     /tmp/cc2Qam1Y.s:4487   .bss:000000d8 uxCurrentNumberOfTasks
     /tmp/cc2Qam1Y.s:4490   .bss:000000dc xTickCount
     /tmp/cc2Qam1Y.s:4493   .bss:000000e0 uxTopUsedPriority
     /tmp/cc2Qam1Y.s:4496   .bss:000000e4 uxTopReadyPriority
     /tmp/cc2Qam1Y.s:4499   .bss:000000e8 xSchedulerRunning
     /tmp/cc2Qam1Y.s:4502   .bss:000000ec uxSchedulerSuspended
     /tmp/cc2Qam1Y.s:4505   .bss:000000f0 uxMissedTicks
     /tmp/cc2Qam1Y.s:4508   .bss:000000f4 xMissedYield
     /tmp/cc2Qam1Y.s:4511   .bss:000000f8 xNumOfOverflows
     /tmp/cc2Qam1Y.s:4514   .bss:000000fc uxTCBNumber
     /tmp/cc2Qam1Y.s:4517   .data:00000000 $d
     /tmp/cc2Qam1Y.s:4520   .data:00000000 xNextTaskUnblockTime
     /tmp/cc2Qam1Y.s:4524   .bss:00000100 pcStatsString
     /tmp/cc2Qam1Y.s:4527   .bss:00000134 ulTaskSwitchedInTime
     /tmp/cc2Qam1Y.s:4530   .text:00000000 $t
     /tmp/cc2Qam1Y.s:4535   .text:00000000 xTaskGenericCreate
     /tmp/cc2Qam1Y.s:7708   .text:00001194 prvAllocateTCBAndStack
     /tmp/cc2Qam1Y.s:7365   .text:00000fa0 prvInitialiseTCBVariables
     /tmp/cc2Qam1Y.s:7453   .text:00001024 prvInitialiseTaskLists
     /tmp/cc2Qam1Y.s:4742   .text:0000014c $d
     /tmp/cc2Qam1Y.s:4752   .text:00000168 $t
     /tmp/cc2Qam1Y.s:4757   .text:00000168 vTaskDelete
     /tmp/cc2Qam1Y.s:4856   .text:000001f8 $d
     /tmp/cc2Qam1Y.s:4864   .text:0000020c $t
     /tmp/cc2Qam1Y.s:4869   .text:0000020c vTaskDelayUntil
     /tmp/cc2Qam1Y.s:5831   .text:00000730 vTaskSuspendAll
     /tmp/cc2Qam1Y.s:7629   .text:00001124 prvAddCurrentTaskToDelayedList
     /tmp/cc2Qam1Y.s:5867   .text:0000074c xTaskResumeAll
     /tmp/cc2Qam1Y.s:4975   .text:000002a4 $d
     /tmp/cc2Qam1Y.s:4980   .text:000002ac $t
     /tmp/cc2Qam1Y.s:4985   .text:000002ac vTaskDelay
     /tmp/cc2Qam1Y.s:5045   .text:000002fc $d
     /tmp/cc2Qam1Y.s:5050   .text:00000304 $t
     /tmp/cc2Qam1Y.s:5055   .text:00000304 uxTaskPriorityGet
     /tmp/cc2Qam1Y.s:5105   .text:00000338 $d
     /tmp/cc2Qam1Y.s:5109   .text:0000033c $t
     /tmp/cc2Qam1Y.s:5114   .text:0000033c vTaskPrioritySet
     /tmp/cc2Qam1Y.s:5285   .text:00000444 $d
     /tmp/cc2Qam1Y.s:5291   .text:00000450 $t
     /tmp/cc2Qam1Y.s:5296   .text:00000450 vTaskSuspend
     /tmp/cc2Qam1Y.s:6689   .text:00000c24 vTaskSwitchContext
     /tmp/cc2Qam1Y.s:5400   .text:000004e4 $d
     /tmp/cc2Qam1Y.s:5407   .text:000004f4 $t
     /tmp/cc2Qam1Y.s:5412   .text:000004f4 xTaskIsTaskSuspended
     /tmp/cc2Qam1Y.s:5468   .text:00000538 $d
     /tmp/cc2Qam1Y.s:5473   .text:00000540 $t
     /tmp/cc2Qam1Y.s:5478   .text:00000540 vTaskResume
     /tmp/cc2Qam1Y.s:5571   .text:000005d0 $d
     /tmp/cc2Qam1Y.s:5577   .text:000005dc $t
     /tmp/cc2Qam1Y.s:5582   .text:000005dc xTaskResumeFromISR
     /tmp/cc2Qam1Y.s:5696   .text:0000068c $d
     /tmp/cc2Qam1Y.s:5705   .rodata:00000000 $d
     /tmp/cc2Qam1Y.s:5709   .text:000006a0 $t
     /tmp/cc2Qam1Y.s:5714   .text:000006a0 vTaskStartScheduler
     /tmp/cc2Qam1Y.s:5778   .text:00000700 $d
     /tmp/cc2Qam1Y.s:7335   .text:00000f90 prvIdleTask
     /tmp/cc2Qam1Y.s:5785   .text:00000710 $t
     /tmp/cc2Qam1Y.s:5790   .text:00000710 vTaskEndScheduler
     /tmp/cc2Qam1Y.s:5822   .text:0000072c $d
     /tmp/cc2Qam1Y.s:5826   .text:00000730 $t
     /tmp/cc2Qam1Y.s:5858   .text:00000748 $d
     /tmp/cc2Qam1Y.s:5862   .text:0000074c $t
     /tmp/cc2Qam1Y.s:6490   .text:00000ae4 vTaskIncrementTick
     /tmp/cc2Qam1Y.s:6025   .text:00000840 $d
     /tmp/cc2Qam1Y.s:6036   .text:00000860 $t
     /tmp/cc2Qam1Y.s:6041   .text:00000860 xTaskGetTickCount
     /tmp/cc2Qam1Y.s:6076   .text:00000880 $d
     /tmp/cc2Qam1Y.s:6080   .text:00000884 $t
     /tmp/cc2Qam1Y.s:6085   .text:00000884 xTaskGetTickCountFromISR
     /tmp/cc2Qam1Y.s:6133   .text:000008b4 $d
     /tmp/cc2Qam1Y.s:6137   .text:000008b8 $t
     /tmp/cc2Qam1Y.s:6142   .text:000008b8 uxTaskGetNumberOfTasks
     /tmp/cc2Qam1Y.s:6167   .text:000008c8 $d
     /tmp/cc2Qam1Y.s:6176   .text:000008cc $t
     /tmp/cc2Qam1Y.s:6181   .text:000008cc vTaskList
     /tmp/cc2Qam1Y.s:7797   .text:00001208 prvListTaskWithinSingleList
     /tmp/cc2Qam1Y.s:6315   .text:000009b4 $d
     /tmp/cc2Qam1Y.s:6325   .text:000009d0 $t
     /tmp/cc2Qam1Y.s:6330   .text:000009d0 vTaskGetRunTimeStats
     /tmp/cc2Qam1Y.s:7935   .text:000012c4 prvGenerateRunTimeStatsForTasksInList
     /tmp/cc2Qam1Y.s:6474   .text:00000ac4 $d
     /tmp/cc2Qam1Y.s:6485   .text:00000ae4 $t
     /tmp/cc2Qam1Y.s:6672   .text:00000c00 $d
     /tmp/cc2Qam1Y.s:6684   .text:00000c24 $t
     /tmp/cc2Qam1Y.s:6853   .text:00000d2c $d
     /tmp/cc2Qam1Y.s:8497   .rodata:00000050 ucExpectedStackBytes.6806
     /tmp/cc2Qam1Y.s:6863   .text:00000d48 $t
     /tmp/cc2Qam1Y.s:6868   .text:00000d48 vTaskPlaceOnEventList
     /tmp/cc2Qam1Y.s:6930   .text:00000da4 $d
     /tmp/cc2Qam1Y.s:6936   .text:00000db0 $t
     /tmp/cc2Qam1Y.s:6941   .text:00000db0 xTaskRemoveFromEventList
     /tmp/cc2Qam1Y.s:7043   .text:00000e50 $d
     /tmp/cc2Qam1Y.s:7051   .text:00000e64 $t
     /tmp/cc2Qam1Y.s:7056   .text:00000e64 vTaskSetTimeOutState
     /tmp/cc2Qam1Y.s:7092   .text:00000e88 $d
     /tmp/cc2Qam1Y.s:7097   .text:00000e90 $t
     /tmp/cc2Qam1Y.s:7102   .text:00000e90 xTaskCheckForTimeOut
     /tmp/cc2Qam1Y.s:7197   .text:00000f1c $d
     /tmp/cc2Qam1Y.s:7202   .text:00000f24 $t
     /tmp/cc2Qam1Y.s:7207   .text:00000f24 vTaskMissedYield
     /tmp/cc2Qam1Y.s:7232   .text:00000f38 $d
     /tmp/cc2Qam1Y.s:7236   .text:00000f3c $t
     /tmp/cc2Qam1Y.s:7241   .text:00000f3c uxTaskGetTaskNumber
     /tmp/cc2Qam1Y.s:7292   .text:00000f6c vTaskSetTaskNumber
     /tmp/cc2Qam1Y.s:7540   .text:000010ac prvCheckTasksWaitingTermination
     /tmp/cc2Qam1Y.s:7525   .text:0000108c $d
     /tmp/cc2Qam1Y.s:7536   .text:000010ac $t
     /tmp/cc2Qam1Y.s:8205   .text:00001424 prvDeleteTCB
     /tmp/cc2Qam1Y.s:7619   .text:00001118 $d
     /tmp/cc2Qam1Y.s:7625   .text:00001124 $t
     /tmp/cc2Qam1Y.s:7696   .text:00001180 $d
     /tmp/cc2Qam1Y.s:7704   .text:00001194 $t
     /tmp/cc2Qam1Y.s:8090   .text:000013b4 usTaskCheckFreeStackSpace
     /tmp/cc2Qam1Y.s:7915   .text:000012bc $d
     /tmp/cc2Qam1Y.s:8491   .bss:00000138 pcStatusString.6881
     /tmp/cc2Qam1Y.s:7931   .text:000012c4 $t
     /tmp/cc2Qam1Y.s:8079   .text:000013a4 $d
     /tmp/cc2Qam1Y.s:8086   .text:000013b4 $t
     /tmp/cc2Qam1Y.s:8146   .text:000013ec uxTaskGetStackHighWaterMark
     /tmp/cc2Qam1Y.s:8197   .text:00001420 $d
     /tmp/cc2Qam1Y.s:8201   .text:00001424 $t
     /tmp/cc2Qam1Y.s:8243   .text:00001444 xTaskGetCurrentTaskHandle
     /tmp/cc2Qam1Y.s:8275   .text:00001460 $d
     /tmp/cc2Qam1Y.s:8279   .text:00001464 $t
     /tmp/cc2Qam1Y.s:8284   .text:00001464 vTaskPriorityInherit
     /tmp/cc2Qam1Y.s:8389   .text:0000150c $d
     /tmp/cc2Qam1Y.s:8395   .text:00001518 $t
     /tmp/cc2Qam1Y.s:8400   .text:00001518 vTaskPriorityDisinherit
     /tmp/cc2Qam1Y.s:8484   .text:00001598 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
vConfigureTimerForRunTimeStats
xPortStartScheduler
vPortEndScheduler
strlen
memcpy
vApplicationStackOverflowHook
memcmp
vListInsert
strncpy
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
sprintf
strcat
