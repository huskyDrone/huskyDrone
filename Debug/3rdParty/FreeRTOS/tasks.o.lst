   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"tasks.c"
  23              	.Ltext0:
  24              		.file 1 "../3rdParty/FreeRTOS/tasks.c"
 4488              		.align	2
 4491              	pxCurrentTCB:
 4492 0000 00000000 		.space	4
 4493              		.align	2
 4494              	pxReadyTasksLists:
 4495 0004 00000000 		.space	100
 4495      00000000 
 4495      00000000 
 4495      00000000 
 4495      00000000 
 4496              		.align	2
 4497              	xDelayedTaskList1:
 4498 0068 00000000 		.space	20
 4498      00000000 
 4498      00000000 
 4498      00000000 
 4498      00000000 
 4499              		.align	2
 4500              	xDelayedTaskList2:
 4501 007c 00000000 		.space	20
 4501      00000000 
 4501      00000000 
 4501      00000000 
 4501      00000000 
 4502              		.align	2
 4503              	pxDelayedTaskList:
 4504 0090 00000000 		.space	4
 4505              		.align	2
 4506              	pxOverflowDelayedTaskList:
 4507 0094 00000000 		.space	4
 4508              		.align	2
 4509              	xPendingReadyList:
 4510 0098 00000000 		.space	20
 4510      00000000 
 4510      00000000 
 4510      00000000 
 4510      00000000 
 4511              		.align	2
 4512              	xTasksWaitingTermination:
 4513 00ac 00000000 		.space	20
 4513      00000000 
 4513      00000000 
 4513      00000000 
 4513      00000000 
 4514              		.align	2
 4515              	uxTasksDeleted:
 4516 00c0 00000000 		.space	4
 4517              		.align	2
 4518              	xSuspendedTaskList:
 4519 00c4 00000000 		.space	20
 4519      00000000 
 4519      00000000 
 4519      00000000 
 4519      00000000 
 4520              		.align	2
 4521              	uxCurrentNumberOfTasks:
 4522 00d8 00000000 		.space	4
 4523              		.align	2
 4524              	xTickCount:
 4525 00dc 00000000 		.space	4
 4526              		.align	2
 4527              	uxTopUsedPriority:
 4528 00e0 00000000 		.space	4
 4529              		.align	2
 4530              	uxTopReadyPriority:
 4531 00e4 00000000 		.space	4
 4532              		.align	2
 4533              	xSchedulerRunning:
 4534 00e8 00000000 		.space	4
 4535              		.align	2
 4536              	uxSchedulerSuspended:
 4537 00ec 00000000 		.space	4
 4538              		.align	2
 4539              	uxMissedTicks:
 4540 00f0 00000000 		.space	4
 4541              		.align	2
 4542              	xMissedYield:
 4543 00f4 00000000 		.space	4
 4544              		.align	2
 4545              	xNumOfOverflows:
 4546 00f8 00000000 		.space	4
 4547              		.align	2
 4548              	uxTCBNumber:
 4549 00fc 00000000 		.space	4
 4550              		.data
 4551              		.align	2
 4554              	xNextTaskUnblockTime:
 4555 0000 FFFFFFFF 		.word	-1
 4556              		.bss
 4557              		.align	2
 4558              	pcStatsString:
 4559 0100 00000000 		.space	50
 4559      00000000 
 4559      00000000 
 4559      00000000 
 4559      00000000 
 4560 0132 0000     		.align	2
 4561              	ulTaskSwitchedInTime:
 4562 0134 00000000 		.space	4
 4563              		.text
 4564              		.align	2
 4565              		.global	xTaskGenericCreate
 4566              		.thumb
 4567              		.thumb_func
 4569              	xTaskGenericCreate:
 4570              	.LFB55:
   1:../3rdParty/FreeRTOS/tasks.c **** /*
   2:../3rdParty/FreeRTOS/tasks.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../3rdParty/FreeRTOS/tasks.c **** 	
   4:../3rdParty/FreeRTOS/tasks.c **** 
   5:../3rdParty/FreeRTOS/tasks.c ****     ***************************************************************************
   6:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
   7:../3rdParty/FreeRTOS/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../3rdParty/FreeRTOS/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../3rdParty/FreeRTOS/tasks.c ****      *    available.                                                         *
  10:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
  11:../3rdParty/FreeRTOS/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../3rdParty/FreeRTOS/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../3rdParty/FreeRTOS/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../3rdParty/FreeRTOS/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../3rdParty/FreeRTOS/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../3rdParty/FreeRTOS/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
  18:../3rdParty/FreeRTOS/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
  20:../3rdParty/FreeRTOS/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../3rdParty/FreeRTOS/tasks.c ****      *                                                                       *
  22:../3rdParty/FreeRTOS/tasks.c ****     ***************************************************************************
  23:../3rdParty/FreeRTOS/tasks.c **** 
  24:../3rdParty/FreeRTOS/tasks.c **** 
  25:../3rdParty/FreeRTOS/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:../3rdParty/FreeRTOS/tasks.c **** 
  27:../3rdParty/FreeRTOS/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../3rdParty/FreeRTOS/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../3rdParty/FreeRTOS/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../3rdParty/FreeRTOS/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../3rdParty/FreeRTOS/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../3rdParty/FreeRTOS/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../3rdParty/FreeRTOS/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../3rdParty/FreeRTOS/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../3rdParty/FreeRTOS/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../3rdParty/FreeRTOS/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:../3rdParty/FreeRTOS/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../3rdParty/FreeRTOS/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../3rdParty/FreeRTOS/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../3rdParty/FreeRTOS/tasks.c ****     FreeRTOS WEB site.
  41:../3rdParty/FreeRTOS/tasks.c **** 
  42:../3rdParty/FreeRTOS/tasks.c ****     1 tab == 4 spaces!
  43:../3rdParty/FreeRTOS/tasks.c **** 
  44:../3rdParty/FreeRTOS/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../3rdParty/FreeRTOS/tasks.c ****     contact details.
  46:../3rdParty/FreeRTOS/tasks.c **** 
  47:../3rdParty/FreeRTOS/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../3rdParty/FreeRTOS/tasks.c ****     critical systems.
  49:../3rdParty/FreeRTOS/tasks.c **** 
  50:../3rdParty/FreeRTOS/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../3rdParty/FreeRTOS/tasks.c ****     licensing and training services.
  52:../3rdParty/FreeRTOS/tasks.c **** */
  53:../3rdParty/FreeRTOS/tasks.c **** 
  54:../3rdParty/FreeRTOS/tasks.c **** 
  55:../3rdParty/FreeRTOS/tasks.c **** #include <stdio.h>
  56:../3rdParty/FreeRTOS/tasks.c **** #include <stdlib.h>
  57:../3rdParty/FreeRTOS/tasks.c **** #include <string.h>
  58:../3rdParty/FreeRTOS/tasks.c **** 
  59:../3rdParty/FreeRTOS/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:../3rdParty/FreeRTOS/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:../3rdParty/FreeRTOS/tasks.c **** task.h is included from an application file. */
  62:../3rdParty/FreeRTOS/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:../3rdParty/FreeRTOS/tasks.c **** 
  64:../3rdParty/FreeRTOS/tasks.c **** #include "FreeRTOS.h"
  65:../3rdParty/FreeRTOS/tasks.c **** #include "task.h"
  66:../3rdParty/FreeRTOS/tasks.c **** #include "timers.h"
  67:../3rdParty/FreeRTOS/tasks.c **** #include "StackMacros.h"
  68:../3rdParty/FreeRTOS/tasks.c **** 
  69:../3rdParty/FreeRTOS/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../3rdParty/FreeRTOS/tasks.c **** 
  71:../3rdParty/FreeRTOS/tasks.c **** /*
  72:../3rdParty/FreeRTOS/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  73:../3rdParty/FreeRTOS/tasks.c ****  */
  74:../3rdParty/FreeRTOS/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  75:../3rdParty/FreeRTOS/tasks.c **** 
  76:../3rdParty/FreeRTOS/tasks.c **** /*
  77:../3rdParty/FreeRTOS/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  78:../3rdParty/FreeRTOS/tasks.c ****  * and stores the context of the task.
  79:../3rdParty/FreeRTOS/tasks.c ****  */
  80:../3rdParty/FreeRTOS/tasks.c **** typedef struct tskTaskControlBlock
  81:../3rdParty/FreeRTOS/tasks.c **** {
  82:../3rdParty/FreeRTOS/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  83:../3rdParty/FreeRTOS/tasks.c **** 
  84:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  85:../3rdParty/FreeRTOS/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  86:../3rdParty/FreeRTOS/tasks.c **** 	#endif	
  87:../3rdParty/FreeRTOS/tasks.c **** 	
  88:../3rdParty/FreeRTOS/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  89:../3rdParty/FreeRTOS/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  90:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  91:../3rdParty/FreeRTOS/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  92:../3rdParty/FreeRTOS/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  93:../3rdParty/FreeRTOS/tasks.c **** 
  94:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  95:../3rdParty/FreeRTOS/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  96:../3rdParty/FreeRTOS/tasks.c **** 	#endif
  97:../3rdParty/FreeRTOS/tasks.c **** 
  98:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  99:../3rdParty/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 100:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 101:../3rdParty/FreeRTOS/tasks.c **** 
 102:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 103:../3rdParty/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This stores a number that increments each time a TCB is c
 104:../3rdParty/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE  uxTaskNumber;	/*< This stores a number specifically for use by third part
 105:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 106:../3rdParty/FreeRTOS/tasks.c **** 
 107:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 108:../3rdParty/FreeRTOS/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 109:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 110:../3rdParty/FreeRTOS/tasks.c **** 
 111:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 112:../3rdParty/FreeRTOS/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 113:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 114:../3rdParty/FreeRTOS/tasks.c **** 
 115:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 116:../3rdParty/FreeRTOS/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 117:../3rdParty/FreeRTOS/tasks.c **** 	#endif
 118:../3rdParty/FreeRTOS/tasks.c **** 
 119:../3rdParty/FreeRTOS/tasks.c **** } tskTCB;
 120:../3rdParty/FreeRTOS/tasks.c **** 
 121:../3rdParty/FreeRTOS/tasks.c **** 
 122:../3rdParty/FreeRTOS/tasks.c **** /*
 123:../3rdParty/FreeRTOS/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 124:../3rdParty/FreeRTOS/tasks.c ****  * than file scope.
 125:../3rdParty/FreeRTOS/tasks.c ****  */
 126:../3rdParty/FreeRTOS/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 127:../3rdParty/FreeRTOS/tasks.c **** 	#define static
 128:../3rdParty/FreeRTOS/tasks.c **** #endif
 129:../3rdParty/FreeRTOS/tasks.c **** 
 130:../3rdParty/FreeRTOS/tasks.c **** /*lint -e956 */
 131:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 132:../3rdParty/FreeRTOS/tasks.c **** 
 133:../3rdParty/FreeRTOS/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 134:../3rdParty/FreeRTOS/tasks.c **** 
 135:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 136:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 137:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 138:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 139:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 140:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 141:../3rdParty/FreeRTOS/tasks.c **** 
 142:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 143:../3rdParty/FreeRTOS/tasks.c **** 
 144:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 145:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 146:../3rdParty/FreeRTOS/tasks.c **** 
 147:../3rdParty/FreeRTOS/tasks.c **** #endif
 148:../3rdParty/FreeRTOS/tasks.c **** 
 149:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 150:../3rdParty/FreeRTOS/tasks.c **** 
 151:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 152:../3rdParty/FreeRTOS/tasks.c **** 
 153:../3rdParty/FreeRTOS/tasks.c **** #endif
 154:../3rdParty/FreeRTOS/tasks.c **** 
 155:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 156:../3rdParty/FreeRTOS/tasks.c **** 	
 157:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
 158:../3rdParty/FreeRTOS/tasks.c **** 	
 159:../3rdParty/FreeRTOS/tasks.c **** #endif
 160:../3rdParty/FreeRTOS/tasks.c **** 
 161:../3rdParty/FreeRTOS/tasks.c **** /* File private variables. --------------------------------*/
 162:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 163:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 164:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 165:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 166:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 167:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 168:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 169:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 170:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 171:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTCBNumber 						= ( unsigned portBASE_TYPE ) 0U;
 172:../3rdParty/FreeRTOS/tasks.c **** PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
 173:../3rdParty/FreeRTOS/tasks.c **** 
 174:../3rdParty/FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 175:../3rdParty/FreeRTOS/tasks.c **** 
 176:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 177:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 178:../3rdParty/FreeRTOS/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 179:../3rdParty/FreeRTOS/tasks.c **** 
 180:../3rdParty/FreeRTOS/tasks.c **** #endif
 181:../3rdParty/FreeRTOS/tasks.c **** 
 182:../3rdParty/FreeRTOS/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 183:../3rdParty/FreeRTOS/tasks.c **** 
 184:../3rdParty/FreeRTOS/tasks.c **** /*
 185:../3rdParty/FreeRTOS/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 186:../3rdParty/FreeRTOS/tasks.c ****  * is used purely for checking the high water mark for tasks.
 187:../3rdParty/FreeRTOS/tasks.c ****  */
 188:../3rdParty/FreeRTOS/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 189:../3rdParty/FreeRTOS/tasks.c **** 
 190:../3rdParty/FreeRTOS/tasks.c **** /*
 191:../3rdParty/FreeRTOS/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 192:../3rdParty/FreeRTOS/tasks.c ****  */
 193:../3rdParty/FreeRTOS/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 194:../3rdParty/FreeRTOS/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 195:../3rdParty/FreeRTOS/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 196:../3rdParty/FreeRTOS/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 197:../3rdParty/FreeRTOS/tasks.c **** 
 198:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 199:../3rdParty/FreeRTOS/tasks.c **** 
 200:../3rdParty/FreeRTOS/tasks.c **** /*
 201:../3rdParty/FreeRTOS/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 202:../3rdParty/FreeRTOS/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 203:../3rdParty/FreeRTOS/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 204:../3rdParty/FreeRTOS/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 205:../3rdParty/FreeRTOS/tasks.c ****  * executing task has been rescheduled.
 206:../3rdParty/FreeRTOS/tasks.c ****  */
 207:../3rdParty/FreeRTOS/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																					\
 208:../3rdParty/FreeRTOS/tasks.c **** 	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
 209:../3rdParty/FreeRTOS/tasks.c **** 	{																													\
 210:../3rdParty/FreeRTOS/tasks.c **** 		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
 211:../3rdParty/FreeRTOS/tasks.c **** 	}																													\
 212:../3rdParty/FreeRTOS/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 213:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 214:../3rdParty/FreeRTOS/tasks.c **** 
 215:../3rdParty/FreeRTOS/tasks.c **** /*
 216:../3rdParty/FreeRTOS/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 217:../3rdParty/FreeRTOS/tasks.c ****  * any require waking.
 218:../3rdParty/FreeRTOS/tasks.c ****  *
 219:../3rdParty/FreeRTOS/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 220:../3rdParty/FreeRTOS/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 221:../3rdParty/FreeRTOS/tasks.c ****  * any further down the list.
 222:../3rdParty/FreeRTOS/tasks.c ****  */
 223:../3rdParty/FreeRTOS/tasks.c **** #define prvCheckDelayedTasks()															\
 224:../3rdParty/FreeRTOS/tasks.c **** {																						\
 225:../3rdParty/FreeRTOS/tasks.c **** portTickType xItemValue;																\
 226:../3rdParty/FreeRTOS/tasks.c **** 																						\
 227:../3rdParty/FreeRTOS/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 228:../3rdParty/FreeRTOS/tasks.c **** 	task referenced from the delayed tasks list? */										\
 229:../3rdParty/FreeRTOS/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 230:../3rdParty/FreeRTOS/tasks.c **** 	{																					\
 231:../3rdParty/FreeRTOS/tasks.c **** 		for( ;; )																		\
 232:../3rdParty/FreeRTOS/tasks.c **** 		{																				\
 233:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 234:../3rdParty/FreeRTOS/tasks.c **** 			{																			\
 235:../3rdParty/FreeRTOS/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 236:../3rdParty/FreeRTOS/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 237:../3rdParty/FreeRTOS/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 238:../3rdParty/FreeRTOS/tasks.c **** 				time through. */														\
 239:../3rdParty/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 240:../3rdParty/FreeRTOS/tasks.c **** 				break;																	\
 241:../3rdParty/FreeRTOS/tasks.c **** 			}																			\
 242:../3rdParty/FreeRTOS/tasks.c **** 			else																		\
 243:../3rdParty/FreeRTOS/tasks.c **** 			{																			\
 244:../3rdParty/FreeRTOS/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 245:../3rdParty/FreeRTOS/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 246:../3rdParty/FreeRTOS/tasks.c **** 				task at the head of the delayed list should be removed from				\
 247:../3rdParty/FreeRTOS/tasks.c **** 				the Blocked state. */													\
 248:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 249:../3rdParty/FreeRTOS/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 250:../3rdParty/FreeRTOS/tasks.c **** 																						\
 251:../3rdParty/FreeRTOS/tasks.c **** 				if( xTickCount < xItemValue )											\
 252:../3rdParty/FreeRTOS/tasks.c **** 				{																		\
 253:../3rdParty/FreeRTOS/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 254:../3rdParty/FreeRTOS/tasks.c **** 					value is the time at which the task at the head of the				\
 255:../3rdParty/FreeRTOS/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 256:../3rdParty/FreeRTOS/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 257:../3rdParty/FreeRTOS/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 258:../3rdParty/FreeRTOS/tasks.c **** 					break;																\
 259:../3rdParty/FreeRTOS/tasks.c **** 				}																		\
 260:../3rdParty/FreeRTOS/tasks.c **** 																						\
 261:../3rdParty/FreeRTOS/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 262:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );							\
 263:../3rdParty/FreeRTOS/tasks.c **** 																						\
 264:../3rdParty/FreeRTOS/tasks.c **** 				/* Is the task waiting on an event also? */								\
 265:../3rdParty/FreeRTOS/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 266:../3rdParty/FreeRTOS/tasks.c **** 				{																		\
 267:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );							\
 268:../3rdParty/FreeRTOS/tasks.c **** 				}																		\
 269:../3rdParty/FreeRTOS/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 270:../3rdParty/FreeRTOS/tasks.c **** 			}																			\
 271:../3rdParty/FreeRTOS/tasks.c **** 		}																				\
 272:../3rdParty/FreeRTOS/tasks.c **** 	}																					\
 273:../3rdParty/FreeRTOS/tasks.c **** }
 274:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 275:../3rdParty/FreeRTOS/tasks.c **** 
 276:../3rdParty/FreeRTOS/tasks.c **** /*
 277:../3rdParty/FreeRTOS/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 278:../3rdParty/FreeRTOS/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 279:../3rdParty/FreeRTOS/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 280:../3rdParty/FreeRTOS/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 281:../3rdParty/FreeRTOS/tasks.c ****  */
 282:../3rdParty/FreeRTOS/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 283:../3rdParty/FreeRTOS/tasks.c **** 
 284:../3rdParty/FreeRTOS/tasks.c **** /* Callback function prototypes. --------------------------*/
 285:../3rdParty/FreeRTOS/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
 286:../3rdParty/FreeRTOS/tasks.c **** //extern void vApplicationTickHook( void );
 287:../3rdParty/FreeRTOS/tasks.c **** 		
 288:../3rdParty/FreeRTOS/tasks.c **** /* File private functions. --------------------------------*/
 289:../3rdParty/FreeRTOS/tasks.c **** 
 290:../3rdParty/FreeRTOS/tasks.c **** /*
 291:../3rdParty/FreeRTOS/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 292:../3rdParty/FreeRTOS/tasks.c ****  * into the TCB structure.
 293:../3rdParty/FreeRTOS/tasks.c ****  */
 294:../3rdParty/FreeRTOS/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 295:../3rdParty/FreeRTOS/tasks.c **** 
 296:../3rdParty/FreeRTOS/tasks.c **** /*
 297:../3rdParty/FreeRTOS/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 298:../3rdParty/FreeRTOS/tasks.c ****  * automatically upon the creation of the first task.
 299:../3rdParty/FreeRTOS/tasks.c ****  */
 300:../3rdParty/FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 301:../3rdParty/FreeRTOS/tasks.c **** 
 302:../3rdParty/FreeRTOS/tasks.c **** /*
 303:../3rdParty/FreeRTOS/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 304:../3rdParty/FreeRTOS/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 305:../3rdParty/FreeRTOS/tasks.c ****  * creation of the first user task.
 306:../3rdParty/FreeRTOS/tasks.c ****  *
 307:../3rdParty/FreeRTOS/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 308:../3rdParty/FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 309:../3rdParty/FreeRTOS/tasks.c ****  *
 310:../3rdParty/FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
 311:../3rdParty/FreeRTOS/tasks.c ****  *
 312:../3rdParty/FreeRTOS/tasks.c ****  */
 313:../3rdParty/FreeRTOS/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 314:../3rdParty/FreeRTOS/tasks.c **** 
 315:../3rdParty/FreeRTOS/tasks.c **** /*
 316:../3rdParty/FreeRTOS/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 317:../3rdParty/FreeRTOS/tasks.c ****  * including the stack pointed to by the TCB.
 318:../3rdParty/FreeRTOS/tasks.c ****  *
 319:../3rdParty/FreeRTOS/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 320:../3rdParty/FreeRTOS/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 321:../3rdParty/FreeRTOS/tasks.c ****  */
 322:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 323:../3rdParty/FreeRTOS/tasks.c **** 
 324:../3rdParty/FreeRTOS/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 325:../3rdParty/FreeRTOS/tasks.c **** 
 326:../3rdParty/FreeRTOS/tasks.c **** #endif
 327:../3rdParty/FreeRTOS/tasks.c **** 
 328:../3rdParty/FreeRTOS/tasks.c **** /*
 329:../3rdParty/FreeRTOS/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 330:../3rdParty/FreeRTOS/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 331:../3rdParty/FreeRTOS/tasks.c ****  * and its TCB deleted.
 332:../3rdParty/FreeRTOS/tasks.c ****  */
 333:../3rdParty/FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 334:../3rdParty/FreeRTOS/tasks.c **** 
 335:../3rdParty/FreeRTOS/tasks.c **** /*
 336:../3rdParty/FreeRTOS/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 337:../3rdParty/FreeRTOS/tasks.c ****  * either the current or the overflow delayed task list.
 338:../3rdParty/FreeRTOS/tasks.c ****  */
 339:../3rdParty/FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 340:../3rdParty/FreeRTOS/tasks.c **** 
 341:../3rdParty/FreeRTOS/tasks.c **** /*
 342:../3rdParty/FreeRTOS/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 343:../3rdParty/FreeRTOS/tasks.c ****  * allocation was successful.
 344:../3rdParty/FreeRTOS/tasks.c ****  */
 345:../3rdParty/FreeRTOS/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 346:../3rdParty/FreeRTOS/tasks.c **** 
 347:../3rdParty/FreeRTOS/tasks.c **** /*
 348:../3rdParty/FreeRTOS/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 349:../3rdParty/FreeRTOS/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 350:../3rdParty/FreeRTOS/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 351:../3rdParty/FreeRTOS/tasks.c ****  * within just that list.
 352:../3rdParty/FreeRTOS/tasks.c ****  *
 353:../3rdParty/FreeRTOS/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 354:../3rdParty/FreeRTOS/tasks.c ****  * NORMAL APPLICATION CODE.
 355:../3rdParty/FreeRTOS/tasks.c ****  */
 356:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 357:../3rdParty/FreeRTOS/tasks.c **** 
 358:../3rdParty/FreeRTOS/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 359:../3rdParty/FreeRTOS/tasks.c **** 
 360:../3rdParty/FreeRTOS/tasks.c **** #endif
 361:../3rdParty/FreeRTOS/tasks.c **** 
 362:../3rdParty/FreeRTOS/tasks.c **** /*
 363:../3rdParty/FreeRTOS/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 364:../3rdParty/FreeRTOS/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 365:../3rdParty/FreeRTOS/tasks.c ****  * determining how much of the stack remains at the original preset value.
 366:../3rdParty/FreeRTOS/tasks.c ****  */
 367:../3rdParty/FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 368:../3rdParty/FreeRTOS/tasks.c **** 
 369:../3rdParty/FreeRTOS/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 370:../3rdParty/FreeRTOS/tasks.c **** 
 371:../3rdParty/FreeRTOS/tasks.c **** #endif
 372:../3rdParty/FreeRTOS/tasks.c **** 
 373:../3rdParty/FreeRTOS/tasks.c **** 
 374:../3rdParty/FreeRTOS/tasks.c **** /*lint +e956 */
 375:../3rdParty/FreeRTOS/tasks.c **** 
 376:../3rdParty/FreeRTOS/tasks.c **** 
 377:../3rdParty/FreeRTOS/tasks.c **** 
 378:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
 379:../3rdParty/FreeRTOS/tasks.c ****  * TASK CREATION API documented in task.h
 380:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
 381:../3rdParty/FreeRTOS/tasks.c **** 
 382:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 383:../3rdParty/FreeRTOS/tasks.c **** {
 4571              		.loc 1 383 0
 4572              		.cfi_startproc
 4573              		@ args = 16, pretend = 0, frame = 32
 4574              		@ frame_needed = 1, uses_anonymous_args = 0
 4575 0000 80B5     		push	{r7, lr}
 4576              	.LCFI0:
 4577              		.cfi_def_cfa_offset 8
 4578 0002 8AB0     		sub	sp, sp, #40
 4579              	.LCFI1:
 4580              		.cfi_def_cfa_offset 48
 4581 0004 02AF     		add	r7, sp, #8
 4582              		.cfi_offset 14, -4
 4583              		.cfi_offset 7, -8
 4584              	.LCFI2:
 4585              		.cfi_def_cfa 7, 40
 4586 0006 F860     		str	r0, [r7, #12]
 4587 0008 B960     		str	r1, [r7, #8]
 4588 000a 3B60     		str	r3, [r7, #0]
 4589 000c 1346     		mov	r3, r2	@ movhi
 4590 000e FB80     		strh	r3, [r7, #6]	@ movhi
 384:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xReturn;
 385:../3rdParty/FreeRTOS/tasks.c **** tskTCB * pxNewTCB;
 386:../3rdParty/FreeRTOS/tasks.c **** 
 387:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxTaskCode );
 388:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
 389:../3rdParty/FreeRTOS/tasks.c **** 
 390:../3rdParty/FreeRTOS/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 391:../3rdParty/FreeRTOS/tasks.c **** 	checking that the allocation was successful. */
 392:../3rdParty/FreeRTOS/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 4591              		.loc 1 392 0
 4592 0010 FB88     		ldrh	r3, [r7, #6]
 4593 0012 1846     		mov	r0, r3
 4594 0014 396B     		ldr	r1, [r7, #48]
 4595 0016 01F0BDF8 		bl	prvAllocateTCBAndStack
 4596 001a B861     		str	r0, [r7, #24]
 393:../3rdParty/FreeRTOS/tasks.c **** 
 394:../3rdParty/FreeRTOS/tasks.c **** 	if( pxNewTCB != NULL )
 4597              		.loc 1 394 0
 4598 001c BB69     		ldr	r3, [r7, #24]
 4599 001e 002B     		cmp	r3, #0
 4600 0020 7CD0     		beq	.L2
 4601              	.LBB2:
 395:../3rdParty/FreeRTOS/tasks.c **** 	{
 396:../3rdParty/FreeRTOS/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 397:../3rdParty/FreeRTOS/tasks.c **** 
 398:../3rdParty/FreeRTOS/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 399:../3rdParty/FreeRTOS/tasks.c **** 			/* Should the task be created in privileged mode? */
 400:../3rdParty/FreeRTOS/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 401:../3rdParty/FreeRTOS/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 402:../3rdParty/FreeRTOS/tasks.c **** 			{
 403:../3rdParty/FreeRTOS/tasks.c **** 				xRunPrivileged = pdTRUE;
 404:../3rdParty/FreeRTOS/tasks.c **** 			}
 405:../3rdParty/FreeRTOS/tasks.c **** 			else
 406:../3rdParty/FreeRTOS/tasks.c **** 			{
 407:../3rdParty/FreeRTOS/tasks.c **** 				xRunPrivileged = pdFALSE;
 408:../3rdParty/FreeRTOS/tasks.c **** 			}
 409:../3rdParty/FreeRTOS/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 410:../3rdParty/FreeRTOS/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 411:../3rdParty/FreeRTOS/tasks.c **** 
 412:../3rdParty/FreeRTOS/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 413:../3rdParty/FreeRTOS/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 414:../3rdParty/FreeRTOS/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 415:../3rdParty/FreeRTOS/tasks.c **** 		required by the port. */
 416:../3rdParty/FreeRTOS/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 417:../3rdParty/FreeRTOS/tasks.c **** 		{
 418:../3rdParty/FreeRTOS/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 4602              		.loc 1 418 0
 4603 0022 BB69     		ldr	r3, [r7, #24]
 4604 0024 1A6B     		ldr	r2, [r3, #48]
 4605 0026 FB88     		ldrh	r3, [r7, #6]
 4606 0028 03F1FF33 		add	r3, r3, #-1
 4607 002c 4FEA8303 		lsl	r3, r3, #2
 4608 0030 D318     		adds	r3, r2, r3
 4609 0032 7B61     		str	r3, [r7, #20]
 419:../3rdParty/FreeRTOS/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 4610              		.loc 1 419 0
 4611 0034 7B69     		ldr	r3, [r7, #20]
 4612 0036 23F00703 		bic	r3, r3, #7
 4613 003a 7B61     		str	r3, [r7, #20]
 420:../3rdParty/FreeRTOS/tasks.c **** 
 421:../3rdParty/FreeRTOS/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 422:../3rdParty/FreeRTOS/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 423:../3rdParty/FreeRTOS/tasks.c **** 		}
 424:../3rdParty/FreeRTOS/tasks.c **** 		#else
 425:../3rdParty/FreeRTOS/tasks.c **** 		{
 426:../3rdParty/FreeRTOS/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 427:../3rdParty/FreeRTOS/tasks.c **** 			
 428:../3rdParty/FreeRTOS/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 429:../3rdParty/FreeRTOS/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 430:../3rdParty/FreeRTOS/tasks.c **** 
 431:../3rdParty/FreeRTOS/tasks.c **** 			/* If we want to use stack checking on architectures that use
 432:../3rdParty/FreeRTOS/tasks.c **** 			a positive stack growth direction then we also need to store the
 433:../3rdParty/FreeRTOS/tasks.c **** 			other extreme of the stack space. */
 434:../3rdParty/FreeRTOS/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 435:../3rdParty/FreeRTOS/tasks.c **** 		}
 436:../3rdParty/FreeRTOS/tasks.c **** 		#endif
 437:../3rdParty/FreeRTOS/tasks.c **** 
 438:../3rdParty/FreeRTOS/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 439:../3rdParty/FreeRTOS/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 4614              		.loc 1 439 0
 4615 003c FB88     		ldrh	r3, [r7, #6]
 4616 003e 0093     		str	r3, [sp, #0]
 4617 0040 B869     		ldr	r0, [r7, #24]
 4618 0042 B968     		ldr	r1, [r7, #8]
 4619 0044 BA6A     		ldr	r2, [r7, #40]
 4620 0046 7B6B     		ldr	r3, [r7, #52]
 4621 0048 00F0AAFF 		bl	prvInitialiseTCBVariables
 440:../3rdParty/FreeRTOS/tasks.c **** 
 441:../3rdParty/FreeRTOS/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 442:../3rdParty/FreeRTOS/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 443:../3rdParty/FreeRTOS/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 444:../3rdParty/FreeRTOS/tasks.c **** 		the	top of stack variable is updated. */
 445:../3rdParty/FreeRTOS/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 446:../3rdParty/FreeRTOS/tasks.c **** 		{
 447:../3rdParty/FreeRTOS/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 448:../3rdParty/FreeRTOS/tasks.c **** 		}
 449:../3rdParty/FreeRTOS/tasks.c **** 		#else
 450:../3rdParty/FreeRTOS/tasks.c **** 		{
 451:../3rdParty/FreeRTOS/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 4622              		.loc 1 451 0
 4623 004c 7869     		ldr	r0, [r7, #20]
 4624 004e F968     		ldr	r1, [r7, #12]
 4625 0050 3A68     		ldr	r2, [r7, #0]
 4626 0052 FFF7FEFF 		bl	pxPortInitialiseStack
 4627 0056 0346     		mov	r3, r0
 4628 0058 1A46     		mov	r2, r3
 4629 005a BB69     		ldr	r3, [r7, #24]
 4630 005c 1A60     		str	r2, [r3, #0]
 452:../3rdParty/FreeRTOS/tasks.c **** 		}
 453:../3rdParty/FreeRTOS/tasks.c **** 		#endif
 454:../3rdParty/FreeRTOS/tasks.c **** 
 455:../3rdParty/FreeRTOS/tasks.c **** 		/* Check the alignment of the initialised stack. */
 456:../3rdParty/FreeRTOS/tasks.c **** 		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long
 457:../3rdParty/FreeRTOS/tasks.c **** 
 458:../3rdParty/FreeRTOS/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 4631              		.loc 1 458 0
 4632 005e FB6A     		ldr	r3, [r7, #44]
 4633 0060 002B     		cmp	r3, #0
 4634 0062 02D0     		beq	.L3
 459:../3rdParty/FreeRTOS/tasks.c **** 		{
 460:../3rdParty/FreeRTOS/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 461:../3rdParty/FreeRTOS/tasks.c **** 			task can use this as a handle to delete the task later if
 462:../3rdParty/FreeRTOS/tasks.c **** 			required.*/
 463:../3rdParty/FreeRTOS/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 4635              		.loc 1 463 0
 4636 0064 FB6A     		ldr	r3, [r7, #44]
 4637 0066 BA69     		ldr	r2, [r7, #24]
 4638 0068 1A60     		str	r2, [r3, #0]
 4639              	.L3:
 464:../3rdParty/FreeRTOS/tasks.c **** 		}
 465:../3rdParty/FreeRTOS/tasks.c **** 		
 466:../3rdParty/FreeRTOS/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 467:../3rdParty/FreeRTOS/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 468:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 4640              		.loc 1 468 0
 4641 006a FFF7FEFF 		bl	vPortEnterCritical
 469:../3rdParty/FreeRTOS/tasks.c **** 		{
 470:../3rdParty/FreeRTOS/tasks.c **** 			uxCurrentNumberOfTasks++;
 4642              		.loc 1 470 0
 4643 006e 374B     		ldr	r3, .L10
 4644 0070 1B68     		ldr	r3, [r3, #0]
 4645 0072 03F10102 		add	r2, r3, #1
 4646 0076 354B     		ldr	r3, .L10
 4647 0078 1A60     		str	r2, [r3, #0]
 471:../3rdParty/FreeRTOS/tasks.c **** 			if( pxCurrentTCB == NULL )
 4648              		.loc 1 471 0
 4649 007a 354B     		ldr	r3, .L10+4
 4650 007c 1B68     		ldr	r3, [r3, #0]
 4651 007e 002B     		cmp	r3, #0
 4652 0080 09D1     		bne	.L4
 472:../3rdParty/FreeRTOS/tasks.c **** 			{
 473:../3rdParty/FreeRTOS/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 474:../3rdParty/FreeRTOS/tasks.c **** 				the suspended state - make this the current task. */
 475:../3rdParty/FreeRTOS/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 4653              		.loc 1 475 0
 4654 0082 334B     		ldr	r3, .L10+4
 4655 0084 BA69     		ldr	r2, [r7, #24]
 4656 0086 1A60     		str	r2, [r3, #0]
 476:../3rdParty/FreeRTOS/tasks.c **** 
 477:../3rdParty/FreeRTOS/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 4657              		.loc 1 477 0
 4658 0088 304B     		ldr	r3, .L10
 4659 008a 1B68     		ldr	r3, [r3, #0]
 4660 008c 012B     		cmp	r3, #1
 4661 008e 0FD1     		bne	.L5
 478:../3rdParty/FreeRTOS/tasks.c **** 				{
 479:../3rdParty/FreeRTOS/tasks.c **** 					/* This is the first task to be created so do the preliminary
 480:../3rdParty/FreeRTOS/tasks.c **** 					initialisation required.  We will not recover if this call
 481:../3rdParty/FreeRTOS/tasks.c **** 					fails, but we will report the failure. */
 482:../3rdParty/FreeRTOS/tasks.c **** 					prvInitialiseTaskLists();
 4662              		.loc 1 482 0
 4663 0090 00F0C8FF 		bl	prvInitialiseTaskLists
 4664 0094 0CE0     		b	.L5
 4665              	.L4:
 483:../3rdParty/FreeRTOS/tasks.c **** 				}
 484:../3rdParty/FreeRTOS/tasks.c **** 			}
 485:../3rdParty/FreeRTOS/tasks.c **** 			else
 486:../3rdParty/FreeRTOS/tasks.c **** 			{
 487:../3rdParty/FreeRTOS/tasks.c **** 				/* If the scheduler is not already running, make this task the
 488:../3rdParty/FreeRTOS/tasks.c **** 				current task if it is the highest priority task to be created
 489:../3rdParty/FreeRTOS/tasks.c **** 				so far. */
 490:../3rdParty/FreeRTOS/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 4666              		.loc 1 490 0
 4667 0096 2F4B     		ldr	r3, .L10+8
 4668 0098 1B68     		ldr	r3, [r3, #0]
 4669 009a 002B     		cmp	r3, #0
 4670 009c 08D1     		bne	.L5
 491:../3rdParty/FreeRTOS/tasks.c **** 				{
 492:../3rdParty/FreeRTOS/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 4671              		.loc 1 492 0
 4672 009e 2C4B     		ldr	r3, .L10+4
 4673 00a0 1B68     		ldr	r3, [r3, #0]
 4674 00a2 DA6A     		ldr	r2, [r3, #44]
 4675 00a4 BB6A     		ldr	r3, [r7, #40]
 4676 00a6 9A42     		cmp	r2, r3
 4677 00a8 02D8     		bhi	.L5
 493:../3rdParty/FreeRTOS/tasks.c **** 					{
 494:../3rdParty/FreeRTOS/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 4678              		.loc 1 494 0
 4679 00aa 294B     		ldr	r3, .L10+4
 4680 00ac BA69     		ldr	r2, [r7, #24]
 4681 00ae 1A60     		str	r2, [r3, #0]
 4682              	.L5:
 495:../3rdParty/FreeRTOS/tasks.c **** 					}
 496:../3rdParty/FreeRTOS/tasks.c **** 				}
 497:../3rdParty/FreeRTOS/tasks.c **** 			}
 498:../3rdParty/FreeRTOS/tasks.c **** 
 499:../3rdParty/FreeRTOS/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 500:../3rdParty/FreeRTOS/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 501:../3rdParty/FreeRTOS/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 4683              		.loc 1 501 0
 4684 00b0 BB69     		ldr	r3, [r7, #24]
 4685 00b2 DA6A     		ldr	r2, [r3, #44]
 4686 00b4 284B     		ldr	r3, .L10+12
 4687 00b6 1B68     		ldr	r3, [r3, #0]
 4688 00b8 9A42     		cmp	r2, r3
 4689 00ba 03D9     		bls	.L6
 502:../3rdParty/FreeRTOS/tasks.c **** 			{
 503:../3rdParty/FreeRTOS/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 4690              		.loc 1 503 0
 4691 00bc BB69     		ldr	r3, [r7, #24]
 4692 00be DA6A     		ldr	r2, [r3, #44]
 4693 00c0 254B     		ldr	r3, .L10+12
 4694 00c2 1A60     		str	r2, [r3, #0]
 4695              	.L6:
 504:../3rdParty/FreeRTOS/tasks.c **** 			}
 505:../3rdParty/FreeRTOS/tasks.c **** 
 506:../3rdParty/FreeRTOS/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 507:../3rdParty/FreeRTOS/tasks.c **** 			{
 508:../3rdParty/FreeRTOS/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 509:../3rdParty/FreeRTOS/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTCBNumber;
 4696              		.loc 1 509 0
 4697 00c4 254B     		ldr	r3, .L10+16
 4698 00c6 1A68     		ldr	r2, [r3, #0]
 4699 00c8 BB69     		ldr	r3, [r7, #24]
 4700 00ca 1A64     		str	r2, [r3, #64]
 510:../3rdParty/FreeRTOS/tasks.c **** 			}
 511:../3rdParty/FreeRTOS/tasks.c **** 			#endif
 512:../3rdParty/FreeRTOS/tasks.c **** 			uxTCBNumber++;
 4701              		.loc 1 512 0
 4702 00cc 234B     		ldr	r3, .L10+16
 4703 00ce 1B68     		ldr	r3, [r3, #0]
 4704 00d0 03F10102 		add	r2, r3, #1
 4705 00d4 214B     		ldr	r3, .L10+16
 4706 00d6 1A60     		str	r2, [r3, #0]
 513:../3rdParty/FreeRTOS/tasks.c **** 
 514:../3rdParty/FreeRTOS/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 4707              		.loc 1 514 0
 4708 00d8 BB69     		ldr	r3, [r7, #24]
 4709 00da DA6A     		ldr	r2, [r3, #44]
 4710 00dc 204B     		ldr	r3, .L10+20
 4711 00de 1B68     		ldr	r3, [r3, #0]
 4712 00e0 9A42     		cmp	r2, r3
 4713 00e2 03D9     		bls	.L7
 4714              		.loc 1 514 0 is_stmt 0 discriminator 1
 4715 00e4 BB69     		ldr	r3, [r7, #24]
 4716 00e6 DA6A     		ldr	r2, [r3, #44]
 4717 00e8 1D4B     		ldr	r3, .L10+20
 4718 00ea 1A60     		str	r2, [r3, #0]
 4719              	.L7:
 4720              		.loc 1 514 0 discriminator 2
 4721 00ec BB69     		ldr	r3, [r7, #24]
 4722 00ee DA6A     		ldr	r2, [r3, #44]
 4723 00f0 1346     		mov	r3, r2
 4724 00f2 4FEA8303 		lsl	r3, r3, #2
 4725 00f6 9B18     		adds	r3, r3, r2
 4726 00f8 4FEA8303 		lsl	r3, r3, #2
 4727 00fc 1A46     		mov	r2, r3
 4728 00fe 194B     		ldr	r3, .L10+24
 4729 0100 D218     		adds	r2, r2, r3
 4730 0102 BB69     		ldr	r3, [r7, #24]
 4731 0104 03F10403 		add	r3, r3, #4
 4732 0108 1046     		mov	r0, r2
 4733 010a 1946     		mov	r1, r3
 4734 010c FFF7FEFF 		bl	vListInsertEnd
 515:../3rdParty/FreeRTOS/tasks.c **** 
 516:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdPASS;
 4735              		.loc 1 516 0 is_stmt 1 discriminator 2
 4736 0110 4FF00103 		mov	r3, #1
 4737 0114 FB61     		str	r3, [r7, #28]
 517:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 518:../3rdParty/FreeRTOS/tasks.c **** 		}
 519:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 4738              		.loc 1 519 0 discriminator 2
 4739 0116 FFF7FEFF 		bl	vPortExitCritical
 4740 011a 02E0     		b	.L8
 4741              	.L2:
 4742              	.LBE2:
 520:../3rdParty/FreeRTOS/tasks.c **** 	}
 521:../3rdParty/FreeRTOS/tasks.c **** 	else
 522:../3rdParty/FreeRTOS/tasks.c **** 	{
 523:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 4743              		.loc 1 523 0
 4744 011c 4FF0FF33 		mov	r3, #-1
 4745 0120 FB61     		str	r3, [r7, #28]
 4746              	.L8:
 524:../3rdParty/FreeRTOS/tasks.c **** 		traceTASK_CREATE_FAILED();
 525:../3rdParty/FreeRTOS/tasks.c **** 	}
 526:../3rdParty/FreeRTOS/tasks.c **** 
 527:../3rdParty/FreeRTOS/tasks.c **** 	if( xReturn == pdPASS )
 4747              		.loc 1 527 0
 4748 0122 FB69     		ldr	r3, [r7, #28]
 4749 0124 012B     		cmp	r3, #1
 4750 0126 0BD1     		bne	.L9
 528:../3rdParty/FreeRTOS/tasks.c **** 	{
 529:../3rdParty/FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 4751              		.loc 1 529 0
 4752 0128 0A4B     		ldr	r3, .L10+8
 4753 012a 1B68     		ldr	r3, [r3, #0]
 4754 012c 002B     		cmp	r3, #0
 4755 012e 07D0     		beq	.L9
 530:../3rdParty/FreeRTOS/tasks.c **** 		{
 531:../3rdParty/FreeRTOS/tasks.c **** 			/* If the created task is of a higher priority than the current task
 532:../3rdParty/FreeRTOS/tasks.c **** 			then it should run now. */
 533:../3rdParty/FreeRTOS/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 4756              		.loc 1 533 0
 4757 0130 074B     		ldr	r3, .L10+4
 4758 0132 1B68     		ldr	r3, [r3, #0]
 4759 0134 DA6A     		ldr	r2, [r3, #44]
 4760 0136 BB6A     		ldr	r3, [r7, #40]
 4761 0138 9A42     		cmp	r2, r3
 4762 013a 01D2     		bcs	.L9
 534:../3rdParty/FreeRTOS/tasks.c **** 			{
 535:../3rdParty/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 4763              		.loc 1 535 0
 4764 013c FFF7FEFF 		bl	vPortYieldFromISR
 4765              	.L9:
 536:../3rdParty/FreeRTOS/tasks.c **** 			}
 537:../3rdParty/FreeRTOS/tasks.c **** 		}
 538:../3rdParty/FreeRTOS/tasks.c **** 	}
 539:../3rdParty/FreeRTOS/tasks.c **** 
 540:../3rdParty/FreeRTOS/tasks.c **** 	return xReturn;
 4766              		.loc 1 540 0
 4767 0140 FB69     		ldr	r3, [r7, #28]
 541:../3rdParty/FreeRTOS/tasks.c **** }
 4768              		.loc 1 541 0
 4769 0142 1846     		mov	r0, r3
 4770 0144 07F12007 		add	r7, r7, #32
 4771 0148 BD46     		mov	sp, r7
 4772 014a 80BD     		pop	{r7, pc}
 4773              	.L11:
 4774              		.align	2
 4775              	.L10:
 4776 014c D8000000 		.word	uxCurrentNumberOfTasks
 4777 0150 00000000 		.word	pxCurrentTCB
 4778 0154 E8000000 		.word	xSchedulerRunning
 4779 0158 E0000000 		.word	uxTopUsedPriority
 4780 015c FC000000 		.word	uxTCBNumber
 4781 0160 E4000000 		.word	uxTopReadyPriority
 4782 0164 04000000 		.word	pxReadyTasksLists
 4783              		.cfi_endproc
 4784              	.LFE55:
 4786              		.align	2
 4787              		.global	vTaskDelete
 4788              		.thumb
 4789              		.thumb_func
 4791              	vTaskDelete:
 4792              	.LFB56:
 542:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 543:../3rdParty/FreeRTOS/tasks.c **** 
 544:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 545:../3rdParty/FreeRTOS/tasks.c **** 
 546:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 547:../3rdParty/FreeRTOS/tasks.c **** 	{
 4793              		.loc 1 547 0
 4794              		.cfi_startproc
 4795              		@ args = 0, pretend = 0, frame = 16
 4796              		@ frame_needed = 1, uses_anonymous_args = 0
 4797 0168 80B5     		push	{r7, lr}
 4798              	.LCFI3:
 4799              		.cfi_def_cfa_offset 8
 4800 016a 84B0     		sub	sp, sp, #16
 4801              	.LCFI4:
 4802              		.cfi_def_cfa_offset 24
 4803 016c 00AF     		add	r7, sp, #0
 4804              		.cfi_offset 14, -4
 4805              		.cfi_offset 7, -8
 4806              	.LCFI5:
 4807              		.cfi_def_cfa_register 7
 4808 016e 7860     		str	r0, [r7, #4]
 548:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 549:../3rdParty/FreeRTOS/tasks.c **** 
 550:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 4809              		.loc 1 550 0
 4810 0170 FFF7FEFF 		bl	vPortEnterCritical
 551:../3rdParty/FreeRTOS/tasks.c **** 		{
 552:../3rdParty/FreeRTOS/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 553:../3rdParty/FreeRTOS/tasks.c **** 			deleted. */
 554:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 4811              		.loc 1 554 0
 4812 0174 204B     		ldr	r3, .L18
 4813 0176 1B68     		ldr	r3, [r3, #0]
 4814 0178 7A68     		ldr	r2, [r7, #4]
 4815 017a 9A42     		cmp	r2, r3
 4816 017c 02D1     		bne	.L13
 555:../3rdParty/FreeRTOS/tasks.c **** 			{
 556:../3rdParty/FreeRTOS/tasks.c **** 				pxTaskToDelete = NULL;
 4817              		.loc 1 556 0
 4818 017e 4FF00003 		mov	r3, #0
 4819 0182 7B60     		str	r3, [r7, #4]
 4820              	.L13:
 557:../3rdParty/FreeRTOS/tasks.c **** 			}
 558:../3rdParty/FreeRTOS/tasks.c **** 
 559:../3rdParty/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 560:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 4821              		.loc 1 560 0
 4822 0184 7B68     		ldr	r3, [r7, #4]
 4823 0186 002B     		cmp	r3, #0
 4824 0188 02D1     		bne	.L14
 4825              		.loc 1 560 0 is_stmt 0 discriminator 1
 4826 018a 1B4B     		ldr	r3, .L18
 4827 018c 1B68     		ldr	r3, [r3, #0]
 4828 018e 00E0     		b	.L15
 4829              	.L14:
 4830              		.loc 1 560 0 discriminator 2
 4831 0190 7B68     		ldr	r3, [r7, #4]
 4832              	.L15:
 4833              		.loc 1 560 0 discriminator 3
 4834 0192 FB60     		str	r3, [r7, #12]
 561:../3rdParty/FreeRTOS/tasks.c **** 
 562:../3rdParty/FreeRTOS/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 563:../3rdParty/FreeRTOS/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 564:../3rdParty/FreeRTOS/tasks.c **** 			the termination list and free up any memory allocated by the
 565:../3rdParty/FreeRTOS/tasks.c **** 			scheduler for the TCB and stack. */
 566:../3rdParty/FreeRTOS/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 4835              		.loc 1 566 0 is_stmt 1 discriminator 3
 4836 0194 FB68     		ldr	r3, [r7, #12]
 4837 0196 03F10403 		add	r3, r3, #4
 4838 019a 1846     		mov	r0, r3
 4839 019c FFF7FEFF 		bl	vListRemove
 567:../3rdParty/FreeRTOS/tasks.c **** 
 568:../3rdParty/FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
 569:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 4840              		.loc 1 569 0 discriminator 3
 4841 01a0 FB68     		ldr	r3, [r7, #12]
 4842 01a2 9B6A     		ldr	r3, [r3, #40]
 4843 01a4 002B     		cmp	r3, #0
 4844 01a6 05D0     		beq	.L16
 570:../3rdParty/FreeRTOS/tasks.c **** 			{
 571:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 4845              		.loc 1 571 0
 4846 01a8 FB68     		ldr	r3, [r7, #12]
 4847 01aa 03F11803 		add	r3, r3, #24
 4848 01ae 1846     		mov	r0, r3
 4849 01b0 FFF7FEFF 		bl	vListRemove
 4850              	.L16:
 572:../3rdParty/FreeRTOS/tasks.c **** 			}
 573:../3rdParty/FreeRTOS/tasks.c **** 
 574:../3rdParty/FreeRTOS/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 4851              		.loc 1 574 0
 4852 01b4 FB68     		ldr	r3, [r7, #12]
 4853 01b6 03F10403 		add	r3, r3, #4
 4854 01ba 1048     		ldr	r0, .L18+4
 4855 01bc 1946     		mov	r1, r3
 4856 01be FFF7FEFF 		bl	vListInsertEnd
 575:../3rdParty/FreeRTOS/tasks.c **** 
 576:../3rdParty/FreeRTOS/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 577:../3rdParty/FreeRTOS/tasks.c **** 			there is a task that has been deleted and that it should therefore
 578:../3rdParty/FreeRTOS/tasks.c **** 			check the xTasksWaitingTermination list. */
 579:../3rdParty/FreeRTOS/tasks.c **** 			++uxTasksDeleted;
 4857              		.loc 1 579 0
 4858 01c2 0F4B     		ldr	r3, .L18+8
 4859 01c4 1B68     		ldr	r3, [r3, #0]
 4860 01c6 03F10102 		add	r2, r3, #1
 4861 01ca 0D4B     		ldr	r3, .L18+8
 4862 01cc 1A60     		str	r2, [r3, #0]
 580:../3rdParty/FreeRTOS/tasks.c **** 
 581:../3rdParty/FreeRTOS/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 582:../3rdParty/FreeRTOS/tasks.c **** 			can detect that the task lists need re-generating. */
 583:../3rdParty/FreeRTOS/tasks.c **** 			uxTCBNumber++;
 4863              		.loc 1 583 0
 4864 01ce 0D4B     		ldr	r3, .L18+12
 4865 01d0 1B68     		ldr	r3, [r3, #0]
 4866 01d2 03F10102 		add	r2, r3, #1
 4867 01d6 0B4B     		ldr	r3, .L18+12
 4868 01d8 1A60     		str	r2, [r3, #0]
 584:../3rdParty/FreeRTOS/tasks.c **** 
 585:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_DELETE( pxTCB );
 586:../3rdParty/FreeRTOS/tasks.c **** 		}
 587:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 4869              		.loc 1 587 0
 4870 01da FFF7FEFF 		bl	vPortExitCritical
 588:../3rdParty/FreeRTOS/tasks.c **** 
 589:../3rdParty/FreeRTOS/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 590:../3rdParty/FreeRTOS/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 4871              		.loc 1 590 0
 4872 01de 0A4B     		ldr	r3, .L18+16
 4873 01e0 1B68     		ldr	r3, [r3, #0]
 4874 01e2 002B     		cmp	r3, #0
 4875 01e4 04D0     		beq	.L12
 591:../3rdParty/FreeRTOS/tasks.c **** 		{
 592:../3rdParty/FreeRTOS/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 4876              		.loc 1 592 0
 4877 01e6 7B68     		ldr	r3, [r7, #4]
 4878 01e8 002B     		cmp	r3, #0
 4879 01ea 01D1     		bne	.L12
 593:../3rdParty/FreeRTOS/tasks.c **** 			{
 594:../3rdParty/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 4880              		.loc 1 594 0
 4881 01ec FFF7FEFF 		bl	vPortYieldFromISR
 4882              	.L12:
 595:../3rdParty/FreeRTOS/tasks.c **** 			}
 596:../3rdParty/FreeRTOS/tasks.c **** 		}
 597:../3rdParty/FreeRTOS/tasks.c **** 	}
 4883              		.loc 1 597 0
 4884 01f0 07F11007 		add	r7, r7, #16
 4885 01f4 BD46     		mov	sp, r7
 4886 01f6 80BD     		pop	{r7, pc}
 4887              	.L19:
 4888              		.align	2
 4889              	.L18:
 4890 01f8 00000000 		.word	pxCurrentTCB
 4891 01fc AC000000 		.word	xTasksWaitingTermination
 4892 0200 C0000000 		.word	uxTasksDeleted
 4893 0204 FC000000 		.word	uxTCBNumber
 4894 0208 E8000000 		.word	xSchedulerRunning
 4895              		.cfi_endproc
 4896              	.LFE56:
 4898              		.align	2
 4899              		.global	vTaskDelayUntil
 4900              		.thumb
 4901              		.thumb_func
 4903              	vTaskDelayUntil:
 4904              	.LFB57:
 598:../3rdParty/FreeRTOS/tasks.c **** 
 599:../3rdParty/FreeRTOS/tasks.c **** #endif
 600:../3rdParty/FreeRTOS/tasks.c **** 
 601:../3rdParty/FreeRTOS/tasks.c **** 
 602:../3rdParty/FreeRTOS/tasks.c **** 
 603:../3rdParty/FreeRTOS/tasks.c **** 
 604:../3rdParty/FreeRTOS/tasks.c **** 
 605:../3rdParty/FreeRTOS/tasks.c **** 
 606:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
 607:../3rdParty/FreeRTOS/tasks.c ****  * TASK CONTROL API documented in task.h
 608:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
 609:../3rdParty/FreeRTOS/tasks.c **** 
 610:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 611:../3rdParty/FreeRTOS/tasks.c **** 
 612:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 613:../3rdParty/FreeRTOS/tasks.c **** 	{
 4905              		.loc 1 613 0
 4906              		.cfi_startproc
 4907              		@ args = 0, pretend = 0, frame = 24
 4908              		@ frame_needed = 1, uses_anonymous_args = 0
 4909 020c 80B5     		push	{r7, lr}
 4910              	.LCFI6:
 4911              		.cfi_def_cfa_offset 8
 4912 020e 86B0     		sub	sp, sp, #24
 4913              	.LCFI7:
 4914              		.cfi_def_cfa_offset 32
 4915 0210 00AF     		add	r7, sp, #0
 4916              		.cfi_offset 14, -4
 4917              		.cfi_offset 7, -8
 4918              	.LCFI8:
 4919              		.cfi_def_cfa_register 7
 4920 0212 7860     		str	r0, [r7, #4]
 4921 0214 3960     		str	r1, [r7, #0]
 614:../3rdParty/FreeRTOS/tasks.c **** 	portTickType xTimeToWake;
 615:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 4922              		.loc 1 615 0
 4923 0216 4FF00003 		mov	r3, #0
 4924 021a 7B61     		str	r3, [r7, #20]
 616:../3rdParty/FreeRTOS/tasks.c **** 
 617:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 618:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 619:../3rdParty/FreeRTOS/tasks.c **** 
 620:../3rdParty/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
 4925              		.loc 1 620 0
 4926 021c FFF7FEFF 		bl	vTaskSuspendAll
 621:../3rdParty/FreeRTOS/tasks.c **** 		{
 622:../3rdParty/FreeRTOS/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 623:../3rdParty/FreeRTOS/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 4927              		.loc 1 623 0
 4928 0220 7B68     		ldr	r3, [r7, #4]
 4929 0222 1A68     		ldr	r2, [r3, #0]
 4930 0224 3B68     		ldr	r3, [r7, #0]
 4931 0226 D318     		adds	r3, r2, r3
 4932 0228 3B61     		str	r3, [r7, #16]
 624:../3rdParty/FreeRTOS/tasks.c **** 
 625:../3rdParty/FreeRTOS/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 4933              		.loc 1 625 0
 4934 022a 7B68     		ldr	r3, [r7, #4]
 4935 022c 1A68     		ldr	r2, [r3, #0]
 4936 022e 1D4B     		ldr	r3, .L26
 4937 0230 1B68     		ldr	r3, [r3, #0]
 4938 0232 9A42     		cmp	r2, r3
 4939 0234 0DD9     		bls	.L21
 626:../3rdParty/FreeRTOS/tasks.c **** 			{
 627:../3rdParty/FreeRTOS/tasks.c **** 				/* The tick count has overflowed since this function was
 628:../3rdParty/FreeRTOS/tasks.c **** 				lasted called.  In this case the only time we should ever
 629:../3rdParty/FreeRTOS/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 630:../3rdParty/FreeRTOS/tasks.c **** 				and the wake time is greater than the tick time.  When this
 631:../3rdParty/FreeRTOS/tasks.c **** 				is the case it is as if neither time had overflowed. */
 632:../3rdParty/FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 4940              		.loc 1 632 0
 4941 0236 7B68     		ldr	r3, [r7, #4]
 4942 0238 1A68     		ldr	r2, [r3, #0]
 4943 023a 3B69     		ldr	r3, [r7, #16]
 4944 023c 9A42     		cmp	r2, r3
 4945 023e 15D9     		bls	.L22
 4946              		.loc 1 632 0 is_stmt 0 discriminator 1
 4947 0240 184B     		ldr	r3, .L26
 4948 0242 1B68     		ldr	r3, [r3, #0]
 4949 0244 3A69     		ldr	r2, [r7, #16]
 4950 0246 9A42     		cmp	r2, r3
 4951 0248 10D9     		bls	.L22
 633:../3rdParty/FreeRTOS/tasks.c **** 				{
 634:../3rdParty/FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 4952              		.loc 1 634 0 is_stmt 1
 4953 024a 4FF00103 		mov	r3, #1
 4954 024e 7B61     		str	r3, [r7, #20]
 4955 0250 0CE0     		b	.L22
 4956              	.L21:
 635:../3rdParty/FreeRTOS/tasks.c **** 				}
 636:../3rdParty/FreeRTOS/tasks.c **** 			}
 637:../3rdParty/FreeRTOS/tasks.c **** 			else
 638:../3rdParty/FreeRTOS/tasks.c **** 			{
 639:../3rdParty/FreeRTOS/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 640:../3rdParty/FreeRTOS/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 641:../3rdParty/FreeRTOS/tasks.c **** 				tick time is less than the wake time. */
 642:../3rdParty/FreeRTOS/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 4957              		.loc 1 642 0
 4958 0252 7B68     		ldr	r3, [r7, #4]
 4959 0254 1A68     		ldr	r2, [r3, #0]
 4960 0256 3B69     		ldr	r3, [r7, #16]
 4961 0258 9A42     		cmp	r2, r3
 4962 025a 04D8     		bhi	.L23
 4963              		.loc 1 642 0 is_stmt 0 discriminator 1
 4964 025c 114B     		ldr	r3, .L26
 4965 025e 1B68     		ldr	r3, [r3, #0]
 4966 0260 3A69     		ldr	r2, [r7, #16]
 4967 0262 9A42     		cmp	r2, r3
 4968 0264 02D9     		bls	.L22
 4969              	.L23:
 643:../3rdParty/FreeRTOS/tasks.c **** 				{
 644:../3rdParty/FreeRTOS/tasks.c **** 					xShouldDelay = pdTRUE;
 4970              		.loc 1 644 0 is_stmt 1
 4971 0266 4FF00103 		mov	r3, #1
 4972 026a 7B61     		str	r3, [r7, #20]
 4973              	.L22:
 645:../3rdParty/FreeRTOS/tasks.c **** 				}
 646:../3rdParty/FreeRTOS/tasks.c **** 			}
 647:../3rdParty/FreeRTOS/tasks.c **** 
 648:../3rdParty/FreeRTOS/tasks.c **** 			/* Update the wake time ready for the next call. */
 649:../3rdParty/FreeRTOS/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 4974              		.loc 1 649 0
 4975 026c 7B68     		ldr	r3, [r7, #4]
 4976 026e 3A69     		ldr	r2, [r7, #16]
 4977 0270 1A60     		str	r2, [r3, #0]
 650:../3rdParty/FreeRTOS/tasks.c **** 
 651:../3rdParty/FreeRTOS/tasks.c **** 			if( xShouldDelay != pdFALSE )
 4978              		.loc 1 651 0
 4979 0272 7B69     		ldr	r3, [r7, #20]
 4980 0274 002B     		cmp	r3, #0
 4981 0276 09D0     		beq	.L24
 652:../3rdParty/FreeRTOS/tasks.c **** 			{
 653:../3rdParty/FreeRTOS/tasks.c **** 				traceTASK_DELAY_UNTIL();
 654:../3rdParty/FreeRTOS/tasks.c **** 
 655:../3rdParty/FreeRTOS/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 656:../3rdParty/FreeRTOS/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 657:../3rdParty/FreeRTOS/tasks.c **** 				both lists. */
 658:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 4982              		.loc 1 658 0
 4983 0278 0B4B     		ldr	r3, .L26+4
 4984 027a 1B68     		ldr	r3, [r3, #0]
 4985 027c 03F10403 		add	r3, r3, #4
 4986 0280 1846     		mov	r0, r3
 4987 0282 FFF7FEFF 		bl	vListRemove
 659:../3rdParty/FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 4988              		.loc 1 659 0
 4989 0286 3869     		ldr	r0, [r7, #16]
 4990 0288 00F04CFF 		bl	prvAddCurrentTaskToDelayedList
 4991              	.L24:
 660:../3rdParty/FreeRTOS/tasks.c **** 			}
 661:../3rdParty/FreeRTOS/tasks.c **** 		}
 662:../3rdParty/FreeRTOS/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 4992              		.loc 1 662 0
 4993 028c FFF7FEFF 		bl	xTaskResumeAll
 4994 0290 F860     		str	r0, [r7, #12]
 663:../3rdParty/FreeRTOS/tasks.c **** 
 664:../3rdParty/FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 665:../3rdParty/FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
 666:../3rdParty/FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 4995              		.loc 1 666 0
 4996 0292 FB68     		ldr	r3, [r7, #12]
 4997 0294 002B     		cmp	r3, #0
 4998 0296 01D1     		bne	.L20
 667:../3rdParty/FreeRTOS/tasks.c **** 		{
 668:../3rdParty/FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
 4999              		.loc 1 668 0
 5000 0298 FFF7FEFF 		bl	vPortYieldFromISR
 5001              	.L20:
 669:../3rdParty/FreeRTOS/tasks.c **** 		}
 670:../3rdParty/FreeRTOS/tasks.c **** 	}
 5002              		.loc 1 670 0
 5003 029c 07F11807 		add	r7, r7, #24
 5004 02a0 BD46     		mov	sp, r7
 5005 02a2 80BD     		pop	{r7, pc}
 5006              	.L27:
 5007              		.align	2
 5008              	.L26:
 5009 02a4 DC000000 		.word	xTickCount
 5010 02a8 00000000 		.word	pxCurrentTCB
 5011              		.cfi_endproc
 5012              	.LFE57:
 5014              		.align	2
 5015              		.global	vTaskDelay
 5016              		.thumb
 5017              		.thumb_func
 5019              	vTaskDelay:
 5020              	.LFB58:
 671:../3rdParty/FreeRTOS/tasks.c **** 
 672:../3rdParty/FreeRTOS/tasks.c **** #endif
 673:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 674:../3rdParty/FreeRTOS/tasks.c **** 
 675:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 676:../3rdParty/FreeRTOS/tasks.c **** 
 677:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 678:../3rdParty/FreeRTOS/tasks.c **** 	{
 5021              		.loc 1 678 0
 5022              		.cfi_startproc
 5023              		@ args = 0, pretend = 0, frame = 16
 5024              		@ frame_needed = 1, uses_anonymous_args = 0
 5025 02ac 80B5     		push	{r7, lr}
 5026              	.LCFI9:
 5027              		.cfi_def_cfa_offset 8
 5028 02ae 84B0     		sub	sp, sp, #16
 5029              	.LCFI10:
 5030              		.cfi_def_cfa_offset 24
 5031 02b0 00AF     		add	r7, sp, #0
 5032              		.cfi_offset 14, -4
 5033              		.cfi_offset 7, -8
 5034              	.LCFI11:
 5035              		.cfi_def_cfa_register 7
 5036 02b2 7860     		str	r0, [r7, #4]
 679:../3rdParty/FreeRTOS/tasks.c **** 	portTickType xTimeToWake;
 680:../3rdParty/FreeRTOS/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 5037              		.loc 1 680 0
 5038 02b4 4FF00003 		mov	r3, #0
 5039 02b8 FB60     		str	r3, [r7, #12]
 681:../3rdParty/FreeRTOS/tasks.c **** 
 682:../3rdParty/FreeRTOS/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 683:../3rdParty/FreeRTOS/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 5040              		.loc 1 683 0
 5041 02ba 7B68     		ldr	r3, [r7, #4]
 5042 02bc 002B     		cmp	r3, #0
 5043 02be 13D0     		beq	.L29
 684:../3rdParty/FreeRTOS/tasks.c **** 		{
 685:../3rdParty/FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 5044              		.loc 1 685 0
 5045 02c0 FFF7FEFF 		bl	vTaskSuspendAll
 686:../3rdParty/FreeRTOS/tasks.c **** 			{
 687:../3rdParty/FreeRTOS/tasks.c **** 				traceTASK_DELAY();
 688:../3rdParty/FreeRTOS/tasks.c **** 
 689:../3rdParty/FreeRTOS/tasks.c **** 				/* A task that is removed from the event list while the
 690:../3rdParty/FreeRTOS/tasks.c **** 				scheduler is suspended will not get placed in the ready
 691:../3rdParty/FreeRTOS/tasks.c **** 				list or removed from the blocked list until the scheduler
 692:../3rdParty/FreeRTOS/tasks.c **** 				is resumed.
 693:../3rdParty/FreeRTOS/tasks.c **** 
 694:../3rdParty/FreeRTOS/tasks.c **** 				This task cannot be in an event list as it is the currently
 695:../3rdParty/FreeRTOS/tasks.c **** 				executing task. */
 696:../3rdParty/FreeRTOS/tasks.c **** 
 697:../3rdParty/FreeRTOS/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 698:../3rdParty/FreeRTOS/tasks.c **** 				not a problem. */
 699:../3rdParty/FreeRTOS/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 5046              		.loc 1 699 0
 5047 02c4 0D4B     		ldr	r3, .L31
 5048 02c6 1A68     		ldr	r2, [r3, #0]
 5049 02c8 7B68     		ldr	r3, [r7, #4]
 5050 02ca D318     		adds	r3, r2, r3
 5051 02cc BB60     		str	r3, [r7, #8]
 700:../3rdParty/FreeRTOS/tasks.c **** 
 701:../3rdParty/FreeRTOS/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 702:../3rdParty/FreeRTOS/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 703:../3rdParty/FreeRTOS/tasks.c **** 				both lists. */
 704:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 5052              		.loc 1 704 0
 5053 02ce 0C4B     		ldr	r3, .L31+4
 5054 02d0 1B68     		ldr	r3, [r3, #0]
 5055 02d2 03F10403 		add	r3, r3, #4
 5056 02d6 1846     		mov	r0, r3
 5057 02d8 FFF7FEFF 		bl	vListRemove
 705:../3rdParty/FreeRTOS/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 5058              		.loc 1 705 0
 5059 02dc B868     		ldr	r0, [r7, #8]
 5060 02de 00F021FF 		bl	prvAddCurrentTaskToDelayedList
 706:../3rdParty/FreeRTOS/tasks.c **** 			}
 707:../3rdParty/FreeRTOS/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 5061              		.loc 1 707 0
 5062 02e2 FFF7FEFF 		bl	xTaskResumeAll
 5063 02e6 F860     		str	r0, [r7, #12]
 5064              	.L29:
 708:../3rdParty/FreeRTOS/tasks.c **** 		}
 709:../3rdParty/FreeRTOS/tasks.c **** 
 710:../3rdParty/FreeRTOS/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 711:../3rdParty/FreeRTOS/tasks.c **** 		have put ourselves to sleep. */
 712:../3rdParty/FreeRTOS/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 5065              		.loc 1 712 0
 5066 02e8 FB68     		ldr	r3, [r7, #12]
 5067 02ea 002B     		cmp	r3, #0
 5068 02ec 01D1     		bne	.L28
 713:../3rdParty/FreeRTOS/tasks.c **** 		{
 714:../3rdParty/FreeRTOS/tasks.c **** 			portYIELD_WITHIN_API();
 5069              		.loc 1 714 0
 5070 02ee FFF7FEFF 		bl	vPortYieldFromISR
 5071              	.L28:
 715:../3rdParty/FreeRTOS/tasks.c **** 		}
 716:../3rdParty/FreeRTOS/tasks.c **** 	}
 5072              		.loc 1 716 0
 5073 02f2 07F11007 		add	r7, r7, #16
 5074 02f6 BD46     		mov	sp, r7
 5075 02f8 80BD     		pop	{r7, pc}
 5076              	.L32:
 5077 02fa 00BF     		.align	2
 5078              	.L31:
 5079 02fc DC000000 		.word	xTickCount
 5080 0300 00000000 		.word	pxCurrentTCB
 5081              		.cfi_endproc
 5082              	.LFE58:
 5084              		.align	2
 5085              		.global	uxTaskPriorityGet
 5086              		.thumb
 5087              		.thumb_func
 5089              	uxTaskPriorityGet:
 5090              	.LFB59:
 717:../3rdParty/FreeRTOS/tasks.c **** 
 718:../3rdParty/FreeRTOS/tasks.c **** #endif
 719:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 720:../3rdParty/FreeRTOS/tasks.c **** 
 721:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 722:../3rdParty/FreeRTOS/tasks.c **** 
 723:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 724:../3rdParty/FreeRTOS/tasks.c **** 	{
 5091              		.loc 1 724 0
 5092              		.cfi_startproc
 5093              		@ args = 0, pretend = 0, frame = 16
 5094              		@ frame_needed = 1, uses_anonymous_args = 0
 5095 0304 80B5     		push	{r7, lr}
 5096              	.LCFI12:
 5097              		.cfi_def_cfa_offset 8
 5098 0306 84B0     		sub	sp, sp, #16
 5099              	.LCFI13:
 5100              		.cfi_def_cfa_offset 24
 5101 0308 00AF     		add	r7, sp, #0
 5102              		.cfi_offset 14, -4
 5103              		.cfi_offset 7, -8
 5104              	.LCFI14:
 5105              		.cfi_def_cfa_register 7
 5106 030a 7860     		str	r0, [r7, #4]
 725:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 726:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 727:../3rdParty/FreeRTOS/tasks.c **** 
 728:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 5107              		.loc 1 728 0
 5108 030c FFF7FEFF 		bl	vPortEnterCritical
 729:../3rdParty/FreeRTOS/tasks.c **** 		{
 730:../3rdParty/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are changing the
 731:../3rdParty/FreeRTOS/tasks.c **** 			priority of the calling function. */
 732:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 5109              		.loc 1 732 0
 5110 0310 7B68     		ldr	r3, [r7, #4]
 5111 0312 002B     		cmp	r3, #0
 5112 0314 02D1     		bne	.L34
 5113              		.loc 1 732 0 is_stmt 0 discriminator 1
 5114 0316 084B     		ldr	r3, .L36
 5115 0318 1B68     		ldr	r3, [r3, #0]
 5116 031a 00E0     		b	.L35
 5117              	.L34:
 5118              		.loc 1 732 0 discriminator 2
 5119 031c 7B68     		ldr	r3, [r7, #4]
 5120              	.L35:
 5121              		.loc 1 732 0 discriminator 3
 5122 031e FB60     		str	r3, [r7, #12]
 733:../3rdParty/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 5123              		.loc 1 733 0 is_stmt 1 discriminator 3
 5124 0320 FB68     		ldr	r3, [r7, #12]
 5125 0322 DB6A     		ldr	r3, [r3, #44]
 5126 0324 BB60     		str	r3, [r7, #8]
 734:../3rdParty/FreeRTOS/tasks.c **** 		}
 735:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 5127              		.loc 1 735 0 discriminator 3
 5128 0326 FFF7FEFF 		bl	vPortExitCritical
 736:../3rdParty/FreeRTOS/tasks.c **** 
 737:../3rdParty/FreeRTOS/tasks.c **** 		return uxReturn;
 5129              		.loc 1 737 0 discriminator 3
 5130 032a BB68     		ldr	r3, [r7, #8]
 738:../3rdParty/FreeRTOS/tasks.c **** 	}
 5131              		.loc 1 738 0 discriminator 3
 5132 032c 1846     		mov	r0, r3
 5133 032e 07F11007 		add	r7, r7, #16
 5134 0332 BD46     		mov	sp, r7
 5135 0334 80BD     		pop	{r7, pc}
 5136              	.L37:
 5137 0336 00BF     		.align	2
 5138              	.L36:
 5139 0338 00000000 		.word	pxCurrentTCB
 5140              		.cfi_endproc
 5141              	.LFE59:
 5143              		.align	2
 5144              		.global	vTaskPrioritySet
 5145              		.thumb
 5146              		.thumb_func
 5148              	vTaskPrioritySet:
 5149              	.LFB60:
 739:../3rdParty/FreeRTOS/tasks.c **** 
 740:../3rdParty/FreeRTOS/tasks.c **** #endif
 741:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 742:../3rdParty/FreeRTOS/tasks.c **** 
 743:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 744:../3rdParty/FreeRTOS/tasks.c **** 
 745:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 746:../3rdParty/FreeRTOS/tasks.c **** 	{
 5150              		.loc 1 746 0
 5151              		.cfi_startproc
 5152              		@ args = 0, pretend = 0, frame = 24
 5153              		@ frame_needed = 1, uses_anonymous_args = 0
 5154 033c 80B5     		push	{r7, lr}
 5155              	.LCFI15:
 5156              		.cfi_def_cfa_offset 8
 5157 033e 86B0     		sub	sp, sp, #24
 5158              	.LCFI16:
 5159              		.cfi_def_cfa_offset 32
 5160 0340 00AF     		add	r7, sp, #0
 5161              		.cfi_offset 14, -4
 5162              		.cfi_offset 7, -8
 5163              	.LCFI17:
 5164              		.cfi_def_cfa_register 7
 5165 0342 7860     		str	r0, [r7, #4]
 5166 0344 3960     		str	r1, [r7, #0]
 747:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 748:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority;
 749:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 5167              		.loc 1 749 0
 5168 0346 4FF00003 		mov	r3, #0
 5169 034a 7B61     		str	r3, [r7, #20]
 750:../3rdParty/FreeRTOS/tasks.c **** 
 751:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 752:../3rdParty/FreeRTOS/tasks.c **** 
 753:../3rdParty/FreeRTOS/tasks.c **** 		/* Ensure the new priority is valid. */
 754:../3rdParty/FreeRTOS/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 5170              		.loc 1 754 0
 5171 034c 3B68     		ldr	r3, [r7, #0]
 5172 034e 042B     		cmp	r3, #4
 5173 0350 02D9     		bls	.L39
 755:../3rdParty/FreeRTOS/tasks.c **** 		{
 756:../3rdParty/FreeRTOS/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 5174              		.loc 1 756 0
 5175 0352 4FF00403 		mov	r3, #4
 5176 0356 3B60     		str	r3, [r7, #0]
 5177              	.L39:
 757:../3rdParty/FreeRTOS/tasks.c **** 		}
 758:../3rdParty/FreeRTOS/tasks.c **** 
 759:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 5178              		.loc 1 759 0
 5179 0358 FFF7FEFF 		bl	vPortEnterCritical
 760:../3rdParty/FreeRTOS/tasks.c **** 		{
 761:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTask == pxCurrentTCB )
 5180              		.loc 1 761 0
 5181 035c 394B     		ldr	r3, .L49
 5182 035e 1B68     		ldr	r3, [r3, #0]
 5183 0360 7A68     		ldr	r2, [r7, #4]
 5184 0362 9A42     		cmp	r2, r3
 5185 0364 02D1     		bne	.L40
 762:../3rdParty/FreeRTOS/tasks.c **** 			{
 763:../3rdParty/FreeRTOS/tasks.c **** 				pxTask = NULL;
 5186              		.loc 1 763 0
 5187 0366 4FF00003 		mov	r3, #0
 5188 036a 7B60     		str	r3, [r7, #4]
 5189              	.L40:
 764:../3rdParty/FreeRTOS/tasks.c **** 			}
 765:../3rdParty/FreeRTOS/tasks.c **** 
 766:../3rdParty/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are changing the
 767:../3rdParty/FreeRTOS/tasks.c **** 			priority of the calling function. */
 768:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 5190              		.loc 1 768 0
 5191 036c 7B68     		ldr	r3, [r7, #4]
 5192 036e 002B     		cmp	r3, #0
 5193 0370 02D1     		bne	.L41
 5194              		.loc 1 768 0 is_stmt 0 discriminator 1
 5195 0372 344B     		ldr	r3, .L49
 5196 0374 1B68     		ldr	r3, [r3, #0]
 5197 0376 00E0     		b	.L42
 5198              	.L41:
 5199              		.loc 1 768 0 discriminator 2
 5200 0378 7B68     		ldr	r3, [r7, #4]
 5201              	.L42:
 5202              		.loc 1 768 0 discriminator 3
 5203 037a 3B61     		str	r3, [r7, #16]
 769:../3rdParty/FreeRTOS/tasks.c **** 
 770:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
 771:../3rdParty/FreeRTOS/tasks.c **** 
 772:../3rdParty/FreeRTOS/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 773:../3rdParty/FreeRTOS/tasks.c **** 			{
 774:../3rdParty/FreeRTOS/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 5204              		.loc 1 774 0 is_stmt 1 discriminator 3
 5205 037c 3B69     		ldr	r3, [r7, #16]
 5206 037e 9B6C     		ldr	r3, [r3, #72]
 5207 0380 FB60     		str	r3, [r7, #12]
 775:../3rdParty/FreeRTOS/tasks.c **** 			}
 776:../3rdParty/FreeRTOS/tasks.c **** 			#else
 777:../3rdParty/FreeRTOS/tasks.c **** 			{
 778:../3rdParty/FreeRTOS/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 779:../3rdParty/FreeRTOS/tasks.c **** 			}
 780:../3rdParty/FreeRTOS/tasks.c **** 			#endif
 781:../3rdParty/FreeRTOS/tasks.c **** 
 782:../3rdParty/FreeRTOS/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 5208              		.loc 1 782 0 discriminator 3
 5209 0382 FA68     		ldr	r2, [r7, #12]
 5210 0384 3B68     		ldr	r3, [r7, #0]
 5211 0386 9A42     		cmp	r2, r3
 5212 0388 56D0     		beq	.L43
 783:../3rdParty/FreeRTOS/tasks.c **** 			{
 784:../3rdParty/FreeRTOS/tasks.c **** 				/* The priority change may have readied a task of higher
 785:../3rdParty/FreeRTOS/tasks.c **** 				priority than the calling task. */
 786:../3rdParty/FreeRTOS/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 5213              		.loc 1 786 0
 5214 038a 3A68     		ldr	r2, [r7, #0]
 5215 038c FB68     		ldr	r3, [r7, #12]
 5216 038e 9A42     		cmp	r2, r3
 5217 0390 06D9     		bls	.L44
 787:../3rdParty/FreeRTOS/tasks.c **** 				{
 788:../3rdParty/FreeRTOS/tasks.c **** 					if( pxTask != NULL )
 5218              		.loc 1 788 0
 5219 0392 7B68     		ldr	r3, [r7, #4]
 5220 0394 002B     		cmp	r3, #0
 5221 0396 09D0     		beq	.L45
 789:../3rdParty/FreeRTOS/tasks.c **** 					{
 790:../3rdParty/FreeRTOS/tasks.c **** 						/* The priority of another task is being raised.  If we
 791:../3rdParty/FreeRTOS/tasks.c **** 						were raising the priority of the currently running task
 792:../3rdParty/FreeRTOS/tasks.c **** 						there would be no need to switch as it must have already
 793:../3rdParty/FreeRTOS/tasks.c **** 						been the highest priority task. */
 794:../3rdParty/FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 5222              		.loc 1 794 0
 5223 0398 4FF00103 		mov	r3, #1
 5224 039c 7B61     		str	r3, [r7, #20]
 5225 039e 05E0     		b	.L45
 5226              	.L44:
 795:../3rdParty/FreeRTOS/tasks.c **** 					}
 796:../3rdParty/FreeRTOS/tasks.c **** 				}
 797:../3rdParty/FreeRTOS/tasks.c **** 				else if( pxTask == NULL )
 5227              		.loc 1 797 0
 5228 03a0 7B68     		ldr	r3, [r7, #4]
 5229 03a2 002B     		cmp	r3, #0
 5230 03a4 02D1     		bne	.L45
 798:../3rdParty/FreeRTOS/tasks.c **** 				{
 799:../3rdParty/FreeRTOS/tasks.c **** 					/* Setting our own priority down means there may now be another
 800:../3rdParty/FreeRTOS/tasks.c **** 					task of higher priority that is ready to execute. */
 801:../3rdParty/FreeRTOS/tasks.c **** 					xYieldRequired = pdTRUE;
 5231              		.loc 1 801 0
 5232 03a6 4FF00103 		mov	r3, #1
 5233 03aa 7B61     		str	r3, [r7, #20]
 5234              	.L45:
 802:../3rdParty/FreeRTOS/tasks.c **** 				}
 803:../3rdParty/FreeRTOS/tasks.c **** 
 804:../3rdParty/FreeRTOS/tasks.c **** 
 805:../3rdParty/FreeRTOS/tasks.c **** 
 806:../3rdParty/FreeRTOS/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 807:../3rdParty/FreeRTOS/tasks.c **** 				{
 808:../3rdParty/FreeRTOS/tasks.c **** 					/* Only change the priority being used if the task is not
 809:../3rdParty/FreeRTOS/tasks.c **** 					currently using an inherited priority. */
 810:../3rdParty/FreeRTOS/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 5235              		.loc 1 810 0
 5236 03ac 3B69     		ldr	r3, [r7, #16]
 5237 03ae 9A6C     		ldr	r2, [r3, #72]
 5238 03b0 3B69     		ldr	r3, [r7, #16]
 5239 03b2 DB6A     		ldr	r3, [r3, #44]
 5240 03b4 9A42     		cmp	r2, r3
 5241 03b6 02D1     		bne	.L46
 811:../3rdParty/FreeRTOS/tasks.c **** 					{
 812:../3rdParty/FreeRTOS/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 5242              		.loc 1 812 0
 5243 03b8 3B69     		ldr	r3, [r7, #16]
 5244 03ba 3A68     		ldr	r2, [r7, #0]
 5245 03bc DA62     		str	r2, [r3, #44]
 5246              	.L46:
 813:../3rdParty/FreeRTOS/tasks.c **** 					}
 814:../3rdParty/FreeRTOS/tasks.c **** 
 815:../3rdParty/FreeRTOS/tasks.c **** 					/* The base priority gets set whatever. */
 816:../3rdParty/FreeRTOS/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 5247              		.loc 1 816 0
 5248 03be 3B69     		ldr	r3, [r7, #16]
 5249 03c0 3A68     		ldr	r2, [r7, #0]
 5250 03c2 9A64     		str	r2, [r3, #72]
 817:../3rdParty/FreeRTOS/tasks.c **** 				}
 818:../3rdParty/FreeRTOS/tasks.c **** 				#else
 819:../3rdParty/FreeRTOS/tasks.c **** 				{
 820:../3rdParty/FreeRTOS/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 821:../3rdParty/FreeRTOS/tasks.c **** 				}
 822:../3rdParty/FreeRTOS/tasks.c **** 				#endif
 823:../3rdParty/FreeRTOS/tasks.c **** 
 824:../3rdParty/FreeRTOS/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 5251              		.loc 1 824 0
 5252 03c4 3B68     		ldr	r3, [r7, #0]
 5253 03c6 C3F10502 		rsb	r2, r3, #5
 5254 03ca 3B69     		ldr	r3, [r7, #16]
 5255 03cc 9A61     		str	r2, [r3, #24]
 825:../3rdParty/FreeRTOS/tasks.c **** 
 826:../3rdParty/FreeRTOS/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 827:../3rdParty/FreeRTOS/tasks.c **** 				nothing more than change it's priority variable. However, if
 828:../3rdParty/FreeRTOS/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 829:../3rdParty/FreeRTOS/tasks.c **** 				in the queue appropriate to its new priority. */
 830:../3rdParty/FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 5256              		.loc 1 830 0
 5257 03ce 3B69     		ldr	r3, [r7, #16]
 5258 03d0 5969     		ldr	r1, [r3, #20]
 5259 03d2 FA68     		ldr	r2, [r7, #12]
 5260 03d4 1346     		mov	r3, r2
 5261 03d6 4FEA8303 		lsl	r3, r3, #2
 5262 03da 9B18     		adds	r3, r3, r2
 5263 03dc 4FEA8303 		lsl	r3, r3, #2
 5264 03e0 1A46     		mov	r2, r3
 5265 03e2 194B     		ldr	r3, .L49+4
 5266 03e4 D318     		adds	r3, r2, r3
 5267 03e6 9942     		cmp	r1, r3
 5268 03e8 21D1     		bne	.L47
 831:../3rdParty/FreeRTOS/tasks.c **** 				{
 832:../3rdParty/FreeRTOS/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 833:../3rdParty/FreeRTOS/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 834:../3rdParty/FreeRTOS/tasks.c **** 					can do this even if the scheduler is suspended. */
 835:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 5269              		.loc 1 835 0
 5270 03ea 3B69     		ldr	r3, [r7, #16]
 5271 03ec 03F10403 		add	r3, r3, #4
 5272 03f0 1846     		mov	r0, r3
 5273 03f2 FFF7FEFF 		bl	vListRemove
 836:../3rdParty/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 5274              		.loc 1 836 0
 5275 03f6 3B69     		ldr	r3, [r7, #16]
 5276 03f8 DA6A     		ldr	r2, [r3, #44]
 5277 03fa 144B     		ldr	r3, .L49+8
 5278 03fc 1B68     		ldr	r3, [r3, #0]
 5279 03fe 9A42     		cmp	r2, r3
 5280 0400 03D9     		bls	.L48
 5281              		.loc 1 836 0 is_stmt 0 discriminator 1
 5282 0402 3B69     		ldr	r3, [r7, #16]
 5283 0404 DA6A     		ldr	r2, [r3, #44]
 5284 0406 114B     		ldr	r3, .L49+8
 5285 0408 1A60     		str	r2, [r3, #0]
 5286              	.L48:
 5287              		.loc 1 836 0 discriminator 2
 5288 040a 3B69     		ldr	r3, [r7, #16]
 5289 040c DA6A     		ldr	r2, [r3, #44]
 5290 040e 1346     		mov	r3, r2
 5291 0410 4FEA8303 		lsl	r3, r3, #2
 5292 0414 9B18     		adds	r3, r3, r2
 5293 0416 4FEA8303 		lsl	r3, r3, #2
 5294 041a 1A46     		mov	r2, r3
 5295 041c 0A4B     		ldr	r3, .L49+4
 5296 041e D218     		adds	r2, r2, r3
 5297 0420 3B69     		ldr	r3, [r7, #16]
 5298 0422 03F10403 		add	r3, r3, #4
 5299 0426 1046     		mov	r0, r2
 5300 0428 1946     		mov	r1, r3
 5301 042a FFF7FEFF 		bl	vListInsertEnd
 5302              	.L47:
 837:../3rdParty/FreeRTOS/tasks.c **** 				}
 838:../3rdParty/FreeRTOS/tasks.c **** 
 839:../3rdParty/FreeRTOS/tasks.c **** 				if( xYieldRequired == pdTRUE )
 5303              		.loc 1 839 0 is_stmt 1
 5304 042e 7B69     		ldr	r3, [r7, #20]
 5305 0430 012B     		cmp	r3, #1
 5306 0432 01D1     		bne	.L43
 840:../3rdParty/FreeRTOS/tasks.c **** 				{
 841:../3rdParty/FreeRTOS/tasks.c **** 					portYIELD_WITHIN_API();
 5307              		.loc 1 841 0
 5308 0434 FFF7FEFF 		bl	vPortYieldFromISR
 5309              	.L43:
 842:../3rdParty/FreeRTOS/tasks.c **** 				}
 843:../3rdParty/FreeRTOS/tasks.c **** 			}
 844:../3rdParty/FreeRTOS/tasks.c **** 		}
 845:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 5310              		.loc 1 845 0
 5311 0438 FFF7FEFF 		bl	vPortExitCritical
 846:../3rdParty/FreeRTOS/tasks.c **** 	}
 5312              		.loc 1 846 0
 5313 043c 07F11807 		add	r7, r7, #24
 5314 0440 BD46     		mov	sp, r7
 5315 0442 80BD     		pop	{r7, pc}
 5316              	.L50:
 5317              		.align	2
 5318              	.L49:
 5319 0444 00000000 		.word	pxCurrentTCB
 5320 0448 04000000 		.word	pxReadyTasksLists
 5321 044c E4000000 		.word	uxTopReadyPriority
 5322              		.cfi_endproc
 5323              	.LFE60:
 5325              		.align	2
 5326              		.global	vTaskSuspend
 5327              		.thumb
 5328              		.thumb_func
 5330              	vTaskSuspend:
 5331              	.LFB61:
 847:../3rdParty/FreeRTOS/tasks.c **** 
 848:../3rdParty/FreeRTOS/tasks.c **** #endif
 849:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 850:../3rdParty/FreeRTOS/tasks.c **** 
 851:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 852:../3rdParty/FreeRTOS/tasks.c **** 
 853:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 854:../3rdParty/FreeRTOS/tasks.c **** 	{
 5332              		.loc 1 854 0
 5333              		.cfi_startproc
 5334              		@ args = 0, pretend = 0, frame = 16
 5335              		@ frame_needed = 1, uses_anonymous_args = 0
 5336 0450 80B5     		push	{r7, lr}
 5337              	.LCFI18:
 5338              		.cfi_def_cfa_offset 8
 5339 0452 84B0     		sub	sp, sp, #16
 5340              	.LCFI19:
 5341              		.cfi_def_cfa_offset 24
 5342 0454 00AF     		add	r7, sp, #0
 5343              		.cfi_offset 14, -4
 5344              		.cfi_offset 7, -8
 5345              	.LCFI20:
 5346              		.cfi_def_cfa_register 7
 5347 0456 7860     		str	r0, [r7, #4]
 855:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 856:../3rdParty/FreeRTOS/tasks.c **** 
 857:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
 5348              		.loc 1 857 0
 5349 0458 FFF7FEFF 		bl	vPortEnterCritical
 858:../3rdParty/FreeRTOS/tasks.c **** 		{
 859:../3rdParty/FreeRTOS/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 860:../3rdParty/FreeRTOS/tasks.c **** 			suspended. */
 861:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 5350              		.loc 1 861 0
 5351 045c 214B     		ldr	r3, .L59
 5352 045e 1B68     		ldr	r3, [r3, #0]
 5353 0460 7A68     		ldr	r2, [r7, #4]
 5354 0462 9A42     		cmp	r2, r3
 5355 0464 02D1     		bne	.L52
 862:../3rdParty/FreeRTOS/tasks.c **** 			{
 863:../3rdParty/FreeRTOS/tasks.c **** 				pxTaskToSuspend = NULL;
 5356              		.loc 1 863 0
 5357 0466 4FF00003 		mov	r3, #0
 5358 046a 7B60     		str	r3, [r7, #4]
 5359              	.L52:
 864:../3rdParty/FreeRTOS/tasks.c **** 			}
 865:../3rdParty/FreeRTOS/tasks.c **** 
 866:../3rdParty/FreeRTOS/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 867:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 5360              		.loc 1 867 0
 5361 046c 7B68     		ldr	r3, [r7, #4]
 5362 046e 002B     		cmp	r3, #0
 5363 0470 02D1     		bne	.L53
 5364              		.loc 1 867 0 is_stmt 0 discriminator 1
 5365 0472 1C4B     		ldr	r3, .L59
 5366 0474 1B68     		ldr	r3, [r3, #0]
 5367 0476 00E0     		b	.L54
 5368              	.L53:
 5369              		.loc 1 867 0 discriminator 2
 5370 0478 7B68     		ldr	r3, [r7, #4]
 5371              	.L54:
 5372              		.loc 1 867 0 discriminator 3
 5373 047a FB60     		str	r3, [r7, #12]
 868:../3rdParty/FreeRTOS/tasks.c **** 
 869:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 870:../3rdParty/FreeRTOS/tasks.c **** 
 871:../3rdParty/FreeRTOS/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 872:../3rdParty/FreeRTOS/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 5374              		.loc 1 872 0 is_stmt 1 discriminator 3
 5375 047c FB68     		ldr	r3, [r7, #12]
 5376 047e 03F10403 		add	r3, r3, #4
 5377 0482 1846     		mov	r0, r3
 5378 0484 FFF7FEFF 		bl	vListRemove
 873:../3rdParty/FreeRTOS/tasks.c **** 
 874:../3rdParty/FreeRTOS/tasks.c **** 			/* Is the task waiting on an event also? */
 875:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 5379              		.loc 1 875 0 discriminator 3
 5380 0488 FB68     		ldr	r3, [r7, #12]
 5381 048a 9B6A     		ldr	r3, [r3, #40]
 5382 048c 002B     		cmp	r3, #0
 5383 048e 05D0     		beq	.L55
 876:../3rdParty/FreeRTOS/tasks.c **** 			{
 877:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 5384              		.loc 1 877 0
 5385 0490 FB68     		ldr	r3, [r7, #12]
 5386 0492 03F11803 		add	r3, r3, #24
 5387 0496 1846     		mov	r0, r3
 5388 0498 FFF7FEFF 		bl	vListRemove
 5389              	.L55:
 878:../3rdParty/FreeRTOS/tasks.c **** 			}
 879:../3rdParty/FreeRTOS/tasks.c **** 
 880:../3rdParty/FreeRTOS/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 5390              		.loc 1 880 0
 5391 049c FB68     		ldr	r3, [r7, #12]
 5392 049e 03F10403 		add	r3, r3, #4
 5393 04a2 1148     		ldr	r0, .L59+4
 5394 04a4 1946     		mov	r1, r3
 5395 04a6 FFF7FEFF 		bl	vListInsertEnd
 881:../3rdParty/FreeRTOS/tasks.c **** 		}
 882:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
 5396              		.loc 1 882 0
 5397 04aa FFF7FEFF 		bl	vPortExitCritical
 883:../3rdParty/FreeRTOS/tasks.c **** 
 884:../3rdParty/FreeRTOS/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 5398              		.loc 1 884 0
 5399 04ae 7B68     		ldr	r3, [r7, #4]
 5400 04b0 002B     		cmp	r3, #0
 5401 04b2 13D1     		bne	.L51
 885:../3rdParty/FreeRTOS/tasks.c **** 		{
 886:../3rdParty/FreeRTOS/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 5402              		.loc 1 886 0
 5403 04b4 0D4B     		ldr	r3, .L59+8
 5404 04b6 1B68     		ldr	r3, [r3, #0]
 5405 04b8 002B     		cmp	r3, #0
 5406 04ba 02D0     		beq	.L57
 887:../3rdParty/FreeRTOS/tasks.c **** 			{
 888:../3rdParty/FreeRTOS/tasks.c **** 				/* We have just suspended the current task. */
 889:../3rdParty/FreeRTOS/tasks.c **** 				portYIELD_WITHIN_API();
 5407              		.loc 1 889 0
 5408 04bc FFF7FEFF 		bl	vPortYieldFromISR
 5409 04c0 0CE0     		b	.L51
 5410              	.L57:
 890:../3rdParty/FreeRTOS/tasks.c **** 			}
 891:../3rdParty/FreeRTOS/tasks.c **** 			else
 892:../3rdParty/FreeRTOS/tasks.c **** 			{
 893:../3rdParty/FreeRTOS/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 894:../3rdParty/FreeRTOS/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 895:../3rdParty/FreeRTOS/tasks.c **** 				must be adjusted to point to a different task. */
 896:../3rdParty/FreeRTOS/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 5411              		.loc 1 896 0
 5412 04c2 094B     		ldr	r3, .L59+4
 5413 04c4 1A68     		ldr	r2, [r3, #0]
 5414 04c6 0A4B     		ldr	r3, .L59+12
 5415 04c8 1B68     		ldr	r3, [r3, #0]
 5416 04ca 9A42     		cmp	r2, r3
 5417 04cc 04D1     		bne	.L58
 897:../3rdParty/FreeRTOS/tasks.c **** 				{
 898:../3rdParty/FreeRTOS/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
 899:../3rdParty/FreeRTOS/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 900:../3rdParty/FreeRTOS/tasks.c **** 					be set to point to it no matter what its relative priority
 901:../3rdParty/FreeRTOS/tasks.c **** 					is. */
 902:../3rdParty/FreeRTOS/tasks.c **** 					pxCurrentTCB = NULL;
 5418              		.loc 1 902 0
 5419 04ce 054B     		ldr	r3, .L59
 5420 04d0 4FF00002 		mov	r2, #0
 5421 04d4 1A60     		str	r2, [r3, #0]
 5422 04d6 01E0     		b	.L51
 5423              	.L58:
 903:../3rdParty/FreeRTOS/tasks.c **** 				}
 904:../3rdParty/FreeRTOS/tasks.c **** 				else
 905:../3rdParty/FreeRTOS/tasks.c **** 				{
 906:../3rdParty/FreeRTOS/tasks.c **** 					vTaskSwitchContext();
 5424              		.loc 1 906 0
 5425 04d8 FFF7FEFF 		bl	vTaskSwitchContext
 5426              	.L51:
 907:../3rdParty/FreeRTOS/tasks.c **** 				}
 908:../3rdParty/FreeRTOS/tasks.c **** 			}
 909:../3rdParty/FreeRTOS/tasks.c **** 		}
 910:../3rdParty/FreeRTOS/tasks.c **** 	}
 5427              		.loc 1 910 0
 5428 04dc 07F11007 		add	r7, r7, #16
 5429 04e0 BD46     		mov	sp, r7
 5430 04e2 80BD     		pop	{r7, pc}
 5431              	.L60:
 5432              		.align	2
 5433              	.L59:
 5434 04e4 00000000 		.word	pxCurrentTCB
 5435 04e8 C4000000 		.word	xSuspendedTaskList
 5436 04ec E8000000 		.word	xSchedulerRunning
 5437 04f0 D8000000 		.word	uxCurrentNumberOfTasks
 5438              		.cfi_endproc
 5439              	.LFE61:
 5441              		.align	2
 5442              		.global	xTaskIsTaskSuspended
 5443              		.thumb
 5444              		.thumb_func
 5446              	xTaskIsTaskSuspended:
 5447              	.LFB62:
 911:../3rdParty/FreeRTOS/tasks.c **** 
 912:../3rdParty/FreeRTOS/tasks.c **** #endif
 913:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 914:../3rdParty/FreeRTOS/tasks.c **** 
 915:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 916:../3rdParty/FreeRTOS/tasks.c **** 
 917:../3rdParty/FreeRTOS/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 918:../3rdParty/FreeRTOS/tasks.c **** 	{
 5448              		.loc 1 918 0
 5449              		.cfi_startproc
 5450              		@ args = 0, pretend = 0, frame = 16
 5451              		@ frame_needed = 1, uses_anonymous_args = 0
 5452              		@ link register save eliminated.
 5453 04f4 80B4     		push	{r7}
 5454              	.LCFI21:
 5455              		.cfi_def_cfa_offset 4
 5456 04f6 85B0     		sub	sp, sp, #20
 5457              	.LCFI22:
 5458              		.cfi_def_cfa_offset 24
 5459 04f8 00AF     		add	r7, sp, #0
 5460              		.cfi_offset 7, -4
 5461              	.LCFI23:
 5462              		.cfi_def_cfa_register 7
 5463 04fa 7860     		str	r0, [r7, #4]
 919:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 5464              		.loc 1 919 0
 5465 04fc 4FF00003 		mov	r3, #0
 5466 0500 FB60     		str	r3, [r7, #12]
 920:../3rdParty/FreeRTOS/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 5467              		.loc 1 920 0
 5468 0502 7B68     		ldr	r3, [r7, #4]
 5469 0504 BB60     		str	r3, [r7, #8]
 921:../3rdParty/FreeRTOS/tasks.c **** 
 922:../3rdParty/FreeRTOS/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
 923:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( xTask );
 924:../3rdParty/FreeRTOS/tasks.c **** 
 925:../3rdParty/FreeRTOS/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 926:../3rdParty/FreeRTOS/tasks.c **** 		suspended list? */
 927:../3rdParty/FreeRTOS/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 5470              		.loc 1 927 0
 5471 0506 BB68     		ldr	r3, [r7, #8]
 5472 0508 5A69     		ldr	r2, [r3, #20]
 5473 050a 0B4B     		ldr	r3, .L63
 5474 050c 9A42     		cmp	r2, r3
 5475 050e 0BD1     		bne	.L62
 928:../3rdParty/FreeRTOS/tasks.c **** 		{
 929:../3rdParty/FreeRTOS/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 930:../3rdParty/FreeRTOS/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 5476              		.loc 1 930 0
 5477 0510 BB68     		ldr	r3, [r7, #8]
 5478 0512 9A6A     		ldr	r2, [r3, #40]
 5479 0514 094B     		ldr	r3, .L63+4
 5480 0516 9A42     		cmp	r2, r3
 5481 0518 06D0     		beq	.L62
 931:../3rdParty/FreeRTOS/tasks.c **** 			{
 932:../3rdParty/FreeRTOS/tasks.c **** 				/* Is it in the suspended list because it is in the
 933:../3rdParty/FreeRTOS/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 934:../3rdParty/FreeRTOS/tasks.c **** 				list because it is blocked on a task with no timeout
 935:../3rdParty/FreeRTOS/tasks.c **** 				specified. */
 936:../3rdParty/FreeRTOS/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 5482              		.loc 1 936 0
 5483 051a BB68     		ldr	r3, [r7, #8]
 5484 051c 9B6A     		ldr	r3, [r3, #40]
 5485 051e 002B     		cmp	r3, #0
 5486 0520 02D1     		bne	.L62
 937:../3rdParty/FreeRTOS/tasks.c **** 				{
 938:../3rdParty/FreeRTOS/tasks.c **** 					xReturn = pdTRUE;
 5487              		.loc 1 938 0
 5488 0522 4FF00103 		mov	r3, #1
 5489 0526 FB60     		str	r3, [r7, #12]
 5490              	.L62:
 939:../3rdParty/FreeRTOS/tasks.c **** 				}
 940:../3rdParty/FreeRTOS/tasks.c **** 			}
 941:../3rdParty/FreeRTOS/tasks.c **** 		}
 942:../3rdParty/FreeRTOS/tasks.c **** 
 943:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
 5491              		.loc 1 943 0
 5492 0528 FB68     		ldr	r3, [r7, #12]
 944:../3rdParty/FreeRTOS/tasks.c **** 	}
 5493              		.loc 1 944 0
 5494 052a 1846     		mov	r0, r3
 5495 052c 07F11407 		add	r7, r7, #20
 5496 0530 BD46     		mov	sp, r7
 5497 0532 80BC     		pop	{r7}
 5498 0534 7047     		bx	lr
 5499              	.L64:
 5500 0536 00BF     		.align	2
 5501              	.L63:
 5502 0538 C4000000 		.word	xSuspendedTaskList
 5503 053c 98000000 		.word	xPendingReadyList
 5504              		.cfi_endproc
 5505              	.LFE62:
 5507              		.align	2
 5508              		.global	vTaskResume
 5509              		.thumb
 5510              		.thumb_func
 5512              	vTaskResume:
 5513              	.LFB63:
 945:../3rdParty/FreeRTOS/tasks.c **** 
 946:../3rdParty/FreeRTOS/tasks.c **** #endif
 947:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 948:../3rdParty/FreeRTOS/tasks.c **** 
 949:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 950:../3rdParty/FreeRTOS/tasks.c **** 
 951:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 952:../3rdParty/FreeRTOS/tasks.c **** 	{
 5514              		.loc 1 952 0
 5515              		.cfi_startproc
 5516              		@ args = 0, pretend = 0, frame = 16
 5517              		@ frame_needed = 1, uses_anonymous_args = 0
 5518 0540 80B5     		push	{r7, lr}
 5519              	.LCFI24:
 5520              		.cfi_def_cfa_offset 8
 5521 0542 84B0     		sub	sp, sp, #16
 5522              	.LCFI25:
 5523              		.cfi_def_cfa_offset 24
 5524 0544 00AF     		add	r7, sp, #0
 5525              		.cfi_offset 14, -4
 5526              		.cfi_offset 7, -8
 5527              	.LCFI26:
 5528              		.cfi_def_cfa_register 7
 5529 0546 7860     		str	r0, [r7, #4]
 953:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
 954:../3rdParty/FreeRTOS/tasks.c **** 
 955:../3rdParty/FreeRTOS/tasks.c **** 		/* It does not make sense to resume the calling task. */
 956:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxTaskToResume );
 957:../3rdParty/FreeRTOS/tasks.c **** 
 958:../3rdParty/FreeRTOS/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
 959:../3rdParty/FreeRTOS/tasks.c **** 		it in the ready list. */
 960:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 5530              		.loc 1 960 0
 5531 0548 7B68     		ldr	r3, [r7, #4]
 5532 054a FB60     		str	r3, [r7, #12]
 961:../3rdParty/FreeRTOS/tasks.c **** 
 962:../3rdParty/FreeRTOS/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
 963:../3rdParty/FreeRTOS/tasks.c **** 		currently executing task. */
 964:../3rdParty/FreeRTOS/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 5533              		.loc 1 964 0
 5534 054c FB68     		ldr	r3, [r7, #12]
 5535 054e 002B     		cmp	r3, #0
 5536 0550 39D0     		beq	.L65
 5537              		.loc 1 964 0 is_stmt 0 discriminator 1
 5538 0552 1F4B     		ldr	r3, .L69
 5539 0554 1B68     		ldr	r3, [r3, #0]
 5540 0556 FA68     		ldr	r2, [r7, #12]
 5541 0558 9A42     		cmp	r2, r3
 5542 055a 34D0     		beq	.L65
 965:../3rdParty/FreeRTOS/tasks.c **** 		{
 966:../3rdParty/FreeRTOS/tasks.c **** 			taskENTER_CRITICAL();
 5543              		.loc 1 966 0 is_stmt 1
 5544 055c FFF7FEFF 		bl	vPortEnterCritical
 967:../3rdParty/FreeRTOS/tasks.c **** 			{
 968:../3rdParty/FreeRTOS/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 5545              		.loc 1 968 0
 5546 0560 F868     		ldr	r0, [r7, #12]
 5547 0562 FFF7FEFF 		bl	xTaskIsTaskSuspended
 5548 0566 0346     		mov	r3, r0
 5549 0568 012B     		cmp	r3, #1
 5550 056a 2AD1     		bne	.L67
 969:../3rdParty/FreeRTOS/tasks.c **** 				{
 970:../3rdParty/FreeRTOS/tasks.c **** 					traceTASK_RESUME( pxTCB );
 971:../3rdParty/FreeRTOS/tasks.c **** 
 972:../3rdParty/FreeRTOS/tasks.c **** 					/* As we are in a critical section we can access the ready
 973:../3rdParty/FreeRTOS/tasks.c **** 					lists even if the scheduler is suspended. */
 974:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 5551              		.loc 1 974 0
 5552 056c FB68     		ldr	r3, [r7, #12]
 5553 056e 03F10403 		add	r3, r3, #4
 5554 0572 1846     		mov	r0, r3
 5555 0574 FFF7FEFF 		bl	vListRemove
 975:../3rdParty/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 5556              		.loc 1 975 0
 5557 0578 FB68     		ldr	r3, [r7, #12]
 5558 057a DA6A     		ldr	r2, [r3, #44]
 5559 057c 154B     		ldr	r3, .L69+4
 5560 057e 1B68     		ldr	r3, [r3, #0]
 5561 0580 9A42     		cmp	r2, r3
 5562 0582 03D9     		bls	.L68
 5563              		.loc 1 975 0 is_stmt 0 discriminator 1
 5564 0584 FB68     		ldr	r3, [r7, #12]
 5565 0586 DA6A     		ldr	r2, [r3, #44]
 5566 0588 124B     		ldr	r3, .L69+4
 5567 058a 1A60     		str	r2, [r3, #0]
 5568              	.L68:
 5569              		.loc 1 975 0 discriminator 2
 5570 058c FB68     		ldr	r3, [r7, #12]
 5571 058e DA6A     		ldr	r2, [r3, #44]
 5572 0590 1346     		mov	r3, r2
 5573 0592 4FEA8303 		lsl	r3, r3, #2
 5574 0596 9B18     		adds	r3, r3, r2
 5575 0598 4FEA8303 		lsl	r3, r3, #2
 5576 059c 1A46     		mov	r2, r3
 5577 059e 0E4B     		ldr	r3, .L69+8
 5578 05a0 D218     		adds	r2, r2, r3
 5579 05a2 FB68     		ldr	r3, [r7, #12]
 5580 05a4 03F10403 		add	r3, r3, #4
 5581 05a8 1046     		mov	r0, r2
 5582 05aa 1946     		mov	r1, r3
 5583 05ac FFF7FEFF 		bl	vListInsertEnd
 976:../3rdParty/FreeRTOS/tasks.c **** 
 977:../3rdParty/FreeRTOS/tasks.c **** 					/* We may have just resumed a higher priority task. */
 978:../3rdParty/FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 5584              		.loc 1 978 0 is_stmt 1 discriminator 2
 5585 05b0 FB68     		ldr	r3, [r7, #12]
 5586 05b2 DA6A     		ldr	r2, [r3, #44]
 5587 05b4 064B     		ldr	r3, .L69
 5588 05b6 1B68     		ldr	r3, [r3, #0]
 5589 05b8 DB6A     		ldr	r3, [r3, #44]
 5590 05ba 9A42     		cmp	r2, r3
 5591 05bc 01D3     		bcc	.L67
 979:../3rdParty/FreeRTOS/tasks.c **** 					{
 980:../3rdParty/FreeRTOS/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
 981:../3rdParty/FreeRTOS/tasks.c **** 						will leave the lists in the correct state for the next yield. */
 982:../3rdParty/FreeRTOS/tasks.c **** 						portYIELD_WITHIN_API();
 5592              		.loc 1 982 0
 5593 05be FFF7FEFF 		bl	vPortYieldFromISR
 5594              	.L67:
 983:../3rdParty/FreeRTOS/tasks.c **** 					}
 984:../3rdParty/FreeRTOS/tasks.c **** 				}
 985:../3rdParty/FreeRTOS/tasks.c **** 			}
 986:../3rdParty/FreeRTOS/tasks.c **** 			taskEXIT_CRITICAL();
 5595              		.loc 1 986 0
 5596 05c2 FFF7FEFF 		bl	vPortExitCritical
 5597              	.L65:
 987:../3rdParty/FreeRTOS/tasks.c **** 		}
 988:../3rdParty/FreeRTOS/tasks.c **** 	}
 5598              		.loc 1 988 0
 5599 05c6 07F11007 		add	r7, r7, #16
 5600 05ca BD46     		mov	sp, r7
 5601 05cc 80BD     		pop	{r7, pc}
 5602              	.L70:
 5603 05ce 00BF     		.align	2
 5604              	.L69:
 5605 05d0 00000000 		.word	pxCurrentTCB
 5606 05d4 E4000000 		.word	uxTopReadyPriority
 5607 05d8 04000000 		.word	pxReadyTasksLists
 5608              		.cfi_endproc
 5609              	.LFE63:
 5611              		.align	2
 5612              		.global	xTaskResumeFromISR
 5613              		.thumb
 5614              		.thumb_func
 5616              	xTaskResumeFromISR:
 5617              	.LFB64:
 989:../3rdParty/FreeRTOS/tasks.c **** 
 990:../3rdParty/FreeRTOS/tasks.c **** #endif
 991:../3rdParty/FreeRTOS/tasks.c **** 
 992:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
 993:../3rdParty/FreeRTOS/tasks.c **** 
 994:../3rdParty/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
 995:../3rdParty/FreeRTOS/tasks.c **** 
 996:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
 997:../3rdParty/FreeRTOS/tasks.c **** 	{
 5618              		.loc 1 997 0
 5619              		.cfi_startproc
 5620              		@ args = 0, pretend = 0, frame = 24
 5621              		@ frame_needed = 1, uses_anonymous_args = 0
 5622 05dc 80B5     		push	{r7, lr}
 5623              	.LCFI27:
 5624              		.cfi_def_cfa_offset 8
 5625 05de 86B0     		sub	sp, sp, #24
 5626              	.LCFI28:
 5627              		.cfi_def_cfa_offset 32
 5628 05e0 00AF     		add	r7, sp, #0
 5629              		.cfi_offset 14, -4
 5630              		.cfi_offset 7, -8
 5631              	.LCFI29:
 5632              		.cfi_def_cfa_register 7
 5633 05e2 7860     		str	r0, [r7, #4]
 998:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 5634              		.loc 1 998 0
 5635 05e4 4FF00003 		mov	r3, #0
 5636 05e8 7B61     		str	r3, [r7, #20]
 999:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1000:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxSavedInterruptStatus;
1001:../3rdParty/FreeRTOS/tasks.c **** 
1002:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxTaskToResume );
1003:../3rdParty/FreeRTOS/tasks.c **** 
1004:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 5637              		.loc 1 1004 0
 5638 05ea 7B68     		ldr	r3, [r7, #4]
 5639 05ec 3B61     		str	r3, [r7, #16]
1005:../3rdParty/FreeRTOS/tasks.c **** 
1006:../3rdParty/FreeRTOS/tasks.c **** 		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 5640              		.loc 1 1006 0
 5641 05ee 4FF00003 		mov	r3, #0
 5642 05f2 FB60     		str	r3, [r7, #12]
 5643              	@ 1006 "../3rdParty/FreeRTOS/tasks.c" 1
 5644 05f4 4FF02800 			mov r0, #40								
 5645 05f8 80F31188 		msr basepri, r0							
 5646              	
 5647              	@ 0 "" 2
1007:../3rdParty/FreeRTOS/tasks.c **** 		{
1008:../3rdParty/FreeRTOS/tasks.c **** 			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 5648              		.loc 1 1008 0
 5649              		.thumb
 5650 05fc 3869     		ldr	r0, [r7, #16]
 5651 05fe FFF7FEFF 		bl	xTaskIsTaskSuspended
 5652 0602 0346     		mov	r3, r0
 5653 0604 012B     		cmp	r3, #1
 5654 0606 37D1     		bne	.L72
1009:../3rdParty/FreeRTOS/tasks.c **** 			{
1010:../3rdParty/FreeRTOS/tasks.c **** 				traceTASK_RESUME_FROM_ISR( pxTCB );
1011:../3rdParty/FreeRTOS/tasks.c **** 
1012:../3rdParty/FreeRTOS/tasks.c **** 				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 5655              		.loc 1 1012 0
 5656 0608 204B     		ldr	r3, .L75
 5657 060a 1B68     		ldr	r3, [r3, #0]
 5658 060c 002B     		cmp	r3, #0
 5659 060e 2CD1     		bne	.L73
1013:../3rdParty/FreeRTOS/tasks.c **** 				{
1014:../3rdParty/FreeRTOS/tasks.c **** 					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 5660              		.loc 1 1014 0
 5661 0610 3B69     		ldr	r3, [r7, #16]
 5662 0612 DA6A     		ldr	r2, [r3, #44]
 5663 0614 1E4B     		ldr	r3, .L75+4
 5664 0616 1B68     		ldr	r3, [r3, #0]
 5665 0618 DB6A     		ldr	r3, [r3, #44]
 5666 061a 9A42     		cmp	r2, r3
 5667 061c 34BF     		ite	cc
 5668 061e 0023     		movcc	r3, #0
 5669 0620 0123     		movcs	r3, #1
 5670 0622 7B61     		str	r3, [r7, #20]
1015:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 5671              		.loc 1 1015 0
 5672 0624 3B69     		ldr	r3, [r7, #16]
 5673 0626 03F10403 		add	r3, r3, #4
 5674 062a 1846     		mov	r0, r3
 5675 062c FFF7FEFF 		bl	vListRemove
1016:../3rdParty/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 5676              		.loc 1 1016 0
 5677 0630 3B69     		ldr	r3, [r7, #16]
 5678 0632 DA6A     		ldr	r2, [r3, #44]
 5679 0634 174B     		ldr	r3, .L75+8
 5680 0636 1B68     		ldr	r3, [r3, #0]
 5681 0638 9A42     		cmp	r2, r3
 5682 063a 03D9     		bls	.L74
 5683              		.loc 1 1016 0 is_stmt 0 discriminator 1
 5684 063c 3B69     		ldr	r3, [r7, #16]
 5685 063e DA6A     		ldr	r2, [r3, #44]
 5686 0640 144B     		ldr	r3, .L75+8
 5687 0642 1A60     		str	r2, [r3, #0]
 5688              	.L74:
 5689              		.loc 1 1016 0 discriminator 2
 5690 0644 3B69     		ldr	r3, [r7, #16]
 5691 0646 DA6A     		ldr	r2, [r3, #44]
 5692 0648 1346     		mov	r3, r2
 5693 064a 4FEA8303 		lsl	r3, r3, #2
 5694 064e 9B18     		adds	r3, r3, r2
 5695 0650 4FEA8303 		lsl	r3, r3, #2
 5696 0654 1A46     		mov	r2, r3
 5697 0656 104B     		ldr	r3, .L75+12
 5698 0658 D218     		adds	r2, r2, r3
 5699 065a 3B69     		ldr	r3, [r7, #16]
 5700 065c 03F10403 		add	r3, r3, #4
 5701 0660 1046     		mov	r0, r2
 5702 0662 1946     		mov	r1, r3
 5703 0664 FFF7FEFF 		bl	vListInsertEnd
 5704 0668 06E0     		b	.L72
 5705              	.L73:
1017:../3rdParty/FreeRTOS/tasks.c **** 				}
1018:../3rdParty/FreeRTOS/tasks.c **** 				else
1019:../3rdParty/FreeRTOS/tasks.c **** 				{
1020:../3rdParty/FreeRTOS/tasks.c **** 					/* We cannot access the delayed or ready lists, so will hold this
1021:../3rdParty/FreeRTOS/tasks.c **** 					task pending until the scheduler is resumed, at which point a
1022:../3rdParty/FreeRTOS/tasks.c **** 					yield will be performed if necessary. */
1023:../3rdParty/FreeRTOS/tasks.c **** 					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 5706              		.loc 1 1023 0 is_stmt 1
 5707 066a 3B69     		ldr	r3, [r7, #16]
 5708 066c 03F11803 		add	r3, r3, #24
 5709 0670 0A48     		ldr	r0, .L75+16
 5710 0672 1946     		mov	r1, r3
 5711 0674 FFF7FEFF 		bl	vListInsertEnd
 5712              	.L72:
1024:../3rdParty/FreeRTOS/tasks.c **** 				}
1025:../3rdParty/FreeRTOS/tasks.c **** 			}
1026:../3rdParty/FreeRTOS/tasks.c **** 		}
1027:../3rdParty/FreeRTOS/tasks.c **** 		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 5713              		.loc 1 1027 0
 5714              	@ 1027 "../3rdParty/FreeRTOS/tasks.c" 1
 5715 0678 4FF00000 			mov r0, #0					
 5716 067c 80F31188 		msr basepri, r0				
 5717              	
 5718              	@ 0 "" 2
1028:../3rdParty/FreeRTOS/tasks.c **** 
1029:../3rdParty/FreeRTOS/tasks.c **** 		return xYieldRequired;
 5719              		.loc 1 1029 0
 5720              		.thumb
 5721 0680 7B69     		ldr	r3, [r7, #20]
1030:../3rdParty/FreeRTOS/tasks.c **** 	}
 5722              		.loc 1 1030 0
 5723 0682 1846     		mov	r0, r3
 5724 0684 07F11807 		add	r7, r7, #24
 5725 0688 BD46     		mov	sp, r7
 5726 068a 80BD     		pop	{r7, pc}
 5727              	.L76:
 5728              		.align	2
 5729              	.L75:
 5730 068c EC000000 		.word	uxSchedulerSuspended
 5731 0690 00000000 		.word	pxCurrentTCB
 5732 0694 E4000000 		.word	uxTopReadyPriority
 5733 0698 04000000 		.word	pxReadyTasksLists
 5734 069c 98000000 		.word	xPendingReadyList
 5735              		.cfi_endproc
 5736              	.LFE64:
 5738              		.section	.rodata
 5739              		.align	2
 5740              	.LC0:
 5741 0000 49444C45 		.ascii	"IDLE\000"
 5741      00
 5742              		.text
 5743              		.align	2
 5744              		.global	vTaskStartScheduler
 5745              		.thumb
 5746              		.thumb_func
 5748              	vTaskStartScheduler:
 5749              	.LFB65:
1031:../3rdParty/FreeRTOS/tasks.c **** 
1032:../3rdParty/FreeRTOS/tasks.c **** #endif
1033:../3rdParty/FreeRTOS/tasks.c **** 
1034:../3rdParty/FreeRTOS/tasks.c **** 
1035:../3rdParty/FreeRTOS/tasks.c **** 
1036:../3rdParty/FreeRTOS/tasks.c **** 
1037:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1038:../3rdParty/FreeRTOS/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1039:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1040:../3rdParty/FreeRTOS/tasks.c **** 
1041:../3rdParty/FreeRTOS/tasks.c **** 
1042:../3rdParty/FreeRTOS/tasks.c **** void vTaskStartScheduler( void )
1043:../3rdParty/FreeRTOS/tasks.c **** {
 5750              		.loc 1 1043 0
 5751              		.cfi_startproc
 5752              		@ args = 0, pretend = 0, frame = 8
 5753              		@ frame_needed = 1, uses_anonymous_args = 0
 5754 06a0 80B5     		push	{r7, lr}
 5755              	.LCFI30:
 5756              		.cfi_def_cfa_offset 8
 5757 06a2 86B0     		sub	sp, sp, #24
 5758              	.LCFI31:
 5759              		.cfi_def_cfa_offset 32
 5760 06a4 04AF     		add	r7, sp, #16
 5761              		.cfi_offset 14, -4
 5762              		.cfi_offset 7, -8
 5763              	.LCFI32:
 5764              		.cfi_def_cfa 7, 16
1044:../3rdParty/FreeRTOS/tasks.c **** portBASE_TYPE xReturn;
1045:../3rdParty/FreeRTOS/tasks.c **** 
1046:../3rdParty/FreeRTOS/tasks.c **** 	/* Add the idle task at the lowest priority. */
1047:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1048:../3rdParty/FreeRTOS/tasks.c **** 	{
1049:../3rdParty/FreeRTOS/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1050:../3rdParty/FreeRTOS/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1051:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1052:../3rdParty/FreeRTOS/tasks.c **** 	}
1053:../3rdParty/FreeRTOS/tasks.c **** 	#else
1054:../3rdParty/FreeRTOS/tasks.c **** 	{
1055:../3rdParty/FreeRTOS/tasks.c **** 		/* Create the idle task without storing its handle. */
1056:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
 5765              		.loc 1 1056 0
 5766 06a6 164B     		ldr	r3, .L79
 5767 06a8 4FF00002 		mov	r2, #0
 5768 06ac 0092     		str	r2, [sp, #0]
 5769 06ae 4FF00002 		mov	r2, #0
 5770 06b2 0192     		str	r2, [sp, #4]
 5771 06b4 4FF00002 		mov	r2, #0
 5772 06b8 0292     		str	r2, [sp, #8]
 5773 06ba 4FF00002 		mov	r2, #0
 5774 06be 0392     		str	r2, [sp, #12]
 5775 06c0 1048     		ldr	r0, .L79+4
 5776 06c2 1946     		mov	r1, r3
 5777 06c4 4FF05002 		mov	r2, #80
 5778 06c8 4FF00003 		mov	r3, #0
 5779 06cc FFF7FEFF 		bl	xTaskGenericCreate
 5780 06d0 7860     		str	r0, [r7, #4]
1057:../3rdParty/FreeRTOS/tasks.c **** 	}
1058:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1059:../3rdParty/FreeRTOS/tasks.c **** 
1060:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1061:../3rdParty/FreeRTOS/tasks.c **** 	{
1062:../3rdParty/FreeRTOS/tasks.c **** 		if( xReturn == pdPASS )
1063:../3rdParty/FreeRTOS/tasks.c **** 		{
1064:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1065:../3rdParty/FreeRTOS/tasks.c **** 		}
1066:../3rdParty/FreeRTOS/tasks.c **** 	}
1067:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1068:../3rdParty/FreeRTOS/tasks.c **** 
1069:../3rdParty/FreeRTOS/tasks.c **** 	if( xReturn == pdPASS )
 5781              		.loc 1 1069 0
 5782 06d2 7B68     		ldr	r3, [r7, #4]
 5783 06d4 012B     		cmp	r3, #1
 5784 06d6 0FD1     		bne	.L77
1070:../3rdParty/FreeRTOS/tasks.c **** 	{
1071:../3rdParty/FreeRTOS/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1072:../3rdParty/FreeRTOS/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1073:../3rdParty/FreeRTOS/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1074:../3rdParty/FreeRTOS/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1075:../3rdParty/FreeRTOS/tasks.c **** 		starts to run.
1076:../3rdParty/FreeRTOS/tasks.c **** 
1077:../3rdParty/FreeRTOS/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1078:../3rdParty/FreeRTOS/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1079:../3rdParty/FreeRTOS/tasks.c **** 		portDISABLE_INTERRUPTS();
 5785              		.loc 1 1079 0
 5786              	@ 1079 "../3rdParty/FreeRTOS/tasks.c" 1
 5787 06d8 4FF02800 			mov r0, #40								
 5788 06dc 80F31188 		msr basepri, r0							
 5789              	
 5790              	@ 0 "" 2
1080:../3rdParty/FreeRTOS/tasks.c **** 
1081:../3rdParty/FreeRTOS/tasks.c **** 		xSchedulerRunning = pdTRUE;
 5791              		.loc 1 1081 0
 5792              		.thumb
 5793 06e0 094B     		ldr	r3, .L79+8
 5794 06e2 4FF00102 		mov	r2, #1
 5795 06e6 1A60     		str	r2, [r3, #0]
1082:../3rdParty/FreeRTOS/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 5796              		.loc 1 1082 0
 5797 06e8 084B     		ldr	r3, .L79+12
 5798 06ea 4FF00002 		mov	r2, #0
 5799 06ee 1A60     		str	r2, [r3, #0]
1083:../3rdParty/FreeRTOS/tasks.c **** 
1084:../3rdParty/FreeRTOS/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1085:../3rdParty/FreeRTOS/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1086:../3rdParty/FreeRTOS/tasks.c **** 		the run time counter time base. */
1087:../3rdParty/FreeRTOS/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 5800              		.loc 1 1087 0
 5801 06f0 FFF7FEFF 		bl	vConfigureTimerForRunTimeStats
1088:../3rdParty/FreeRTOS/tasks.c **** 		
1089:../3rdParty/FreeRTOS/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1090:../3rdParty/FreeRTOS/tasks.c **** 		portable interface. */
1091:../3rdParty/FreeRTOS/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
 5802              		.loc 1 1091 0
 5803 06f4 FFF7FEFF 		bl	xPortStartScheduler
 5804              	.L77:
1092:../3rdParty/FreeRTOS/tasks.c **** 		{
1093:../3rdParty/FreeRTOS/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1094:../3rdParty/FreeRTOS/tasks.c **** 			function will not return. */
1095:../3rdParty/FreeRTOS/tasks.c **** 		}
1096:../3rdParty/FreeRTOS/tasks.c **** 		else
1097:../3rdParty/FreeRTOS/tasks.c **** 		{
1098:../3rdParty/FreeRTOS/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1099:../3rdParty/FreeRTOS/tasks.c **** 		}
1100:../3rdParty/FreeRTOS/tasks.c **** 	}
1101:../3rdParty/FreeRTOS/tasks.c **** 
1102:../3rdParty/FreeRTOS/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1103:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( xReturn );
1104:../3rdParty/FreeRTOS/tasks.c **** }
 5805              		.loc 1 1104 0
 5806 06f8 07F10807 		add	r7, r7, #8
 5807 06fc BD46     		mov	sp, r7
 5808 06fe 80BD     		pop	{r7, pc}
 5809              	.L80:
 5810              		.align	2
 5811              	.L79:
 5812 0700 00000000 		.word	.LC0
 5813 0704 00000000 		.word	prvIdleTask
 5814 0708 E8000000 		.word	xSchedulerRunning
 5815 070c DC000000 		.word	xTickCount
 5816              		.cfi_endproc
 5817              	.LFE65:
 5819              		.align	2
 5820              		.global	vTaskEndScheduler
 5821              		.thumb
 5822              		.thumb_func
 5824              	vTaskEndScheduler:
 5825              	.LFB66:
1105:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1106:../3rdParty/FreeRTOS/tasks.c **** 
1107:../3rdParty/FreeRTOS/tasks.c **** void vTaskEndScheduler( void )
1108:../3rdParty/FreeRTOS/tasks.c **** {
 5826              		.loc 1 1108 0
 5827              		.cfi_startproc
 5828              		@ args = 0, pretend = 0, frame = 0
 5829              		@ frame_needed = 1, uses_anonymous_args = 0
 5830 0710 80B5     		push	{r7, lr}
 5831              	.LCFI33:
 5832              		.cfi_def_cfa_offset 8
 5833 0712 00AF     		add	r7, sp, #0
 5834              		.cfi_offset 14, -4
 5835              		.cfi_offset 7, -8
 5836              	.LCFI34:
 5837              		.cfi_def_cfa_register 7
1109:../3rdParty/FreeRTOS/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1110:../3rdParty/FreeRTOS/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1111:../3rdParty/FreeRTOS/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1112:../3rdParty/FreeRTOS/tasks.c **** 	portDISABLE_INTERRUPTS();
 5838              		.loc 1 1112 0
 5839              	@ 1112 "../3rdParty/FreeRTOS/tasks.c" 1
 5840 0714 4FF02800 			mov r0, #40								
 5841 0718 80F31188 		msr basepri, r0							
 5842              	
 5843              	@ 0 "" 2
1113:../3rdParty/FreeRTOS/tasks.c **** 	xSchedulerRunning = pdFALSE;
 5844              		.loc 1 1113 0
 5845              		.thumb
 5846 071c 034B     		ldr	r3, .L82
 5847 071e 4FF00002 		mov	r2, #0
 5848 0722 1A60     		str	r2, [r3, #0]
1114:../3rdParty/FreeRTOS/tasks.c **** 	vPortEndScheduler();
 5849              		.loc 1 1114 0
 5850 0724 FFF7FEFF 		bl	vPortEndScheduler
1115:../3rdParty/FreeRTOS/tasks.c **** }
 5851              		.loc 1 1115 0
 5852 0728 80BD     		pop	{r7, pc}
 5853              	.L83:
 5854 072a 00BF     		.align	2
 5855              	.L82:
 5856 072c E8000000 		.word	xSchedulerRunning
 5857              		.cfi_endproc
 5858              	.LFE66:
 5860              		.align	2
 5861              		.global	vTaskSuspendAll
 5862              		.thumb
 5863              		.thumb_func
 5865              	vTaskSuspendAll:
 5866              	.LFB67:
1116:../3rdParty/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1117:../3rdParty/FreeRTOS/tasks.c **** 
1118:../3rdParty/FreeRTOS/tasks.c **** void vTaskSuspendAll( void )
1119:../3rdParty/FreeRTOS/tasks.c **** {
 5867              		.loc 1 1119 0
 5868              		.cfi_startproc
 5869              		@ args = 0, pretend = 0, frame = 0
 5870              		@ frame_needed = 1, uses_anonymous_args = 0
 5871              		@ link register save eliminated.
 5872 0730 80B4     		push	{r7}
 5873              	.LCFI35:
 5874              		.cfi_def_cfa_offset 4
 5875 0732 00AF     		add	r7, sp, #0
 5876              		.cfi_offset 7, -4
 5877              	.LCFI36:
 5878              		.cfi_def_cfa_register 7
1120:../3rdParty/FreeRTOS/tasks.c **** 	/* A critical section is not required as the variable is of type
1121:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE. */
1122:../3rdParty/FreeRTOS/tasks.c **** 	++uxSchedulerSuspended;
 5879              		.loc 1 1122 0
 5880 0734 044B     		ldr	r3, .L85
 5881 0736 1B68     		ldr	r3, [r3, #0]
 5882 0738 03F10102 		add	r2, r3, #1
 5883 073c 024B     		ldr	r3, .L85
 5884 073e 1A60     		str	r2, [r3, #0]
1123:../3rdParty/FreeRTOS/tasks.c **** }
 5885              		.loc 1 1123 0
 5886 0740 BD46     		mov	sp, r7
 5887 0742 80BC     		pop	{r7}
 5888 0744 7047     		bx	lr
 5889              	.L86:
 5890 0746 00BF     		.align	2
 5891              	.L85:
 5892 0748 EC000000 		.word	uxSchedulerSuspended
 5893              		.cfi_endproc
 5894              	.LFE67:
 5896              		.align	2
 5897              		.global	xTaskResumeAll
 5898              		.thumb
 5899              		.thumb_func
 5901              	xTaskResumeAll:
 5902              	.LFB68:
1124:../3rdParty/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1125:../3rdParty/FreeRTOS/tasks.c **** 
1126:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1127:../3rdParty/FreeRTOS/tasks.c **** {
 5903              		.loc 1 1127 0
 5904              		.cfi_startproc
 5905              		@ args = 0, pretend = 0, frame = 8
 5906              		@ frame_needed = 1, uses_anonymous_args = 0
 5907 074c 90B5     		push	{r4, r7, lr}
 5908              	.LCFI37:
 5909              		.cfi_def_cfa_offset 12
 5910 074e 83B0     		sub	sp, sp, #12
 5911              	.LCFI38:
 5912              		.cfi_def_cfa_offset 24
 5913 0750 00AF     		add	r7, sp, #0
 5914              		.cfi_offset 14, -4
 5915              		.cfi_offset 7, -8
 5916              		.cfi_offset 4, -12
 5917              	.LCFI39:
 5918              		.cfi_def_cfa_register 7
1128:../3rdParty/FreeRTOS/tasks.c **** register tskTCB *pxTCB;
1129:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 5919              		.loc 1 1129 0
 5920 0752 4FF00003 		mov	r3, #0
 5921 0756 7B60     		str	r3, [r7, #4]
1130:../3rdParty/FreeRTOS/tasks.c **** 
1131:../3rdParty/FreeRTOS/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1132:../3rdParty/FreeRTOS/tasks.c **** 	previous call to vTaskSuspendAll(). */
1133:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1134:../3rdParty/FreeRTOS/tasks.c **** 
1135:../3rdParty/FreeRTOS/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1136:../3rdParty/FreeRTOS/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1137:../3rdParty/FreeRTOS/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1138:../3rdParty/FreeRTOS/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1139:../3rdParty/FreeRTOS/tasks.c **** 	tasks from this list into their appropriate ready list. */
1140:../3rdParty/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 5922              		.loc 1 1140 0
 5923 0758 FFF7FEFF 		bl	vPortEnterCritical
1141:../3rdParty/FreeRTOS/tasks.c **** 	{
1142:../3rdParty/FreeRTOS/tasks.c **** 		--uxSchedulerSuspended;
 5924              		.loc 1 1142 0
 5925 075c 384B     		ldr	r3, .L96
 5926 075e 1B68     		ldr	r3, [r3, #0]
 5927 0760 03F1FF32 		add	r2, r3, #-1
 5928 0764 364B     		ldr	r3, .L96
 5929 0766 1A60     		str	r2, [r3, #0]
1143:../3rdParty/FreeRTOS/tasks.c **** 
1144:../3rdParty/FreeRTOS/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 5930              		.loc 1 1144 0
 5931 0768 354B     		ldr	r3, .L96
 5932 076a 1B68     		ldr	r3, [r3, #0]
 5933 076c 002B     		cmp	r3, #0
 5934 076e 5ED1     		bne	.L88
1145:../3rdParty/FreeRTOS/tasks.c **** 		{
1146:../3rdParty/FreeRTOS/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 5935              		.loc 1 1146 0
 5936 0770 344B     		ldr	r3, .L96+4
 5937 0772 1B68     		ldr	r3, [r3, #0]
 5938 0774 002B     		cmp	r3, #0
 5939 0776 5AD0     		beq	.L88
 5940              	.LBB3:
1147:../3rdParty/FreeRTOS/tasks.c **** 			{
1148:../3rdParty/FreeRTOS/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 5941              		.loc 1 1148 0
 5942 0778 4FF00003 		mov	r3, #0
 5943 077c 3B60     		str	r3, [r7, #0]
1149:../3rdParty/FreeRTOS/tasks.c **** 
1150:../3rdParty/FreeRTOS/tasks.c **** 				/* Move any readied tasks from the pending list into the
1151:../3rdParty/FreeRTOS/tasks.c **** 				appropriate ready list. */
1152:../3rdParty/FreeRTOS/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 5944              		.loc 1 1152 0
 5945 077e 2EE0     		b	.L89
 5946              	.L91:
1153:../3rdParty/FreeRTOS/tasks.c **** 				{
1154:../3rdParty/FreeRTOS/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 5947              		.loc 1 1154 0
 5948 0780 314B     		ldr	r3, .L96+8
 5949 0782 DB68     		ldr	r3, [r3, #12]
 5950 0784 DB68     		ldr	r3, [r3, #12]
 5951 0786 1C46     		mov	r4, r3
1155:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 5952              		.loc 1 1155 0
 5953 0788 04F11803 		add	r3, r4, #24
 5954 078c 1846     		mov	r0, r3
 5955 078e FFF7FEFF 		bl	vListRemove
1156:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 5956              		.loc 1 1156 0
 5957 0792 04F10403 		add	r3, r4, #4
 5958 0796 1846     		mov	r0, r3
 5959 0798 FFF7FEFF 		bl	vListRemove
1157:../3rdParty/FreeRTOS/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 5960              		.loc 1 1157 0
 5961 079c E26A     		ldr	r2, [r4, #44]
 5962 079e 2B4B     		ldr	r3, .L96+12
 5963 07a0 1B68     		ldr	r3, [r3, #0]
 5964 07a2 9A42     		cmp	r2, r3
 5965 07a4 02D9     		bls	.L90
 5966              		.loc 1 1157 0 is_stmt 0 discriminator 1
 5967 07a6 E26A     		ldr	r2, [r4, #44]
 5968 07a8 284B     		ldr	r3, .L96+12
 5969 07aa 1A60     		str	r2, [r3, #0]
 5970              	.L90:
 5971              		.loc 1 1157 0 discriminator 2
 5972 07ac E26A     		ldr	r2, [r4, #44]
 5973 07ae 1346     		mov	r3, r2
 5974 07b0 4FEA8303 		lsl	r3, r3, #2
 5975 07b4 9B18     		adds	r3, r3, r2
 5976 07b6 4FEA8303 		lsl	r3, r3, #2
 5977 07ba 1A46     		mov	r2, r3
 5978 07bc 244B     		ldr	r3, .L96+16
 5979 07be D218     		adds	r2, r2, r3
 5980 07c0 04F10403 		add	r3, r4, #4
 5981 07c4 1046     		mov	r0, r2
 5982 07c6 1946     		mov	r1, r3
 5983 07c8 FFF7FEFF 		bl	vListInsertEnd
1158:../3rdParty/FreeRTOS/tasks.c **** 
1159:../3rdParty/FreeRTOS/tasks.c **** 					/* If we have moved a task that has a priority higher than
1160:../3rdParty/FreeRTOS/tasks.c **** 					the current task then we should yield. */
1161:../3rdParty/FreeRTOS/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 5984              		.loc 1 1161 0 is_stmt 1 discriminator 2
 5985 07cc E26A     		ldr	r2, [r4, #44]
 5986 07ce 214B     		ldr	r3, .L96+20
 5987 07d0 1B68     		ldr	r3, [r3, #0]
 5988 07d2 DB6A     		ldr	r3, [r3, #44]
 5989 07d4 9A42     		cmp	r2, r3
 5990 07d6 02D3     		bcc	.L89
1162:../3rdParty/FreeRTOS/tasks.c **** 					{
1163:../3rdParty/FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 5991              		.loc 1 1163 0
 5992 07d8 4FF00103 		mov	r3, #1
 5993 07dc 3B60     		str	r3, [r7, #0]
 5994              	.L89:
1152:../3rdParty/FreeRTOS/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 5995              		.loc 1 1152 0 discriminator 1
 5996 07de 1A4B     		ldr	r3, .L96+8
 5997 07e0 1B68     		ldr	r3, [r3, #0]
 5998 07e2 002B     		cmp	r3, #0
 5999 07e4 CCD1     		bne	.L91
1164:../3rdParty/FreeRTOS/tasks.c **** 					}
1165:../3rdParty/FreeRTOS/tasks.c **** 				}
1166:../3rdParty/FreeRTOS/tasks.c **** 
1167:../3rdParty/FreeRTOS/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1168:../3rdParty/FreeRTOS/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1169:../3rdParty/FreeRTOS/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1170:../3rdParty/FreeRTOS/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 6000              		.loc 1 1170 0
 6001 07e6 1C4B     		ldr	r3, .L96+24
 6002 07e8 1B68     		ldr	r3, [r3, #0]
 6003 07ea 002B     		cmp	r3, #0
 6004 07ec 0FD0     		beq	.L92
1171:../3rdParty/FreeRTOS/tasks.c **** 				{
1172:../3rdParty/FreeRTOS/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 6005              		.loc 1 1172 0
 6006 07ee 07E0     		b	.L93
 6007              	.L94:
1173:../3rdParty/FreeRTOS/tasks.c **** 					{
1174:../3rdParty/FreeRTOS/tasks.c **** 						vTaskIncrementTick();
 6008              		.loc 1 1174 0
 6009 07f0 FFF7FEFF 		bl	vTaskIncrementTick
1175:../3rdParty/FreeRTOS/tasks.c **** 						--uxMissedTicks;
 6010              		.loc 1 1175 0
 6011 07f4 184B     		ldr	r3, .L96+24
 6012 07f6 1B68     		ldr	r3, [r3, #0]
 6013 07f8 03F1FF32 		add	r2, r3, #-1
 6014 07fc 164B     		ldr	r3, .L96+24
 6015 07fe 1A60     		str	r2, [r3, #0]
 6016              	.L93:
1172:../3rdParty/FreeRTOS/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 6017              		.loc 1 1172 0 discriminator 1
 6018 0800 154B     		ldr	r3, .L96+24
 6019 0802 1B68     		ldr	r3, [r3, #0]
 6020 0804 002B     		cmp	r3, #0
 6021 0806 F3D1     		bne	.L94
1176:../3rdParty/FreeRTOS/tasks.c **** 					}
1177:../3rdParty/FreeRTOS/tasks.c **** 
1178:../3rdParty/FreeRTOS/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1179:../3rdParty/FreeRTOS/tasks.c **** 					to ensure the highest priority task that is ready to run is
1180:../3rdParty/FreeRTOS/tasks.c **** 					the task actually running. */
1181:../3rdParty/FreeRTOS/tasks.c **** 					#if configUSE_PREEMPTION == 1
1182:../3rdParty/FreeRTOS/tasks.c **** 					{
1183:../3rdParty/FreeRTOS/tasks.c **** 						xYieldRequired = pdTRUE;
 6022              		.loc 1 1183 0
 6023 0808 4FF00103 		mov	r3, #1
 6024 080c 3B60     		str	r3, [r7, #0]
 6025              	.L92:
1184:../3rdParty/FreeRTOS/tasks.c **** 					}
1185:../3rdParty/FreeRTOS/tasks.c **** 					#endif
1186:../3rdParty/FreeRTOS/tasks.c **** 				}
1187:../3rdParty/FreeRTOS/tasks.c **** 
1188:../3rdParty/FreeRTOS/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 6026              		.loc 1 1188 0
 6027 080e 3B68     		ldr	r3, [r7, #0]
 6028 0810 012B     		cmp	r3, #1
 6029 0812 03D0     		beq	.L95
 6030              		.loc 1 1188 0 is_stmt 0 discriminator 1
 6031 0814 114B     		ldr	r3, .L96+28
 6032 0816 1B68     		ldr	r3, [r3, #0]
 6033 0818 012B     		cmp	r3, #1
 6034 081a 08D1     		bne	.L88
 6035              	.L95:
1189:../3rdParty/FreeRTOS/tasks.c **** 				{
1190:../3rdParty/FreeRTOS/tasks.c **** 					xAlreadyYielded = pdTRUE;
 6036              		.loc 1 1190 0 is_stmt 1
 6037 081c 4FF00103 		mov	r3, #1
 6038 0820 7B60     		str	r3, [r7, #4]
1191:../3rdParty/FreeRTOS/tasks.c **** 					xMissedYield = pdFALSE;
 6039              		.loc 1 1191 0
 6040 0822 0E4B     		ldr	r3, .L96+28
 6041 0824 4FF00002 		mov	r2, #0
 6042 0828 1A60     		str	r2, [r3, #0]
1192:../3rdParty/FreeRTOS/tasks.c **** 					portYIELD_WITHIN_API();
 6043              		.loc 1 1192 0
 6044 082a FFF7FEFF 		bl	vPortYieldFromISR
 6045              	.L88:
 6046              	.LBE3:
1193:../3rdParty/FreeRTOS/tasks.c **** 				}
1194:../3rdParty/FreeRTOS/tasks.c **** 			}
1195:../3rdParty/FreeRTOS/tasks.c **** 		}
1196:../3rdParty/FreeRTOS/tasks.c **** 	}
1197:../3rdParty/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 6047              		.loc 1 1197 0
 6048 082e FFF7FEFF 		bl	vPortExitCritical
1198:../3rdParty/FreeRTOS/tasks.c **** 
1199:../3rdParty/FreeRTOS/tasks.c **** 	return xAlreadyYielded;
 6049              		.loc 1 1199 0
 6050 0832 7B68     		ldr	r3, [r7, #4]
1200:../3rdParty/FreeRTOS/tasks.c **** }
 6051              		.loc 1 1200 0
 6052 0834 1846     		mov	r0, r3
 6053 0836 07F10C07 		add	r7, r7, #12
 6054 083a BD46     		mov	sp, r7
 6055 083c 90BD     		pop	{r4, r7, pc}
 6056              	.L97:
 6057 083e 00BF     		.align	2
 6058              	.L96:
 6059 0840 EC000000 		.word	uxSchedulerSuspended
 6060 0844 D8000000 		.word	uxCurrentNumberOfTasks
 6061 0848 98000000 		.word	xPendingReadyList
 6062 084c E4000000 		.word	uxTopReadyPriority
 6063 0850 04000000 		.word	pxReadyTasksLists
 6064 0854 00000000 		.word	pxCurrentTCB
 6065 0858 F0000000 		.word	uxMissedTicks
 6066 085c F4000000 		.word	xMissedYield
 6067              		.cfi_endproc
 6068              	.LFE68:
 6070              		.align	2
 6071              		.global	xTaskGetTickCount
 6072              		.thumb
 6073              		.thumb_func
 6075              	xTaskGetTickCount:
 6076              	.LFB69:
1201:../3rdParty/FreeRTOS/tasks.c **** 
1202:../3rdParty/FreeRTOS/tasks.c **** 
1203:../3rdParty/FreeRTOS/tasks.c **** 
1204:../3rdParty/FreeRTOS/tasks.c **** 
1205:../3rdParty/FreeRTOS/tasks.c **** 
1206:../3rdParty/FreeRTOS/tasks.c **** 
1207:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1208:../3rdParty/FreeRTOS/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1209:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1210:../3rdParty/FreeRTOS/tasks.c **** 
1211:../3rdParty/FreeRTOS/tasks.c **** 
1212:../3rdParty/FreeRTOS/tasks.c **** 
1213:../3rdParty/FreeRTOS/tasks.c **** portTickType xTaskGetTickCount( void )
1214:../3rdParty/FreeRTOS/tasks.c **** {
 6077              		.loc 1 1214 0
 6078              		.cfi_startproc
 6079              		@ args = 0, pretend = 0, frame = 8
 6080              		@ frame_needed = 1, uses_anonymous_args = 0
 6081 0860 80B5     		push	{r7, lr}
 6082              	.LCFI40:
 6083              		.cfi_def_cfa_offset 8
 6084 0862 82B0     		sub	sp, sp, #8
 6085              	.LCFI41:
 6086              		.cfi_def_cfa_offset 16
 6087 0864 00AF     		add	r7, sp, #0
 6088              		.cfi_offset 14, -4
 6089              		.cfi_offset 7, -8
 6090              	.LCFI42:
 6091              		.cfi_def_cfa_register 7
1215:../3rdParty/FreeRTOS/tasks.c **** portTickType xTicks;
1216:../3rdParty/FreeRTOS/tasks.c **** 
1217:../3rdParty/FreeRTOS/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1218:../3rdParty/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 6092              		.loc 1 1218 0
 6093 0866 FFF7FEFF 		bl	vPortEnterCritical
1219:../3rdParty/FreeRTOS/tasks.c **** 	{
1220:../3rdParty/FreeRTOS/tasks.c **** 		xTicks = xTickCount;
 6094              		.loc 1 1220 0
 6095 086a 054B     		ldr	r3, .L99
 6096 086c 1B68     		ldr	r3, [r3, #0]
 6097 086e 7B60     		str	r3, [r7, #4]
1221:../3rdParty/FreeRTOS/tasks.c **** 	}
1222:../3rdParty/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 6098              		.loc 1 1222 0
 6099 0870 FFF7FEFF 		bl	vPortExitCritical
1223:../3rdParty/FreeRTOS/tasks.c **** 
1224:../3rdParty/FreeRTOS/tasks.c **** 	return xTicks;
 6100              		.loc 1 1224 0
 6101 0874 7B68     		ldr	r3, [r7, #4]
1225:../3rdParty/FreeRTOS/tasks.c **** }
 6102              		.loc 1 1225 0
 6103 0876 1846     		mov	r0, r3
 6104 0878 07F10807 		add	r7, r7, #8
 6105 087c BD46     		mov	sp, r7
 6106 087e 80BD     		pop	{r7, pc}
 6107              	.L100:
 6108              		.align	2
 6109              	.L99:
 6110 0880 DC000000 		.word	xTickCount
 6111              		.cfi_endproc
 6112              	.LFE69:
 6114              		.align	2
 6115              		.global	xTaskGetTickCountFromISR
 6116              		.thumb
 6117              		.thumb_func
 6119              	xTaskGetTickCountFromISR:
 6120              	.LFB70:
1226:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1227:../3rdParty/FreeRTOS/tasks.c **** 
1228:../3rdParty/FreeRTOS/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1229:../3rdParty/FreeRTOS/tasks.c **** {
 6121              		.loc 1 1229 0
 6122              		.cfi_startproc
 6123              		@ args = 0, pretend = 0, frame = 8
 6124              		@ frame_needed = 1, uses_anonymous_args = 0
 6125              		@ link register save eliminated.
 6126 0884 80B4     		push	{r7}
 6127              	.LCFI43:
 6128              		.cfi_def_cfa_offset 4
 6129 0886 83B0     		sub	sp, sp, #12
 6130              	.LCFI44:
 6131              		.cfi_def_cfa_offset 16
 6132 0888 00AF     		add	r7, sp, #0
 6133              		.cfi_offset 7, -4
 6134              	.LCFI45:
 6135              		.cfi_def_cfa_register 7
1230:../3rdParty/FreeRTOS/tasks.c **** portTickType xReturn;
1231:../3rdParty/FreeRTOS/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1232:../3rdParty/FreeRTOS/tasks.c **** 
1233:../3rdParty/FreeRTOS/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 6136              		.loc 1 1233 0
 6137 088a 4FF00003 		mov	r3, #0
 6138 088e 7B60     		str	r3, [r7, #4]
 6139              	@ 1233 "../3rdParty/FreeRTOS/tasks.c" 1
 6140 0890 4FF02800 			mov r0, #40								
 6141 0894 80F31188 		msr basepri, r0							
 6142              	
 6143              	@ 0 "" 2
1234:../3rdParty/FreeRTOS/tasks.c **** 	xReturn = xTickCount;
 6144              		.loc 1 1234 0
 6145              		.thumb
 6146 0898 064B     		ldr	r3, .L102
 6147 089a 1B68     		ldr	r3, [r3, #0]
 6148 089c 3B60     		str	r3, [r7, #0]
1235:../3rdParty/FreeRTOS/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 6149              		.loc 1 1235 0
 6150              	@ 1235 "../3rdParty/FreeRTOS/tasks.c" 1
 6151 089e 4FF00000 			mov r0, #0					
 6152 08a2 80F31188 		msr basepri, r0				
 6153              	
 6154              	@ 0 "" 2
1236:../3rdParty/FreeRTOS/tasks.c **** 
1237:../3rdParty/FreeRTOS/tasks.c **** 	return xReturn;
 6155              		.loc 1 1237 0
 6156              		.thumb
 6157 08a6 3B68     		ldr	r3, [r7, #0]
1238:../3rdParty/FreeRTOS/tasks.c **** }
 6158              		.loc 1 1238 0
 6159 08a8 1846     		mov	r0, r3
 6160 08aa 07F10C07 		add	r7, r7, #12
 6161 08ae BD46     		mov	sp, r7
 6162 08b0 80BC     		pop	{r7}
 6163 08b2 7047     		bx	lr
 6164              	.L103:
 6165              		.align	2
 6166              	.L102:
 6167 08b4 DC000000 		.word	xTickCount
 6168              		.cfi_endproc
 6169              	.LFE70:
 6171              		.align	2
 6172              		.global	uxTaskGetNumberOfTasks
 6173              		.thumb
 6174              		.thumb_func
 6176              	uxTaskGetNumberOfTasks:
 6177              	.LFB71:
1239:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1240:../3rdParty/FreeRTOS/tasks.c **** 
1241:../3rdParty/FreeRTOS/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1242:../3rdParty/FreeRTOS/tasks.c **** {
 6178              		.loc 1 1242 0
 6179              		.cfi_startproc
 6180              		@ args = 0, pretend = 0, frame = 0
 6181              		@ frame_needed = 1, uses_anonymous_args = 0
 6182              		@ link register save eliminated.
 6183 08b8 80B4     		push	{r7}
 6184              	.LCFI46:
 6185              		.cfi_def_cfa_offset 4
 6186 08ba 00AF     		add	r7, sp, #0
 6187              		.cfi_offset 7, -4
 6188              	.LCFI47:
 6189              		.cfi_def_cfa_register 7
1243:../3rdParty/FreeRTOS/tasks.c **** 	/* A critical section is not required because the variables are of type
1244:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE. */
1245:../3rdParty/FreeRTOS/tasks.c **** 	return uxCurrentNumberOfTasks;
 6190              		.loc 1 1245 0
 6191 08bc 024B     		ldr	r3, .L105
 6192 08be 1B68     		ldr	r3, [r3, #0]
1246:../3rdParty/FreeRTOS/tasks.c **** }
 6193              		.loc 1 1246 0
 6194 08c0 1846     		mov	r0, r3
 6195 08c2 BD46     		mov	sp, r7
 6196 08c4 80BC     		pop	{r7}
 6197 08c6 7047     		bx	lr
 6198              	.L106:
 6199              		.align	2
 6200              	.L105:
 6201 08c8 D8000000 		.word	uxCurrentNumberOfTasks
 6202              		.cfi_endproc
 6203              	.LFE71:
 6205              		.section	.rodata
 6206 0005 000000   		.align	2
 6207              	.LC1:
 6208 0008 0D0A00   		.ascii	"\015\012\000"
 6209              		.text
 6210              		.align	2
 6211              		.global	vTaskList
 6212              		.thumb
 6213              		.thumb_func
 6215              	vTaskList:
 6216              	.LFB72:
1247:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1248:../3rdParty/FreeRTOS/tasks.c **** 
1249:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1250:../3rdParty/FreeRTOS/tasks.c **** 
1251:../3rdParty/FreeRTOS/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1252:../3rdParty/FreeRTOS/tasks.c **** 	{
1253:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1254:../3rdParty/FreeRTOS/tasks.c **** 
1255:../3rdParty/FreeRTOS/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1256:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1257:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxTCB );
1258:../3rdParty/FreeRTOS/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1259:../3rdParty/FreeRTOS/tasks.c **** 	}
1260:../3rdParty/FreeRTOS/tasks.c **** 
1261:../3rdParty/FreeRTOS/tasks.c **** #endif
1262:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1263:../3rdParty/FreeRTOS/tasks.c **** 
1264:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1265:../3rdParty/FreeRTOS/tasks.c **** 
1266:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1267:../3rdParty/FreeRTOS/tasks.c **** 	{
 6217              		.loc 1 1267 0
 6218              		.cfi_startproc
 6219              		@ args = 0, pretend = 0, frame = 16
 6220              		@ frame_needed = 1, uses_anonymous_args = 0
 6221 08cc 90B5     		push	{r4, r7, lr}
 6222              	.LCFI48:
 6223              		.cfi_def_cfa_offset 12
 6224 08ce 85B0     		sub	sp, sp, #20
 6225              	.LCFI49:
 6226              		.cfi_def_cfa_offset 32
 6227 08d0 00AF     		add	r7, sp, #0
 6228              		.cfi_offset 14, -4
 6229              		.cfi_offset 7, -8
 6230              		.cfi_offset 4, -12
 6231              	.LCFI50:
 6232              		.cfi_def_cfa_register 7
 6233 08d2 7860     		str	r0, [r7, #4]
1268:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1269:../3rdParty/FreeRTOS/tasks.c **** 
1270:../3rdParty/FreeRTOS/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1271:../3rdParty/FreeRTOS/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1272:../3rdParty/FreeRTOS/tasks.c **** 
1273:../3rdParty/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
 6234              		.loc 1 1273 0
 6235 08d4 FFF7FEFF 		bl	vTaskSuspendAll
1274:../3rdParty/FreeRTOS/tasks.c **** 		{
1275:../3rdParty/FreeRTOS/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1276:../3rdParty/FreeRTOS/tasks.c **** 			report the task name, state and stack high water mark. */
1277:../3rdParty/FreeRTOS/tasks.c **** 
1278:../3rdParty/FreeRTOS/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
 6236              		.loc 1 1278 0
 6237 08d8 7B68     		ldr	r3, [r7, #4]
 6238 08da 4FF00002 		mov	r2, #0
 6239 08de 1A70     		strb	r2, [r3, #0]
1279:../3rdParty/FreeRTOS/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 6240              		.loc 1 1279 0
 6241 08e0 7C68     		ldr	r4, [r7, #4]
 6242 08e2 2046     		mov	r0, r4
 6243 08e4 FFF7FEFF 		bl	strlen
 6244 08e8 0346     		mov	r3, r0
 6245 08ea E318     		adds	r3, r4, r3
 6246 08ec 1846     		mov	r0, r3
 6247 08ee 3149     		ldr	r1, .L114
 6248 08f0 4FF00302 		mov	r2, #3
 6249 08f4 FFF7FEFF 		bl	memcpy
1280:../3rdParty/FreeRTOS/tasks.c **** 
1281:../3rdParty/FreeRTOS/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 6250              		.loc 1 1281 0
 6251 08f8 2F4B     		ldr	r3, .L114+4
 6252 08fa 1B68     		ldr	r3, [r3, #0]
 6253 08fc 03F10103 		add	r3, r3, #1
 6254 0900 FB60     		str	r3, [r7, #12]
 6255              	.L109:
1282:../3rdParty/FreeRTOS/tasks.c **** 
1283:../3rdParty/FreeRTOS/tasks.c **** 			do
1284:../3rdParty/FreeRTOS/tasks.c **** 			{
1285:../3rdParty/FreeRTOS/tasks.c **** 				uxQueue--;
 6256              		.loc 1 1285 0
 6257 0902 FB68     		ldr	r3, [r7, #12]
 6258 0904 03F1FF33 		add	r3, r3, #-1
 6259 0908 FB60     		str	r3, [r7, #12]
1286:../3rdParty/FreeRTOS/tasks.c **** 
1287:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 6260              		.loc 1 1287 0
 6261 090a FA68     		ldr	r2, [r7, #12]
 6262 090c 1346     		mov	r3, r2
 6263 090e 4FEA8303 		lsl	r3, r3, #2
 6264 0912 9B18     		adds	r3, r3, r2
 6265 0914 4FEA8303 		lsl	r3, r3, #2
 6266 0918 1A46     		mov	r2, r3
 6267 091a 284B     		ldr	r3, .L114+8
 6268 091c D318     		adds	r3, r2, r3
 6269 091e 1B68     		ldr	r3, [r3, #0]
 6270 0920 002B     		cmp	r3, #0
 6271 0922 0FD0     		beq	.L108
1288:../3rdParty/FreeRTOS/tasks.c **** 				{
1289:../3rdParty/FreeRTOS/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
 6272              		.loc 1 1289 0
 6273 0924 FA68     		ldr	r2, [r7, #12]
 6274 0926 1346     		mov	r3, r2
 6275 0928 4FEA8303 		lsl	r3, r3, #2
 6276 092c 9B18     		adds	r3, r3, r2
 6277 092e 4FEA8303 		lsl	r3, r3, #2
 6278 0932 1A46     		mov	r2, r3
 6279 0934 214B     		ldr	r3, .L114+8
 6280 0936 D318     		adds	r3, r2, r3
 6281 0938 7868     		ldr	r0, [r7, #4]
 6282 093a 1946     		mov	r1, r3
 6283 093c 4FF05202 		mov	r2, #82
 6284 0940 00F062FC 		bl	prvListTaskWithinSingleList
 6285              	.L108:
1290:../3rdParty/FreeRTOS/tasks.c **** 				}
1291:../3rdParty/FreeRTOS/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 6286              		.loc 1 1291 0
 6287 0944 FB68     		ldr	r3, [r7, #12]
 6288 0946 002B     		cmp	r3, #0
 6289 0948 DBD1     		bne	.L109
1292:../3rdParty/FreeRTOS/tasks.c **** 
1293:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 6290              		.loc 1 1293 0
 6291 094a 1D4B     		ldr	r3, .L114+12
 6292 094c 1B68     		ldr	r3, [r3, #0]
 6293 094e 1B68     		ldr	r3, [r3, #0]
 6294 0950 002B     		cmp	r3, #0
 6295 0952 07D0     		beq	.L110
1294:../3rdParty/FreeRTOS/tasks.c **** 			{
1295:../3rdParty/FreeRTOS/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
 6296              		.loc 1 1295 0
 6297 0954 1A4B     		ldr	r3, .L114+12
 6298 0956 1B68     		ldr	r3, [r3, #0]
 6299 0958 7868     		ldr	r0, [r7, #4]
 6300 095a 1946     		mov	r1, r3
 6301 095c 4FF04202 		mov	r2, #66
 6302 0960 00F052FC 		bl	prvListTaskWithinSingleList
 6303              	.L110:
1296:../3rdParty/FreeRTOS/tasks.c **** 			}
1297:../3rdParty/FreeRTOS/tasks.c **** 
1298:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 6304              		.loc 1 1298 0
 6305 0964 174B     		ldr	r3, .L114+16
 6306 0966 1B68     		ldr	r3, [r3, #0]
 6307 0968 1B68     		ldr	r3, [r3, #0]
 6308 096a 002B     		cmp	r3, #0
 6309 096c 07D0     		beq	.L111
1299:../3rdParty/FreeRTOS/tasks.c **** 			{
1300:../3rdParty/FreeRTOS/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
 6310              		.loc 1 1300 0
 6311 096e 154B     		ldr	r3, .L114+16
 6312 0970 1B68     		ldr	r3, [r3, #0]
 6313 0972 7868     		ldr	r0, [r7, #4]
 6314 0974 1946     		mov	r1, r3
 6315 0976 4FF04202 		mov	r2, #66
 6316 097a 00F045FC 		bl	prvListTaskWithinSingleList
 6317              	.L111:
1301:../3rdParty/FreeRTOS/tasks.c **** 			}
1302:../3rdParty/FreeRTOS/tasks.c **** 
1303:../3rdParty/FreeRTOS/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1304:../3rdParty/FreeRTOS/tasks.c **** 			{
1305:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 6318              		.loc 1 1305 0
 6319 097e 124B     		ldr	r3, .L114+20
 6320 0980 1B68     		ldr	r3, [r3, #0]
 6321 0982 002B     		cmp	r3, #0
 6322 0984 05D0     		beq	.L112
1306:../3rdParty/FreeRTOS/tasks.c **** 				{
1307:../3rdParty/FreeRTOS/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
 6323              		.loc 1 1307 0
 6324 0986 7868     		ldr	r0, [r7, #4]
 6325 0988 0F49     		ldr	r1, .L114+20
 6326 098a 4FF04402 		mov	r2, #68
 6327 098e 00F03BFC 		bl	prvListTaskWithinSingleList
 6328              	.L112:
1308:../3rdParty/FreeRTOS/tasks.c **** 				}
1309:../3rdParty/FreeRTOS/tasks.c **** 			}
1310:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1311:../3rdParty/FreeRTOS/tasks.c **** 
1312:../3rdParty/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1313:../3rdParty/FreeRTOS/tasks.c **** 			{
1314:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 6329              		.loc 1 1314 0
 6330 0992 0E4B     		ldr	r3, .L114+24
 6331 0994 1B68     		ldr	r3, [r3, #0]
 6332 0996 002B     		cmp	r3, #0
 6333 0998 05D0     		beq	.L113
1315:../3rdParty/FreeRTOS/tasks.c **** 				{
1316:../3rdParty/FreeRTOS/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
 6334              		.loc 1 1316 0
 6335 099a 7868     		ldr	r0, [r7, #4]
 6336 099c 0B49     		ldr	r1, .L114+24
 6337 099e 4FF05302 		mov	r2, #83
 6338 09a2 00F031FC 		bl	prvListTaskWithinSingleList
 6339              	.L113:
1317:../3rdParty/FreeRTOS/tasks.c **** 				}
1318:../3rdParty/FreeRTOS/tasks.c **** 			}
1319:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1320:../3rdParty/FreeRTOS/tasks.c **** 		}
1321:../3rdParty/FreeRTOS/tasks.c **** 		xTaskResumeAll();
 6340              		.loc 1 1321 0
 6341 09a6 FFF7FEFF 		bl	xTaskResumeAll
1322:../3rdParty/FreeRTOS/tasks.c **** 	}
 6342              		.loc 1 1322 0
 6343 09aa 07F11407 		add	r7, r7, #20
 6344 09ae BD46     		mov	sp, r7
 6345 09b0 90BD     		pop	{r4, r7, pc}
 6346              	.L115:
 6347 09b2 00BF     		.align	2
 6348              	.L114:
 6349 09b4 08000000 		.word	.LC1
 6350 09b8 E0000000 		.word	uxTopUsedPriority
 6351 09bc 04000000 		.word	pxReadyTasksLists
 6352 09c0 90000000 		.word	pxDelayedTaskList
 6353 09c4 94000000 		.word	pxOverflowDelayedTaskList
 6354 09c8 AC000000 		.word	xTasksWaitingTermination
 6355 09cc C4000000 		.word	xSuspendedTaskList
 6356              		.cfi_endproc
 6357              	.LFE72:
 6359              		.align	2
 6360              		.global	vTaskGetRunTimeStats
 6361              		.thumb
 6362              		.thumb_func
 6364              	vTaskGetRunTimeStats:
 6365              	.LFB73:
1323:../3rdParty/FreeRTOS/tasks.c **** 
1324:../3rdParty/FreeRTOS/tasks.c **** #endif
1325:../3rdParty/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1326:../3rdParty/FreeRTOS/tasks.c **** 
1327:../3rdParty/FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1328:../3rdParty/FreeRTOS/tasks.c **** 
1329:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1330:../3rdParty/FreeRTOS/tasks.c **** 	{
 6366              		.loc 1 1330 0
 6367              		.cfi_startproc
 6368              		@ args = 0, pretend = 0, frame = 16
 6369              		@ frame_needed = 1, uses_anonymous_args = 0
 6370 09d0 90B5     		push	{r4, r7, lr}
 6371              	.LCFI51:
 6372              		.cfi_def_cfa_offset 12
 6373 09d2 85B0     		sub	sp, sp, #20
 6374              	.LCFI52:
 6375              		.cfi_def_cfa_offset 32
 6376 09d4 00AF     		add	r7, sp, #0
 6377              		.cfi_offset 14, -4
 6378              		.cfi_offset 7, -8
 6379              		.cfi_offset 4, -12
 6380              	.LCFI53:
 6381              		.cfi_def_cfa_register 7
 6382 09d6 7860     		str	r0, [r7, #4]
1331:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1332:../3rdParty/FreeRTOS/tasks.c **** 	unsigned long ulTotalRunTime;
1333:../3rdParty/FreeRTOS/tasks.c **** 
1334:../3rdParty/FreeRTOS/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1335:../3rdParty/FreeRTOS/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1336:../3rdParty/FreeRTOS/tasks.c **** 
1337:../3rdParty/FreeRTOS/tasks.c **** 		vTaskSuspendAll();
 6383              		.loc 1 1337 0
 6384 09d8 FFF7FEFF 		bl	vTaskSuspendAll
1338:../3rdParty/FreeRTOS/tasks.c **** 		{
1339:../3rdParty/FreeRTOS/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1340:../3rdParty/FreeRTOS/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1341:../3rdParty/FreeRTOS/tasks.c **** 			#else
1342:../3rdParty/FreeRTOS/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 6385              		.loc 1 1342 0
 6386 09dc 4FF04023 		mov	r3, #1073758208
 6387 09e0 9B68     		ldr	r3, [r3, #8]
 6388 09e2 BB60     		str	r3, [r7, #8]
1343:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1344:../3rdParty/FreeRTOS/tasks.c **** 
1345:../3rdParty/FreeRTOS/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1346:../3rdParty/FreeRTOS/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1347:../3rdParty/FreeRTOS/tasks.c **** 			ulTotalRunTime /= 100UL;
 6389              		.loc 1 1347 0
 6390 09e4 BA68     		ldr	r2, [r7, #8]
 6391 09e6 374B     		ldr	r3, .L123
 6392 09e8 A3FB0213 		umull	r1, r3, r3, r2
 6393 09ec 4FEA5313 		lsr	r3, r3, #5
 6394 09f0 BB60     		str	r3, [r7, #8]
1348:../3rdParty/FreeRTOS/tasks.c **** 			
1349:../3rdParty/FreeRTOS/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1350:../3rdParty/FreeRTOS/tasks.c **** 			generating a table of run timer percentages in the provided
1351:../3rdParty/FreeRTOS/tasks.c **** 			buffer. */
1352:../3rdParty/FreeRTOS/tasks.c **** 
1353:../3rdParty/FreeRTOS/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
 6395              		.loc 1 1353 0
 6396 09f2 7B68     		ldr	r3, [r7, #4]
 6397 09f4 4FF00002 		mov	r2, #0
 6398 09f8 1A70     		strb	r2, [r3, #0]
1354:../3rdParty/FreeRTOS/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 6399              		.loc 1 1354 0
 6400 09fa 7C68     		ldr	r4, [r7, #4]
 6401 09fc 2046     		mov	r0, r4
 6402 09fe FFF7FEFF 		bl	strlen
 6403 0a02 0346     		mov	r3, r0
 6404 0a04 E318     		adds	r3, r4, r3
 6405 0a06 1846     		mov	r0, r3
 6406 0a08 2F49     		ldr	r1, .L123+4
 6407 0a0a 4FF00302 		mov	r2, #3
 6408 0a0e FFF7FEFF 		bl	memcpy
1355:../3rdParty/FreeRTOS/tasks.c **** 
1356:../3rdParty/FreeRTOS/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
 6409              		.loc 1 1356 0
 6410 0a12 2E4B     		ldr	r3, .L123+8
 6411 0a14 1B68     		ldr	r3, [r3, #0]
 6412 0a16 03F10103 		add	r3, r3, #1
 6413 0a1a FB60     		str	r3, [r7, #12]
 6414              	.L118:
1357:../3rdParty/FreeRTOS/tasks.c **** 
1358:../3rdParty/FreeRTOS/tasks.c **** 			do
1359:../3rdParty/FreeRTOS/tasks.c **** 			{
1360:../3rdParty/FreeRTOS/tasks.c **** 				uxQueue--;
 6415              		.loc 1 1360 0
 6416 0a1c FB68     		ldr	r3, [r7, #12]
 6417 0a1e 03F1FF33 		add	r3, r3, #-1
 6418 0a22 FB60     		str	r3, [r7, #12]
1361:../3rdParty/FreeRTOS/tasks.c **** 
1362:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
 6419              		.loc 1 1362 0
 6420 0a24 FA68     		ldr	r2, [r7, #12]
 6421 0a26 1346     		mov	r3, r2
 6422 0a28 4FEA8303 		lsl	r3, r3, #2
 6423 0a2c 9B18     		adds	r3, r3, r2
 6424 0a2e 4FEA8303 		lsl	r3, r3, #2
 6425 0a32 1A46     		mov	r2, r3
 6426 0a34 264B     		ldr	r3, .L123+12
 6427 0a36 D318     		adds	r3, r2, r3
 6428 0a38 1B68     		ldr	r3, [r3, #0]
 6429 0a3a 002B     		cmp	r3, #0
 6430 0a3c 0ED0     		beq	.L117
1363:../3rdParty/FreeRTOS/tasks.c **** 				{
1364:../3rdParty/FreeRTOS/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
 6431              		.loc 1 1364 0
 6432 0a3e FA68     		ldr	r2, [r7, #12]
 6433 0a40 1346     		mov	r3, r2
 6434 0a42 4FEA8303 		lsl	r3, r3, #2
 6435 0a46 9B18     		adds	r3, r3, r2
 6436 0a48 4FEA8303 		lsl	r3, r3, #2
 6437 0a4c 1A46     		mov	r2, r3
 6438 0a4e 204B     		ldr	r3, .L123+12
 6439 0a50 D318     		adds	r3, r2, r3
 6440 0a52 7868     		ldr	r0, [r7, #4]
 6441 0a54 1946     		mov	r1, r3
 6442 0a56 BA68     		ldr	r2, [r7, #8]
 6443 0a58 00F034FC 		bl	prvGenerateRunTimeStatsForTasksInList
 6444              	.L117:
1365:../3rdParty/FreeRTOS/tasks.c **** 				}
1366:../3rdParty/FreeRTOS/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
 6445              		.loc 1 1366 0
 6446 0a5c FB68     		ldr	r3, [r7, #12]
 6447 0a5e 002B     		cmp	r3, #0
 6448 0a60 DCD1     		bne	.L118
1367:../3rdParty/FreeRTOS/tasks.c **** 
1368:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
 6449              		.loc 1 1368 0
 6450 0a62 1C4B     		ldr	r3, .L123+16
 6451 0a64 1B68     		ldr	r3, [r3, #0]
 6452 0a66 1B68     		ldr	r3, [r3, #0]
 6453 0a68 002B     		cmp	r3, #0
 6454 0a6a 06D0     		beq	.L119
1369:../3rdParty/FreeRTOS/tasks.c **** 			{
1370:../3rdParty/FreeRTOS/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
 6455              		.loc 1 1370 0
 6456 0a6c 194B     		ldr	r3, .L123+16
 6457 0a6e 1B68     		ldr	r3, [r3, #0]
 6458 0a70 7868     		ldr	r0, [r7, #4]
 6459 0a72 1946     		mov	r1, r3
 6460 0a74 BA68     		ldr	r2, [r7, #8]
 6461 0a76 00F025FC 		bl	prvGenerateRunTimeStatsForTasksInList
 6462              	.L119:
1371:../3rdParty/FreeRTOS/tasks.c **** 			}
1372:../3rdParty/FreeRTOS/tasks.c **** 
1373:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
 6463              		.loc 1 1373 0
 6464 0a7a 174B     		ldr	r3, .L123+20
 6465 0a7c 1B68     		ldr	r3, [r3, #0]
 6466 0a7e 1B68     		ldr	r3, [r3, #0]
 6467 0a80 002B     		cmp	r3, #0
 6468 0a82 06D0     		beq	.L120
1374:../3rdParty/FreeRTOS/tasks.c **** 			{
1375:../3rdParty/FreeRTOS/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
 6469              		.loc 1 1375 0
 6470 0a84 144B     		ldr	r3, .L123+20
 6471 0a86 1B68     		ldr	r3, [r3, #0]
 6472 0a88 7868     		ldr	r0, [r7, #4]
 6473 0a8a 1946     		mov	r1, r3
 6474 0a8c BA68     		ldr	r2, [r7, #8]
 6475 0a8e 00F019FC 		bl	prvGenerateRunTimeStatsForTasksInList
 6476              	.L120:
1376:../3rdParty/FreeRTOS/tasks.c **** 			}
1377:../3rdParty/FreeRTOS/tasks.c **** 
1378:../3rdParty/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1379:../3rdParty/FreeRTOS/tasks.c **** 			{
1380:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
 6477              		.loc 1 1380 0
 6478 0a92 124B     		ldr	r3, .L123+24
 6479 0a94 1B68     		ldr	r3, [r3, #0]
 6480 0a96 002B     		cmp	r3, #0
 6481 0a98 04D0     		beq	.L121
1381:../3rdParty/FreeRTOS/tasks.c **** 				{
1382:../3rdParty/FreeRTOS/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
 6482              		.loc 1 1382 0
 6483 0a9a 7868     		ldr	r0, [r7, #4]
 6484 0a9c 0F49     		ldr	r1, .L123+24
 6485 0a9e BA68     		ldr	r2, [r7, #8]
 6486 0aa0 00F010FC 		bl	prvGenerateRunTimeStatsForTasksInList
 6487              	.L121:
1383:../3rdParty/FreeRTOS/tasks.c **** 				}
1384:../3rdParty/FreeRTOS/tasks.c **** 			}
1385:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1386:../3rdParty/FreeRTOS/tasks.c **** 
1387:../3rdParty/FreeRTOS/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1388:../3rdParty/FreeRTOS/tasks.c **** 			{
1389:../3rdParty/FreeRTOS/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
 6488              		.loc 1 1389 0
 6489 0aa4 0E4B     		ldr	r3, .L123+28
 6490 0aa6 1B68     		ldr	r3, [r3, #0]
 6491 0aa8 002B     		cmp	r3, #0
 6492 0aaa 04D0     		beq	.L122
1390:../3rdParty/FreeRTOS/tasks.c **** 				{
1391:../3rdParty/FreeRTOS/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
 6493              		.loc 1 1391 0
 6494 0aac 7868     		ldr	r0, [r7, #4]
 6495 0aae 0C49     		ldr	r1, .L123+28
 6496 0ab0 BA68     		ldr	r2, [r7, #8]
 6497 0ab2 00F007FC 		bl	prvGenerateRunTimeStatsForTasksInList
 6498              	.L122:
1392:../3rdParty/FreeRTOS/tasks.c **** 				}
1393:../3rdParty/FreeRTOS/tasks.c **** 			}
1394:../3rdParty/FreeRTOS/tasks.c **** 			#endif
1395:../3rdParty/FreeRTOS/tasks.c **** 		}
1396:../3rdParty/FreeRTOS/tasks.c **** 		xTaskResumeAll();
 6499              		.loc 1 1396 0
 6500 0ab6 FFF7FEFF 		bl	xTaskResumeAll
1397:../3rdParty/FreeRTOS/tasks.c **** 	}
 6501              		.loc 1 1397 0
 6502 0aba 07F11407 		add	r7, r7, #20
 6503 0abe BD46     		mov	sp, r7
 6504 0ac0 90BD     		pop	{r4, r7, pc}
 6505              	.L124:
 6506 0ac2 00BF     		.align	2
 6507              	.L123:
 6508 0ac4 1F85EB51 		.word	1374389535
 6509 0ac8 08000000 		.word	.LC1
 6510 0acc E0000000 		.word	uxTopUsedPriority
 6511 0ad0 04000000 		.word	pxReadyTasksLists
 6512 0ad4 90000000 		.word	pxDelayedTaskList
 6513 0ad8 94000000 		.word	pxOverflowDelayedTaskList
 6514 0adc AC000000 		.word	xTasksWaitingTermination
 6515 0ae0 C4000000 		.word	xSuspendedTaskList
 6516              		.cfi_endproc
 6517              	.LFE73:
 6519              		.align	2
 6520              		.global	vTaskIncrementTick
 6521              		.thumb
 6522              		.thumb_func
 6524              	vTaskIncrementTick:
 6525              	.LFB74:
1398:../3rdParty/FreeRTOS/tasks.c **** 
1399:../3rdParty/FreeRTOS/tasks.c **** #endif
1400:../3rdParty/FreeRTOS/tasks.c **** /*----------------------------------------------------------*/
1401:../3rdParty/FreeRTOS/tasks.c **** 
1402:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1403:../3rdParty/FreeRTOS/tasks.c **** 
1404:../3rdParty/FreeRTOS/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1405:../3rdParty/FreeRTOS/tasks.c **** 	{
1406:../3rdParty/FreeRTOS/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1407:../3rdParty/FreeRTOS/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1408:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1409:../3rdParty/FreeRTOS/tasks.c **** 		return xIdleTaskHandle;
1410:../3rdParty/FreeRTOS/tasks.c **** 	}
1411:../3rdParty/FreeRTOS/tasks.c **** 	
1412:../3rdParty/FreeRTOS/tasks.c **** #endif
1413:../3rdParty/FreeRTOS/tasks.c **** 
1414:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1415:../3rdParty/FreeRTOS/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1416:../3rdParty/FreeRTOS/tasks.c ****  * documented in task.h
1417:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1418:../3rdParty/FreeRTOS/tasks.c **** 
1419:../3rdParty/FreeRTOS/tasks.c **** void vTaskIncrementTick( void )
1420:../3rdParty/FreeRTOS/tasks.c **** {
 6526              		.loc 1 1420 0
 6527              		.cfi_startproc
 6528              		@ args = 0, pretend = 0, frame = 16
 6529              		@ frame_needed = 1, uses_anonymous_args = 0
 6530 0ae4 80B5     		push	{r7, lr}
 6531              	.LCFI54:
 6532              		.cfi_def_cfa_offset 8
 6533 0ae6 84B0     		sub	sp, sp, #16
 6534              	.LCFI55:
 6535              		.cfi_def_cfa_offset 24
 6536 0ae8 00AF     		add	r7, sp, #0
 6537              		.cfi_offset 14, -4
 6538              		.cfi_offset 7, -8
 6539              	.LCFI56:
 6540              		.cfi_def_cfa_register 7
1421:../3rdParty/FreeRTOS/tasks.c **** tskTCB * pxTCB;
1422:../3rdParty/FreeRTOS/tasks.c **** 
1423:../3rdParty/FreeRTOS/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1424:../3rdParty/FreeRTOS/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1425:../3rdParty/FreeRTOS/tasks.c **** 	tasks to be unblocked. */
1426:../3rdParty/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 6541              		.loc 1 1426 0
 6542 0aea 454B     		ldr	r3, .L136
 6543 0aec 1B68     		ldr	r3, [r3, #0]
 6544 0aee 002B     		cmp	r3, #0
 6545 0af0 7AD1     		bne	.L126
1427:../3rdParty/FreeRTOS/tasks.c **** 	{
1428:../3rdParty/FreeRTOS/tasks.c **** 		++xTickCount;
 6546              		.loc 1 1428 0
 6547 0af2 444B     		ldr	r3, .L136+4
 6548 0af4 1B68     		ldr	r3, [r3, #0]
 6549 0af6 03F10102 		add	r2, r3, #1
 6550 0afa 424B     		ldr	r3, .L136+4
 6551 0afc 1A60     		str	r2, [r3, #0]
1429:../3rdParty/FreeRTOS/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 6552              		.loc 1 1429 0
 6553 0afe 414B     		ldr	r3, .L136+4
 6554 0b00 1B68     		ldr	r3, [r3, #0]
 6555 0b02 002B     		cmp	r3, #0
 6556 0b04 22D1     		bne	.L127
 6557              	.LBB4:
1430:../3rdParty/FreeRTOS/tasks.c **** 		{
1431:../3rdParty/FreeRTOS/tasks.c **** 			xList *pxTemp;
1432:../3rdParty/FreeRTOS/tasks.c **** 
1433:../3rdParty/FreeRTOS/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1434:../3rdParty/FreeRTOS/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1435:../3rdParty/FreeRTOS/tasks.c **** 			an error! */
1436:../3rdParty/FreeRTOS/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1437:../3rdParty/FreeRTOS/tasks.c **** 			
1438:../3rdParty/FreeRTOS/tasks.c **** 			pxTemp = pxDelayedTaskList;
 6558              		.loc 1 1438 0
 6559 0b06 404B     		ldr	r3, .L136+8
 6560 0b08 1B68     		ldr	r3, [r3, #0]
 6561 0b0a FB60     		str	r3, [r7, #12]
1439:../3rdParty/FreeRTOS/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 6562              		.loc 1 1439 0
 6563 0b0c 3F4B     		ldr	r3, .L136+12
 6564 0b0e 1A68     		ldr	r2, [r3, #0]
 6565 0b10 3D4B     		ldr	r3, .L136+8
 6566 0b12 1A60     		str	r2, [r3, #0]
1440:../3rdParty/FreeRTOS/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 6567              		.loc 1 1440 0
 6568 0b14 3D4B     		ldr	r3, .L136+12
 6569 0b16 FA68     		ldr	r2, [r7, #12]
 6570 0b18 1A60     		str	r2, [r3, #0]
1441:../3rdParty/FreeRTOS/tasks.c **** 			xNumOfOverflows++;
 6571              		.loc 1 1441 0
 6572 0b1a 3D4B     		ldr	r3, .L136+16
 6573 0b1c 1B68     		ldr	r3, [r3, #0]
 6574 0b1e 03F10102 		add	r2, r3, #1
 6575 0b22 3B4B     		ldr	r3, .L136+16
 6576 0b24 1A60     		str	r2, [r3, #0]
1442:../3rdParty/FreeRTOS/tasks.c **** 	
1443:../3rdParty/FreeRTOS/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 6577              		.loc 1 1443 0
 6578 0b26 384B     		ldr	r3, .L136+8
 6579 0b28 1B68     		ldr	r3, [r3, #0]
 6580 0b2a 1B68     		ldr	r3, [r3, #0]
 6581 0b2c 002B     		cmp	r3, #0
 6582 0b2e 04D1     		bne	.L128
1444:../3rdParty/FreeRTOS/tasks.c **** 			{
1445:../3rdParty/FreeRTOS/tasks.c **** 				/* The new current delayed list is empty.  Set
1446:../3rdParty/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1447:../3rdParty/FreeRTOS/tasks.c **** 				extremely unlikely that the	
1448:../3rdParty/FreeRTOS/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1449:../3rdParty/FreeRTOS/tasks.c **** 				there is an item in the delayed list. */
1450:../3rdParty/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
 6583              		.loc 1 1450 0
 6584 0b30 384B     		ldr	r3, .L136+20
 6585 0b32 4FF0FF32 		mov	r2, #-1
 6586 0b36 1A60     		str	r2, [r3, #0]
 6587 0b38 08E0     		b	.L127
 6588              	.L128:
1451:../3rdParty/FreeRTOS/tasks.c **** 			}
1452:../3rdParty/FreeRTOS/tasks.c **** 			else
1453:../3rdParty/FreeRTOS/tasks.c **** 			{
1454:../3rdParty/FreeRTOS/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1455:../3rdParty/FreeRTOS/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1456:../3rdParty/FreeRTOS/tasks.c **** 				which the task at the head of the delayed list should be removed
1457:../3rdParty/FreeRTOS/tasks.c **** 				from the Blocked state. */
1458:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 6589              		.loc 1 1458 0
 6590 0b3a 334B     		ldr	r3, .L136+8
 6591 0b3c 1B68     		ldr	r3, [r3, #0]
 6592 0b3e DB68     		ldr	r3, [r3, #12]
 6593 0b40 DB68     		ldr	r3, [r3, #12]
 6594 0b42 BB60     		str	r3, [r7, #8]
1459:../3rdParty/FreeRTOS/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 6595              		.loc 1 1459 0
 6596 0b44 BB68     		ldr	r3, [r7, #8]
 6597 0b46 5A68     		ldr	r2, [r3, #4]
 6598 0b48 324B     		ldr	r3, .L136+20
 6599 0b4a 1A60     		str	r2, [r3, #0]
 6600              	.L127:
 6601              	.LBE4:
 6602              	.LBB5:
1460:../3rdParty/FreeRTOS/tasks.c **** 			}
1461:../3rdParty/FreeRTOS/tasks.c **** 		}
1462:../3rdParty/FreeRTOS/tasks.c **** 
1463:../3rdParty/FreeRTOS/tasks.c **** 		/* See if this tick has made a timeout expire. */
1464:../3rdParty/FreeRTOS/tasks.c **** 		prvCheckDelayedTasks();
 6603              		.loc 1 1464 0
 6604 0b4c 2D4B     		ldr	r3, .L136+4
 6605 0b4e 1A68     		ldr	r2, [r3, #0]
 6606 0b50 304B     		ldr	r3, .L136+20
 6607 0b52 1B68     		ldr	r3, [r3, #0]
 6608 0b54 9A42     		cmp	r2, r3
 6609 0b56 4DD3     		bcc	.L135
 6610              	.L134:
 6611              		.loc 1 1464 0 is_stmt 0 discriminator 1
 6612 0b58 2B4B     		ldr	r3, .L136+8
 6613 0b5a 1B68     		ldr	r3, [r3, #0]
 6614 0b5c 1B68     		ldr	r3, [r3, #0]
 6615 0b5e 002B     		cmp	r3, #0
 6616 0b60 04D1     		bne	.L130
 6617              		.loc 1 1464 0 discriminator 2
 6618 0b62 2C4B     		ldr	r3, .L136+20
 6619 0b64 4FF0FF32 		mov	r2, #-1
 6620 0b68 1A60     		str	r2, [r3, #0]
 6621 0b6a 43E0     		b	.L135
 6622              	.L130:
 6623              		.loc 1 1464 0 discriminator 3
 6624 0b6c 264B     		ldr	r3, .L136+8
 6625 0b6e 1B68     		ldr	r3, [r3, #0]
 6626 0b70 DB68     		ldr	r3, [r3, #12]
 6627 0b72 DB68     		ldr	r3, [r3, #12]
 6628 0b74 BB60     		str	r3, [r7, #8]
 6629 0b76 BB68     		ldr	r3, [r7, #8]
 6630 0b78 5B68     		ldr	r3, [r3, #4]
 6631 0b7a 7B60     		str	r3, [r7, #4]
 6632 0b7c 214B     		ldr	r3, .L136+4
 6633 0b7e 1A68     		ldr	r2, [r3, #0]
 6634 0b80 7B68     		ldr	r3, [r7, #4]
 6635 0b82 9A42     		cmp	r2, r3
 6636 0b84 03D2     		bcs	.L131
 6637              		.loc 1 1464 0 discriminator 4
 6638 0b86 234B     		ldr	r3, .L136+20
 6639 0b88 7A68     		ldr	r2, [r7, #4]
 6640 0b8a 1A60     		str	r2, [r3, #0]
 6641 0b8c 32E0     		b	.L135
 6642              	.L131:
 6643              		.loc 1 1464 0 discriminator 5
 6644 0b8e BB68     		ldr	r3, [r7, #8]
 6645 0b90 03F10403 		add	r3, r3, #4
 6646 0b94 1846     		mov	r0, r3
 6647 0b96 FFF7FEFF 		bl	vListRemove
 6648 0b9a BB68     		ldr	r3, [r7, #8]
 6649 0b9c 9B6A     		ldr	r3, [r3, #40]
 6650 0b9e 002B     		cmp	r3, #0
 6651 0ba0 05D0     		beq	.L132
 6652              		.loc 1 1464 0 discriminator 6
 6653 0ba2 BB68     		ldr	r3, [r7, #8]
 6654 0ba4 03F11803 		add	r3, r3, #24
 6655 0ba8 1846     		mov	r0, r3
 6656 0baa FFF7FEFF 		bl	vListRemove
 6657              	.L132:
 6658              		.loc 1 1464 0 discriminator 7
 6659 0bae BB68     		ldr	r3, [r7, #8]
 6660 0bb0 DA6A     		ldr	r2, [r3, #44]
 6661 0bb2 194B     		ldr	r3, .L136+24
 6662 0bb4 1B68     		ldr	r3, [r3, #0]
 6663 0bb6 9A42     		cmp	r2, r3
 6664 0bb8 03D9     		bls	.L133
 6665              		.loc 1 1464 0 discriminator 8
 6666 0bba BB68     		ldr	r3, [r7, #8]
 6667 0bbc DA6A     		ldr	r2, [r3, #44]
 6668 0bbe 164B     		ldr	r3, .L136+24
 6669 0bc0 1A60     		str	r2, [r3, #0]
 6670              	.L133:
 6671              		.loc 1 1464 0 discriminator 9
 6672 0bc2 BB68     		ldr	r3, [r7, #8]
 6673 0bc4 DA6A     		ldr	r2, [r3, #44]
 6674 0bc6 1346     		mov	r3, r2
 6675 0bc8 4FEA8303 		lsl	r3, r3, #2
 6676 0bcc 9B18     		adds	r3, r3, r2
 6677 0bce 4FEA8303 		lsl	r3, r3, #2
 6678 0bd2 1A46     		mov	r2, r3
 6679 0bd4 114B     		ldr	r3, .L136+28
 6680 0bd6 D218     		adds	r2, r2, r3
 6681 0bd8 BB68     		ldr	r3, [r7, #8]
 6682 0bda 03F10403 		add	r3, r3, #4
 6683 0bde 1046     		mov	r0, r2
 6684 0be0 1946     		mov	r1, r3
 6685 0be2 FFF7FEFF 		bl	vListInsertEnd
 6686 0be6 B7E7     		b	.L134
 6687              	.L126:
 6688              	.LBE5:
1465:../3rdParty/FreeRTOS/tasks.c **** 	}
1466:../3rdParty/FreeRTOS/tasks.c **** 	else
1467:../3rdParty/FreeRTOS/tasks.c **** 	{
1468:../3rdParty/FreeRTOS/tasks.c **** 		++uxMissedTicks;
 6689              		.loc 1 1468 0 is_stmt 1
 6690 0be8 0D4B     		ldr	r3, .L136+32
 6691 0bea 1B68     		ldr	r3, [r3, #0]
 6692 0bec 03F10102 		add	r2, r3, #1
 6693 0bf0 0B4B     		ldr	r3, .L136+32
 6694 0bf2 1A60     		str	r2, [r3, #0]
 6695              	.L135:
1469:../3rdParty/FreeRTOS/tasks.c **** 
1470:../3rdParty/FreeRTOS/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1471:../3rdParty/FreeRTOS/tasks.c **** 		scheduler is locked. */
1472:../3rdParty/FreeRTOS/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1473:../3rdParty/FreeRTOS/tasks.c **** 		{
1474:../3rdParty/FreeRTOS/tasks.c **** 			//vApplicationTickHook();
1475:../3rdParty/FreeRTOS/tasks.c **** 		}
1476:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1477:../3rdParty/FreeRTOS/tasks.c **** 	}
1478:../3rdParty/FreeRTOS/tasks.c **** 
1479:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1480:../3rdParty/FreeRTOS/tasks.c **** 	{
1481:../3rdParty/FreeRTOS/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1482:../3rdParty/FreeRTOS/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1483:../3rdParty/FreeRTOS/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
 6696              		.loc 1 1483 0
 6697 0bf4 0A4B     		ldr	r3, .L136+32
 6698 0bf6 1B68     		ldr	r3, [r3, #0]
1484:../3rdParty/FreeRTOS/tasks.c **** 		{
1485:../3rdParty/FreeRTOS/tasks.c **** 			//vApplicationTickHook();
1486:../3rdParty/FreeRTOS/tasks.c **** 		}
1487:../3rdParty/FreeRTOS/tasks.c **** 	}
1488:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1489:../3rdParty/FreeRTOS/tasks.c **** 
1490:../3rdParty/FreeRTOS/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1491:../3rdParty/FreeRTOS/tasks.c **** }
 6699              		.loc 1 1491 0
 6700 0bf8 07F11007 		add	r7, r7, #16
 6701 0bfc BD46     		mov	sp, r7
 6702 0bfe 80BD     		pop	{r7, pc}
 6703              	.L137:
 6704              		.align	2
 6705              	.L136:
 6706 0c00 EC000000 		.word	uxSchedulerSuspended
 6707 0c04 DC000000 		.word	xTickCount
 6708 0c08 90000000 		.word	pxDelayedTaskList
 6709 0c0c 94000000 		.word	pxOverflowDelayedTaskList
 6710 0c10 F8000000 		.word	xNumOfOverflows
 6711 0c14 00000000 		.word	xNextTaskUnblockTime
 6712 0c18 E4000000 		.word	uxTopReadyPriority
 6713 0c1c 04000000 		.word	pxReadyTasksLists
 6714 0c20 F0000000 		.word	uxMissedTicks
 6715              		.cfi_endproc
 6716              	.LFE74:
 6718              		.align	2
 6719              		.global	vTaskSwitchContext
 6720              		.thumb
 6721              		.thumb_func
 6723              	vTaskSwitchContext:
 6724              	.LFB75:
1492:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1493:../3rdParty/FreeRTOS/tasks.c **** 
1494:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1495:../3rdParty/FreeRTOS/tasks.c **** 
1496:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1497:../3rdParty/FreeRTOS/tasks.c **** 	{
1498:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *xTCB;
1499:../3rdParty/FreeRTOS/tasks.c **** 
1500:../3rdParty/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1501:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask == NULL )
1502:../3rdParty/FreeRTOS/tasks.c **** 		{
1503:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1504:../3rdParty/FreeRTOS/tasks.c **** 		}
1505:../3rdParty/FreeRTOS/tasks.c **** 		else
1506:../3rdParty/FreeRTOS/tasks.c **** 		{
1507:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1508:../3rdParty/FreeRTOS/tasks.c **** 		}
1509:../3rdParty/FreeRTOS/tasks.c **** 
1510:../3rdParty/FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1511:../3rdParty/FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
1512:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
1513:../3rdParty/FreeRTOS/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1514:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
1515:../3rdParty/FreeRTOS/tasks.c **** 	}
1516:../3rdParty/FreeRTOS/tasks.c **** 
1517:../3rdParty/FreeRTOS/tasks.c **** #endif
1518:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1519:../3rdParty/FreeRTOS/tasks.c **** 
1520:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1521:../3rdParty/FreeRTOS/tasks.c **** 
1522:../3rdParty/FreeRTOS/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1523:../3rdParty/FreeRTOS/tasks.c **** 	{
1524:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *xTCB;
1525:../3rdParty/FreeRTOS/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1526:../3rdParty/FreeRTOS/tasks.c **** 
1527:../3rdParty/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1528:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask == NULL )
1529:../3rdParty/FreeRTOS/tasks.c **** 		{
1530:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1531:../3rdParty/FreeRTOS/tasks.c **** 		}
1532:../3rdParty/FreeRTOS/tasks.c **** 		else
1533:../3rdParty/FreeRTOS/tasks.c **** 		{
1534:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1535:../3rdParty/FreeRTOS/tasks.c **** 		}
1536:../3rdParty/FreeRTOS/tasks.c **** 
1537:../3rdParty/FreeRTOS/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1538:../3rdParty/FreeRTOS/tasks.c **** 		the value can be accessed from an interrupt. */
1539:../3rdParty/FreeRTOS/tasks.c **** 		taskENTER_CRITICAL();
1540:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1541:../3rdParty/FreeRTOS/tasks.c **** 		taskEXIT_CRITICAL();
1542:../3rdParty/FreeRTOS/tasks.c **** 
1543:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
1544:../3rdParty/FreeRTOS/tasks.c **** 	}
1545:../3rdParty/FreeRTOS/tasks.c **** 
1546:../3rdParty/FreeRTOS/tasks.c **** #endif
1547:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1548:../3rdParty/FreeRTOS/tasks.c **** 
1549:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1550:../3rdParty/FreeRTOS/tasks.c **** 
1551:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1552:../3rdParty/FreeRTOS/tasks.c **** 	{
1553:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *xTCB;
1554:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xReturn;
1555:../3rdParty/FreeRTOS/tasks.c **** 
1556:../3rdParty/FreeRTOS/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1557:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask == NULL )
1558:../3rdParty/FreeRTOS/tasks.c **** 		{
1559:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1560:../3rdParty/FreeRTOS/tasks.c **** 		}
1561:../3rdParty/FreeRTOS/tasks.c **** 		else
1562:../3rdParty/FreeRTOS/tasks.c **** 		{
1563:../3rdParty/FreeRTOS/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1564:../3rdParty/FreeRTOS/tasks.c **** 		}
1565:../3rdParty/FreeRTOS/tasks.c **** 
1566:../3rdParty/FreeRTOS/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1567:../3rdParty/FreeRTOS/tasks.c **** 		{
1568:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1569:../3rdParty/FreeRTOS/tasks.c **** 		}
1570:../3rdParty/FreeRTOS/tasks.c **** 		else
1571:../3rdParty/FreeRTOS/tasks.c **** 		{
1572:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdFAIL;
1573:../3rdParty/FreeRTOS/tasks.c **** 		}
1574:../3rdParty/FreeRTOS/tasks.c **** 
1575:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
1576:../3rdParty/FreeRTOS/tasks.c **** 	}
1577:../3rdParty/FreeRTOS/tasks.c **** 
1578:../3rdParty/FreeRTOS/tasks.c **** #endif
1579:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1580:../3rdParty/FreeRTOS/tasks.c **** 
1581:../3rdParty/FreeRTOS/tasks.c **** void vTaskSwitchContext( void )
1582:../3rdParty/FreeRTOS/tasks.c **** {
 6725              		.loc 1 1582 0
 6726              		.cfi_startproc
 6727              		@ args = 0, pretend = 0, frame = 8
 6728              		@ frame_needed = 1, uses_anonymous_args = 0
 6729 0c24 80B5     		push	{r7, lr}
 6730              	.LCFI57:
 6731              		.cfi_def_cfa_offset 8
 6732 0c26 82B0     		sub	sp, sp, #8
 6733              	.LCFI58:
 6734              		.cfi_def_cfa_offset 16
 6735 0c28 00AF     		add	r7, sp, #0
 6736              		.cfi_offset 14, -4
 6737              		.cfi_offset 7, -8
 6738              	.LCFI59:
 6739              		.cfi_def_cfa_register 7
1583:../3rdParty/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 6740              		.loc 1 1583 0
 6741 0c2a 404B     		ldr	r3, .L147
 6742 0c2c 1B68     		ldr	r3, [r3, #0]
 6743 0c2e 002B     		cmp	r3, #0
 6744 0c30 04D0     		beq	.L139
1584:../3rdParty/FreeRTOS/tasks.c **** 	{
1585:../3rdParty/FreeRTOS/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1586:../3rdParty/FreeRTOS/tasks.c **** 		switch. */
1587:../3rdParty/FreeRTOS/tasks.c **** 		xMissedYield = pdTRUE;
 6745              		.loc 1 1587 0
 6746 0c32 3F4B     		ldr	r3, .L147+4
 6747 0c34 4FF00102 		mov	r2, #1
 6748 0c38 1A60     		str	r2, [r3, #0]
 6749 0c3a 73E0     		b	.L138
 6750              	.L139:
 6751              	.LBB6:
1588:../3rdParty/FreeRTOS/tasks.c **** 	}
1589:../3rdParty/FreeRTOS/tasks.c **** 	else
1590:../3rdParty/FreeRTOS/tasks.c **** 	{
1591:../3rdParty/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_OUT();
1592:../3rdParty/FreeRTOS/tasks.c **** 	
1593:../3rdParty/FreeRTOS/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1594:../3rdParty/FreeRTOS/tasks.c **** 		{
1595:../3rdParty/FreeRTOS/tasks.c **** 			unsigned long ulTempCounter;
1596:../3rdParty/FreeRTOS/tasks.c **** 			
1597:../3rdParty/FreeRTOS/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1598:../3rdParty/FreeRTOS/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1599:../3rdParty/FreeRTOS/tasks.c **** 				#else
1600:../3rdParty/FreeRTOS/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 6752              		.loc 1 1600 0
 6753 0c3c 4FF04023 		mov	r3, #1073758208
 6754 0c40 9B68     		ldr	r3, [r3, #8]
 6755 0c42 7B60     		str	r3, [r7, #4]
1601:../3rdParty/FreeRTOS/tasks.c **** 				#endif
1602:../3rdParty/FreeRTOS/tasks.c **** 	
1603:../3rdParty/FreeRTOS/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1604:../3rdParty/FreeRTOS/tasks.c **** 				time so far.  The time the task started running was stored in
1605:../3rdParty/FreeRTOS/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1606:../3rdParty/FreeRTOS/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1607:../3rdParty/FreeRTOS/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1608:../3rdParty/FreeRTOS/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 6756              		.loc 1 1608 0
 6757 0c44 3B4B     		ldr	r3, .L147+8
 6758 0c46 1B68     		ldr	r3, [r3, #0]
 6759 0c48 D96C     		ldr	r1, [r3, #76]
 6760 0c4a 3B4A     		ldr	r2, .L147+12
 6761 0c4c 1268     		ldr	r2, [r2, #0]
 6762 0c4e 7868     		ldr	r0, [r7, #4]
 6763 0c50 821A     		subs	r2, r0, r2
 6764 0c52 8A18     		adds	r2, r1, r2
 6765 0c54 DA64     		str	r2, [r3, #76]
1609:../3rdParty/FreeRTOS/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
 6766              		.loc 1 1609 0
 6767 0c56 384B     		ldr	r3, .L147+12
 6768 0c58 7A68     		ldr	r2, [r7, #4]
 6769 0c5a 1A60     		str	r2, [r3, #0]
 6770              	.LBE6:
1610:../3rdParty/FreeRTOS/tasks.c **** 		}
1611:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1612:../3rdParty/FreeRTOS/tasks.c **** 	
1613:../3rdParty/FreeRTOS/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 6771              		.loc 1 1613 0
 6772 0c5c 354B     		ldr	r3, .L147+8
 6773 0c5e 1B68     		ldr	r3, [r3, #0]
 6774 0c60 1A68     		ldr	r2, [r3, #0]
 6775 0c62 344B     		ldr	r3, .L147+8
 6776 0c64 1B68     		ldr	r3, [r3, #0]
 6777 0c66 1B6B     		ldr	r3, [r3, #48]
 6778 0c68 9A42     		cmp	r2, r3
 6779 0c6a 0AD8     		bhi	.L141
 6780              		.loc 1 1613 0 is_stmt 0 discriminator 1
 6781 0c6c 314B     		ldr	r3, .L147+8
 6782 0c6e 1B68     		ldr	r3, [r3, #0]
 6783 0c70 1A46     		mov	r2, r3
 6784 0c72 304B     		ldr	r3, .L147+8
 6785 0c74 1B68     		ldr	r3, [r3, #0]
 6786 0c76 03F13403 		add	r3, r3, #52
 6787 0c7a 1046     		mov	r0, r2
 6788 0c7c 1946     		mov	r1, r3
 6789 0c7e FFF7FEFF 		bl	vApplicationStackOverflowHook
 6790              	.L141:
 6791              	.LBB7:
1614:../3rdParty/FreeRTOS/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 6792              		.loc 1 1614 0 is_stmt 1
 6793 0c82 2C4B     		ldr	r3, .L147+8
 6794 0c84 1B68     		ldr	r3, [r3, #0]
 6795 0c86 1B6B     		ldr	r3, [r3, #48]
 6796 0c88 1846     		mov	r0, r3
 6797 0c8a 2C49     		ldr	r1, .L147+16
 6798 0c8c 4FF01402 		mov	r2, #20
 6799 0c90 FFF7FEFF 		bl	memcmp
 6800 0c94 0346     		mov	r3, r0
 6801 0c96 002B     		cmp	r3, #0
 6802 0c98 12D0     		beq	.L146
 6803              		.loc 1 1614 0 is_stmt 0 discriminator 1
 6804 0c9a 264B     		ldr	r3, .L147+8
 6805 0c9c 1B68     		ldr	r3, [r3, #0]
 6806 0c9e 1A46     		mov	r2, r3
 6807 0ca0 244B     		ldr	r3, .L147+8
 6808 0ca2 1B68     		ldr	r3, [r3, #0]
 6809 0ca4 03F13403 		add	r3, r3, #52
 6810 0ca8 1046     		mov	r0, r2
 6811 0caa 1946     		mov	r1, r3
 6812 0cac FFF7FEFF 		bl	vApplicationStackOverflowHook
 6813              	.LBE7:
1615:../3rdParty/FreeRTOS/tasks.c **** 	
1616:../3rdParty/FreeRTOS/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */
1617:../3rdParty/FreeRTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 6814              		.loc 1 1617 0 is_stmt 1 discriminator 1
 6815 0cb0 07E0     		b	.L143
 6816              	.L144:
1618:../3rdParty/FreeRTOS/tasks.c **** 		{
1619:../3rdParty/FreeRTOS/tasks.c **** 			configASSERT( uxTopReadyPriority );
1620:../3rdParty/FreeRTOS/tasks.c **** 			--uxTopReadyPriority;
 6817              		.loc 1 1620 0
 6818 0cb2 234B     		ldr	r3, .L147+20
 6819 0cb4 1B68     		ldr	r3, [r3, #0]
 6820 0cb6 03F1FF32 		add	r2, r3, #-1
 6821 0cba 214B     		ldr	r3, .L147+20
 6822 0cbc 1A60     		str	r2, [r3, #0]
 6823 0cbe 00E0     		b	.L143
 6824              	.L146:
1617:../3rdParty/FreeRTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 6825              		.loc 1 1617 0
 6826 0cc0 00BF     		nop
 6827              	.L143:
1617:../3rdParty/FreeRTOS/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 6828              		.loc 1 1617 0 is_stmt 0 discriminator 1
 6829 0cc2 1F4B     		ldr	r3, .L147+20
 6830 0cc4 1A68     		ldr	r2, [r3, #0]
 6831 0cc6 1346     		mov	r3, r2
 6832 0cc8 4FEA8303 		lsl	r3, r3, #2
 6833 0ccc 9B18     		adds	r3, r3, r2
 6834 0cce 4FEA8303 		lsl	r3, r3, #2
 6835 0cd2 1A46     		mov	r2, r3
 6836 0cd4 1B4B     		ldr	r3, .L147+24
 6837 0cd6 D318     		adds	r3, r2, r3
 6838 0cd8 1B68     		ldr	r3, [r3, #0]
 6839 0cda 002B     		cmp	r3, #0
 6840 0cdc E9D0     		beq	.L144
 6841              	.LBB8:
1621:../3rdParty/FreeRTOS/tasks.c **** 		}
1622:../3rdParty/FreeRTOS/tasks.c **** 	
1623:../3rdParty/FreeRTOS/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1624:../3rdParty/FreeRTOS/tasks.c **** 		same priority get an equal share of the processor time. */
1625:../3rdParty/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 6842              		.loc 1 1625 0 is_stmt 1
 6843 0cde 184B     		ldr	r3, .L147+20
 6844 0ce0 1A68     		ldr	r2, [r3, #0]
 6845 0ce2 1346     		mov	r3, r2
 6846 0ce4 4FEA8303 		lsl	r3, r3, #2
 6847 0ce8 9B18     		adds	r3, r3, r2
 6848 0cea 4FEA8303 		lsl	r3, r3, #2
 6849 0cee 1A46     		mov	r2, r3
 6850 0cf0 144B     		ldr	r3, .L147+24
 6851 0cf2 D318     		adds	r3, r2, r3
 6852 0cf4 3B60     		str	r3, [r7, #0]
 6853 0cf6 3B68     		ldr	r3, [r7, #0]
 6854 0cf8 5B68     		ldr	r3, [r3, #4]
 6855 0cfa 5A68     		ldr	r2, [r3, #4]
 6856 0cfc 3B68     		ldr	r3, [r7, #0]
 6857 0cfe 5A60     		str	r2, [r3, #4]
 6858 0d00 3B68     		ldr	r3, [r7, #0]
 6859 0d02 5A68     		ldr	r2, [r3, #4]
 6860 0d04 3B68     		ldr	r3, [r7, #0]
 6861 0d06 03F10803 		add	r3, r3, #8
 6862 0d0a 9A42     		cmp	r2, r3
 6863 0d0c 04D1     		bne	.L145
 6864              		.loc 1 1625 0 is_stmt 0 discriminator 1
 6865 0d0e 3B68     		ldr	r3, [r7, #0]
 6866 0d10 5B68     		ldr	r3, [r3, #4]
 6867 0d12 5A68     		ldr	r2, [r3, #4]
 6868 0d14 3B68     		ldr	r3, [r7, #0]
 6869 0d16 5A60     		str	r2, [r3, #4]
 6870              	.L145:
 6871              		.loc 1 1625 0 discriminator 2
 6872 0d18 3B68     		ldr	r3, [r7, #0]
 6873 0d1a 5B68     		ldr	r3, [r3, #4]
 6874 0d1c DB68     		ldr	r3, [r3, #12]
 6875 0d1e 1A46     		mov	r2, r3
 6876 0d20 044B     		ldr	r3, .L147+8
 6877 0d22 1A60     		str	r2, [r3, #0]
 6878              	.L138:
 6879              	.LBE8:
1626:../3rdParty/FreeRTOS/tasks.c **** 	
1627:../3rdParty/FreeRTOS/tasks.c **** 		traceTASK_SWITCHED_IN();
1628:../3rdParty/FreeRTOS/tasks.c **** 	}
1629:../3rdParty/FreeRTOS/tasks.c **** }
 6880              		.loc 1 1629 0 is_stmt 1
 6881 0d24 07F10807 		add	r7, r7, #8
 6882 0d28 BD46     		mov	sp, r7
 6883 0d2a 80BD     		pop	{r7, pc}
 6884              	.L148:
 6885              		.align	2
 6886              	.L147:
 6887 0d2c EC000000 		.word	uxSchedulerSuspended
 6888 0d30 F4000000 		.word	xMissedYield
 6889 0d34 00000000 		.word	pxCurrentTCB
 6890 0d38 34010000 		.word	ulTaskSwitchedInTime
 6891 0d3c 50000000 		.word	ucExpectedStackBytes.6911
 6892 0d40 E4000000 		.word	uxTopReadyPriority
 6893 0d44 04000000 		.word	pxReadyTasksLists
 6894              		.cfi_endproc
 6895              	.LFE75:
 6897              		.align	2
 6898              		.global	vTaskPlaceOnEventList
 6899              		.thumb
 6900              		.thumb_func
 6902              	vTaskPlaceOnEventList:
 6903              	.LFB76:
1630:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1631:../3rdParty/FreeRTOS/tasks.c **** 
1632:../3rdParty/FreeRTOS/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1633:../3rdParty/FreeRTOS/tasks.c **** {
 6904              		.loc 1 1633 0
 6905              		.cfi_startproc
 6906              		@ args = 0, pretend = 0, frame = 16
 6907              		@ frame_needed = 1, uses_anonymous_args = 0
 6908 0d48 80B5     		push	{r7, lr}
 6909              	.LCFI60:
 6910              		.cfi_def_cfa_offset 8
 6911 0d4a 84B0     		sub	sp, sp, #16
 6912              	.LCFI61:
 6913              		.cfi_def_cfa_offset 24
 6914 0d4c 00AF     		add	r7, sp, #0
 6915              		.cfi_offset 14, -4
 6916              		.cfi_offset 7, -8
 6917              	.LCFI62:
 6918              		.cfi_def_cfa_register 7
 6919 0d4e 7860     		str	r0, [r7, #4]
 6920 0d50 3960     		str	r1, [r7, #0]
1634:../3rdParty/FreeRTOS/tasks.c **** portTickType xTimeToWake;
1635:../3rdParty/FreeRTOS/tasks.c **** 
1636:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxEventList );
1637:../3rdParty/FreeRTOS/tasks.c **** 
1638:../3rdParty/FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1639:../3rdParty/FreeRTOS/tasks.c **** 	SCHEDULER SUSPENDED. */
1640:../3rdParty/FreeRTOS/tasks.c **** 
1641:../3rdParty/FreeRTOS/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1642:../3rdParty/FreeRTOS/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1643:../3rdParty/FreeRTOS/tasks.c **** 	is the first to be woken by the event. */
1644:../3rdParty/FreeRTOS/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 6921              		.loc 1 1644 0
 6922 0d52 144B     		ldr	r3, .L152
 6923 0d54 1B68     		ldr	r3, [r3, #0]
 6924 0d56 03F11803 		add	r3, r3, #24
 6925 0d5a 7868     		ldr	r0, [r7, #4]
 6926 0d5c 1946     		mov	r1, r3
 6927 0d5e FFF7FEFF 		bl	vListInsert
1645:../3rdParty/FreeRTOS/tasks.c **** 
1646:../3rdParty/FreeRTOS/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1647:../3rdParty/FreeRTOS/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1648:../3rdParty/FreeRTOS/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1649:../3rdParty/FreeRTOS/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 6928              		.loc 1 1649 0
 6929 0d62 104B     		ldr	r3, .L152
 6930 0d64 1B68     		ldr	r3, [r3, #0]
 6931 0d66 03F10403 		add	r3, r3, #4
 6932 0d6a 1846     		mov	r0, r3
 6933 0d6c FFF7FEFF 		bl	vListRemove
1650:../3rdParty/FreeRTOS/tasks.c **** 
1651:../3rdParty/FreeRTOS/tasks.c **** 
1652:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1653:../3rdParty/FreeRTOS/tasks.c **** 	{
1654:../3rdParty/FreeRTOS/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 6934              		.loc 1 1654 0
 6935 0d70 3B68     		ldr	r3, [r7, #0]
 6936 0d72 B3F1FF3F 		cmp	r3, #-1
 6937 0d76 08D1     		bne	.L150
1655:../3rdParty/FreeRTOS/tasks.c **** 		{
1656:../3rdParty/FreeRTOS/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1657:../3rdParty/FreeRTOS/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1658:../3rdParty/FreeRTOS/tasks.c **** 			indefinitely. */
1659:../3rdParty/FreeRTOS/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 6938              		.loc 1 1659 0
 6939 0d78 0A4B     		ldr	r3, .L152
 6940 0d7a 1B68     		ldr	r3, [r3, #0]
 6941 0d7c 03F10403 		add	r3, r3, #4
 6942 0d80 0948     		ldr	r0, .L152+4
 6943 0d82 1946     		mov	r1, r3
 6944 0d84 FFF7FEFF 		bl	vListInsertEnd
 6945 0d88 07E0     		b	.L149
 6946              	.L150:
1660:../3rdParty/FreeRTOS/tasks.c **** 		}
1661:../3rdParty/FreeRTOS/tasks.c **** 		else
1662:../3rdParty/FreeRTOS/tasks.c **** 		{
1663:../3rdParty/FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1664:../3rdParty/FreeRTOS/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1665:../3rdParty/FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
 6947              		.loc 1 1665 0
 6948 0d8a 084B     		ldr	r3, .L152+8
 6949 0d8c 1A68     		ldr	r2, [r3, #0]
 6950 0d8e 3B68     		ldr	r3, [r7, #0]
 6951 0d90 D318     		adds	r3, r2, r3
 6952 0d92 FB60     		str	r3, [r7, #12]
1666:../3rdParty/FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 6953              		.loc 1 1666 0
 6954 0d94 F868     		ldr	r0, [r7, #12]
 6955 0d96 00F0C5F9 		bl	prvAddCurrentTaskToDelayedList
 6956              	.L149:
1667:../3rdParty/FreeRTOS/tasks.c **** 		}
1668:../3rdParty/FreeRTOS/tasks.c **** 	}
1669:../3rdParty/FreeRTOS/tasks.c **** 	#else
1670:../3rdParty/FreeRTOS/tasks.c **** 	{
1671:../3rdParty/FreeRTOS/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1672:../3rdParty/FreeRTOS/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1673:../3rdParty/FreeRTOS/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1674:../3rdParty/FreeRTOS/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1675:../3rdParty/FreeRTOS/tasks.c **** 	}
1676:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1677:../3rdParty/FreeRTOS/tasks.c **** }
 6957              		.loc 1 1677 0
 6958 0d9a 07F11007 		add	r7, r7, #16
 6959 0d9e BD46     		mov	sp, r7
 6960 0da0 80BD     		pop	{r7, pc}
 6961              	.L153:
 6962 0da2 00BF     		.align	2
 6963              	.L152:
 6964 0da4 00000000 		.word	pxCurrentTCB
 6965 0da8 C4000000 		.word	xSuspendedTaskList
 6966 0dac DC000000 		.word	xTickCount
 6967              		.cfi_endproc
 6968              	.LFE76:
 6970              		.align	2
 6971              		.global	xTaskRemoveFromEventList
 6972              		.thumb
 6973              		.thumb_func
 6975              	xTaskRemoveFromEventList:
 6976              	.LFB77:
1678:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1679:../3rdParty/FreeRTOS/tasks.c **** 
1680:../3rdParty/FreeRTOS/tasks.c **** #if configUSE_TIMERS == 1
1681:../3rdParty/FreeRTOS/tasks.c **** 
1682:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1683:../3rdParty/FreeRTOS/tasks.c **** 	{
1684:../3rdParty/FreeRTOS/tasks.c **** 	portTickType xTimeToWake;
1685:../3rdParty/FreeRTOS/tasks.c **** 
1686:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxEventList );
1687:../3rdParty/FreeRTOS/tasks.c **** 
1688:../3rdParty/FreeRTOS/tasks.c **** 		/* This function should not be called by application code hence the
1689:../3rdParty/FreeRTOS/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1690:../3rdParty/FreeRTOS/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1691:../3rdParty/FreeRTOS/tasks.c **** 		it should be called from a critical section. */
1692:../3rdParty/FreeRTOS/tasks.c **** 
1693:../3rdParty/FreeRTOS/tasks.c **** 	
1694:../3rdParty/FreeRTOS/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1695:../3rdParty/FreeRTOS/tasks.c **** 		In this case it is assume that this is the only task that is going to
1696:../3rdParty/FreeRTOS/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1697:../3rdParty/FreeRTOS/tasks.c **** 		can be used in place of vListInsert. */
1698:../3rdParty/FreeRTOS/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1699:../3rdParty/FreeRTOS/tasks.c **** 
1700:../3rdParty/FreeRTOS/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1701:../3rdParty/FreeRTOS/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1702:../3rdParty/FreeRTOS/tasks.c **** 		function is called form a critical section. */
1703:../3rdParty/FreeRTOS/tasks.c **** 		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1704:../3rdParty/FreeRTOS/tasks.c **** 
1705:../3rdParty/FreeRTOS/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1706:../3rdParty/FreeRTOS/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1707:../3rdParty/FreeRTOS/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1708:../3rdParty/FreeRTOS/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1709:../3rdParty/FreeRTOS/tasks.c **** 	}
1710:../3rdParty/FreeRTOS/tasks.c **** 	
1711:../3rdParty/FreeRTOS/tasks.c **** #endif /* configUSE_TIMERS */
1712:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1713:../3rdParty/FreeRTOS/tasks.c **** 
1714:../3rdParty/FreeRTOS/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1715:../3rdParty/FreeRTOS/tasks.c **** {
 6977              		.loc 1 1715 0
 6978              		.cfi_startproc
 6979              		@ args = 0, pretend = 0, frame = 16
 6980              		@ frame_needed = 1, uses_anonymous_args = 0
 6981 0db0 80B5     		push	{r7, lr}
 6982              	.LCFI63:
 6983              		.cfi_def_cfa_offset 8
 6984 0db2 84B0     		sub	sp, sp, #16
 6985              	.LCFI64:
 6986              		.cfi_def_cfa_offset 24
 6987 0db4 00AF     		add	r7, sp, #0
 6988              		.cfi_offset 14, -4
 6989              		.cfi_offset 7, -8
 6990              	.LCFI65:
 6991              		.cfi_def_cfa_register 7
 6992 0db6 7860     		str	r0, [r7, #4]
1716:../3rdParty/FreeRTOS/tasks.c **** tskTCB *pxUnblockedTCB;
1717:../3rdParty/FreeRTOS/tasks.c **** portBASE_TYPE xReturn;
1718:../3rdParty/FreeRTOS/tasks.c **** 
1719:../3rdParty/FreeRTOS/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1720:../3rdParty/FreeRTOS/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1721:../3rdParty/FreeRTOS/tasks.c **** 
1722:../3rdParty/FreeRTOS/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1723:../3rdParty/FreeRTOS/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1724:../3rdParty/FreeRTOS/tasks.c **** 	it to the ready list.
1725:../3rdParty/FreeRTOS/tasks.c **** 
1726:../3rdParty/FreeRTOS/tasks.c **** 	If an event is for a queue that is locked then this function will never
1727:../3rdParty/FreeRTOS/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1728:../3rdParty/FreeRTOS/tasks.c **** 	means we can always expect exclusive access to the event list here.
1729:../3rdParty/FreeRTOS/tasks.c **** 	
1730:../3rdParty/FreeRTOS/tasks.c **** 	This function assumes that a check has already been made to ensure that
1731:../3rdParty/FreeRTOS/tasks.c **** 	pxEventList is not empty. */
1732:../3rdParty/FreeRTOS/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 6993              		.loc 1 1732 0
 6994 0db8 7B68     		ldr	r3, [r7, #4]
 6995 0dba DB68     		ldr	r3, [r3, #12]
 6996 0dbc DB68     		ldr	r3, [r3, #12]
 6997 0dbe BB60     		str	r3, [r7, #8]
1733:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxUnblockedTCB );
1734:../3rdParty/FreeRTOS/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 6998              		.loc 1 1734 0
 6999 0dc0 BB68     		ldr	r3, [r7, #8]
 7000 0dc2 03F11803 		add	r3, r3, #24
 7001 0dc6 1846     		mov	r0, r3
 7002 0dc8 FFF7FEFF 		bl	vListRemove
1735:../3rdParty/FreeRTOS/tasks.c **** 
1736:../3rdParty/FreeRTOS/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 7003              		.loc 1 1736 0
 7004 0dcc 204B     		ldr	r3, .L160
 7005 0dce 1B68     		ldr	r3, [r3, #0]
 7006 0dd0 002B     		cmp	r3, #0
 7007 0dd2 22D1     		bne	.L155
1737:../3rdParty/FreeRTOS/tasks.c **** 	{
1738:../3rdParty/FreeRTOS/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 7008              		.loc 1 1738 0
 7009 0dd4 BB68     		ldr	r3, [r7, #8]
 7010 0dd6 03F10403 		add	r3, r3, #4
 7011 0dda 1846     		mov	r0, r3
 7012 0ddc FFF7FEFF 		bl	vListRemove
1739:../3rdParty/FreeRTOS/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 7013              		.loc 1 1739 0
 7014 0de0 BB68     		ldr	r3, [r7, #8]
 7015 0de2 DA6A     		ldr	r2, [r3, #44]
 7016 0de4 1B4B     		ldr	r3, .L160+4
 7017 0de6 1B68     		ldr	r3, [r3, #0]
 7018 0de8 9A42     		cmp	r2, r3
 7019 0dea 03D9     		bls	.L156
 7020              		.loc 1 1739 0 is_stmt 0 discriminator 1
 7021 0dec BB68     		ldr	r3, [r7, #8]
 7022 0dee DA6A     		ldr	r2, [r3, #44]
 7023 0df0 184B     		ldr	r3, .L160+4
 7024 0df2 1A60     		str	r2, [r3, #0]
 7025              	.L156:
 7026              		.loc 1 1739 0 discriminator 2
 7027 0df4 BB68     		ldr	r3, [r7, #8]
 7028 0df6 DA6A     		ldr	r2, [r3, #44]
 7029 0df8 1346     		mov	r3, r2
 7030 0dfa 4FEA8303 		lsl	r3, r3, #2
 7031 0dfe 9B18     		adds	r3, r3, r2
 7032 0e00 4FEA8303 		lsl	r3, r3, #2
 7033 0e04 1A46     		mov	r2, r3
 7034 0e06 144B     		ldr	r3, .L160+8
 7035 0e08 D218     		adds	r2, r2, r3
 7036 0e0a BB68     		ldr	r3, [r7, #8]
 7037 0e0c 03F10403 		add	r3, r3, #4
 7038 0e10 1046     		mov	r0, r2
 7039 0e12 1946     		mov	r1, r3
 7040 0e14 FFF7FEFF 		bl	vListInsertEnd
 7041 0e18 06E0     		b	.L157
 7042              	.L155:
1740:../3rdParty/FreeRTOS/tasks.c **** 	}
1741:../3rdParty/FreeRTOS/tasks.c **** 	else
1742:../3rdParty/FreeRTOS/tasks.c **** 	{
1743:../3rdParty/FreeRTOS/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1744:../3rdParty/FreeRTOS/tasks.c **** 		task pending until the scheduler is resumed. */
1745:../3rdParty/FreeRTOS/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 7043              		.loc 1 1745 0 is_stmt 1
 7044 0e1a BB68     		ldr	r3, [r7, #8]
 7045 0e1c 03F11803 		add	r3, r3, #24
 7046 0e20 0E48     		ldr	r0, .L160+12
 7047 0e22 1946     		mov	r1, r3
 7048 0e24 FFF7FEFF 		bl	vListInsertEnd
 7049              	.L157:
1746:../3rdParty/FreeRTOS/tasks.c **** 	}
1747:../3rdParty/FreeRTOS/tasks.c **** 
1748:../3rdParty/FreeRTOS/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 7050              		.loc 1 1748 0
 7051 0e28 BB68     		ldr	r3, [r7, #8]
 7052 0e2a DA6A     		ldr	r2, [r3, #44]
 7053 0e2c 0C4B     		ldr	r3, .L160+16
 7054 0e2e 1B68     		ldr	r3, [r3, #0]
 7055 0e30 DB6A     		ldr	r3, [r3, #44]
 7056 0e32 9A42     		cmp	r2, r3
 7057 0e34 03D3     		bcc	.L158
1749:../3rdParty/FreeRTOS/tasks.c **** 	{
1750:../3rdParty/FreeRTOS/tasks.c **** 		/* Return true if the task removed from the event list has
1751:../3rdParty/FreeRTOS/tasks.c **** 		a higher priority than the calling task.  This allows
1752:../3rdParty/FreeRTOS/tasks.c **** 		the calling task to know if it should force a context
1753:../3rdParty/FreeRTOS/tasks.c **** 		switch now. */
1754:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = pdTRUE;
 7058              		.loc 1 1754 0
 7059 0e36 4FF00103 		mov	r3, #1
 7060 0e3a FB60     		str	r3, [r7, #12]
 7061 0e3c 02E0     		b	.L159
 7062              	.L158:
1755:../3rdParty/FreeRTOS/tasks.c **** 	}
1756:../3rdParty/FreeRTOS/tasks.c **** 	else
1757:../3rdParty/FreeRTOS/tasks.c **** 	{
1758:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = pdFALSE;
 7063              		.loc 1 1758 0
 7064 0e3e 4FF00003 		mov	r3, #0
 7065 0e42 FB60     		str	r3, [r7, #12]
 7066              	.L159:
1759:../3rdParty/FreeRTOS/tasks.c **** 	}
1760:../3rdParty/FreeRTOS/tasks.c **** 
1761:../3rdParty/FreeRTOS/tasks.c **** 	return xReturn;
 7067              		.loc 1 1761 0
 7068 0e44 FB68     		ldr	r3, [r7, #12]
1762:../3rdParty/FreeRTOS/tasks.c **** }
 7069              		.loc 1 1762 0
 7070 0e46 1846     		mov	r0, r3
 7071 0e48 07F11007 		add	r7, r7, #16
 7072 0e4c BD46     		mov	sp, r7
 7073 0e4e 80BD     		pop	{r7, pc}
 7074              	.L161:
 7075              		.align	2
 7076              	.L160:
 7077 0e50 EC000000 		.word	uxSchedulerSuspended
 7078 0e54 E4000000 		.word	uxTopReadyPriority
 7079 0e58 04000000 		.word	pxReadyTasksLists
 7080 0e5c 98000000 		.word	xPendingReadyList
 7081 0e60 00000000 		.word	pxCurrentTCB
 7082              		.cfi_endproc
 7083              	.LFE77:
 7085              		.align	2
 7086              		.global	vTaskSetTimeOutState
 7087              		.thumb
 7088              		.thumb_func
 7090              	vTaskSetTimeOutState:
 7091              	.LFB78:
1763:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1764:../3rdParty/FreeRTOS/tasks.c **** 
1765:../3rdParty/FreeRTOS/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1766:../3rdParty/FreeRTOS/tasks.c **** {
 7092              		.loc 1 1766 0
 7093              		.cfi_startproc
 7094              		@ args = 0, pretend = 0, frame = 8
 7095              		@ frame_needed = 1, uses_anonymous_args = 0
 7096              		@ link register save eliminated.
 7097 0e64 80B4     		push	{r7}
 7098              	.LCFI66:
 7099              		.cfi_def_cfa_offset 4
 7100 0e66 83B0     		sub	sp, sp, #12
 7101              	.LCFI67:
 7102              		.cfi_def_cfa_offset 16
 7103 0e68 00AF     		add	r7, sp, #0
 7104              		.cfi_offset 7, -4
 7105              	.LCFI68:
 7106              		.cfi_def_cfa_register 7
 7107 0e6a 7860     		str	r0, [r7, #4]
1767:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
1768:../3rdParty/FreeRTOS/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 7108              		.loc 1 1768 0
 7109 0e6c 064B     		ldr	r3, .L163
 7110 0e6e 1A68     		ldr	r2, [r3, #0]
 7111 0e70 7B68     		ldr	r3, [r7, #4]
 7112 0e72 1A60     		str	r2, [r3, #0]
1769:../3rdParty/FreeRTOS/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 7113              		.loc 1 1769 0
 7114 0e74 054B     		ldr	r3, .L163+4
 7115 0e76 1A68     		ldr	r2, [r3, #0]
 7116 0e78 7B68     		ldr	r3, [r7, #4]
 7117 0e7a 5A60     		str	r2, [r3, #4]
1770:../3rdParty/FreeRTOS/tasks.c **** }
 7118              		.loc 1 1770 0
 7119 0e7c 07F10C07 		add	r7, r7, #12
 7120 0e80 BD46     		mov	sp, r7
 7121 0e82 80BC     		pop	{r7}
 7122 0e84 7047     		bx	lr
 7123              	.L164:
 7124 0e86 00BF     		.align	2
 7125              	.L163:
 7126 0e88 F8000000 		.word	xNumOfOverflows
 7127 0e8c DC000000 		.word	xTickCount
 7128              		.cfi_endproc
 7129              	.LFE78:
 7131              		.align	2
 7132              		.global	xTaskCheckForTimeOut
 7133              		.thumb
 7134              		.thumb_func
 7136              	xTaskCheckForTimeOut:
 7137              	.LFB79:
1771:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1772:../3rdParty/FreeRTOS/tasks.c **** 
1773:../3rdParty/FreeRTOS/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1774:../3rdParty/FreeRTOS/tasks.c **** {
 7138              		.loc 1 1774 0
 7139              		.cfi_startproc
 7140              		@ args = 0, pretend = 0, frame = 16
 7141              		@ frame_needed = 1, uses_anonymous_args = 0
 7142 0e90 80B5     		push	{r7, lr}
 7143              	.LCFI69:
 7144              		.cfi_def_cfa_offset 8
 7145 0e92 84B0     		sub	sp, sp, #16
 7146              	.LCFI70:
 7147              		.cfi_def_cfa_offset 24
 7148 0e94 00AF     		add	r7, sp, #0
 7149              		.cfi_offset 14, -4
 7150              		.cfi_offset 7, -8
 7151              	.LCFI71:
 7152              		.cfi_def_cfa_register 7
 7153 0e96 7860     		str	r0, [r7, #4]
 7154 0e98 3960     		str	r1, [r7, #0]
1775:../3rdParty/FreeRTOS/tasks.c **** portBASE_TYPE xReturn;
1776:../3rdParty/FreeRTOS/tasks.c **** 
1777:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxTimeOut );
1778:../3rdParty/FreeRTOS/tasks.c **** 	configASSERT( pxTicksToWait );
1779:../3rdParty/FreeRTOS/tasks.c **** 
1780:../3rdParty/FreeRTOS/tasks.c **** 	taskENTER_CRITICAL();
 7155              		.loc 1 1780 0
 7156 0e9a FFF7FEFF 		bl	vPortEnterCritical
1781:../3rdParty/FreeRTOS/tasks.c **** 	{
1782:../3rdParty/FreeRTOS/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1783:../3rdParty/FreeRTOS/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1784:../3rdParty/FreeRTOS/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1785:../3rdParty/FreeRTOS/tasks.c **** 			therefore never time out. */
1786:../3rdParty/FreeRTOS/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 7157              		.loc 1 1786 0
 7158 0e9e 3B68     		ldr	r3, [r7, #0]
 7159 0ea0 1B68     		ldr	r3, [r3, #0]
 7160 0ea2 B3F1FF3F 		cmp	r3, #-1
 7161 0ea6 03D1     		bne	.L166
1787:../3rdParty/FreeRTOS/tasks.c **** 			{
1788:../3rdParty/FreeRTOS/tasks.c **** 				xReturn = pdFALSE;
 7162              		.loc 1 1788 0
 7163 0ea8 4FF00003 		mov	r3, #0
 7164 0eac FB60     		str	r3, [r7, #12]
 7165 0eae 2CE0     		b	.L167
 7166              	.L166:
1789:../3rdParty/FreeRTOS/tasks.c **** 			}
1790:../3rdParty/FreeRTOS/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1791:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1792:../3rdParty/FreeRTOS/tasks.c **** 
1793:../3rdParty/FreeRTOS/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 7167              		.loc 1 1793 0
 7168 0eb0 7B68     		ldr	r3, [r7, #4]
 7169 0eb2 1A68     		ldr	r2, [r3, #0]
 7170 0eb4 194B     		ldr	r3, .L170
 7171 0eb6 1B68     		ldr	r3, [r3, #0]
 7172 0eb8 9A42     		cmp	r2, r3
 7173 0eba 09D0     		beq	.L168
 7174              		.loc 1 1793 0 is_stmt 0 discriminator 1
 7175 0ebc 7B68     		ldr	r3, [r7, #4]
 7176 0ebe 5A68     		ldr	r2, [r3, #4]
 7177 0ec0 174B     		ldr	r3, .L170+4
 7178 0ec2 1B68     		ldr	r3, [r3, #0]
 7179 0ec4 9A42     		cmp	r2, r3
 7180 0ec6 03D8     		bhi	.L168
1794:../3rdParty/FreeRTOS/tasks.c **** 		{
1795:../3rdParty/FreeRTOS/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1796:../3rdParty/FreeRTOS/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1797:../3rdParty/FreeRTOS/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1798:../3rdParty/FreeRTOS/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1799:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
 7181              		.loc 1 1799 0 is_stmt 1
 7182 0ec8 4FF00103 		mov	r3, #1
 7183 0ecc FB60     		str	r3, [r7, #12]
 7184 0ece 1CE0     		b	.L167
 7185              	.L168:
1800:../3rdParty/FreeRTOS/tasks.c **** 		}
1801:../3rdParty/FreeRTOS/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 7186              		.loc 1 1801 0
 7187 0ed0 134B     		ldr	r3, .L170+4
 7188 0ed2 1A68     		ldr	r2, [r3, #0]
 7189 0ed4 7B68     		ldr	r3, [r7, #4]
 7190 0ed6 5B68     		ldr	r3, [r3, #4]
 7191 0ed8 D21A     		subs	r2, r2, r3
 7192 0eda 3B68     		ldr	r3, [r7, #0]
 7193 0edc 1B68     		ldr	r3, [r3, #0]
 7194 0ede 9A42     		cmp	r2, r3
 7195 0ee0 10D2     		bcs	.L169
1802:../3rdParty/FreeRTOS/tasks.c **** 		{
1803:../3rdParty/FreeRTOS/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1804:../3rdParty/FreeRTOS/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 7196              		.loc 1 1804 0
 7197 0ee2 3B68     		ldr	r3, [r7, #0]
 7198 0ee4 1A68     		ldr	r2, [r3, #0]
 7199 0ee6 7B68     		ldr	r3, [r7, #4]
 7200 0ee8 5968     		ldr	r1, [r3, #4]
 7201 0eea 0D4B     		ldr	r3, .L170+4
 7202 0eec 1B68     		ldr	r3, [r3, #0]
 7203 0eee CB1A     		subs	r3, r1, r3
 7204 0ef0 D218     		adds	r2, r2, r3
 7205 0ef2 3B68     		ldr	r3, [r7, #0]
 7206 0ef4 1A60     		str	r2, [r3, #0]
1805:../3rdParty/FreeRTOS/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 7207              		.loc 1 1805 0
 7208 0ef6 7868     		ldr	r0, [r7, #4]
 7209 0ef8 FFF7FEFF 		bl	vTaskSetTimeOutState
1806:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdFALSE;
 7210              		.loc 1 1806 0
 7211 0efc 4FF00003 		mov	r3, #0
 7212 0f00 FB60     		str	r3, [r7, #12]
 7213 0f02 02E0     		b	.L167
 7214              	.L169:
1807:../3rdParty/FreeRTOS/tasks.c **** 		}
1808:../3rdParty/FreeRTOS/tasks.c **** 		else
1809:../3rdParty/FreeRTOS/tasks.c **** 		{
1810:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = pdTRUE;
 7215              		.loc 1 1810 0
 7216 0f04 4FF00103 		mov	r3, #1
 7217 0f08 FB60     		str	r3, [r7, #12]
 7218              	.L167:
1811:../3rdParty/FreeRTOS/tasks.c **** 		}
1812:../3rdParty/FreeRTOS/tasks.c **** 	}
1813:../3rdParty/FreeRTOS/tasks.c **** 	taskEXIT_CRITICAL();
 7219              		.loc 1 1813 0
 7220 0f0a FFF7FEFF 		bl	vPortExitCritical
1814:../3rdParty/FreeRTOS/tasks.c **** 
1815:../3rdParty/FreeRTOS/tasks.c **** 	return xReturn;
 7221              		.loc 1 1815 0
 7222 0f0e FB68     		ldr	r3, [r7, #12]
1816:../3rdParty/FreeRTOS/tasks.c **** }
 7223              		.loc 1 1816 0
 7224 0f10 1846     		mov	r0, r3
 7225 0f12 07F11007 		add	r7, r7, #16
 7226 0f16 BD46     		mov	sp, r7
 7227 0f18 80BD     		pop	{r7, pc}
 7228              	.L171:
 7229 0f1a 00BF     		.align	2
 7230              	.L170:
 7231 0f1c F8000000 		.word	xNumOfOverflows
 7232 0f20 DC000000 		.word	xTickCount
 7233              		.cfi_endproc
 7234              	.LFE79:
 7236              		.align	2
 7237              		.global	vTaskMissedYield
 7238              		.thumb
 7239              		.thumb_func
 7241              	vTaskMissedYield:
 7242              	.LFB80:
1817:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1818:../3rdParty/FreeRTOS/tasks.c **** 
1819:../3rdParty/FreeRTOS/tasks.c **** void vTaskMissedYield( void )
1820:../3rdParty/FreeRTOS/tasks.c **** {
 7243              		.loc 1 1820 0
 7244              		.cfi_startproc
 7245              		@ args = 0, pretend = 0, frame = 0
 7246              		@ frame_needed = 1, uses_anonymous_args = 0
 7247              		@ link register save eliminated.
 7248 0f24 80B4     		push	{r7}
 7249              	.LCFI72:
 7250              		.cfi_def_cfa_offset 4
 7251 0f26 00AF     		add	r7, sp, #0
 7252              		.cfi_offset 7, -4
 7253              	.LCFI73:
 7254              		.cfi_def_cfa_register 7
1821:../3rdParty/FreeRTOS/tasks.c **** 	xMissedYield = pdTRUE;
 7255              		.loc 1 1821 0
 7256 0f28 034B     		ldr	r3, .L173
 7257 0f2a 4FF00102 		mov	r2, #1
 7258 0f2e 1A60     		str	r2, [r3, #0]
1822:../3rdParty/FreeRTOS/tasks.c **** }
 7259              		.loc 1 1822 0
 7260 0f30 BD46     		mov	sp, r7
 7261 0f32 80BC     		pop	{r7}
 7262 0f34 7047     		bx	lr
 7263              	.L174:
 7264 0f36 00BF     		.align	2
 7265              	.L173:
 7266 0f38 F4000000 		.word	xMissedYield
 7267              		.cfi_endproc
 7268              	.LFE80:
 7270              		.align	2
 7271              		.global	uxTaskGetTaskNumber
 7272              		.thumb
 7273              		.thumb_func
 7275              	uxTaskGetTaskNumber:
 7276              	.LFB81:
1823:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1824:../3rdParty/FreeRTOS/tasks.c **** 
1825:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1826:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
1827:../3rdParty/FreeRTOS/tasks.c **** 	{
 7277              		.loc 1 1827 0
 7278              		.cfi_startproc
 7279              		@ args = 0, pretend = 0, frame = 16
 7280              		@ frame_needed = 1, uses_anonymous_args = 0
 7281              		@ link register save eliminated.
 7282 0f3c 80B4     		push	{r7}
 7283              	.LCFI74:
 7284              		.cfi_def_cfa_offset 4
 7285 0f3e 85B0     		sub	sp, sp, #20
 7286              	.LCFI75:
 7287              		.cfi_def_cfa_offset 24
 7288 0f40 00AF     		add	r7, sp, #0
 7289              		.cfi_offset 7, -4
 7290              	.LCFI76:
 7291              		.cfi_def_cfa_register 7
 7292 0f42 7860     		str	r0, [r7, #4]
1828:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
1829:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1830:../3rdParty/FreeRTOS/tasks.c **** 	
1831:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask != NULL )
 7293              		.loc 1 1831 0
 7294 0f44 7B68     		ldr	r3, [r7, #4]
 7295 0f46 002B     		cmp	r3, #0
 7296 0f48 05D0     		beq	.L176
1832:../3rdParty/FreeRTOS/tasks.c **** 		{
1833:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
 7297              		.loc 1 1833 0
 7298 0f4a 7B68     		ldr	r3, [r7, #4]
 7299 0f4c BB60     		str	r3, [r7, #8]
1834:../3rdParty/FreeRTOS/tasks.c **** 			uxReturn = pxTCB->uxTaskNumber;
 7300              		.loc 1 1834 0
 7301 0f4e BB68     		ldr	r3, [r7, #8]
 7302 0f50 5B6C     		ldr	r3, [r3, #68]
 7303 0f52 FB60     		str	r3, [r7, #12]
 7304 0f54 02E0     		b	.L177
 7305              	.L176:
1835:../3rdParty/FreeRTOS/tasks.c **** 		}
1836:../3rdParty/FreeRTOS/tasks.c **** 		else
1837:../3rdParty/FreeRTOS/tasks.c **** 		{
1838:../3rdParty/FreeRTOS/tasks.c **** 			uxReturn = 0U;
 7306              		.loc 1 1838 0
 7307 0f56 4FF00003 		mov	r3, #0
 7308 0f5a FB60     		str	r3, [r7, #12]
 7309              	.L177:
1839:../3rdParty/FreeRTOS/tasks.c **** 		}
1840:../3rdParty/FreeRTOS/tasks.c **** 		
1841:../3rdParty/FreeRTOS/tasks.c **** 		return uxReturn;
 7310              		.loc 1 1841 0
 7311 0f5c FB68     		ldr	r3, [r7, #12]
1842:../3rdParty/FreeRTOS/tasks.c **** 	}
 7312              		.loc 1 1842 0
 7313 0f5e 1846     		mov	r0, r3
 7314 0f60 07F11407 		add	r7, r7, #20
 7315 0f64 BD46     		mov	sp, r7
 7316 0f66 80BC     		pop	{r7}
 7317 0f68 7047     		bx	lr
 7318              		.cfi_endproc
 7319              	.LFE81:
 7321 0f6a 00BF     		.align	2
 7322              		.global	vTaskSetTaskNumber
 7323              		.thumb
 7324              		.thumb_func
 7326              	vTaskSetTaskNumber:
 7327              	.LFB82:
1843:../3rdParty/FreeRTOS/tasks.c **** #endif
1844:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
1845:../3rdParty/FreeRTOS/tasks.c **** 
1846:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1847:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
1848:../3rdParty/FreeRTOS/tasks.c **** 	{
 7328              		.loc 1 1848 0
 7329              		.cfi_startproc
 7330              		@ args = 0, pretend = 0, frame = 16
 7331              		@ frame_needed = 1, uses_anonymous_args = 0
 7332              		@ link register save eliminated.
 7333 0f6c 80B4     		push	{r7}
 7334              	.LCFI77:
 7335              		.cfi_def_cfa_offset 4
 7336 0f6e 85B0     		sub	sp, sp, #20
 7337              	.LCFI78:
 7338              		.cfi_def_cfa_offset 24
 7339 0f70 00AF     		add	r7, sp, #0
 7340              		.cfi_offset 7, -4
 7341              	.LCFI79:
 7342              		.cfi_def_cfa_register 7
 7343 0f72 7860     		str	r0, [r7, #4]
 7344 0f74 3960     		str	r1, [r7, #0]
1849:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
1850:../3rdParty/FreeRTOS/tasks.c **** 	
1851:../3rdParty/FreeRTOS/tasks.c **** 		if( xTask != NULL )
 7345              		.loc 1 1851 0
 7346 0f76 7B68     		ldr	r3, [r7, #4]
 7347 0f78 002B     		cmp	r3, #0
 7348 0f7a 04D0     		beq	.L178
1852:../3rdParty/FreeRTOS/tasks.c **** 		{
1853:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB = ( tskTCB * ) xTask;
 7349              		.loc 1 1853 0
 7350 0f7c 7B68     		ldr	r3, [r7, #4]
 7351 0f7e FB60     		str	r3, [r7, #12]
1854:../3rdParty/FreeRTOS/tasks.c **** 			pxTCB->uxTaskNumber = uxHandle;
 7352              		.loc 1 1854 0
 7353 0f80 FB68     		ldr	r3, [r7, #12]
 7354 0f82 3A68     		ldr	r2, [r7, #0]
 7355 0f84 5A64     		str	r2, [r3, #68]
 7356              	.L178:
1855:../3rdParty/FreeRTOS/tasks.c **** 		}
1856:../3rdParty/FreeRTOS/tasks.c **** 	}
 7357              		.loc 1 1856 0
 7358 0f86 07F11407 		add	r7, r7, #20
 7359 0f8a BD46     		mov	sp, r7
 7360 0f8c 80BC     		pop	{r7}
 7361 0f8e 7047     		bx	lr
 7362              		.cfi_endproc
 7363              	.LFE82:
 7365              		.align	2
 7366              		.thumb
 7367              		.thumb_func
 7369              	prvIdleTask:
 7370              	.LFB83:
1857:../3rdParty/FreeRTOS/tasks.c **** #endif
1858:../3rdParty/FreeRTOS/tasks.c **** 
1859:../3rdParty/FreeRTOS/tasks.c **** 
1860:../3rdParty/FreeRTOS/tasks.c **** /*
1861:../3rdParty/FreeRTOS/tasks.c ****  * -----------------------------------------------------------
1862:../3rdParty/FreeRTOS/tasks.c ****  * The Idle task.
1863:../3rdParty/FreeRTOS/tasks.c ****  * ----------------------------------------------------------
1864:../3rdParty/FreeRTOS/tasks.c ****  *
1865:../3rdParty/FreeRTOS/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1866:../3rdParty/FreeRTOS/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1867:../3rdParty/FreeRTOS/tasks.c ****  *
1868:../3rdParty/FreeRTOS/tasks.c ****  * void prvIdleTask( void *pvParameters );
1869:../3rdParty/FreeRTOS/tasks.c ****  *
1870:../3rdParty/FreeRTOS/tasks.c ****  */
1871:../3rdParty/FreeRTOS/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1872:../3rdParty/FreeRTOS/tasks.c **** {
 7371              		.loc 1 1872 0
 7372              		.cfi_startproc
 7373              		@ args = 0, pretend = 0, frame = 8
 7374              		@ frame_needed = 1, uses_anonymous_args = 0
 7375 0f90 80B5     		push	{r7, lr}
 7376              	.LCFI80:
 7377              		.cfi_def_cfa_offset 8
 7378 0f92 82B0     		sub	sp, sp, #8
 7379              	.LCFI81:
 7380              		.cfi_def_cfa_offset 16
 7381 0f94 00AF     		add	r7, sp, #0
 7382              		.cfi_offset 14, -4
 7383              		.cfi_offset 7, -8
 7384              	.LCFI82:
 7385              		.cfi_def_cfa_register 7
 7386 0f96 7860     		str	r0, [r7, #4]
 7387              	.L181:
1873:../3rdParty/FreeRTOS/tasks.c **** 	/* Stop warnings. */
1874:../3rdParty/FreeRTOS/tasks.c **** 	( void ) pvParameters;
1875:../3rdParty/FreeRTOS/tasks.c **** 
1876:../3rdParty/FreeRTOS/tasks.c **** 	for( ;; )
1877:../3rdParty/FreeRTOS/tasks.c **** 	{
1878:../3rdParty/FreeRTOS/tasks.c **** 		/* See if any tasks have been deleted. */
1879:../3rdParty/FreeRTOS/tasks.c **** 		prvCheckTasksWaitingTermination();
 7388              		.loc 1 1879 0 discriminator 1
 7389 0f98 00F088F8 		bl	prvCheckTasksWaitingTermination
1880:../3rdParty/FreeRTOS/tasks.c **** 
1881:../3rdParty/FreeRTOS/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1882:../3rdParty/FreeRTOS/tasks.c **** 		{
1883:../3rdParty/FreeRTOS/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1884:../3rdParty/FreeRTOS/tasks.c **** 			see if any other task has become available.  If we are using
1885:../3rdParty/FreeRTOS/tasks.c **** 			preemption we don't need to do this as any task becoming available
1886:../3rdParty/FreeRTOS/tasks.c **** 			will automatically get the processor anyway. */
1887:../3rdParty/FreeRTOS/tasks.c **** 			taskYIELD();
1888:../3rdParty/FreeRTOS/tasks.c **** 		}
1889:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1890:../3rdParty/FreeRTOS/tasks.c **** 
1891:../3rdParty/FreeRTOS/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1892:../3rdParty/FreeRTOS/tasks.c **** 		{
1893:../3rdParty/FreeRTOS/tasks.c **** 			/* When using preemption tasks of equal priority will be
1894:../3rdParty/FreeRTOS/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1895:../3rdParty/FreeRTOS/tasks.c **** 			to run then the idle task should yield before the end of the
1896:../3rdParty/FreeRTOS/tasks.c **** 			timeslice.
1897:../3rdParty/FreeRTOS/tasks.c **** 
1898:../3rdParty/FreeRTOS/tasks.c **** 			A critical region is not required here as we are just reading from
1899:../3rdParty/FreeRTOS/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1900:../3rdParty/FreeRTOS/tasks.c **** 			the ready list at the idle priority contains more than one task
1901:../3rdParty/FreeRTOS/tasks.c **** 			then a task other than the idle task is ready to execute. */
1902:../3rdParty/FreeRTOS/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1903:../3rdParty/FreeRTOS/tasks.c **** 			{
1904:../3rdParty/FreeRTOS/tasks.c **** 				taskYIELD();
1905:../3rdParty/FreeRTOS/tasks.c **** 			}
1906:../3rdParty/FreeRTOS/tasks.c **** 		}
1907:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1908:../3rdParty/FreeRTOS/tasks.c **** 
1909:../3rdParty/FreeRTOS/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1910:../3rdParty/FreeRTOS/tasks.c **** 		{
1911:../3rdParty/FreeRTOS/tasks.c **** 			extern void vApplicationIdleHook( void );
1912:../3rdParty/FreeRTOS/tasks.c **** 
1913:../3rdParty/FreeRTOS/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1914:../3rdParty/FreeRTOS/tasks.c **** 			allows the application designer to add background functionality
1915:../3rdParty/FreeRTOS/tasks.c **** 			without the overhead of a separate task.
1916:../3rdParty/FreeRTOS/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1917:../3rdParty/FreeRTOS/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1918:../3rdParty/FreeRTOS/tasks.c **** 			vApplicationIdleHook();
1919:../3rdParty/FreeRTOS/tasks.c **** 		}
1920:../3rdParty/FreeRTOS/tasks.c **** 		#endif
1921:../3rdParty/FreeRTOS/tasks.c **** 	}
 7390              		.loc 1 1921 0 discriminator 1
 7391 0f9c FCE7     		b	.L181
 7392              		.cfi_endproc
 7393              	.LFE83:
 7395 0f9e 00BF     		.align	2
 7396              		.thumb
 7397              		.thumb_func
 7399              	prvInitialiseTCBVariables:
 7400              	.LFB84:
1922:../3rdParty/FreeRTOS/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1923:../3rdParty/FreeRTOS/tasks.c **** 
1924:../3rdParty/FreeRTOS/tasks.c **** 
1925:../3rdParty/FreeRTOS/tasks.c **** 
1926:../3rdParty/FreeRTOS/tasks.c **** 
1927:../3rdParty/FreeRTOS/tasks.c **** 
1928:../3rdParty/FreeRTOS/tasks.c **** 
1929:../3rdParty/FreeRTOS/tasks.c **** 
1930:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------
1931:../3rdParty/FreeRTOS/tasks.c ****  * File private functions documented at the top of the file.
1932:../3rdParty/FreeRTOS/tasks.c ****  *----------------------------------------------------------*/
1933:../3rdParty/FreeRTOS/tasks.c **** 
1934:../3rdParty/FreeRTOS/tasks.c **** 
1935:../3rdParty/FreeRTOS/tasks.c **** 
1936:../3rdParty/FreeRTOS/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1937:../3rdParty/FreeRTOS/tasks.c **** {
 7401              		.loc 1 1937 0
 7402              		.cfi_startproc
 7403              		@ args = 4, pretend = 0, frame = 16
 7404              		@ frame_needed = 1, uses_anonymous_args = 0
 7405 0fa0 80B5     		push	{r7, lr}
 7406              	.LCFI83:
 7407              		.cfi_def_cfa_offset 8
 7408 0fa2 84B0     		sub	sp, sp, #16
 7409              	.LCFI84:
 7410              		.cfi_def_cfa_offset 24
 7411 0fa4 00AF     		add	r7, sp, #0
 7412              		.cfi_offset 14, -4
 7413              		.cfi_offset 7, -8
 7414              	.LCFI85:
 7415              		.cfi_def_cfa_register 7
 7416 0fa6 F860     		str	r0, [r7, #12]
 7417 0fa8 B960     		str	r1, [r7, #8]
 7418 0faa 7A60     		str	r2, [r7, #4]
 7419 0fac 3B60     		str	r3, [r7, #0]
1938:../3rdParty/FreeRTOS/tasks.c **** 	/* Store the function name in the TCB. */
1939:../3rdParty/FreeRTOS/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1940:../3rdParty/FreeRTOS/tasks.c **** 	{
1941:../3rdParty/FreeRTOS/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1942:../3rdParty/FreeRTOS/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 7420              		.loc 1 1942 0
 7421 0fae FB68     		ldr	r3, [r7, #12]
 7422 0fb0 03F13403 		add	r3, r3, #52
 7423 0fb4 1A46     		mov	r2, r3
 7424 0fb6 BB68     		ldr	r3, [r7, #8]
 7425 0fb8 1046     		mov	r0, r2
 7426 0fba 1946     		mov	r1, r3
 7427 0fbc 4FF00C02 		mov	r2, #12
 7428 0fc0 FFF7FEFF 		bl	strncpy
1943:../3rdParty/FreeRTOS/tasks.c **** 	}
1944:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1945:../3rdParty/FreeRTOS/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
 7429              		.loc 1 1945 0
 7430 0fc4 FB68     		ldr	r3, [r7, #12]
 7431 0fc6 4FF00002 		mov	r2, #0
 7432 0fca 83F83F20 		strb	r2, [r3, #63]
1946:../3rdParty/FreeRTOS/tasks.c **** 
1947:../3rdParty/FreeRTOS/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1948:../3rdParty/FreeRTOS/tasks.c **** 	remove the privilege bit if one is present. */
1949:../3rdParty/FreeRTOS/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 7433              		.loc 1 1949 0
 7434 0fce 7B68     		ldr	r3, [r7, #4]
 7435 0fd0 042B     		cmp	r3, #4
 7436 0fd2 02D9     		bls	.L183
1950:../3rdParty/FreeRTOS/tasks.c **** 	{
1951:../3rdParty/FreeRTOS/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 7437              		.loc 1 1951 0
 7438 0fd4 4FF00403 		mov	r3, #4
 7439 0fd8 7B60     		str	r3, [r7, #4]
 7440              	.L183:
1952:../3rdParty/FreeRTOS/tasks.c **** 	}
1953:../3rdParty/FreeRTOS/tasks.c **** 
1954:../3rdParty/FreeRTOS/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 7441              		.loc 1 1954 0
 7442 0fda FB68     		ldr	r3, [r7, #12]
 7443 0fdc 7A68     		ldr	r2, [r7, #4]
 7444 0fde DA62     		str	r2, [r3, #44]
1955:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
1956:../3rdParty/FreeRTOS/tasks.c **** 	{
1957:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 7445              		.loc 1 1957 0
 7446 0fe0 FB68     		ldr	r3, [r7, #12]
 7447 0fe2 7A68     		ldr	r2, [r7, #4]
 7448 0fe4 9A64     		str	r2, [r3, #72]
1958:../3rdParty/FreeRTOS/tasks.c **** 	}
1959:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1960:../3rdParty/FreeRTOS/tasks.c **** 
1961:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 7449              		.loc 1 1961 0
 7450 0fe6 FB68     		ldr	r3, [r7, #12]
 7451 0fe8 03F10403 		add	r3, r3, #4
 7452 0fec 1846     		mov	r0, r3
 7453 0fee FFF7FEFF 		bl	vListInitialiseItem
1962:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 7454              		.loc 1 1962 0
 7455 0ff2 FB68     		ldr	r3, [r7, #12]
 7456 0ff4 03F11803 		add	r3, r3, #24
 7457 0ff8 1846     		mov	r0, r3
 7458 0ffa FFF7FEFF 		bl	vListInitialiseItem
1963:../3rdParty/FreeRTOS/tasks.c **** 
1964:../3rdParty/FreeRTOS/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1965:../3rdParty/FreeRTOS/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
1966:../3rdParty/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 7459              		.loc 1 1966 0
 7460 0ffe FB68     		ldr	r3, [r7, #12]
 7461 1000 FA68     		ldr	r2, [r7, #12]
 7462 1002 1A61     		str	r2, [r3, #16]
1967:../3rdParty/FreeRTOS/tasks.c **** 
1968:../3rdParty/FreeRTOS/tasks.c **** 	/* Event lists are always in priority order. */
1969:../3rdParty/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 7463              		.loc 1 1969 0
 7464 1004 7B68     		ldr	r3, [r7, #4]
 7465 1006 C3F10502 		rsb	r2, r3, #5
 7466 100a FB68     		ldr	r3, [r7, #12]
 7467 100c 9A61     		str	r2, [r3, #24]
1970:../3rdParty/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 7468              		.loc 1 1970 0
 7469 100e FB68     		ldr	r3, [r7, #12]
 7470 1010 FA68     		ldr	r2, [r7, #12]
 7471 1012 5A62     		str	r2, [r3, #36]
1971:../3rdParty/FreeRTOS/tasks.c **** 
1972:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1973:../3rdParty/FreeRTOS/tasks.c **** 	{
1974:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
1975:../3rdParty/FreeRTOS/tasks.c **** 	}
1976:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1977:../3rdParty/FreeRTOS/tasks.c **** 
1978:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1979:../3rdParty/FreeRTOS/tasks.c **** 	{
1980:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB->pxTaskTag = NULL;
1981:../3rdParty/FreeRTOS/tasks.c **** 	}
1982:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1983:../3rdParty/FreeRTOS/tasks.c **** 
1984:../3rdParty/FreeRTOS/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1985:../3rdParty/FreeRTOS/tasks.c **** 	{
1986:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
 7472              		.loc 1 1986 0
 7473 1014 FB68     		ldr	r3, [r7, #12]
 7474 1016 4FF00002 		mov	r2, #0
 7475 101a DA64     		str	r2, [r3, #76]
1987:../3rdParty/FreeRTOS/tasks.c **** 	}
1988:../3rdParty/FreeRTOS/tasks.c **** 	#endif
1989:../3rdParty/FreeRTOS/tasks.c **** 
1990:../3rdParty/FreeRTOS/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1991:../3rdParty/FreeRTOS/tasks.c **** 	{
1992:../3rdParty/FreeRTOS/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1993:../3rdParty/FreeRTOS/tasks.c **** 	}
1994:../3rdParty/FreeRTOS/tasks.c **** 	#else
1995:../3rdParty/FreeRTOS/tasks.c **** 	{
1996:../3rdParty/FreeRTOS/tasks.c **** 		( void ) xRegions;
1997:../3rdParty/FreeRTOS/tasks.c **** 		( void ) usStackDepth;
1998:../3rdParty/FreeRTOS/tasks.c **** 	}
1999:../3rdParty/FreeRTOS/tasks.c **** 	#endif
2000:../3rdParty/FreeRTOS/tasks.c **** }
 7476              		.loc 1 2000 0
 7477 101c 07F11007 		add	r7, r7, #16
 7478 1020 BD46     		mov	sp, r7
 7479 1022 80BD     		pop	{r7, pc}
 7480              		.cfi_endproc
 7481              	.LFE84:
 7483              		.align	2
 7484              		.thumb
 7485              		.thumb_func
 7487              	prvInitialiseTaskLists:
 7488              	.LFB85:
2001:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2002:../3rdParty/FreeRTOS/tasks.c **** 
2003:../3rdParty/FreeRTOS/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2004:../3rdParty/FreeRTOS/tasks.c **** 
2005:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2006:../3rdParty/FreeRTOS/tasks.c **** 	{
2007:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
2008:../3rdParty/FreeRTOS/tasks.c **** 	
2009:../3rdParty/FreeRTOS/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2010:../3rdParty/FreeRTOS/tasks.c **** 		{
2011:../3rdParty/FreeRTOS/tasks.c **** 			xTaskToModify = NULL;
2012:../3rdParty/FreeRTOS/tasks.c **** 		}
2013:../3rdParty/FreeRTOS/tasks.c **** 
2014:../3rdParty/FreeRTOS/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2015:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2016:../3rdParty/FreeRTOS/tasks.c **** 
2017:../3rdParty/FreeRTOS/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2018:../3rdParty/FreeRTOS/tasks.c **** 	}
2019:../3rdParty/FreeRTOS/tasks.c **** 	/*-----------------------------------------------------------*/
2020:../3rdParty/FreeRTOS/tasks.c **** #endif
2021:../3rdParty/FreeRTOS/tasks.c **** 
2022:../3rdParty/FreeRTOS/tasks.c **** static void prvInitialiseTaskLists( void )
2023:../3rdParty/FreeRTOS/tasks.c **** {
 7489              		.loc 1 2023 0
 7490              		.cfi_startproc
 7491              		@ args = 0, pretend = 0, frame = 8
 7492              		@ frame_needed = 1, uses_anonymous_args = 0
 7493 1024 80B5     		push	{r7, lr}
 7494              	.LCFI86:
 7495              		.cfi_def_cfa_offset 8
 7496 1026 82B0     		sub	sp, sp, #8
 7497              	.LCFI87:
 7498              		.cfi_def_cfa_offset 16
 7499 1028 00AF     		add	r7, sp, #0
 7500              		.cfi_offset 14, -4
 7501              		.cfi_offset 7, -8
 7502              	.LCFI88:
 7503              		.cfi_def_cfa_register 7
2024:../3rdParty/FreeRTOS/tasks.c **** unsigned portBASE_TYPE uxPriority;
2025:../3rdParty/FreeRTOS/tasks.c **** 
2026:../3rdParty/FreeRTOS/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 7504              		.loc 1 2026 0
 7505 102a 4FF00003 		mov	r3, #0
 7506 102e 7B60     		str	r3, [r7, #4]
 7507 1030 10E0     		b	.L185
 7508              	.L186:
2027:../3rdParty/FreeRTOS/tasks.c **** 	{
2028:../3rdParty/FreeRTOS/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 7509              		.loc 1 2028 0 discriminator 2
 7510 1032 7A68     		ldr	r2, [r7, #4]
 7511 1034 1346     		mov	r3, r2
 7512 1036 4FEA8303 		lsl	r3, r3, #2
 7513 103a 9B18     		adds	r3, r3, r2
 7514 103c 4FEA8303 		lsl	r3, r3, #2
 7515 1040 1A46     		mov	r2, r3
 7516 1042 124B     		ldr	r3, .L187
 7517 1044 D318     		adds	r3, r2, r3
 7518 1046 1846     		mov	r0, r3
 7519 1048 FFF7FEFF 		bl	vListInitialise
2026:../3rdParty/FreeRTOS/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 7520              		.loc 1 2026 0 discriminator 2
 7521 104c 7B68     		ldr	r3, [r7, #4]
 7522 104e 03F10103 		add	r3, r3, #1
 7523 1052 7B60     		str	r3, [r7, #4]
 7524              	.L185:
2026:../3rdParty/FreeRTOS/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 7525              		.loc 1 2026 0 is_stmt 0 discriminator 1
 7526 1054 7B68     		ldr	r3, [r7, #4]
 7527 1056 042B     		cmp	r3, #4
 7528 1058 EBD9     		bls	.L186
2029:../3rdParty/FreeRTOS/tasks.c **** 	}
2030:../3rdParty/FreeRTOS/tasks.c **** 
2031:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 7529              		.loc 1 2031 0 is_stmt 1
 7530 105a 0D48     		ldr	r0, .L187+4
 7531 105c FFF7FEFF 		bl	vListInitialise
2032:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 7532              		.loc 1 2032 0
 7533 1060 0C48     		ldr	r0, .L187+8
 7534 1062 FFF7FEFF 		bl	vListInitialise
2033:../3rdParty/FreeRTOS/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 7535              		.loc 1 2033 0
 7536 1066 0C48     		ldr	r0, .L187+12
 7537 1068 FFF7FEFF 		bl	vListInitialise
2034:../3rdParty/FreeRTOS/tasks.c **** 
2035:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2036:../3rdParty/FreeRTOS/tasks.c **** 	{
2037:../3rdParty/FreeRTOS/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 7538              		.loc 1 2037 0
 7539 106c 0B48     		ldr	r0, .L187+16
 7540 106e FFF7FEFF 		bl	vListInitialise
2038:../3rdParty/FreeRTOS/tasks.c **** 	}
2039:../3rdParty/FreeRTOS/tasks.c **** 	#endif
2040:../3rdParty/FreeRTOS/tasks.c **** 
2041:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2042:../3rdParty/FreeRTOS/tasks.c **** 	{
2043:../3rdParty/FreeRTOS/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 7541              		.loc 1 2043 0
 7542 1072 0B48     		ldr	r0, .L187+20
 7543 1074 FFF7FEFF 		bl	vListInitialise
2044:../3rdParty/FreeRTOS/tasks.c **** 	}
2045:../3rdParty/FreeRTOS/tasks.c **** 	#endif
2046:../3rdParty/FreeRTOS/tasks.c **** 
2047:../3rdParty/FreeRTOS/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2048:../3rdParty/FreeRTOS/tasks.c **** 	using list2. */
2049:../3rdParty/FreeRTOS/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 7544              		.loc 1 2049 0
 7545 1078 0A4B     		ldr	r3, .L187+24
 7546 107a 054A     		ldr	r2, .L187+4
 7547 107c 1A60     		str	r2, [r3, #0]
2050:../3rdParty/FreeRTOS/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 7548              		.loc 1 2050 0
 7549 107e 0A4B     		ldr	r3, .L187+28
 7550 1080 044A     		ldr	r2, .L187+8
 7551 1082 1A60     		str	r2, [r3, #0]
2051:../3rdParty/FreeRTOS/tasks.c **** }
 7552              		.loc 1 2051 0
 7553 1084 07F10807 		add	r7, r7, #8
 7554 1088 BD46     		mov	sp, r7
 7555 108a 80BD     		pop	{r7, pc}
 7556              	.L188:
 7557              		.align	2
 7558              	.L187:
 7559 108c 04000000 		.word	pxReadyTasksLists
 7560 1090 68000000 		.word	xDelayedTaskList1
 7561 1094 7C000000 		.word	xDelayedTaskList2
 7562 1098 98000000 		.word	xPendingReadyList
 7563 109c AC000000 		.word	xTasksWaitingTermination
 7564 10a0 C4000000 		.word	xSuspendedTaskList
 7565 10a4 90000000 		.word	pxDelayedTaskList
 7566 10a8 94000000 		.word	pxOverflowDelayedTaskList
 7567              		.cfi_endproc
 7568              	.LFE85:
 7570              		.align	2
 7571              		.thumb
 7572              		.thumb_func
 7574              	prvCheckTasksWaitingTermination:
 7575              	.LFB86:
2052:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2053:../3rdParty/FreeRTOS/tasks.c **** 
2054:../3rdParty/FreeRTOS/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2055:../3rdParty/FreeRTOS/tasks.c **** {
 7576              		.loc 1 2055 0
 7577              		.cfi_startproc
 7578              		@ args = 0, pretend = 0, frame = 8
 7579              		@ frame_needed = 1, uses_anonymous_args = 0
 7580 10ac 80B5     		push	{r7, lr}
 7581              	.LCFI89:
 7582              		.cfi_def_cfa_offset 8
 7583 10ae 82B0     		sub	sp, sp, #8
 7584              	.LCFI90:
 7585              		.cfi_def_cfa_offset 16
 7586 10b0 00AF     		add	r7, sp, #0
 7587              		.cfi_offset 14, -4
 7588              		.cfi_offset 7, -8
 7589              	.LCFI91:
 7590              		.cfi_def_cfa_register 7
 7591              	.LBB9:
2056:../3rdParty/FreeRTOS/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2057:../3rdParty/FreeRTOS/tasks.c **** 	{
2058:../3rdParty/FreeRTOS/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2059:../3rdParty/FreeRTOS/tasks.c **** 
2060:../3rdParty/FreeRTOS/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2061:../3rdParty/FreeRTOS/tasks.c **** 		too often in the idle task. */
2062:../3rdParty/FreeRTOS/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 7592              		.loc 1 2062 0
 7593 10b2 194B     		ldr	r3, .L191
 7594 10b4 1B68     		ldr	r3, [r3, #0]
 7595 10b6 002B     		cmp	r3, #0
 7596 10b8 2AD0     		beq	.L189
2063:../3rdParty/FreeRTOS/tasks.c **** 		{
2064:../3rdParty/FreeRTOS/tasks.c **** 			vTaskSuspendAll();
 7597              		.loc 1 2064 0
 7598 10ba FFF7FEFF 		bl	vTaskSuspendAll
2065:../3rdParty/FreeRTOS/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 7599              		.loc 1 2065 0
 7600 10be 174B     		ldr	r3, .L191+4
 7601 10c0 1B68     		ldr	r3, [r3, #0]
 7602 10c2 002B     		cmp	r3, #0
 7603 10c4 14BF     		ite	ne
 7604 10c6 0023     		movne	r3, #0
 7605 10c8 0123     		moveq	r3, #1
 7606 10ca 7B60     		str	r3, [r7, #4]
2066:../3rdParty/FreeRTOS/tasks.c **** 			xTaskResumeAll();
 7607              		.loc 1 2066 0
 7608 10cc FFF7FEFF 		bl	xTaskResumeAll
2067:../3rdParty/FreeRTOS/tasks.c **** 
2068:../3rdParty/FreeRTOS/tasks.c **** 			if( xListIsEmpty == pdFALSE )
 7609              		.loc 1 2068 0
 7610 10d0 7B68     		ldr	r3, [r7, #4]
 7611 10d2 002B     		cmp	r3, #0
 7612 10d4 1CD1     		bne	.L189
 7613              	.LBB10:
2069:../3rdParty/FreeRTOS/tasks.c **** 			{
2070:../3rdParty/FreeRTOS/tasks.c **** 				tskTCB *pxTCB;
2071:../3rdParty/FreeRTOS/tasks.c **** 
2072:../3rdParty/FreeRTOS/tasks.c **** 				taskENTER_CRITICAL();
 7614              		.loc 1 2072 0
 7615 10d6 FFF7FEFF 		bl	vPortEnterCritical
2073:../3rdParty/FreeRTOS/tasks.c **** 				{
2074:../3rdParty/FreeRTOS/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 7616              		.loc 1 2074 0
 7617 10da 104B     		ldr	r3, .L191+4
 7618 10dc DB68     		ldr	r3, [r3, #12]
 7619 10de DB68     		ldr	r3, [r3, #12]
 7620 10e0 3B60     		str	r3, [r7, #0]
2075:../3rdParty/FreeRTOS/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 7621              		.loc 1 2075 0
 7622 10e2 3B68     		ldr	r3, [r7, #0]
 7623 10e4 03F10403 		add	r3, r3, #4
 7624 10e8 1846     		mov	r0, r3
 7625 10ea FFF7FEFF 		bl	vListRemove
2076:../3rdParty/FreeRTOS/tasks.c **** 					--uxCurrentNumberOfTasks;
 7626              		.loc 1 2076 0
 7627 10ee 0C4B     		ldr	r3, .L191+8
 7628 10f0 1B68     		ldr	r3, [r3, #0]
 7629 10f2 03F1FF32 		add	r2, r3, #-1
 7630 10f6 0A4B     		ldr	r3, .L191+8
 7631 10f8 1A60     		str	r2, [r3, #0]
2077:../3rdParty/FreeRTOS/tasks.c **** 					--uxTasksDeleted;
 7632              		.loc 1 2077 0
 7633 10fa 074B     		ldr	r3, .L191
 7634 10fc 1B68     		ldr	r3, [r3, #0]
 7635 10fe 03F1FF32 		add	r2, r3, #-1
 7636 1102 054B     		ldr	r3, .L191
 7637 1104 1A60     		str	r2, [r3, #0]
2078:../3rdParty/FreeRTOS/tasks.c **** 				}
2079:../3rdParty/FreeRTOS/tasks.c **** 				taskEXIT_CRITICAL();
 7638              		.loc 1 2079 0
 7639 1106 FFF7FEFF 		bl	vPortExitCritical
2080:../3rdParty/FreeRTOS/tasks.c **** 
2081:../3rdParty/FreeRTOS/tasks.c **** 				prvDeleteTCB( pxTCB );
 7640              		.loc 1 2081 0
 7641 110a 3868     		ldr	r0, [r7, #0]
 7642 110c 00F08AF9 		bl	prvDeleteTCB
 7643              	.L189:
 7644              	.LBE10:
 7645              	.LBE9:
2082:../3rdParty/FreeRTOS/tasks.c **** 			}
2083:../3rdParty/FreeRTOS/tasks.c **** 		}
2084:../3rdParty/FreeRTOS/tasks.c **** 	}
2085:../3rdParty/FreeRTOS/tasks.c **** 	#endif
2086:../3rdParty/FreeRTOS/tasks.c **** }
 7646              		.loc 1 2086 0
 7647 1110 07F10807 		add	r7, r7, #8
 7648 1114 BD46     		mov	sp, r7
 7649 1116 80BD     		pop	{r7, pc}
 7650              	.L192:
 7651              		.align	2
 7652              	.L191:
 7653 1118 C0000000 		.word	uxTasksDeleted
 7654 111c AC000000 		.word	xTasksWaitingTermination
 7655 1120 D8000000 		.word	uxCurrentNumberOfTasks
 7656              		.cfi_endproc
 7657              	.LFE86:
 7659              		.align	2
 7660              		.thumb
 7661              		.thumb_func
 7663              	prvAddCurrentTaskToDelayedList:
 7664              	.LFB87:
2087:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2088:../3rdParty/FreeRTOS/tasks.c **** 
2089:../3rdParty/FreeRTOS/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2090:../3rdParty/FreeRTOS/tasks.c **** {
 7665              		.loc 1 2090 0
 7666              		.cfi_startproc
 7667              		@ args = 0, pretend = 0, frame = 8
 7668              		@ frame_needed = 1, uses_anonymous_args = 0
 7669 1124 80B5     		push	{r7, lr}
 7670              	.LCFI92:
 7671              		.cfi_def_cfa_offset 8
 7672 1126 82B0     		sub	sp, sp, #8
 7673              	.LCFI93:
 7674              		.cfi_def_cfa_offset 16
 7675 1128 00AF     		add	r7, sp, #0
 7676              		.cfi_offset 14, -4
 7677              		.cfi_offset 7, -8
 7678              	.LCFI94:
 7679              		.cfi_def_cfa_register 7
 7680 112a 7860     		str	r0, [r7, #4]
2091:../3rdParty/FreeRTOS/tasks.c **** 	/* The list item will be inserted in wake time order. */
2092:../3rdParty/FreeRTOS/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 7681              		.loc 1 2092 0
 7682 112c 144B     		ldr	r3, .L196
 7683 112e 1B68     		ldr	r3, [r3, #0]
 7684 1130 7A68     		ldr	r2, [r7, #4]
 7685 1132 5A60     		str	r2, [r3, #4]
2093:../3rdParty/FreeRTOS/tasks.c **** 
2094:../3rdParty/FreeRTOS/tasks.c **** 	if( xTimeToWake < xTickCount )
 7686              		.loc 1 2094 0
 7687 1134 134B     		ldr	r3, .L196+4
 7688 1136 1B68     		ldr	r3, [r3, #0]
 7689 1138 7A68     		ldr	r2, [r7, #4]
 7690 113a 9A42     		cmp	r2, r3
 7691 113c 0AD2     		bcs	.L194
2095:../3rdParty/FreeRTOS/tasks.c **** 	{
2096:../3rdParty/FreeRTOS/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2097:../3rdParty/FreeRTOS/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
 7692              		.loc 1 2097 0
 7693 113e 124B     		ldr	r3, .L196+8
 7694 1140 1A68     		ldr	r2, [r3, #0]
 7695 1142 0F4B     		ldr	r3, .L196
 7696 1144 1B68     		ldr	r3, [r3, #0]
 7697 1146 03F10403 		add	r3, r3, #4
 7698 114a 1046     		mov	r0, r2
 7699 114c 1946     		mov	r1, r3
 7700 114e FFF7FEFF 		bl	vListInsert
 7701 1152 11E0     		b	.L193
 7702              	.L194:
2098:../3rdParty/FreeRTOS/tasks.c **** 	}
2099:../3rdParty/FreeRTOS/tasks.c **** 	else
2100:../3rdParty/FreeRTOS/tasks.c **** 	{
2101:../3rdParty/FreeRTOS/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2102:../3rdParty/FreeRTOS/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
 7703              		.loc 1 2102 0
 7704 1154 0D4B     		ldr	r3, .L196+12
 7705 1156 1A68     		ldr	r2, [r3, #0]
 7706 1158 094B     		ldr	r3, .L196
 7707 115a 1B68     		ldr	r3, [r3, #0]
 7708 115c 03F10403 		add	r3, r3, #4
 7709 1160 1046     		mov	r0, r2
 7710 1162 1946     		mov	r1, r3
 7711 1164 FFF7FEFF 		bl	vListInsert
2103:../3rdParty/FreeRTOS/tasks.c **** 
2104:../3rdParty/FreeRTOS/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2105:../3rdParty/FreeRTOS/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2106:../3rdParty/FreeRTOS/tasks.c **** 		too. */
2107:../3rdParty/FreeRTOS/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
 7712              		.loc 1 2107 0
 7713 1168 094B     		ldr	r3, .L196+16
 7714 116a 1B68     		ldr	r3, [r3, #0]
 7715 116c 7A68     		ldr	r2, [r7, #4]
 7716 116e 9A42     		cmp	r2, r3
 7717 1170 02D2     		bcs	.L193
2108:../3rdParty/FreeRTOS/tasks.c **** 		{
2109:../3rdParty/FreeRTOS/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
 7718              		.loc 1 2109 0
 7719 1172 074B     		ldr	r3, .L196+16
 7720 1174 7A68     		ldr	r2, [r7, #4]
 7721 1176 1A60     		str	r2, [r3, #0]
 7722              	.L193:
2110:../3rdParty/FreeRTOS/tasks.c **** 		}
2111:../3rdParty/FreeRTOS/tasks.c **** 	}
2112:../3rdParty/FreeRTOS/tasks.c **** }
 7723              		.loc 1 2112 0
 7724 1178 07F10807 		add	r7, r7, #8
 7725 117c BD46     		mov	sp, r7
 7726 117e 80BD     		pop	{r7, pc}
 7727              	.L197:
 7728              		.align	2
 7729              	.L196:
 7730 1180 00000000 		.word	pxCurrentTCB
 7731 1184 DC000000 		.word	xTickCount
 7732 1188 94000000 		.word	pxOverflowDelayedTaskList
 7733 118c 90000000 		.word	pxDelayedTaskList
 7734 1190 00000000 		.word	xNextTaskUnblockTime
 7735              		.cfi_endproc
 7736              	.LFE87:
 7738              		.align	2
 7739              		.thumb
 7740              		.thumb_func
 7742              	prvAllocateTCBAndStack:
 7743              	.LFB88:
2113:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2114:../3rdParty/FreeRTOS/tasks.c **** 
2115:../3rdParty/FreeRTOS/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2116:../3rdParty/FreeRTOS/tasks.c **** {
 7744              		.loc 1 2116 0
 7745              		.cfi_startproc
 7746              		@ args = 0, pretend = 0, frame = 16
 7747              		@ frame_needed = 1, uses_anonymous_args = 0
 7748 1194 80B5     		push	{r7, lr}
 7749              	.LCFI95:
 7750              		.cfi_def_cfa_offset 8
 7751 1196 84B0     		sub	sp, sp, #16
 7752              	.LCFI96:
 7753              		.cfi_def_cfa_offset 24
 7754 1198 00AF     		add	r7, sp, #0
 7755              		.cfi_offset 14, -4
 7756              		.cfi_offset 7, -8
 7757              	.LCFI97:
 7758              		.cfi_def_cfa_register 7
 7759 119a 0346     		mov	r3, r0
 7760 119c 3960     		str	r1, [r7, #0]
 7761 119e FB80     		strh	r3, [r7, #6]	@ movhi
2117:../3rdParty/FreeRTOS/tasks.c **** tskTCB *pxNewTCB;
2118:../3rdParty/FreeRTOS/tasks.c **** 
2119:../3rdParty/FreeRTOS/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2120:../3rdParty/FreeRTOS/tasks.c **** 	the implementation of the port malloc function. */
2121:../3rdParty/FreeRTOS/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 7762              		.loc 1 2121 0
 7763 11a0 4FF05000 		mov	r0, #80
 7764 11a4 FFF7FEFF 		bl	pvPortMalloc
 7765 11a8 0346     		mov	r3, r0
 7766 11aa FB60     		str	r3, [r7, #12]
2122:../3rdParty/FreeRTOS/tasks.c **** 
2123:../3rdParty/FreeRTOS/tasks.c **** 	if( pxNewTCB != NULL )
 7767              		.loc 1 2123 0
 7768 11ac FB68     		ldr	r3, [r7, #12]
 7769 11ae 002B     		cmp	r3, #0
 7770 11b0 23D0     		beq	.L199
2124:../3rdParty/FreeRTOS/tasks.c **** 	{
2125:../3rdParty/FreeRTOS/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2126:../3rdParty/FreeRTOS/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2127:../3rdParty/FreeRTOS/tasks.c **** 		be deleted later if required. */
2128:../3rdParty/FreeRTOS/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 7771              		.loc 1 2128 0
 7772 11b2 3B68     		ldr	r3, [r7, #0]
 7773 11b4 002B     		cmp	r3, #0
 7774 11b6 07D1     		bne	.L200
 7775              		.loc 1 2128 0 is_stmt 0 discriminator 1
 7776 11b8 FB88     		ldrh	r3, [r7, #6]
 7777 11ba 4FEA8303 		lsl	r3, r3, #2
 7778 11be 1846     		mov	r0, r3
 7779 11c0 FFF7FEFF 		bl	pvPortMalloc
 7780 11c4 0346     		mov	r3, r0
 7781 11c6 00E0     		b	.L201
 7782              	.L200:
 7783              		.loc 1 2128 0 discriminator 2
 7784 11c8 3B68     		ldr	r3, [r7, #0]
 7785              	.L201:
 7786              		.loc 1 2128 0 discriminator 3
 7787 11ca FA68     		ldr	r2, [r7, #12]
 7788 11cc 1363     		str	r3, [r2, #48]
2129:../3rdParty/FreeRTOS/tasks.c **** 
2130:../3rdParty/FreeRTOS/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 7789              		.loc 1 2130 0 is_stmt 1 discriminator 3
 7790 11ce FB68     		ldr	r3, [r7, #12]
 7791 11d0 1B6B     		ldr	r3, [r3, #48]
 7792 11d2 002B     		cmp	r3, #0
 7793 11d4 06D1     		bne	.L202
2131:../3rdParty/FreeRTOS/tasks.c **** 		{
2132:../3rdParty/FreeRTOS/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2133:../3rdParty/FreeRTOS/tasks.c **** 			vPortFree( pxNewTCB );
 7794              		.loc 1 2133 0
 7795 11d6 F868     		ldr	r0, [r7, #12]
 7796 11d8 FFF7FEFF 		bl	vPortFree
2134:../3rdParty/FreeRTOS/tasks.c **** 			pxNewTCB = NULL;
 7797              		.loc 1 2134 0
 7798 11dc 4FF00003 		mov	r3, #0
 7799 11e0 FB60     		str	r3, [r7, #12]
 7800 11e2 0AE0     		b	.L199
 7801              	.L202:
2135:../3rdParty/FreeRTOS/tasks.c **** 		}
2136:../3rdParty/FreeRTOS/tasks.c **** 		else
2137:../3rdParty/FreeRTOS/tasks.c **** 		{
2138:../3rdParty/FreeRTOS/tasks.c **** 			/* Just to help debugging. */
2139:../3rdParty/FreeRTOS/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
 7802              		.loc 1 2139 0
 7803 11e4 FB68     		ldr	r3, [r7, #12]
 7804 11e6 1A6B     		ldr	r2, [r3, #48]
 7805 11e8 FB88     		ldrh	r3, [r7, #6]
 7806 11ea 4FEA8303 		lsl	r3, r3, #2
 7807 11ee 1046     		mov	r0, r2
 7808 11f0 4FF0A501 		mov	r1, #165
 7809 11f4 1A46     		mov	r2, r3
 7810 11f6 FFF7FEFF 		bl	memset
 7811              	.L199:
2140:../3rdParty/FreeRTOS/tasks.c **** 		}
2141:../3rdParty/FreeRTOS/tasks.c **** 	}
2142:../3rdParty/FreeRTOS/tasks.c **** 
2143:../3rdParty/FreeRTOS/tasks.c **** 	return pxNewTCB;
 7812              		.loc 1 2143 0
 7813 11fa FB68     		ldr	r3, [r7, #12]
2144:../3rdParty/FreeRTOS/tasks.c **** }
 7814              		.loc 1 2144 0
 7815 11fc 1846     		mov	r0, r3
 7816 11fe 07F11007 		add	r7, r7, #16
 7817 1202 BD46     		mov	sp, r7
 7818 1204 80BD     		pop	{r7, pc}
 7819              		.cfi_endproc
 7820              	.LFE88:
 7822              		.section	.rodata
 7823 000b 00       		.align	2
 7824              	.LC2:
 7825 000c 25730909 		.ascii	"%s\011\011%c\011%u\011%u\011%u\015\012\000"
 7825      25630925 
 7825      75092575 
 7825      0925750D 
 7825      0A00
 7826              		.text
 7827 1206 00BF     		.align	2
 7828              		.thumb
 7829              		.thumb_func
 7831              	prvListTaskWithinSingleList:
 7832              	.LFB89:
2145:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2146:../3rdParty/FreeRTOS/tasks.c **** 
2147:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2148:../3rdParty/FreeRTOS/tasks.c **** 
2149:../3rdParty/FreeRTOS/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2150:../3rdParty/FreeRTOS/tasks.c **** 	{
 7833              		.loc 1 2150 0
 7834              		.cfi_startproc
 7835              		@ args = 0, pretend = 0, frame = 40
 7836              		@ frame_needed = 1, uses_anonymous_args = 0
 7837 1208 90B5     		push	{r4, r7, lr}
 7838              	.LCFI98:
 7839              		.cfi_def_cfa_offset 12
 7840 120a 8FB0     		sub	sp, sp, #60
 7841              	.LCFI99:
 7842              		.cfi_def_cfa_offset 72
 7843 120c 04AF     		add	r7, sp, #16
 7844              		.cfi_offset 14, -4
 7845              		.cfi_offset 7, -8
 7846              		.cfi_offset 4, -12
 7847              	.LCFI100:
 7848              		.cfi_def_cfa 7, 56
 7849 120e F860     		str	r0, [r7, #12]
 7850 1210 B960     		str	r1, [r7, #8]
 7851 1212 1346     		mov	r3, r2
 7852 1214 FB71     		strb	r3, [r7, #7]
 7853              	.LBB11:
2151:../3rdParty/FreeRTOS/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2152:../3rdParty/FreeRTOS/tasks.c **** 	unsigned short usStackRemaining;
2153:../3rdParty/FreeRTOS/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
2154:../3rdParty/FreeRTOS/tasks.c **** 
2155:../3rdParty/FreeRTOS/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2156:../3rdParty/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 7854              		.loc 1 2156 0
 7855 1216 BB68     		ldr	r3, [r7, #8]
 7856 1218 7B62     		str	r3, [r7, #36]
 7857 121a 7B6A     		ldr	r3, [r7, #36]
 7858 121c 5B68     		ldr	r3, [r3, #4]
 7859 121e 5A68     		ldr	r2, [r3, #4]
 7860 1220 7B6A     		ldr	r3, [r7, #36]
 7861 1222 5A60     		str	r2, [r3, #4]
 7862 1224 7B6A     		ldr	r3, [r7, #36]
 7863 1226 5A68     		ldr	r2, [r3, #4]
 7864 1228 7B6A     		ldr	r3, [r7, #36]
 7865 122a 03F10803 		add	r3, r3, #8
 7866 122e 9A42     		cmp	r2, r3
 7867 1230 04D1     		bne	.L204
 7868              		.loc 1 2156 0 is_stmt 0 discriminator 1
 7869 1232 7B6A     		ldr	r3, [r7, #36]
 7870 1234 5B68     		ldr	r3, [r3, #4]
 7871 1236 5A68     		ldr	r2, [r3, #4]
 7872 1238 7B6A     		ldr	r3, [r7, #36]
 7873 123a 5A60     		str	r2, [r3, #4]
 7874              	.L204:
 7875              		.loc 1 2156 0 discriminator 2
 7876 123c 7B6A     		ldr	r3, [r7, #36]
 7877 123e 5B68     		ldr	r3, [r3, #4]
 7878 1240 DB68     		ldr	r3, [r3, #12]
 7879 1242 3B62     		str	r3, [r7, #32]
 7880              	.L206:
 7881              	.LBE11:
 7882              	.LBB12:
2157:../3rdParty/FreeRTOS/tasks.c **** 		do
2158:../3rdParty/FreeRTOS/tasks.c **** 		{
2159:../3rdParty/FreeRTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 7883              		.loc 1 2159 0 is_stmt 1
 7884 1244 BB68     		ldr	r3, [r7, #8]
 7885 1246 FB61     		str	r3, [r7, #28]
 7886 1248 FB69     		ldr	r3, [r7, #28]
 7887 124a 5B68     		ldr	r3, [r3, #4]
 7888 124c 5A68     		ldr	r2, [r3, #4]
 7889 124e FB69     		ldr	r3, [r7, #28]
 7890 1250 5A60     		str	r2, [r3, #4]
 7891 1252 FB69     		ldr	r3, [r7, #28]
 7892 1254 5A68     		ldr	r2, [r3, #4]
 7893 1256 FB69     		ldr	r3, [r7, #28]
 7894 1258 03F10803 		add	r3, r3, #8
 7895 125c 9A42     		cmp	r2, r3
 7896 125e 04D1     		bne	.L205
 7897              		.loc 1 2159 0 is_stmt 0 discriminator 1
 7898 1260 FB69     		ldr	r3, [r7, #28]
 7899 1262 5B68     		ldr	r3, [r3, #4]
 7900 1264 5A68     		ldr	r2, [r3, #4]
 7901 1266 FB69     		ldr	r3, [r7, #28]
 7902 1268 5A60     		str	r2, [r3, #4]
 7903              	.L205:
 7904              		.loc 1 2159 0 discriminator 2
 7905 126a FB69     		ldr	r3, [r7, #28]
 7906 126c 5B68     		ldr	r3, [r3, #4]
 7907 126e DB68     		ldr	r3, [r3, #12]
 7908 1270 BB61     		str	r3, [r7, #24]
 7909              	.LBE12:
2160:../3rdParty/FreeRTOS/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2161:../3rdParty/FreeRTOS/tasks.c **** 			{
2162:../3rdParty/FreeRTOS/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2163:../3rdParty/FreeRTOS/tasks.c **** 			}
2164:../3rdParty/FreeRTOS/tasks.c **** 			#else
2165:../3rdParty/FreeRTOS/tasks.c **** 			{
2166:../3rdParty/FreeRTOS/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
 7910              		.loc 1 2166 0 is_stmt 1 discriminator 2
 7911 1272 BB69     		ldr	r3, [r7, #24]
 7912 1274 1B6B     		ldr	r3, [r3, #48]
 7913 1276 1846     		mov	r0, r3
 7914 1278 00F09CF8 		bl	usTaskCheckFreeStackSpace
 7915 127c 0346     		mov	r3, r0
 7916 127e FB82     		strh	r3, [r7, #22]	@ movhi
2167:../3rdParty/FreeRTOS/tasks.c **** 			}
2168:../3rdParty/FreeRTOS/tasks.c **** 			#endif			
2169:../3rdParty/FreeRTOS/tasks.c **** 			
2170:../3rdParty/FreeRTOS/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
 7917              		.loc 1 2170 0 discriminator 2
 7918 1280 BB69     		ldr	r3, [r7, #24]
 7919 1282 03F13402 		add	r2, r3, #52
 7920 1286 97F90730 		ldrsb	r3, [r7, #7]
 7921 128a B969     		ldr	r1, [r7, #24]
 7922 128c CC6A     		ldr	r4, [r1, #44]
 7923 128e F88A     		ldrh	r0, [r7, #22]
 7924 1290 B969     		ldr	r1, [r7, #24]
 7925 1292 096C     		ldr	r1, [r1, #64]
 7926 1294 0094     		str	r4, [sp, #0]
 7927 1296 0190     		str	r0, [sp, #4]
 7928 1298 0291     		str	r1, [sp, #8]
 7929 129a 0848     		ldr	r0, .L207
 7930 129c 0849     		ldr	r1, .L207+4
 7931 129e FFF7FEFF 		bl	sprintf
2171:../3rdParty/FreeRTOS/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
 7932              		.loc 1 2171 0 discriminator 2
 7933 12a2 FB68     		ldr	r3, [r7, #12]
 7934 12a4 1846     		mov	r0, r3
 7935 12a6 0549     		ldr	r1, .L207
 7936 12a8 FFF7FEFF 		bl	strcat
2172:../3rdParty/FreeRTOS/tasks.c **** 
2173:../3rdParty/FreeRTOS/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 7937              		.loc 1 2173 0 discriminator 2
 7938 12ac BA69     		ldr	r2, [r7, #24]
 7939 12ae 3B6A     		ldr	r3, [r7, #32]
 7940 12b0 9A42     		cmp	r2, r3
 7941 12b2 C7D1     		bne	.L206
2174:../3rdParty/FreeRTOS/tasks.c **** 	}
 7942              		.loc 1 2174 0
 7943 12b4 07F12C07 		add	r7, r7, #44
 7944 12b8 BD46     		mov	sp, r7
 7945 12ba 90BD     		pop	{r4, r7, pc}
 7946              	.L208:
 7947              		.align	2
 7948              	.L207:
 7949 12bc 38010000 		.word	pcStatusString.6986
 7950 12c0 0C000000 		.word	.LC2
 7951              		.cfi_endproc
 7952              	.LFE89:
 7954              		.section	.rodata
 7955 001e 0000     		.align	2
 7956              	.LC3:
 7957 0020 25730909 		.ascii	"%s\011\0110\011\0110%%\015\012\000"
 7957      30090930 
 7957      25250D0A 
 7957      00
 7958 002d 000000   		.align	2
 7959              	.LC4:
 7960 0030 25730909 		.ascii	"%s\011\011%u\011\011%u%%\015\012\000"
 7960      25750909 
 7960      25752525 
 7960      0D0A00
 7961 003f 00       		.align	2
 7962              	.LC5:
 7963 0040 25730909 		.ascii	"%s\011\011%u\011\011<1%%\015\012\000"
 7963      25750909 
 7963      3C312525 
 7963      0D0A00
 7964              		.text
 7965              		.align	2
 7966              		.thumb
 7967              		.thumb_func
 7969              	prvGenerateRunTimeStatsForTasksInList:
 7970              	.LFB90:
2175:../3rdParty/FreeRTOS/tasks.c **** 
2176:../3rdParty/FreeRTOS/tasks.c **** #endif
2177:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2178:../3rdParty/FreeRTOS/tasks.c **** 
2179:../3rdParty/FreeRTOS/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2180:../3rdParty/FreeRTOS/tasks.c **** 
2181:../3rdParty/FreeRTOS/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2182:../3rdParty/FreeRTOS/tasks.c **** 	{
 7971              		.loc 1 2182 0
 7972              		.cfi_startproc
 7973              		@ args = 0, pretend = 0, frame = 40
 7974              		@ frame_needed = 1, uses_anonymous_args = 0
 7975 12c4 80B5     		push	{r7, lr}
 7976              	.LCFI101:
 7977              		.cfi_def_cfa_offset 8
 7978 12c6 8CB0     		sub	sp, sp, #48
 7979              	.LCFI102:
 7980              		.cfi_def_cfa_offset 56
 7981 12c8 02AF     		add	r7, sp, #8
 7982              		.cfi_offset 14, -4
 7983              		.cfi_offset 7, -8
 7984              	.LCFI103:
 7985              		.cfi_def_cfa 7, 48
 7986 12ca F860     		str	r0, [r7, #12]
 7987 12cc B960     		str	r1, [r7, #8]
 7988 12ce 7A60     		str	r2, [r7, #4]
 7989              	.LBB13:
2183:../3rdParty/FreeRTOS/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2184:../3rdParty/FreeRTOS/tasks.c **** 	unsigned long ulStatsAsPercentage;
2185:../3rdParty/FreeRTOS/tasks.c **** 
2186:../3rdParty/FreeRTOS/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2187:../3rdParty/FreeRTOS/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
 7990              		.loc 1 2187 0
 7991 12d0 BB68     		ldr	r3, [r7, #8]
 7992 12d2 7B62     		str	r3, [r7, #36]
 7993 12d4 7B6A     		ldr	r3, [r7, #36]
 7994 12d6 5B68     		ldr	r3, [r3, #4]
 7995 12d8 5A68     		ldr	r2, [r3, #4]
 7996 12da 7B6A     		ldr	r3, [r7, #36]
 7997 12dc 5A60     		str	r2, [r3, #4]
 7998 12de 7B6A     		ldr	r3, [r7, #36]
 7999 12e0 5A68     		ldr	r2, [r3, #4]
 8000 12e2 7B6A     		ldr	r3, [r7, #36]
 8001 12e4 03F10803 		add	r3, r3, #8
 8002 12e8 9A42     		cmp	r2, r3
 8003 12ea 04D1     		bne	.L210
 8004              		.loc 1 2187 0 is_stmt 0 discriminator 1
 8005 12ec 7B6A     		ldr	r3, [r7, #36]
 8006 12ee 5B68     		ldr	r3, [r3, #4]
 8007 12f0 5A68     		ldr	r2, [r3, #4]
 8008 12f2 7B6A     		ldr	r3, [r7, #36]
 8009 12f4 5A60     		str	r2, [r3, #4]
 8010              	.L210:
 8011              		.loc 1 2187 0 discriminator 2
 8012 12f6 7B6A     		ldr	r3, [r7, #36]
 8013 12f8 5B68     		ldr	r3, [r3, #4]
 8014 12fa DB68     		ldr	r3, [r3, #12]
 8015 12fc 3B62     		str	r3, [r7, #32]
 8016              	.L216:
 8017              	.LBE13:
 8018              	.LBB14:
2188:../3rdParty/FreeRTOS/tasks.c **** 		do
2189:../3rdParty/FreeRTOS/tasks.c **** 		{
2190:../3rdParty/FreeRTOS/tasks.c **** 			/* Get next TCB in from the list. */
2191:../3rdParty/FreeRTOS/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
 8019              		.loc 1 2191 0 is_stmt 1
 8020 12fe BB68     		ldr	r3, [r7, #8]
 8021 1300 FB61     		str	r3, [r7, #28]
 8022 1302 FB69     		ldr	r3, [r7, #28]
 8023 1304 5B68     		ldr	r3, [r3, #4]
 8024 1306 5A68     		ldr	r2, [r3, #4]
 8025 1308 FB69     		ldr	r3, [r7, #28]
 8026 130a 5A60     		str	r2, [r3, #4]
 8027 130c FB69     		ldr	r3, [r7, #28]
 8028 130e 5A68     		ldr	r2, [r3, #4]
 8029 1310 FB69     		ldr	r3, [r7, #28]
 8030 1312 03F10803 		add	r3, r3, #8
 8031 1316 9A42     		cmp	r2, r3
 8032 1318 04D1     		bne	.L211
 8033              		.loc 1 2191 0 is_stmt 0 discriminator 1
 8034 131a FB69     		ldr	r3, [r7, #28]
 8035 131c 5B68     		ldr	r3, [r3, #4]
 8036 131e 5A68     		ldr	r2, [r3, #4]
 8037 1320 FB69     		ldr	r3, [r7, #28]
 8038 1322 5A60     		str	r2, [r3, #4]
 8039              	.L211:
 8040              		.loc 1 2191 0 discriminator 2
 8041 1324 FB69     		ldr	r3, [r7, #28]
 8042 1326 5B68     		ldr	r3, [r3, #4]
 8043 1328 DB68     		ldr	r3, [r3, #12]
 8044 132a BB61     		str	r3, [r7, #24]
 8045              	.LBE14:
2192:../3rdParty/FreeRTOS/tasks.c **** 
2193:../3rdParty/FreeRTOS/tasks.c **** 			/* Divide by zero check. */
2194:../3rdParty/FreeRTOS/tasks.c **** 			if( ulTotalRunTime > 0UL )
 8046              		.loc 1 2194 0 is_stmt 1 discriminator 2
 8047 132c 7B68     		ldr	r3, [r7, #4]
 8048 132e 002B     		cmp	r3, #0
 8049 1330 2FD0     		beq	.L212
2195:../3rdParty/FreeRTOS/tasks.c **** 			{
2196:../3rdParty/FreeRTOS/tasks.c **** 				/* Has the task run at all? */
2197:../3rdParty/FreeRTOS/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
 8050              		.loc 1 2197 0
 8051 1332 BB69     		ldr	r3, [r7, #24]
 8052 1334 DB6C     		ldr	r3, [r3, #76]
 8053 1336 002B     		cmp	r3, #0
 8054 1338 08D1     		bne	.L213
2198:../3rdParty/FreeRTOS/tasks.c **** 				{
2199:../3rdParty/FreeRTOS/tasks.c **** 					/* The task has used no CPU time at all. */
2200:../3rdParty/FreeRTOS/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
 8055              		.loc 1 2200 0
 8056 133a BB69     		ldr	r3, [r7, #24]
 8057 133c 03F13403 		add	r3, r3, #52
 8058 1340 1848     		ldr	r0, .L217
 8059 1342 1949     		ldr	r1, .L217+4
 8060 1344 1A46     		mov	r2, r3
 8061 1346 FFF7FEFF 		bl	sprintf
 8062 134a 1DE0     		b	.L214
 8063              	.L213:
2201:../3rdParty/FreeRTOS/tasks.c **** 				}
2202:../3rdParty/FreeRTOS/tasks.c **** 				else
2203:../3rdParty/FreeRTOS/tasks.c **** 				{
2204:../3rdParty/FreeRTOS/tasks.c **** 					/* What percentage of the total run time has the task used?
2205:../3rdParty/FreeRTOS/tasks.c **** 					This will always be rounded down to the nearest integer.
2206:../3rdParty/FreeRTOS/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2207:../3rdParty/FreeRTOS/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
 8064              		.loc 1 2207 0
 8065 134c BB69     		ldr	r3, [r7, #24]
 8066 134e DA6C     		ldr	r2, [r3, #76]
 8067 1350 7B68     		ldr	r3, [r7, #4]
 8068 1352 B2FBF3F3 		udiv	r3, r2, r3
 8069 1356 7B61     		str	r3, [r7, #20]
2208:../3rdParty/FreeRTOS/tasks.c **** 
2209:../3rdParty/FreeRTOS/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
 8070              		.loc 1 2209 0
 8071 1358 7B69     		ldr	r3, [r7, #20]
 8072 135a 002B     		cmp	r3, #0
 8073 135c 0BD0     		beq	.L215
2210:../3rdParty/FreeRTOS/tasks.c **** 					{
2211:../3rdParty/FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2212:../3rdParty/FreeRTOS/tasks.c **** 						{
2213:../3rdParty/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2214:../3rdParty/FreeRTOS/tasks.c **** 						}
2215:../3rdParty/FreeRTOS/tasks.c **** 						#else
2216:../3rdParty/FreeRTOS/tasks.c **** 						{
2217:../3rdParty/FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2218:../3rdParty/FreeRTOS/tasks.c **** 							printf() library can be used. */
2219:../3rdParty/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned
 8074              		.loc 1 2219 0
 8075 135e BB69     		ldr	r3, [r7, #24]
 8076 1360 03F13402 		add	r2, r3, #52
 8077 1364 BB69     		ldr	r3, [r7, #24]
 8078 1366 DB6C     		ldr	r3, [r3, #76]
 8079 1368 7969     		ldr	r1, [r7, #20]
 8080 136a 0091     		str	r1, [sp, #0]
 8081 136c 0D48     		ldr	r0, .L217
 8082 136e 0F49     		ldr	r1, .L217+8
 8083 1370 FFF7FEFF 		bl	sprintf
 8084 1374 08E0     		b	.L214
 8085              	.L215:
2220:../3rdParty/FreeRTOS/tasks.c **** 						}
2221:../3rdParty/FreeRTOS/tasks.c **** 						#endif
2222:../3rdParty/FreeRTOS/tasks.c **** 					}
2223:../3rdParty/FreeRTOS/tasks.c **** 					else
2224:../3rdParty/FreeRTOS/tasks.c **** 					{
2225:../3rdParty/FreeRTOS/tasks.c **** 						/* If the percentage is zero here then the task has
2226:../3rdParty/FreeRTOS/tasks.c **** 						consumed less than 1% of the total run time. */
2227:../3rdParty/FreeRTOS/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2228:../3rdParty/FreeRTOS/tasks.c **** 						{
2229:../3rdParty/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2230:../3rdParty/FreeRTOS/tasks.c **** 						}
2231:../3rdParty/FreeRTOS/tasks.c **** 						#else
2232:../3rdParty/FreeRTOS/tasks.c **** 						{
2233:../3rdParty/FreeRTOS/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2234:../3rdParty/FreeRTOS/tasks.c **** 							printf() library can be used. */
2235:../3rdParty/FreeRTOS/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned
 8086              		.loc 1 2235 0
 8087 1376 BB69     		ldr	r3, [r7, #24]
 8088 1378 03F13402 		add	r2, r3, #52
 8089 137c BB69     		ldr	r3, [r7, #24]
 8090 137e DB6C     		ldr	r3, [r3, #76]
 8091 1380 0848     		ldr	r0, .L217
 8092 1382 0B49     		ldr	r1, .L217+12
 8093 1384 FFF7FEFF 		bl	sprintf
 8094              	.L214:
2236:../3rdParty/FreeRTOS/tasks.c **** 						}
2237:../3rdParty/FreeRTOS/tasks.c **** 						#endif
2238:../3rdParty/FreeRTOS/tasks.c **** 					}
2239:../3rdParty/FreeRTOS/tasks.c **** 				}
2240:../3rdParty/FreeRTOS/tasks.c **** 
2241:../3rdParty/FreeRTOS/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
 8095              		.loc 1 2241 0
 8096 1388 FB68     		ldr	r3, [r7, #12]
 8097 138a 1846     		mov	r0, r3
 8098 138c 0549     		ldr	r1, .L217
 8099 138e FFF7FEFF 		bl	strcat
 8100              	.L212:
2242:../3rdParty/FreeRTOS/tasks.c **** 			}
2243:../3rdParty/FreeRTOS/tasks.c **** 
2244:../3rdParty/FreeRTOS/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
 8101              		.loc 1 2244 0
 8102 1392 BA69     		ldr	r2, [r7, #24]
 8103 1394 3B6A     		ldr	r3, [r7, #32]
 8104 1396 9A42     		cmp	r2, r3
 8105 1398 B1D1     		bne	.L216
2245:../3rdParty/FreeRTOS/tasks.c **** 	}
 8106              		.loc 1 2245 0
 8107 139a 07F12807 		add	r7, r7, #40
 8108 139e BD46     		mov	sp, r7
 8109 13a0 80BD     		pop	{r7, pc}
 8110              	.L218:
 8111 13a2 00BF     		.align	2
 8112              	.L217:
 8113 13a4 00010000 		.word	pcStatsString
 8114 13a8 20000000 		.word	.LC3
 8115 13ac 30000000 		.word	.LC4
 8116 13b0 40000000 		.word	.LC5
 8117              		.cfi_endproc
 8118              	.LFE90:
 8120              		.align	2
 8121              		.thumb
 8122              		.thumb_func
 8124              	usTaskCheckFreeStackSpace:
 8125              	.LFB91:
2246:../3rdParty/FreeRTOS/tasks.c **** 
2247:../3rdParty/FreeRTOS/tasks.c **** #endif
2248:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2249:../3rdParty/FreeRTOS/tasks.c **** 
2250:../3rdParty/FreeRTOS/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2251:../3rdParty/FreeRTOS/tasks.c **** 
2252:../3rdParty/FreeRTOS/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2253:../3rdParty/FreeRTOS/tasks.c **** 	{
 8126              		.loc 1 2253 0
 8127              		.cfi_startproc
 8128              		@ args = 0, pretend = 0, frame = 8
 8129              		@ frame_needed = 1, uses_anonymous_args = 0
 8130              		@ link register save eliminated.
 8131 13b4 90B4     		push	{r4, r7}
 8132              	.LCFI104:
 8133              		.cfi_def_cfa_offset 8
 8134 13b6 82B0     		sub	sp, sp, #8
 8135              	.LCFI105:
 8136              		.cfi_def_cfa_offset 16
 8137 13b8 00AF     		add	r7, sp, #0
 8138              		.cfi_offset 7, -4
 8139              		.cfi_offset 4, -8
 8140              	.LCFI106:
 8141              		.cfi_def_cfa_register 7
 8142 13ba 7860     		str	r0, [r7, #4]
2254:../3rdParty/FreeRTOS/tasks.c **** 	register unsigned short usCount = 0U;
 8143              		.loc 1 2254 0
 8144 13bc 4FF00004 		mov	r4, #0
2255:../3rdParty/FreeRTOS/tasks.c **** 
2256:../3rdParty/FreeRTOS/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 8145              		.loc 1 2256 0
 8146 13c0 06E0     		b	.L220
 8147              	.L221:
2257:../3rdParty/FreeRTOS/tasks.c **** 		{
2258:../3rdParty/FreeRTOS/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
 8148              		.loc 1 2258 0
 8149 13c2 7B68     		ldr	r3, [r7, #4]
 8150 13c4 03F10103 		add	r3, r3, #1
 8151 13c8 7B60     		str	r3, [r7, #4]
2259:../3rdParty/FreeRTOS/tasks.c **** 			usCount++;
 8152              		.loc 1 2259 0
 8153 13ca 04F10103 		add	r3, r4, #1
 8154 13ce 9CB2     		uxth	r4, r3
 8155              	.L220:
2256:../3rdParty/FreeRTOS/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
 8156              		.loc 1 2256 0 discriminator 1
 8157 13d0 7B68     		ldr	r3, [r7, #4]
 8158 13d2 1B78     		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 8159 13d4 A52B     		cmp	r3, #165
 8160 13d6 F4D0     		beq	.L221
2260:../3rdParty/FreeRTOS/tasks.c **** 		}
2261:../3rdParty/FreeRTOS/tasks.c **** 
2262:../3rdParty/FreeRTOS/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
 8161              		.loc 1 2262 0
 8162 13d8 4FEA9403 		lsr	r3, r4, #2
 8163 13dc 9CB2     		uxth	r4, r3
2263:../3rdParty/FreeRTOS/tasks.c **** 
2264:../3rdParty/FreeRTOS/tasks.c **** 		return usCount;
 8164              		.loc 1 2264 0
 8165 13de 2346     		mov	r3, r4
2265:../3rdParty/FreeRTOS/tasks.c **** 	}
 8166              		.loc 1 2265 0
 8167 13e0 1846     		mov	r0, r3
 8168 13e2 07F10807 		add	r7, r7, #8
 8169 13e6 BD46     		mov	sp, r7
 8170 13e8 90BC     		pop	{r4, r7}
 8171 13ea 7047     		bx	lr
 8172              		.cfi_endproc
 8173              	.LFE91:
 8175              		.align	2
 8176              		.global	uxTaskGetStackHighWaterMark
 8177              		.thumb
 8178              		.thumb_func
 8180              	uxTaskGetStackHighWaterMark:
 8181              	.LFB92:
2266:../3rdParty/FreeRTOS/tasks.c **** 
2267:../3rdParty/FreeRTOS/tasks.c **** #endif
2268:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2269:../3rdParty/FreeRTOS/tasks.c **** 
2270:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2271:../3rdParty/FreeRTOS/tasks.c **** 
2272:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2273:../3rdParty/FreeRTOS/tasks.c **** 	{
 8182              		.loc 1 2273 0
 8183              		.cfi_startproc
 8184              		@ args = 0, pretend = 0, frame = 24
 8185              		@ frame_needed = 1, uses_anonymous_args = 0
 8186 13ec 80B5     		push	{r7, lr}
 8187              	.LCFI107:
 8188              		.cfi_def_cfa_offset 8
 8189 13ee 86B0     		sub	sp, sp, #24
 8190              	.LCFI108:
 8191              		.cfi_def_cfa_offset 32
 8192 13f0 00AF     		add	r7, sp, #0
 8193              		.cfi_offset 14, -4
 8194              		.cfi_offset 7, -8
 8195              	.LCFI109:
 8196              		.cfi_def_cfa_register 7
 8197 13f2 7860     		str	r0, [r7, #4]
2274:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB *pxTCB;
2275:../3rdParty/FreeRTOS/tasks.c **** 	unsigned char *pcEndOfStack;
2276:../3rdParty/FreeRTOS/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2277:../3rdParty/FreeRTOS/tasks.c **** 
2278:../3rdParty/FreeRTOS/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
 8198              		.loc 1 2278 0
 8199 13f4 7B68     		ldr	r3, [r7, #4]
 8200 13f6 002B     		cmp	r3, #0
 8201 13f8 02D1     		bne	.L223
 8202              		.loc 1 2278 0 is_stmt 0 discriminator 1
 8203 13fa 094B     		ldr	r3, .L225
 8204 13fc 1B68     		ldr	r3, [r3, #0]
 8205 13fe 00E0     		b	.L224
 8206              	.L223:
 8207              		.loc 1 2278 0 discriminator 2
 8208 1400 7B68     		ldr	r3, [r7, #4]
 8209              	.L224:
 8210              		.loc 1 2278 0 discriminator 3
 8211 1402 7B61     		str	r3, [r7, #20]
2279:../3rdParty/FreeRTOS/tasks.c **** 
2280:../3rdParty/FreeRTOS/tasks.c **** 		#if portSTACK_GROWTH < 0
2281:../3rdParty/FreeRTOS/tasks.c **** 		{
2282:../3rdParty/FreeRTOS/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
 8212              		.loc 1 2282 0 is_stmt 1 discriminator 3
 8213 1404 7B69     		ldr	r3, [r7, #20]
 8214 1406 1B6B     		ldr	r3, [r3, #48]
 8215 1408 3B61     		str	r3, [r7, #16]
2283:../3rdParty/FreeRTOS/tasks.c **** 		}
2284:../3rdParty/FreeRTOS/tasks.c **** 		#else
2285:../3rdParty/FreeRTOS/tasks.c **** 		{
2286:../3rdParty/FreeRTOS/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2287:../3rdParty/FreeRTOS/tasks.c **** 		}
2288:../3rdParty/FreeRTOS/tasks.c **** 		#endif
2289:../3rdParty/FreeRTOS/tasks.c **** 
2290:../3rdParty/FreeRTOS/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
 8216              		.loc 1 2290 0 discriminator 3
 8217 140a 3869     		ldr	r0, [r7, #16]
 8218 140c FFF7D2FF 		bl	usTaskCheckFreeStackSpace
 8219 1410 0346     		mov	r3, r0
 8220 1412 FB60     		str	r3, [r7, #12]
2291:../3rdParty/FreeRTOS/tasks.c **** 
2292:../3rdParty/FreeRTOS/tasks.c **** 		return uxReturn;
 8221              		.loc 1 2292 0 discriminator 3
 8222 1414 FB68     		ldr	r3, [r7, #12]
2293:../3rdParty/FreeRTOS/tasks.c **** 	}
 8223              		.loc 1 2293 0 discriminator 3
 8224 1416 1846     		mov	r0, r3
 8225 1418 07F11807 		add	r7, r7, #24
 8226 141c BD46     		mov	sp, r7
 8227 141e 80BD     		pop	{r7, pc}
 8228              	.L226:
 8229              		.align	2
 8230              	.L225:
 8231 1420 00000000 		.word	pxCurrentTCB
 8232              		.cfi_endproc
 8233              	.LFE92:
 8235              		.align	2
 8236              		.thumb
 8237              		.thumb_func
 8239              	prvDeleteTCB:
 8240              	.LFB93:
2294:../3rdParty/FreeRTOS/tasks.c **** 
2295:../3rdParty/FreeRTOS/tasks.c **** #endif
2296:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2297:../3rdParty/FreeRTOS/tasks.c **** 
2298:../3rdParty/FreeRTOS/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2299:../3rdParty/FreeRTOS/tasks.c **** 
2300:../3rdParty/FreeRTOS/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2301:../3rdParty/FreeRTOS/tasks.c **** 	{
 8241              		.loc 1 2301 0
 8242              		.cfi_startproc
 8243              		@ args = 0, pretend = 0, frame = 8
 8244              		@ frame_needed = 1, uses_anonymous_args = 0
 8245 1424 80B5     		push	{r7, lr}
 8246              	.LCFI110:
 8247              		.cfi_def_cfa_offset 8
 8248 1426 82B0     		sub	sp, sp, #8
 8249              	.LCFI111:
 8250              		.cfi_def_cfa_offset 16
 8251 1428 00AF     		add	r7, sp, #0
 8252              		.cfi_offset 14, -4
 8253              		.cfi_offset 7, -8
 8254              	.LCFI112:
 8255              		.cfi_def_cfa_register 7
 8256 142a 7860     		str	r0, [r7, #4]
2302:../3rdParty/FreeRTOS/tasks.c **** 		/* This call is required specifically for the TriCore port.  It must be
2303:../3rdParty/FreeRTOS/tasks.c **** 		above the vPortFree() calls. */
2304:../3rdParty/FreeRTOS/tasks.c **** 		portCLEAN_UP_TCB( pxTCB );
2305:../3rdParty/FreeRTOS/tasks.c **** 
2306:../3rdParty/FreeRTOS/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2307:../3rdParty/FreeRTOS/tasks.c **** 		the task to free any memory allocated at the application level. */
2308:../3rdParty/FreeRTOS/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 8257              		.loc 1 2308 0
 8258 142c 7B68     		ldr	r3, [r7, #4]
 8259 142e 1B6B     		ldr	r3, [r3, #48]
 8260 1430 1846     		mov	r0, r3
 8261 1432 FFF7FEFF 		bl	vPortFree
2309:../3rdParty/FreeRTOS/tasks.c **** 		vPortFree( pxTCB );
 8262              		.loc 1 2309 0
 8263 1436 7868     		ldr	r0, [r7, #4]
 8264 1438 FFF7FEFF 		bl	vPortFree
2310:../3rdParty/FreeRTOS/tasks.c **** 	}
 8265              		.loc 1 2310 0
 8266 143c 07F10807 		add	r7, r7, #8
 8267 1440 BD46     		mov	sp, r7
 8268 1442 80BD     		pop	{r7, pc}
 8269              		.cfi_endproc
 8270              	.LFE93:
 8272              		.align	2
 8273              		.global	xTaskGetCurrentTaskHandle
 8274              		.thumb
 8275              		.thumb_func
 8277              	xTaskGetCurrentTaskHandle:
 8278              	.LFB94:
2311:../3rdParty/FreeRTOS/tasks.c **** 
2312:../3rdParty/FreeRTOS/tasks.c **** #endif
2313:../3rdParty/FreeRTOS/tasks.c **** 
2314:../3rdParty/FreeRTOS/tasks.c **** 
2315:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2316:../3rdParty/FreeRTOS/tasks.c **** 
2317:../3rdParty/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2318:../3rdParty/FreeRTOS/tasks.c **** 
2319:../3rdParty/FreeRTOS/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2320:../3rdParty/FreeRTOS/tasks.c **** 	{
 8279              		.loc 1 2320 0
 8280              		.cfi_startproc
 8281              		@ args = 0, pretend = 0, frame = 8
 8282              		@ frame_needed = 1, uses_anonymous_args = 0
 8283              		@ link register save eliminated.
 8284 1444 80B4     		push	{r7}
 8285              	.LCFI113:
 8286              		.cfi_def_cfa_offset 4
 8287 1446 83B0     		sub	sp, sp, #12
 8288              	.LCFI114:
 8289              		.cfi_def_cfa_offset 16
 8290 1448 00AF     		add	r7, sp, #0
 8291              		.cfi_offset 7, -4
 8292              	.LCFI115:
 8293              		.cfi_def_cfa_register 7
2321:../3rdParty/FreeRTOS/tasks.c **** 	xTaskHandle xReturn;
2322:../3rdParty/FreeRTOS/tasks.c **** 
2323:../3rdParty/FreeRTOS/tasks.c **** 		/* A critical section is not required as this is not called from
2324:../3rdParty/FreeRTOS/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2325:../3rdParty/FreeRTOS/tasks.c **** 		individual execution thread. */
2326:../3rdParty/FreeRTOS/tasks.c **** 		xReturn = pxCurrentTCB;
 8294              		.loc 1 2326 0
 8295 144a 054B     		ldr	r3, .L229
 8296 144c 1B68     		ldr	r3, [r3, #0]
 8297 144e 7B60     		str	r3, [r7, #4]
2327:../3rdParty/FreeRTOS/tasks.c **** 
2328:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
 8298              		.loc 1 2328 0
 8299 1450 7B68     		ldr	r3, [r7, #4]
2329:../3rdParty/FreeRTOS/tasks.c **** 	}
 8300              		.loc 1 2329 0
 8301 1452 1846     		mov	r0, r3
 8302 1454 07F10C07 		add	r7, r7, #12
 8303 1458 BD46     		mov	sp, r7
 8304 145a 80BC     		pop	{r7}
 8305 145c 7047     		bx	lr
 8306              	.L230:
 8307 145e 00BF     		.align	2
 8308              	.L229:
 8309 1460 00000000 		.word	pxCurrentTCB
 8310              		.cfi_endproc
 8311              	.LFE94:
 8313              		.align	2
 8314              		.global	vTaskPriorityInherit
 8315              		.thumb
 8316              		.thumb_func
 8318              	vTaskPriorityInherit:
 8319              	.LFB95:
2330:../3rdParty/FreeRTOS/tasks.c **** 
2331:../3rdParty/FreeRTOS/tasks.c **** #endif
2332:../3rdParty/FreeRTOS/tasks.c **** 
2333:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2334:../3rdParty/FreeRTOS/tasks.c **** 
2335:../3rdParty/FreeRTOS/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2336:../3rdParty/FreeRTOS/tasks.c **** 
2337:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2338:../3rdParty/FreeRTOS/tasks.c **** 	{
2339:../3rdParty/FreeRTOS/tasks.c **** 	portBASE_TYPE xReturn;
2340:../3rdParty/FreeRTOS/tasks.c **** 
2341:../3rdParty/FreeRTOS/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
2342:../3rdParty/FreeRTOS/tasks.c **** 		{
2343:../3rdParty/FreeRTOS/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2344:../3rdParty/FreeRTOS/tasks.c **** 		}
2345:../3rdParty/FreeRTOS/tasks.c **** 		else
2346:../3rdParty/FreeRTOS/tasks.c **** 		{
2347:../3rdParty/FreeRTOS/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2348:../3rdParty/FreeRTOS/tasks.c **** 			{
2349:../3rdParty/FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
2350:../3rdParty/FreeRTOS/tasks.c **** 			}
2351:../3rdParty/FreeRTOS/tasks.c **** 			else
2352:../3rdParty/FreeRTOS/tasks.c **** 			{
2353:../3rdParty/FreeRTOS/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2354:../3rdParty/FreeRTOS/tasks.c **** 			}
2355:../3rdParty/FreeRTOS/tasks.c **** 		}
2356:../3rdParty/FreeRTOS/tasks.c **** 
2357:../3rdParty/FreeRTOS/tasks.c **** 		return xReturn;
2358:../3rdParty/FreeRTOS/tasks.c **** 	}
2359:../3rdParty/FreeRTOS/tasks.c **** 
2360:../3rdParty/FreeRTOS/tasks.c **** #endif
2361:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2362:../3rdParty/FreeRTOS/tasks.c **** 
2363:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2364:../3rdParty/FreeRTOS/tasks.c **** 
2365:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2366:../3rdParty/FreeRTOS/tasks.c **** 	{
 8320              		.loc 1 2366 0
 8321              		.cfi_startproc
 8322              		@ args = 0, pretend = 0, frame = 16
 8323              		@ frame_needed = 1, uses_anonymous_args = 0
 8324 1464 80B5     		push	{r7, lr}
 8325              	.LCFI116:
 8326              		.cfi_def_cfa_offset 8
 8327 1466 84B0     		sub	sp, sp, #16
 8328              	.LCFI117:
 8329              		.cfi_def_cfa_offset 24
 8330 1468 00AF     		add	r7, sp, #0
 8331              		.cfi_offset 14, -4
 8332              		.cfi_offset 7, -8
 8333              	.LCFI118:
 8334              		.cfi_def_cfa_register 7
 8335 146a 7860     		str	r0, [r7, #4]
2367:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 8336              		.loc 1 2367 0
 8337 146c 7B68     		ldr	r3, [r7, #4]
 8338 146e FB60     		str	r3, [r7, #12]
2368:../3rdParty/FreeRTOS/tasks.c **** 
2369:../3rdParty/FreeRTOS/tasks.c **** 		configASSERT( pxMutexHolder );
2370:../3rdParty/FreeRTOS/tasks.c **** 
2371:../3rdParty/FreeRTOS/tasks.c **** 		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8339              		.loc 1 2371 0
 8340 1470 FB68     		ldr	r3, [r7, #12]
 8341 1472 DA6A     		ldr	r2, [r3, #44]
 8342 1474 254B     		ldr	r3, .L235
 8343 1476 1B68     		ldr	r3, [r3, #0]
 8344 1478 DB6A     		ldr	r3, [r3, #44]
 8345 147a 9A42     		cmp	r2, r3
 8346 147c 42D2     		bcs	.L231
2372:../3rdParty/FreeRTOS/tasks.c **** 		{
2373:../3rdParty/FreeRTOS/tasks.c **** 			/* Adjust the mutex holder state to account for its new priority. */
2374:../3rdParty/FreeRTOS/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 8347              		.loc 1 2374 0
 8348 147e 234B     		ldr	r3, .L235
 8349 1480 1B68     		ldr	r3, [r3, #0]
 8350 1482 DB6A     		ldr	r3, [r3, #44]
 8351 1484 C3F10502 		rsb	r2, r3, #5
 8352 1488 FB68     		ldr	r3, [r7, #12]
 8353 148a 9A61     		str	r2, [r3, #24]
2375:../3rdParty/FreeRTOS/tasks.c **** 
2376:../3rdParty/FreeRTOS/tasks.c **** 			/* If the task being modified is in the ready state it will need to
2377:../3rdParty/FreeRTOS/tasks.c **** 			be moved in to a new list. */
2378:../3rdParty/FreeRTOS/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 8354              		.loc 1 2378 0
 8355 148c FB68     		ldr	r3, [r7, #12]
 8356 148e 5969     		ldr	r1, [r3, #20]
 8357 1490 FB68     		ldr	r3, [r7, #12]
 8358 1492 DA6A     		ldr	r2, [r3, #44]
 8359 1494 1346     		mov	r3, r2
 8360 1496 4FEA8303 		lsl	r3, r3, #2
 8361 149a 9B18     		adds	r3, r3, r2
 8362 149c 4FEA8303 		lsl	r3, r3, #2
 8363 14a0 1A46     		mov	r2, r3
 8364 14a2 1B4B     		ldr	r3, .L235+4
 8365 14a4 D318     		adds	r3, r2, r3
 8366 14a6 9942     		cmp	r1, r3
 8367 14a8 27D1     		bne	.L233
2379:../3rdParty/FreeRTOS/tasks.c **** 			{
2380:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 8368              		.loc 1 2380 0
 8369 14aa FB68     		ldr	r3, [r7, #12]
 8370 14ac 03F10403 		add	r3, r3, #4
 8371 14b0 1846     		mov	r0, r3
 8372 14b2 FFF7FEFF 		bl	vListRemove
2381:../3rdParty/FreeRTOS/tasks.c **** 
2382:../3rdParty/FreeRTOS/tasks.c **** 				/* Inherit the priority before being moved into the new list. */
2383:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8373              		.loc 1 2383 0
 8374 14b6 154B     		ldr	r3, .L235
 8375 14b8 1B68     		ldr	r3, [r3, #0]
 8376 14ba DA6A     		ldr	r2, [r3, #44]
 8377 14bc FB68     		ldr	r3, [r7, #12]
 8378 14be DA62     		str	r2, [r3, #44]
2384:../3rdParty/FreeRTOS/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 8379              		.loc 1 2384 0
 8380 14c0 FB68     		ldr	r3, [r7, #12]
 8381 14c2 DA6A     		ldr	r2, [r3, #44]
 8382 14c4 134B     		ldr	r3, .L235+8
 8383 14c6 1B68     		ldr	r3, [r3, #0]
 8384 14c8 9A42     		cmp	r2, r3
 8385 14ca 03D9     		bls	.L234
 8386              		.loc 1 2384 0 is_stmt 0 discriminator 1
 8387 14cc FB68     		ldr	r3, [r7, #12]
 8388 14ce DA6A     		ldr	r2, [r3, #44]
 8389 14d0 104B     		ldr	r3, .L235+8
 8390 14d2 1A60     		str	r2, [r3, #0]
 8391              	.L234:
 8392              		.loc 1 2384 0 discriminator 2
 8393 14d4 FB68     		ldr	r3, [r7, #12]
 8394 14d6 DA6A     		ldr	r2, [r3, #44]
 8395 14d8 1346     		mov	r3, r2
 8396 14da 4FEA8303 		lsl	r3, r3, #2
 8397 14de 9B18     		adds	r3, r3, r2
 8398 14e0 4FEA8303 		lsl	r3, r3, #2
 8399 14e4 1A46     		mov	r2, r3
 8400 14e6 0A4B     		ldr	r3, .L235+4
 8401 14e8 D218     		adds	r2, r2, r3
 8402 14ea FB68     		ldr	r3, [r7, #12]
 8403 14ec 03F10403 		add	r3, r3, #4
 8404 14f0 1046     		mov	r0, r2
 8405 14f2 1946     		mov	r1, r3
 8406 14f4 FFF7FEFF 		bl	vListInsertEnd
 8407 14f8 04E0     		b	.L231
 8408              	.L233:
2385:../3rdParty/FreeRTOS/tasks.c **** 			}
2386:../3rdParty/FreeRTOS/tasks.c **** 			else
2387:../3rdParty/FreeRTOS/tasks.c **** 			{
2388:../3rdParty/FreeRTOS/tasks.c **** 				/* Just inherit the priority. */
2389:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8409              		.loc 1 2389 0 is_stmt 1
 8410 14fa 044B     		ldr	r3, .L235
 8411 14fc 1B68     		ldr	r3, [r3, #0]
 8412 14fe DA6A     		ldr	r2, [r3, #44]
 8413 1500 FB68     		ldr	r3, [r7, #12]
 8414 1502 DA62     		str	r2, [r3, #44]
 8415              	.L231:
2390:../3rdParty/FreeRTOS/tasks.c **** 			}
2391:../3rdParty/FreeRTOS/tasks.c **** 
2392:../3rdParty/FreeRTOS/tasks.c **** 			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2393:../3rdParty/FreeRTOS/tasks.c **** 		}
2394:../3rdParty/FreeRTOS/tasks.c **** 	}
 8416              		.loc 1 2394 0
 8417 1504 07F11007 		add	r7, r7, #16
 8418 1508 BD46     		mov	sp, r7
 8419 150a 80BD     		pop	{r7, pc}
 8420              	.L236:
 8421              		.align	2
 8422              	.L235:
 8423 150c 00000000 		.word	pxCurrentTCB
 8424 1510 04000000 		.word	pxReadyTasksLists
 8425 1514 E4000000 		.word	uxTopReadyPriority
 8426              		.cfi_endproc
 8427              	.LFE95:
 8429              		.align	2
 8430              		.global	vTaskPriorityDisinherit
 8431              		.thumb
 8432              		.thumb_func
 8434              	vTaskPriorityDisinherit:
 8435              	.LFB96:
2395:../3rdParty/FreeRTOS/tasks.c **** 
2396:../3rdParty/FreeRTOS/tasks.c **** #endif
2397:../3rdParty/FreeRTOS/tasks.c **** /*-----------------------------------------------------------*/
2398:../3rdParty/FreeRTOS/tasks.c **** 
2399:../3rdParty/FreeRTOS/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2400:../3rdParty/FreeRTOS/tasks.c **** 
2401:../3rdParty/FreeRTOS/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2402:../3rdParty/FreeRTOS/tasks.c **** 	{
 8436              		.loc 1 2402 0
 8437              		.cfi_startproc
 8438              		@ args = 0, pretend = 0, frame = 16
 8439              		@ frame_needed = 1, uses_anonymous_args = 0
 8440 1518 80B5     		push	{r7, lr}
 8441              	.LCFI119:
 8442              		.cfi_def_cfa_offset 8
 8443 151a 84B0     		sub	sp, sp, #16
 8444              	.LCFI120:
 8445              		.cfi_def_cfa_offset 24
 8446 151c 00AF     		add	r7, sp, #0
 8447              		.cfi_offset 14, -4
 8448              		.cfi_offset 7, -8
 8449              	.LCFI121:
 8450              		.cfi_def_cfa_register 7
 8451 151e 7860     		str	r0, [r7, #4]
2403:../3rdParty/FreeRTOS/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 8452              		.loc 1 2403 0
 8453 1520 7B68     		ldr	r3, [r7, #4]
 8454 1522 FB60     		str	r3, [r7, #12]
2404:../3rdParty/FreeRTOS/tasks.c **** 
2405:../3rdParty/FreeRTOS/tasks.c **** 		if( pxMutexHolder != NULL )
 8455              		.loc 1 2405 0
 8456 1524 7B68     		ldr	r3, [r7, #4]
 8457 1526 002B     		cmp	r3, #0
 8458 1528 31D0     		beq	.L237
2406:../3rdParty/FreeRTOS/tasks.c **** 		{
2407:../3rdParty/FreeRTOS/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8459              		.loc 1 2407 0
 8460 152a FB68     		ldr	r3, [r7, #12]
 8461 152c DA6A     		ldr	r2, [r3, #44]
 8462 152e FB68     		ldr	r3, [r7, #12]
 8463 1530 9B6C     		ldr	r3, [r3, #72]
 8464 1532 9A42     		cmp	r2, r3
 8465 1534 2BD0     		beq	.L237
2408:../3rdParty/FreeRTOS/tasks.c **** 			{
2409:../3rdParty/FreeRTOS/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2410:../3rdParty/FreeRTOS/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2411:../3rdParty/FreeRTOS/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 8466              		.loc 1 2411 0
 8467 1536 FB68     		ldr	r3, [r7, #12]
 8468 1538 03F10403 		add	r3, r3, #4
 8469 153c 1846     		mov	r0, r3
 8470 153e FFF7FEFF 		bl	vListRemove
2412:../3rdParty/FreeRTOS/tasks.c **** 
2413:../3rdParty/FreeRTOS/tasks.c **** 				/* Disinherit the priority before adding the task into the new
2414:../3rdParty/FreeRTOS/tasks.c **** 				ready list. */
2415:../3rdParty/FreeRTOS/tasks.c **** 				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2416:../3rdParty/FreeRTOS/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 8471              		.loc 1 2416 0
 8472 1542 FB68     		ldr	r3, [r7, #12]
 8473 1544 9A6C     		ldr	r2, [r3, #72]
 8474 1546 FB68     		ldr	r3, [r7, #12]
 8475 1548 DA62     		str	r2, [r3, #44]
2417:../3rdParty/FreeRTOS/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 8476              		.loc 1 2417 0
 8477 154a FB68     		ldr	r3, [r7, #12]
 8478 154c DB6A     		ldr	r3, [r3, #44]
 8479 154e C3F10502 		rsb	r2, r3, #5
 8480 1552 FB68     		ldr	r3, [r7, #12]
 8481 1554 9A61     		str	r2, [r3, #24]
2418:../3rdParty/FreeRTOS/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 8482              		.loc 1 2418 0
 8483 1556 FB68     		ldr	r3, [r7, #12]
 8484 1558 DA6A     		ldr	r2, [r3, #44]
 8485 155a 0F4B     		ldr	r3, .L240
 8486 155c 1B68     		ldr	r3, [r3, #0]
 8487 155e 9A42     		cmp	r2, r3
 8488 1560 03D9     		bls	.L239
 8489              		.loc 1 2418 0 is_stmt 0 discriminator 1
 8490 1562 FB68     		ldr	r3, [r7, #12]
 8491 1564 DA6A     		ldr	r2, [r3, #44]
 8492 1566 0C4B     		ldr	r3, .L240
 8493 1568 1A60     		str	r2, [r3, #0]
 8494              	.L239:
 8495              		.loc 1 2418 0 discriminator 2
 8496 156a FB68     		ldr	r3, [r7, #12]
 8497 156c DA6A     		ldr	r2, [r3, #44]
 8498 156e 1346     		mov	r3, r2
 8499 1570 4FEA8303 		lsl	r3, r3, #2
 8500 1574 9B18     		adds	r3, r3, r2
 8501 1576 4FEA8303 		lsl	r3, r3, #2
 8502 157a 1A46     		mov	r2, r3
 8503 157c 074B     		ldr	r3, .L240+4
 8504 157e D218     		adds	r2, r2, r3
 8505 1580 FB68     		ldr	r3, [r7, #12]
 8506 1582 03F10403 		add	r3, r3, #4
 8507 1586 1046     		mov	r0, r2
 8508 1588 1946     		mov	r1, r3
 8509 158a FFF7FEFF 		bl	vListInsertEnd
 8510              	.L237:
2419:../3rdParty/FreeRTOS/tasks.c **** 			}
2420:../3rdParty/FreeRTOS/tasks.c **** 		}
2421:../3rdParty/FreeRTOS/tasks.c **** 	}
 8511              		.loc 1 2421 0 is_stmt 1
 8512 158e 07F11007 		add	r7, r7, #16
 8513 1592 BD46     		mov	sp, r7
 8514 1594 80BD     		pop	{r7, pc}
 8515              	.L241:
 8516 1596 00BF     		.align	2
 8517              	.L240:
 8518 1598 E4000000 		.word	uxTopReadyPriority
 8519 159c 04000000 		.word	pxReadyTasksLists
 8520              		.cfi_endproc
 8521              	.LFE96:
 8523              		.bss
 8524              		.align	2
 8525              	pcStatusString.6986:
 8526 0138 00000000 		.space	50
 8526      00000000 
 8526      00000000 
 8526      00000000 
 8526      00000000 
 8527 016a 0000     		.section	.rodata
 8528 004f 00       		.align	2
 8531              	ucExpectedStackBytes.6911:
 8532 0050 A5       		.byte	-91
 8533 0051 A5       		.byte	-91
 8534 0052 A5       		.byte	-91
 8535 0053 A5       		.byte	-91
 8536 0054 A5       		.byte	-91
 8537 0055 A5       		.byte	-91
 8538 0056 A5       		.byte	-91
 8539 0057 A5       		.byte	-91
 8540 0058 A5       		.byte	-91
 8541 0059 A5       		.byte	-91
 8542 005a A5       		.byte	-91
 8543 005b A5       		.byte	-91
 8544 005c A5       		.byte	-91
 8545 005d A5       		.byte	-91
 8546 005e A5       		.byte	-91
 8547 005f A5       		.byte	-91
 8548 0060 A5       		.byte	-91
 8549 0061 A5       		.byte	-91
 8550 0062 A5       		.byte	-91
 8551 0063 A5       		.byte	-91
 8552              		.text
 8553              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
     /tmp/ccligUTX.s:4491   .bss:00000000 pxCurrentTCB
     /tmp/ccligUTX.s:4488   .bss:00000000 $d
     /tmp/ccligUTX.s:4494   .bss:00000004 pxReadyTasksLists
     /tmp/ccligUTX.s:4497   .bss:00000068 xDelayedTaskList1
     /tmp/ccligUTX.s:4500   .bss:0000007c xDelayedTaskList2
     /tmp/ccligUTX.s:4503   .bss:00000090 pxDelayedTaskList
     /tmp/ccligUTX.s:4506   .bss:00000094 pxOverflowDelayedTaskList
     /tmp/ccligUTX.s:4509   .bss:00000098 xPendingReadyList
     /tmp/ccligUTX.s:4512   .bss:000000ac xTasksWaitingTermination
     /tmp/ccligUTX.s:4515   .bss:000000c0 uxTasksDeleted
     /tmp/ccligUTX.s:4518   .bss:000000c4 xSuspendedTaskList
     /tmp/ccligUTX.s:4521   .bss:000000d8 uxCurrentNumberOfTasks
     /tmp/ccligUTX.s:4524   .bss:000000dc xTickCount
     /tmp/ccligUTX.s:4527   .bss:000000e0 uxTopUsedPriority
     /tmp/ccligUTX.s:4530   .bss:000000e4 uxTopReadyPriority
     /tmp/ccligUTX.s:4533   .bss:000000e8 xSchedulerRunning
     /tmp/ccligUTX.s:4536   .bss:000000ec uxSchedulerSuspended
     /tmp/ccligUTX.s:4539   .bss:000000f0 uxMissedTicks
     /tmp/ccligUTX.s:4542   .bss:000000f4 xMissedYield
     /tmp/ccligUTX.s:4545   .bss:000000f8 xNumOfOverflows
     /tmp/ccligUTX.s:4548   .bss:000000fc uxTCBNumber
     /tmp/ccligUTX.s:4551   .data:00000000 $d
     /tmp/ccligUTX.s:4554   .data:00000000 xNextTaskUnblockTime
     /tmp/ccligUTX.s:4558   .bss:00000100 pcStatsString
     /tmp/ccligUTX.s:4561   .bss:00000134 ulTaskSwitchedInTime
     /tmp/ccligUTX.s:4564   .text:00000000 $t
     /tmp/ccligUTX.s:4569   .text:00000000 xTaskGenericCreate
     /tmp/ccligUTX.s:7742   .text:00001194 prvAllocateTCBAndStack
     /tmp/ccligUTX.s:7399   .text:00000fa0 prvInitialiseTCBVariables
     /tmp/ccligUTX.s:7487   .text:00001024 prvInitialiseTaskLists
     /tmp/ccligUTX.s:4776   .text:0000014c $d
     /tmp/ccligUTX.s:4786   .text:00000168 $t
     /tmp/ccligUTX.s:4791   .text:00000168 vTaskDelete
     /tmp/ccligUTX.s:4890   .text:000001f8 $d
     /tmp/ccligUTX.s:4898   .text:0000020c $t
     /tmp/ccligUTX.s:4903   .text:0000020c vTaskDelayUntil
     /tmp/ccligUTX.s:5865   .text:00000730 vTaskSuspendAll
     /tmp/ccligUTX.s:7663   .text:00001124 prvAddCurrentTaskToDelayedList
     /tmp/ccligUTX.s:5901   .text:0000074c xTaskResumeAll
     /tmp/ccligUTX.s:5009   .text:000002a4 $d
     /tmp/ccligUTX.s:5014   .text:000002ac $t
     /tmp/ccligUTX.s:5019   .text:000002ac vTaskDelay
     /tmp/ccligUTX.s:5079   .text:000002fc $d
     /tmp/ccligUTX.s:5084   .text:00000304 $t
     /tmp/ccligUTX.s:5089   .text:00000304 uxTaskPriorityGet
     /tmp/ccligUTX.s:5139   .text:00000338 $d
     /tmp/ccligUTX.s:5143   .text:0000033c $t
     /tmp/ccligUTX.s:5148   .text:0000033c vTaskPrioritySet
     /tmp/ccligUTX.s:5319   .text:00000444 $d
     /tmp/ccligUTX.s:5325   .text:00000450 $t
     /tmp/ccligUTX.s:5330   .text:00000450 vTaskSuspend
     /tmp/ccligUTX.s:6723   .text:00000c24 vTaskSwitchContext
     /tmp/ccligUTX.s:5434   .text:000004e4 $d
     /tmp/ccligUTX.s:5441   .text:000004f4 $t
     /tmp/ccligUTX.s:5446   .text:000004f4 xTaskIsTaskSuspended
     /tmp/ccligUTX.s:5502   .text:00000538 $d
     /tmp/ccligUTX.s:5507   .text:00000540 $t
     /tmp/ccligUTX.s:5512   .text:00000540 vTaskResume
     /tmp/ccligUTX.s:5605   .text:000005d0 $d
     /tmp/ccligUTX.s:5611   .text:000005dc $t
     /tmp/ccligUTX.s:5616   .text:000005dc xTaskResumeFromISR
     /tmp/ccligUTX.s:5730   .text:0000068c $d
     /tmp/ccligUTX.s:5739   .rodata:00000000 $d
     /tmp/ccligUTX.s:5743   .text:000006a0 $t
     /tmp/ccligUTX.s:5748   .text:000006a0 vTaskStartScheduler
     /tmp/ccligUTX.s:5812   .text:00000700 $d
     /tmp/ccligUTX.s:7369   .text:00000f90 prvIdleTask
     /tmp/ccligUTX.s:5819   .text:00000710 $t
     /tmp/ccligUTX.s:5824   .text:00000710 vTaskEndScheduler
     /tmp/ccligUTX.s:5856   .text:0000072c $d
     /tmp/ccligUTX.s:5860   .text:00000730 $t
     /tmp/ccligUTX.s:5892   .text:00000748 $d
     /tmp/ccligUTX.s:5896   .text:0000074c $t
     /tmp/ccligUTX.s:6524   .text:00000ae4 vTaskIncrementTick
     /tmp/ccligUTX.s:6059   .text:00000840 $d
     /tmp/ccligUTX.s:6070   .text:00000860 $t
     /tmp/ccligUTX.s:6075   .text:00000860 xTaskGetTickCount
     /tmp/ccligUTX.s:6110   .text:00000880 $d
     /tmp/ccligUTX.s:6114   .text:00000884 $t
     /tmp/ccligUTX.s:6119   .text:00000884 xTaskGetTickCountFromISR
     /tmp/ccligUTX.s:6167   .text:000008b4 $d
     /tmp/ccligUTX.s:6171   .text:000008b8 $t
     /tmp/ccligUTX.s:6176   .text:000008b8 uxTaskGetNumberOfTasks
     /tmp/ccligUTX.s:6201   .text:000008c8 $d
     /tmp/ccligUTX.s:6210   .text:000008cc $t
     /tmp/ccligUTX.s:6215   .text:000008cc vTaskList
     /tmp/ccligUTX.s:7831   .text:00001208 prvListTaskWithinSingleList
     /tmp/ccligUTX.s:6349   .text:000009b4 $d
     /tmp/ccligUTX.s:6359   .text:000009d0 $t
     /tmp/ccligUTX.s:6364   .text:000009d0 vTaskGetRunTimeStats
     /tmp/ccligUTX.s:7969   .text:000012c4 prvGenerateRunTimeStatsForTasksInList
     /tmp/ccligUTX.s:6508   .text:00000ac4 $d
     /tmp/ccligUTX.s:6519   .text:00000ae4 $t
     /tmp/ccligUTX.s:6706   .text:00000c00 $d
     /tmp/ccligUTX.s:6718   .text:00000c24 $t
     /tmp/ccligUTX.s:6887   .text:00000d2c $d
     /tmp/ccligUTX.s:8531   .rodata:00000050 ucExpectedStackBytes.6911
     /tmp/ccligUTX.s:6897   .text:00000d48 $t
     /tmp/ccligUTX.s:6902   .text:00000d48 vTaskPlaceOnEventList
     /tmp/ccligUTX.s:6964   .text:00000da4 $d
     /tmp/ccligUTX.s:6970   .text:00000db0 $t
     /tmp/ccligUTX.s:6975   .text:00000db0 xTaskRemoveFromEventList
     /tmp/ccligUTX.s:7077   .text:00000e50 $d
     /tmp/ccligUTX.s:7085   .text:00000e64 $t
     /tmp/ccligUTX.s:7090   .text:00000e64 vTaskSetTimeOutState
     /tmp/ccligUTX.s:7126   .text:00000e88 $d
     /tmp/ccligUTX.s:7131   .text:00000e90 $t
     /tmp/ccligUTX.s:7136   .text:00000e90 xTaskCheckForTimeOut
     /tmp/ccligUTX.s:7231   .text:00000f1c $d
     /tmp/ccligUTX.s:7236   .text:00000f24 $t
     /tmp/ccligUTX.s:7241   .text:00000f24 vTaskMissedYield
     /tmp/ccligUTX.s:7266   .text:00000f38 $d
     /tmp/ccligUTX.s:7270   .text:00000f3c $t
     /tmp/ccligUTX.s:7275   .text:00000f3c uxTaskGetTaskNumber
     /tmp/ccligUTX.s:7326   .text:00000f6c vTaskSetTaskNumber
     /tmp/ccligUTX.s:7574   .text:000010ac prvCheckTasksWaitingTermination
     /tmp/ccligUTX.s:7559   .text:0000108c $d
     /tmp/ccligUTX.s:7570   .text:000010ac $t
     /tmp/ccligUTX.s:8239   .text:00001424 prvDeleteTCB
     /tmp/ccligUTX.s:7653   .text:00001118 $d
     /tmp/ccligUTX.s:7659   .text:00001124 $t
     /tmp/ccligUTX.s:7730   .text:00001180 $d
     /tmp/ccligUTX.s:7738   .text:00001194 $t
     /tmp/ccligUTX.s:8124   .text:000013b4 usTaskCheckFreeStackSpace
     /tmp/ccligUTX.s:7949   .text:000012bc $d
     /tmp/ccligUTX.s:8525   .bss:00000138 pcStatusString.6986
     /tmp/ccligUTX.s:7965   .text:000012c4 $t
     /tmp/ccligUTX.s:8113   .text:000013a4 $d
     /tmp/ccligUTX.s:8120   .text:000013b4 $t
     /tmp/ccligUTX.s:8180   .text:000013ec uxTaskGetStackHighWaterMark
     /tmp/ccligUTX.s:8231   .text:00001420 $d
     /tmp/ccligUTX.s:8235   .text:00001424 $t
     /tmp/ccligUTX.s:8277   .text:00001444 xTaskGetCurrentTaskHandle
     /tmp/ccligUTX.s:8309   .text:00001460 $d
     /tmp/ccligUTX.s:8313   .text:00001464 $t
     /tmp/ccligUTX.s:8318   .text:00001464 vTaskPriorityInherit
     /tmp/ccligUTX.s:8423   .text:0000150c $d
     /tmp/ccligUTX.s:8429   .text:00001518 $t
     /tmp/ccligUTX.s:8434   .text:00001518 vTaskPriorityDisinherit
     /tmp/ccligUTX.s:8518   .text:00001598 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
vConfigureTimerForRunTimeStats
xPortStartScheduler
vPortEndScheduler
strlen
memcpy
vApplicationStackOverflowHook
memcmp
vListInsert
strncpy
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
sprintf
strcat
