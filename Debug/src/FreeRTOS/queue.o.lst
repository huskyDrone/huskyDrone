   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"queue.c"
  23              	.Ltext0:
  24              		.file 1 "../src/FreeRTOS/queue.c"
 4018              		.align	2
 4019              		.global	xQueueGenericCreate
 4020              		.thumb
 4021              		.thumb_func
 4023              	xQueueGenericCreate:
 4024              	.LFB29:
   1:../src/FreeRTOS/queue.c **** /*
   2:../src/FreeRTOS/queue.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../src/FreeRTOS/queue.c **** 
   4:../src/FreeRTOS/queue.c **** 
   5:../src/FreeRTOS/queue.c ****     ***************************************************************************
   6:../src/FreeRTOS/queue.c ****      *                                                                       *
   7:../src/FreeRTOS/queue.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../src/FreeRTOS/queue.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../src/FreeRTOS/queue.c ****      *    available.                                                         *
  10:../src/FreeRTOS/queue.c ****      *                                                                       *
  11:../src/FreeRTOS/queue.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../src/FreeRTOS/queue.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../src/FreeRTOS/queue.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../src/FreeRTOS/queue.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../src/FreeRTOS/queue.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../src/FreeRTOS/queue.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../src/FreeRTOS/queue.c ****      *                                                                       *
  18:../src/FreeRTOS/queue.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../src/FreeRTOS/queue.c ****      *                                                                       *
  20:../src/FreeRTOS/queue.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../src/FreeRTOS/queue.c ****      *                                                                       *
  22:../src/FreeRTOS/queue.c ****     ***************************************************************************
  23:../src/FreeRTOS/queue.c **** 
  24:../src/FreeRTOS/queue.c **** 
  25:../src/FreeRTOS/queue.c ****     This file is part of the FreeRTOS distribution.
  26:../src/FreeRTOS/queue.c **** 
  27:../src/FreeRTOS/queue.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../src/FreeRTOS/queue.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../src/FreeRTOS/queue.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../src/FreeRTOS/queue.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../src/FreeRTOS/queue.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../src/FreeRTOS/queue.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../src/FreeRTOS/queue.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../src/FreeRTOS/queue.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../src/FreeRTOS/queue.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../src/FreeRTOS/queue.c ****     more details. You should have received a copy of the GNU General Public
  37:../src/FreeRTOS/queue.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../src/FreeRTOS/queue.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../src/FreeRTOS/queue.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../src/FreeRTOS/queue.c ****     FreeRTOS WEB site.
  41:../src/FreeRTOS/queue.c **** 
  42:../src/FreeRTOS/queue.c ****     1 tab == 4 spaces!
  43:../src/FreeRTOS/queue.c **** 
  44:../src/FreeRTOS/queue.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../src/FreeRTOS/queue.c ****     contact details.
  46:../src/FreeRTOS/queue.c **** 
  47:../src/FreeRTOS/queue.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../src/FreeRTOS/queue.c ****     critical systems.
  49:../src/FreeRTOS/queue.c **** 
  50:../src/FreeRTOS/queue.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../src/FreeRTOS/queue.c ****     licensing and training services.
  52:../src/FreeRTOS/queue.c **** */
  53:../src/FreeRTOS/queue.c **** 
  54:../src/FreeRTOS/queue.c **** #include <stdlib.h>
  55:../src/FreeRTOS/queue.c **** #include <string.h>
  56:../src/FreeRTOS/queue.c **** 
  57:../src/FreeRTOS/queue.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  58:../src/FreeRTOS/queue.c **** all the API functions to use the MPU wrappers.  That should only be done when
  59:../src/FreeRTOS/queue.c **** task.h is included from an application file. */
  60:../src/FreeRTOS/queue.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  61:../src/FreeRTOS/queue.c **** 
  62:../src/FreeRTOS/queue.c **** #include "FreeRTOS.h"
  63:../src/FreeRTOS/queue.c **** #include "task.h"
  64:../src/FreeRTOS/queue.c **** 
  65:../src/FreeRTOS/queue.c **** #if ( configUSE_CO_ROUTINES == 1 )
  66:../src/FreeRTOS/queue.c **** 	#include "croutine.h"
  67:../src/FreeRTOS/queue.c **** #endif
  68:../src/FreeRTOS/queue.c **** 
  69:../src/FreeRTOS/queue.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:../src/FreeRTOS/queue.c **** 
  71:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------
  72:../src/FreeRTOS/queue.c ****  * PUBLIC LIST API documented in list.h
  73:../src/FreeRTOS/queue.c ****  *----------------------------------------------------------*/
  74:../src/FreeRTOS/queue.c **** 
  75:../src/FreeRTOS/queue.c **** /* Constants used with the cRxLock and cTxLock structure members. */
  76:../src/FreeRTOS/queue.c **** #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
  77:../src/FreeRTOS/queue.c **** #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
  78:../src/FreeRTOS/queue.c **** 
  79:../src/FreeRTOS/queue.c **** #define queueERRONEOUS_UNBLOCK			( -1 )
  80:../src/FreeRTOS/queue.c **** 
  81:../src/FreeRTOS/queue.c **** /* For internal use only. */
  82:../src/FreeRTOS/queue.c **** #define	queueSEND_TO_BACK				( 0 )
  83:../src/FreeRTOS/queue.c **** #define	queueSEND_TO_FRONT				( 1 )
  84:../src/FreeRTOS/queue.c **** 
  85:../src/FreeRTOS/queue.c **** /* Effectively make a union out of the xQUEUE structure. */
  86:../src/FreeRTOS/queue.c **** #define pxMutexHolder					pcTail
  87:../src/FreeRTOS/queue.c **** #define uxQueueType						pcHead
  88:../src/FreeRTOS/queue.c **** #define uxRecursiveCallCount			pcReadFrom
  89:../src/FreeRTOS/queue.c **** #define queueQUEUE_IS_MUTEX				NULL
  90:../src/FreeRTOS/queue.c **** 
  91:../src/FreeRTOS/queue.c **** /* Semaphores do not actually store or copy data, so have an items size of
  92:../src/FreeRTOS/queue.c **** zero. */
  93:../src/FreeRTOS/queue.c **** #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
  94:../src/FreeRTOS/queue.c **** #define queueDONT_BLOCK					 ( ( portTickType ) 0U )
  95:../src/FreeRTOS/queue.c **** #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
  96:../src/FreeRTOS/queue.c **** 
  97:../src/FreeRTOS/queue.c **** /* These definitions *must* match those in queue.h. */
  98:../src/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_BASE				( 0U )
  99:../src/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_MUTEX 				( 1U )
 100:../src/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( 2U )
 101:../src/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_BINARY_SEMAPHORE	( 3U )
 102:../src/FreeRTOS/queue.c **** #define queueQUEUE_TYPE_RECURSIVE_MUTEX		( 4U )
 103:../src/FreeRTOS/queue.c **** 
 104:../src/FreeRTOS/queue.c **** /*
 105:../src/FreeRTOS/queue.c ****  * Definition of the queue used by the scheduler.
 106:../src/FreeRTOS/queue.c ****  * Items are queued by copy, not reference.
 107:../src/FreeRTOS/queue.c ****  */
 108:../src/FreeRTOS/queue.c **** typedef struct QueueDefinition
 109:../src/FreeRTOS/queue.c **** {
 110:../src/FreeRTOS/queue.c **** 	signed char *pcHead;				/*< Points to the beginning of the queue storage area. */
 111:../src/FreeRTOS/queue.c **** 	signed char *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more by
 112:../src/FreeRTOS/queue.c **** 
 113:../src/FreeRTOS/queue.c **** 	signed char *pcWriteTo;				/*< Points to the free next place in the storage area. */
 114:../src/FreeRTOS/queue.c **** 	signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
 115:../src/FreeRTOS/queue.c **** 
 116:../src/FreeRTOS/queue.c **** 	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue. 
 117:../src/FreeRTOS/queue.c **** 	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue
 118:../src/FreeRTOS/queue.c **** 
 119:../src/FreeRTOS/queue.c **** 	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. 
 120:../src/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it wi
 121:../src/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
 122:../src/FreeRTOS/queue.c **** 
 123:../src/FreeRTOS/queue.c **** 	signed portBASE_TYPE xRxLock;			/*< Stores the number of items received from the queue (removed fr
 124:../src/FreeRTOS/queue.c **** 	signed portBASE_TYPE xTxLock;			/*< Stores the number of items transmitted to the queue (added to 
 125:../src/FreeRTOS/queue.c **** 	
 126:../src/FreeRTOS/queue.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 127:../src/FreeRTOS/queue.c **** 		unsigned char ucQueueNumber;
 128:../src/FreeRTOS/queue.c **** 		unsigned char ucQueueType;
 129:../src/FreeRTOS/queue.c **** 	#endif
 130:../src/FreeRTOS/queue.c **** 
 131:../src/FreeRTOS/queue.c **** } xQUEUE;
 132:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 133:../src/FreeRTOS/queue.c **** 
 134:../src/FreeRTOS/queue.c **** /*
 135:../src/FreeRTOS/queue.c ****  * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
 136:../src/FreeRTOS/queue.c ****  * To keep the definition private the API header file defines it as a
 137:../src/FreeRTOS/queue.c ****  * pointer to void.
 138:../src/FreeRTOS/queue.c ****  */
 139:../src/FreeRTOS/queue.c **** typedef xQUEUE * xQueueHandle;
 140:../src/FreeRTOS/queue.c **** 
 141:../src/FreeRTOS/queue.c **** /*
 142:../src/FreeRTOS/queue.c ****  * Prototypes for public functions are included here so we don't have to
 143:../src/FreeRTOS/queue.c ****  * include the API header file (as it defines xQueueHandle differently).  These
 144:../src/FreeRTOS/queue.c ****  * functions are documented in the API header file.
 145:../src/FreeRTOS/queue.c ****  */
 146:../src/FreeRTOS/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 147:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, port
 148:../src/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 149:../src/FreeRTOS/queue.c **** void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 150:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 151:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 152:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
 153:../src/FreeRTOS/queue.c **** xQueueHandle xQueueCreateMutex( unsigned char ucQueueType ) PRIVILEGED_FUNCTION;
 154:../src/FreeRTOS/queue.c **** xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_
 155:../src/FreeRTOS/queue.c **** portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_F
 156:../src/FreeRTOS/queue.c **** portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
 157:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, 
 158:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTick
 159:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 160:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 161:../src/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCT
 162:../src/FreeRTOS/queue.c **** void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait ) PRIVILEGED_F
 163:../src/FreeRTOS/queue.c **** unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 164:../src/FreeRTOS/queue.c **** void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber ) PRIVILEGED_FUNCTION;
 165:../src/FreeRTOS/queue.c **** unsigned char ucQueueGetQueueType( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 166:../src/FreeRTOS/queue.c **** 
 167:../src/FreeRTOS/queue.c **** /*
 168:../src/FreeRTOS/queue.c ****  * Co-routine queue functions differ from task queue functions.  Co-routines are
 169:../src/FreeRTOS/queue.c ****  * an optional component.
 170:../src/FreeRTOS/queue.c ****  */
 171:../src/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
 172:../src/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed 
 173:../src/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE
 174:../src/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType x
 175:../src/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToW
 176:../src/FreeRTOS/queue.c **** #endif
 177:../src/FreeRTOS/queue.c **** 
 178:../src/FreeRTOS/queue.c **** /*
 179:../src/FreeRTOS/queue.c ****  * The queue registry is just a means for kernel aware debuggers to locate
 180:../src/FreeRTOS/queue.c ****  * queue structures.  It has no other purpose so is an optional component.
 181:../src/FreeRTOS/queue.c ****  */
 182:../src/FreeRTOS/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
 183:../src/FreeRTOS/queue.c **** 
 184:../src/FreeRTOS/queue.c **** 	/* The type stored within the queue registry array.  This allows a name
 185:../src/FreeRTOS/queue.c **** 	to be assigned to each queue making kernel aware debugging a little
 186:../src/FreeRTOS/queue.c **** 	more user friendly. */
 187:../src/FreeRTOS/queue.c **** 	typedef struct QUEUE_REGISTRY_ITEM
 188:../src/FreeRTOS/queue.c **** 	{
 189:../src/FreeRTOS/queue.c **** 		signed char *pcQueueName;
 190:../src/FreeRTOS/queue.c **** 		xQueueHandle xHandle;
 191:../src/FreeRTOS/queue.c **** 	} xQueueRegistryItem;
 192:../src/FreeRTOS/queue.c **** 
 193:../src/FreeRTOS/queue.c **** 	/* The queue registry is simply an array of xQueueRegistryItem structures.
 194:../src/FreeRTOS/queue.c **** 	The pcQueueName member of a structure being NULL is indicative of the
 195:../src/FreeRTOS/queue.c **** 	array position being vacant. */
 196:../src/FreeRTOS/queue.c **** 	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
 197:../src/FreeRTOS/queue.c **** 
 198:../src/FreeRTOS/queue.c **** 	/* Removes a queue from the registry by simply setting the pcQueueName
 199:../src/FreeRTOS/queue.c **** 	member to NULL. */
 200:../src/FreeRTOS/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
 201:../src/FreeRTOS/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
 202:../src/FreeRTOS/queue.c **** #endif
 203:../src/FreeRTOS/queue.c **** 
 204:../src/FreeRTOS/queue.c **** /*
 205:../src/FreeRTOS/queue.c ****  * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
 206:../src/FreeRTOS/queue.c ****  * prevent an ISR from adding or removing items to the queue, but does prevent
 207:../src/FreeRTOS/queue.c ****  * an ISR from removing tasks from the queue event lists.  If an ISR finds a
 208:../src/FreeRTOS/queue.c ****  * queue is locked it will instead increment the appropriate queue lock count
 209:../src/FreeRTOS/queue.c ****  * to indicate that a task may require unblocking.  When the queue in unlocked
 210:../src/FreeRTOS/queue.c ****  * these lock counts are inspected, and the appropriate action taken.
 211:../src/FreeRTOS/queue.c ****  */
 212:../src/FreeRTOS/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 213:../src/FreeRTOS/queue.c **** 
 214:../src/FreeRTOS/queue.c **** /*
 215:../src/FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any data in a queue.
 216:../src/FreeRTOS/queue.c ****  *
 217:../src/FreeRTOS/queue.c ****  * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
 218:../src/FreeRTOS/queue.c ****  */
 219:../src/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 220:../src/FreeRTOS/queue.c **** 
 221:../src/FreeRTOS/queue.c **** /*
 222:../src/FreeRTOS/queue.c ****  * Uses a critical section to determine if there is any space in a queue.
 223:../src/FreeRTOS/queue.c ****  *
 224:../src/FreeRTOS/queue.c ****  * @return pdTRUE if there is no space, otherwise pdFALSE;
 225:../src/FreeRTOS/queue.c ****  */
 226:../src/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
 227:../src/FreeRTOS/queue.c **** 
 228:../src/FreeRTOS/queue.c **** /*
 229:../src/FreeRTOS/queue.c ****  * Copies an item into the queue, either at the front of the queue or the
 230:../src/FreeRTOS/queue.c ****  * back of the queue.
 231:../src/FreeRTOS/queue.c ****  */
 232:../src/FreeRTOS/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
 233:../src/FreeRTOS/queue.c **** 
 234:../src/FreeRTOS/queue.c **** /*
 235:../src/FreeRTOS/queue.c ****  * Copies an item out of a queue.
 236:../src/FreeRTOS/queue.c ****  */
 237:../src/FreeRTOS/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTIO
 238:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 239:../src/FreeRTOS/queue.c **** 
 240:../src/FreeRTOS/queue.c **** /*
 241:../src/FreeRTOS/queue.c ****  * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
 242:../src/FreeRTOS/queue.c ****  * accessing the queue event lists.
 243:../src/FreeRTOS/queue.c ****  */
 244:../src/FreeRTOS/queue.c **** #define prvLockQueue( pxQueue )								\
 245:../src/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();									\
 246:../src/FreeRTOS/queue.c **** 	{														\
 247:../src/FreeRTOS/queue.c **** 		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
 248:../src/FreeRTOS/queue.c **** 		{													\
 249:../src/FreeRTOS/queue.c **** 			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
 250:../src/FreeRTOS/queue.c **** 		}													\
 251:../src/FreeRTOS/queue.c **** 		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
 252:../src/FreeRTOS/queue.c **** 		{													\
 253:../src/FreeRTOS/queue.c **** 			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
 254:../src/FreeRTOS/queue.c **** 		}													\
 255:../src/FreeRTOS/queue.c **** 	}														\
 256:../src/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL()
 257:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 258:../src/FreeRTOS/queue.c **** 
 259:../src/FreeRTOS/queue.c **** 
 260:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------
 261:../src/FreeRTOS/queue.c ****  * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 262:../src/FreeRTOS/queue.c ****  *----------------------------------------------------------*/
 263:../src/FreeRTOS/queue.c **** 
 264:../src/FreeRTOS/queue.c **** xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxIt
 265:../src/FreeRTOS/queue.c **** {
 4025              		.loc 1 265 0
 4026              		.cfi_startproc
 4027              		@ args = 0, pretend = 0, frame = 32
 4028              		@ frame_needed = 1, uses_anonymous_args = 0
 4029 0000 80B5     		push	{r7, lr}
 4030              	.LCFI0:
 4031              		.cfi_def_cfa_offset 8
 4032 0002 88B0     		sub	sp, sp, #32
 4033              	.LCFI1:
 4034              		.cfi_def_cfa_offset 40
 4035 0004 00AF     		add	r7, sp, #0
 4036              		.cfi_offset 14, -4
 4037              		.cfi_offset 7, -8
 4038              	.LCFI2:
 4039              		.cfi_def_cfa_register 7
 4040 0006 F860     		str	r0, [r7, #12]
 4041 0008 B960     		str	r1, [r7, #8]
 4042 000a 1346     		mov	r3, r2
 4043 000c FB71     		strb	r3, [r7, #7]
 266:../src/FreeRTOS/queue.c **** xQUEUE *pxNewQueue;
 267:../src/FreeRTOS/queue.c **** size_t xQueueSizeInBytes;
 268:../src/FreeRTOS/queue.c **** xQueueHandle xReturn = NULL;
 4044              		.loc 1 268 0
 4045 000e 4FF00003 		mov	r3, #0
 4046 0012 FB61     		str	r3, [r7, #28]
 269:../src/FreeRTOS/queue.c **** 
 270:../src/FreeRTOS/queue.c **** 	/* Remove compiler warnings about unused parameters should 
 271:../src/FreeRTOS/queue.c **** 	configUSE_TRACE_FACILITY not be set to 1. */
 272:../src/FreeRTOS/queue.c **** 	( void ) ucQueueType;
 273:../src/FreeRTOS/queue.c **** 
 274:../src/FreeRTOS/queue.c **** 	/* Allocate the new queue structure. */
 275:../src/FreeRTOS/queue.c **** 	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 4047              		.loc 1 275 0
 4048 0014 FB68     		ldr	r3, [r7, #12]
 4049 0016 002B     		cmp	r3, #0
 4050 0018 5AD0     		beq	.L2
 276:../src/FreeRTOS/queue.c **** 	{
 277:../src/FreeRTOS/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 4051              		.loc 1 277 0
 4052 001a 4FF05000 		mov	r0, #80
 4053 001e FFF7FEFF 		bl	pvPortMalloc
 4054 0022 0346     		mov	r3, r0
 4055 0024 BB61     		str	r3, [r7, #24]
 278:../src/FreeRTOS/queue.c **** 		if( pxNewQueue != NULL )
 4056              		.loc 1 278 0
 4057 0026 BB69     		ldr	r3, [r7, #24]
 4058 0028 002B     		cmp	r3, #0
 4059 002a 51D0     		beq	.L2
 279:../src/FreeRTOS/queue.c **** 		{
 280:../src/FreeRTOS/queue.c **** 			/* Create the list of pointers to queue items.  The queue is one byte
 281:../src/FreeRTOS/queue.c **** 			longer than asked for to make wrap checking easier/faster. */
 282:../src/FreeRTOS/queue.c **** 			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 4060              		.loc 1 282 0
 4061 002c FB68     		ldr	r3, [r7, #12]
 4062 002e BA68     		ldr	r2, [r7, #8]
 4063 0030 02FB03F3 		mul	r3, r2, r3
 4064 0034 03F10103 		add	r3, r3, #1
 4065 0038 7B61     		str	r3, [r7, #20]
 283:../src/FreeRTOS/queue.c **** 
 284:../src/FreeRTOS/queue.c **** 			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 4066              		.loc 1 284 0
 4067 003a 7869     		ldr	r0, [r7, #20]
 4068 003c FFF7FEFF 		bl	pvPortMalloc
 4069 0040 0346     		mov	r3, r0
 4070 0042 1A46     		mov	r2, r3
 4071 0044 BB69     		ldr	r3, [r7, #24]
 4072 0046 1A60     		str	r2, [r3, #0]
 285:../src/FreeRTOS/queue.c **** 			if( pxNewQueue->pcHead != NULL )
 4073              		.loc 1 285 0
 4074 0048 BB69     		ldr	r3, [r7, #24]
 4075 004a 1B68     		ldr	r3, [r3, #0]
 4076 004c 002B     		cmp	r3, #0
 4077 004e 3CD0     		beq	.L3
 286:../src/FreeRTOS/queue.c **** 			{
 287:../src/FreeRTOS/queue.c **** 				/* Initialise the queue members as described above where the
 288:../src/FreeRTOS/queue.c **** 				queue type is defined. */
 289:../src/FreeRTOS/queue.c **** 				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
 4078              		.loc 1 289 0
 4079 0050 BB69     		ldr	r3, [r7, #24]
 4080 0052 1A68     		ldr	r2, [r3, #0]
 4081 0054 FB68     		ldr	r3, [r7, #12]
 4082 0056 B968     		ldr	r1, [r7, #8]
 4083 0058 01FB03F3 		mul	r3, r1, r3
 4084 005c D218     		adds	r2, r2, r3
 4085 005e BB69     		ldr	r3, [r7, #24]
 4086 0060 5A60     		str	r2, [r3, #4]
 290:../src/FreeRTOS/queue.c **** 				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 4087              		.loc 1 290 0
 4088 0062 BB69     		ldr	r3, [r7, #24]
 4089 0064 4FF00002 		mov	r2, #0
 4090 0068 9A63     		str	r2, [r3, #56]
 291:../src/FreeRTOS/queue.c **** 				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
 4091              		.loc 1 291 0
 4092 006a BB69     		ldr	r3, [r7, #24]
 4093 006c 1A68     		ldr	r2, [r3, #0]
 4094 006e BB69     		ldr	r3, [r7, #24]
 4095 0070 9A60     		str	r2, [r3, #8]
 292:../src/FreeRTOS/queue.c **** 				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U
 4096              		.loc 1 292 0
 4097 0072 BB69     		ldr	r3, [r7, #24]
 4098 0074 1A68     		ldr	r2, [r3, #0]
 4099 0076 FB68     		ldr	r3, [r7, #12]
 4100 0078 03F1FF33 		add	r3, r3, #-1
 4101 007c B968     		ldr	r1, [r7, #8]
 4102 007e 01FB03F3 		mul	r3, r1, r3
 4103 0082 D218     		adds	r2, r2, r3
 4104 0084 BB69     		ldr	r3, [r7, #24]
 4105 0086 DA60     		str	r2, [r3, #12]
 293:../src/FreeRTOS/queue.c **** 				pxNewQueue->uxLength = uxQueueLength;
 4106              		.loc 1 293 0
 4107 0088 BB69     		ldr	r3, [r7, #24]
 4108 008a FA68     		ldr	r2, [r7, #12]
 4109 008c DA63     		str	r2, [r3, #60]
 294:../src/FreeRTOS/queue.c **** 				pxNewQueue->uxItemSize = uxItemSize;
 4110              		.loc 1 294 0
 4111 008e BB69     		ldr	r3, [r7, #24]
 4112 0090 BA68     		ldr	r2, [r7, #8]
 4113 0092 1A64     		str	r2, [r3, #64]
 295:../src/FreeRTOS/queue.c **** 				pxNewQueue->xRxLock = queueUNLOCKED;
 4114              		.loc 1 295 0
 4115 0094 BB69     		ldr	r3, [r7, #24]
 4116 0096 4FF0FF32 		mov	r2, #-1
 4117 009a 5A64     		str	r2, [r3, #68]
 296:../src/FreeRTOS/queue.c **** 				pxNewQueue->xTxLock = queueUNLOCKED;
 4118              		.loc 1 296 0
 4119 009c BB69     		ldr	r3, [r7, #24]
 4120 009e 4FF0FF32 		mov	r2, #-1
 4121 00a2 9A64     		str	r2, [r3, #72]
 297:../src/FreeRTOS/queue.c **** 				#if ( configUSE_TRACE_FACILITY == 1 )
 298:../src/FreeRTOS/queue.c **** 				{
 299:../src/FreeRTOS/queue.c **** 					pxNewQueue->ucQueueType = ucQueueType;
 4122              		.loc 1 299 0
 4123 00a4 BB69     		ldr	r3, [r7, #24]
 4124 00a6 FA79     		ldrb	r2, [r7, #7]
 4125 00a8 83F84D20 		strb	r2, [r3, #77]
 300:../src/FreeRTOS/queue.c **** 				}
 301:../src/FreeRTOS/queue.c **** 				#endif /* configUSE_TRACE_FACILITY */
 302:../src/FreeRTOS/queue.c **** 
 303:../src/FreeRTOS/queue.c **** 				/* Likewise ensure the event queues start with the correct state. */
 304:../src/FreeRTOS/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 4126              		.loc 1 304 0
 4127 00ac BB69     		ldr	r3, [r7, #24]
 4128 00ae 03F11003 		add	r3, r3, #16
 4129 00b2 1846     		mov	r0, r3
 4130 00b4 FFF7FEFF 		bl	vListInitialise
 305:../src/FreeRTOS/queue.c **** 				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 4131              		.loc 1 305 0
 4132 00b8 BB69     		ldr	r3, [r7, #24]
 4133 00ba 03F12403 		add	r3, r3, #36
 4134 00be 1846     		mov	r0, r3
 4135 00c0 FFF7FEFF 		bl	vListInitialise
 306:../src/FreeRTOS/queue.c **** 
 307:../src/FreeRTOS/queue.c **** 				traceQUEUE_CREATE( pxNewQueue );
 308:../src/FreeRTOS/queue.c **** 				xReturn = pxNewQueue;
 4136              		.loc 1 308 0
 4137 00c4 BB69     		ldr	r3, [r7, #24]
 4138 00c6 FB61     		str	r3, [r7, #28]
 4139 00c8 02E0     		b	.L2
 4140              	.L3:
 309:../src/FreeRTOS/queue.c **** 			}
 310:../src/FreeRTOS/queue.c **** 			else
 311:../src/FreeRTOS/queue.c **** 			{
 312:../src/FreeRTOS/queue.c **** 				traceQUEUE_CREATE_FAILED( ucQueueType );
 313:../src/FreeRTOS/queue.c **** 				vPortFree( pxNewQueue );
 4141              		.loc 1 313 0
 4142 00ca B869     		ldr	r0, [r7, #24]
 4143 00cc FFF7FEFF 		bl	vPortFree
 4144              	.L2:
 314:../src/FreeRTOS/queue.c **** 			}
 315:../src/FreeRTOS/queue.c **** 		}
 316:../src/FreeRTOS/queue.c **** 	}
 317:../src/FreeRTOS/queue.c **** 
 318:../src/FreeRTOS/queue.c **** 	configASSERT( xReturn );
 319:../src/FreeRTOS/queue.c **** 
 320:../src/FreeRTOS/queue.c **** 	return xReturn;
 4145              		.loc 1 320 0
 4146 00d0 FB69     		ldr	r3, [r7, #28]
 321:../src/FreeRTOS/queue.c **** }
 4147              		.loc 1 321 0
 4148 00d2 1846     		mov	r0, r3
 4149 00d4 07F12007 		add	r7, r7, #32
 4150 00d8 BD46     		mov	sp, r7
 4151 00da 80BD     		pop	{r7, pc}
 4152              		.cfi_endproc
 4153              	.LFE29:
 4155              		.align	2
 4156              		.global	xQueueCreateMutex
 4157              		.thumb
 4158              		.thumb_func
 4160              	xQueueCreateMutex:
 4161              	.LFB30:
 322:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 323:../src/FreeRTOS/queue.c **** 
 324:../src/FreeRTOS/queue.c **** #if ( configUSE_MUTEXES == 1 )
 325:../src/FreeRTOS/queue.c **** 
 326:../src/FreeRTOS/queue.c **** 	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
 327:../src/FreeRTOS/queue.c **** 	{
 4162              		.loc 1 327 0
 4163              		.cfi_startproc
 4164              		@ args = 0, pretend = 0, frame = 16
 4165              		@ frame_needed = 1, uses_anonymous_args = 0
 4166 00dc 80B5     		push	{r7, lr}
 4167              	.LCFI3:
 4168              		.cfi_def_cfa_offset 8
 4169 00de 84B0     		sub	sp, sp, #16
 4170              	.LCFI4:
 4171              		.cfi_def_cfa_offset 24
 4172 00e0 00AF     		add	r7, sp, #0
 4173              		.cfi_offset 14, -4
 4174              		.cfi_offset 7, -8
 4175              	.LCFI5:
 4176              		.cfi_def_cfa_register 7
 4177 00e2 0346     		mov	r3, r0
 4178 00e4 FB71     		strb	r3, [r7, #7]
 328:../src/FreeRTOS/queue.c **** 	xQUEUE *pxNewQueue;
 329:../src/FreeRTOS/queue.c **** 
 330:../src/FreeRTOS/queue.c **** 		/* Prevent compiler warnings about unused parameters if
 331:../src/FreeRTOS/queue.c **** 		configUSE_TRACE_FACILITY does not equal 1. */
 332:../src/FreeRTOS/queue.c **** 		( void ) ucQueueType;
 333:../src/FreeRTOS/queue.c **** 	
 334:../src/FreeRTOS/queue.c **** 		/* Allocate the new queue structure. */
 335:../src/FreeRTOS/queue.c **** 		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 4179              		.loc 1 335 0
 4180 00e6 4FF05000 		mov	r0, #80
 4181 00ea FFF7FEFF 		bl	pvPortMalloc
 4182 00ee 0346     		mov	r3, r0
 4183 00f0 FB60     		str	r3, [r7, #12]
 336:../src/FreeRTOS/queue.c **** 		if( pxNewQueue != NULL )
 4184              		.loc 1 336 0
 4185 00f2 FB68     		ldr	r3, [r7, #12]
 4186 00f4 002B     		cmp	r3, #0
 4187 00f6 3CD0     		beq	.L5
 337:../src/FreeRTOS/queue.c **** 		{
 338:../src/FreeRTOS/queue.c **** 			/* Information required for priority inheritance. */
 339:../src/FreeRTOS/queue.c **** 			pxNewQueue->pxMutexHolder = NULL;
 4188              		.loc 1 339 0
 4189 00f8 FB68     		ldr	r3, [r7, #12]
 4190 00fa 4FF00002 		mov	r2, #0
 4191 00fe 5A60     		str	r2, [r3, #4]
 340:../src/FreeRTOS/queue.c **** 			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 4192              		.loc 1 340 0
 4193 0100 FB68     		ldr	r3, [r7, #12]
 4194 0102 4FF00002 		mov	r2, #0
 4195 0106 1A60     		str	r2, [r3, #0]
 341:../src/FreeRTOS/queue.c **** 
 342:../src/FreeRTOS/queue.c **** 			/* Queues used as a mutex no data is actually copied into or out
 343:../src/FreeRTOS/queue.c **** 			of the queue. */
 344:../src/FreeRTOS/queue.c **** 			pxNewQueue->pcWriteTo = NULL;
 4196              		.loc 1 344 0
 4197 0108 FB68     		ldr	r3, [r7, #12]
 4198 010a 4FF00002 		mov	r2, #0
 4199 010e 9A60     		str	r2, [r3, #8]
 345:../src/FreeRTOS/queue.c **** 			pxNewQueue->pcReadFrom = NULL;
 4200              		.loc 1 345 0
 4201 0110 FB68     		ldr	r3, [r7, #12]
 4202 0112 4FF00002 		mov	r2, #0
 4203 0116 DA60     		str	r2, [r3, #12]
 346:../src/FreeRTOS/queue.c **** 
 347:../src/FreeRTOS/queue.c **** 			/* Each mutex has a length of 1 (like a binary semaphore) and
 348:../src/FreeRTOS/queue.c **** 			an item size of 0 as nothing is actually copied into or out
 349:../src/FreeRTOS/queue.c **** 			of the mutex. */
 350:../src/FreeRTOS/queue.c **** 			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 4204              		.loc 1 350 0
 4205 0118 FB68     		ldr	r3, [r7, #12]
 4206 011a 4FF00002 		mov	r2, #0
 4207 011e 9A63     		str	r2, [r3, #56]
 351:../src/FreeRTOS/queue.c **** 			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 4208              		.loc 1 351 0
 4209 0120 FB68     		ldr	r3, [r7, #12]
 4210 0122 4FF00102 		mov	r2, #1
 4211 0126 DA63     		str	r2, [r3, #60]
 352:../src/FreeRTOS/queue.c **** 			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 4212              		.loc 1 352 0
 4213 0128 FB68     		ldr	r3, [r7, #12]
 4214 012a 4FF00002 		mov	r2, #0
 4215 012e 1A64     		str	r2, [r3, #64]
 353:../src/FreeRTOS/queue.c **** 			pxNewQueue->xRxLock = queueUNLOCKED;
 4216              		.loc 1 353 0
 4217 0130 FB68     		ldr	r3, [r7, #12]
 4218 0132 4FF0FF32 		mov	r2, #-1
 4219 0136 5A64     		str	r2, [r3, #68]
 354:../src/FreeRTOS/queue.c **** 			pxNewQueue->xTxLock = queueUNLOCKED;
 4220              		.loc 1 354 0
 4221 0138 FB68     		ldr	r3, [r7, #12]
 4222 013a 4FF0FF32 		mov	r2, #-1
 4223 013e 9A64     		str	r2, [r3, #72]
 355:../src/FreeRTOS/queue.c **** 			
 356:../src/FreeRTOS/queue.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 357:../src/FreeRTOS/queue.c **** 			{
 358:../src/FreeRTOS/queue.c **** 				pxNewQueue->ucQueueType = ucQueueType;
 4224              		.loc 1 358 0
 4225 0140 FB68     		ldr	r3, [r7, #12]
 4226 0142 FA79     		ldrb	r2, [r7, #7]
 4227 0144 83F84D20 		strb	r2, [r3, #77]
 359:../src/FreeRTOS/queue.c **** 			}
 360:../src/FreeRTOS/queue.c **** 			#endif
 361:../src/FreeRTOS/queue.c **** 
 362:../src/FreeRTOS/queue.c **** 			/* Ensure the event queues start with the correct state. */
 363:../src/FreeRTOS/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 4228              		.loc 1 363 0
 4229 0148 FB68     		ldr	r3, [r7, #12]
 4230 014a 03F11003 		add	r3, r3, #16
 4231 014e 1846     		mov	r0, r3
 4232 0150 FFF7FEFF 		bl	vListInitialise
 364:../src/FreeRTOS/queue.c **** 			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 4233              		.loc 1 364 0
 4234 0154 FB68     		ldr	r3, [r7, #12]
 4235 0156 03F12403 		add	r3, r3, #36
 4236 015a 1846     		mov	r0, r3
 4237 015c FFF7FEFF 		bl	vListInitialise
 365:../src/FreeRTOS/queue.c **** 
 366:../src/FreeRTOS/queue.c **** 			traceCREATE_MUTEX( pxNewQueue );
 367:../src/FreeRTOS/queue.c **** 
 368:../src/FreeRTOS/queue.c **** 			/* Start with the semaphore in the expected state. */
 369:../src/FreeRTOS/queue.c **** 			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 4238              		.loc 1 369 0
 4239 0160 F868     		ldr	r0, [r7, #12]
 4240 0162 4FF00001 		mov	r1, #0
 4241 0166 4FF00002 		mov	r2, #0
 4242 016a 4FF00003 		mov	r3, #0
 4243 016e FFF7FEFF 		bl	xQueueGenericSend
 4244              	.L5:
 370:../src/FreeRTOS/queue.c **** 		}
 371:../src/FreeRTOS/queue.c **** 		else
 372:../src/FreeRTOS/queue.c **** 		{
 373:../src/FreeRTOS/queue.c **** 			traceCREATE_MUTEX_FAILED();
 374:../src/FreeRTOS/queue.c **** 		}
 375:../src/FreeRTOS/queue.c **** 
 376:../src/FreeRTOS/queue.c **** 		configASSERT( pxNewQueue );
 377:../src/FreeRTOS/queue.c **** 		return pxNewQueue;
 4245              		.loc 1 377 0
 4246 0172 FB68     		ldr	r3, [r7, #12]
 378:../src/FreeRTOS/queue.c **** 	}
 4247              		.loc 1 378 0
 4248 0174 1846     		mov	r0, r3
 4249 0176 07F11007 		add	r7, r7, #16
 4250 017a BD46     		mov	sp, r7
 4251 017c 80BD     		pop	{r7, pc}
 4252              		.cfi_endproc
 4253              	.LFE30:
 4255 017e 00BF     		.align	2
 4256              		.global	xQueueGiveMutexRecursive
 4257              		.thumb
 4258              		.thumb_func
 4260              	xQueueGiveMutexRecursive:
 4261              	.LFB31:
 379:../src/FreeRTOS/queue.c **** 
 380:../src/FreeRTOS/queue.c **** #endif /* configUSE_MUTEXES */
 381:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 382:../src/FreeRTOS/queue.c **** 
 383:../src/FreeRTOS/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 384:../src/FreeRTOS/queue.c **** 
 385:../src/FreeRTOS/queue.c **** 	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
 386:../src/FreeRTOS/queue.c **** 	{
 4262              		.loc 1 386 0
 4263              		.cfi_startproc
 4264              		@ args = 0, pretend = 0, frame = 16
 4265              		@ frame_needed = 1, uses_anonymous_args = 0
 4266 0180 90B5     		push	{r4, r7, lr}
 4267              	.LCFI6:
 4268              		.cfi_def_cfa_offset 12
 4269 0182 85B0     		sub	sp, sp, #20
 4270              	.LCFI7:
 4271              		.cfi_def_cfa_offset 32
 4272 0184 00AF     		add	r7, sp, #0
 4273              		.cfi_offset 14, -4
 4274              		.cfi_offset 7, -8
 4275              		.cfi_offset 4, -12
 4276              	.LCFI8:
 4277              		.cfi_def_cfa_register 7
 4278 0186 7860     		str	r0, [r7, #4]
 387:../src/FreeRTOS/queue.c **** 	portBASE_TYPE xReturn;
 388:../src/FreeRTOS/queue.c **** 
 389:../src/FreeRTOS/queue.c **** 		configASSERT( pxMutex );
 390:../src/FreeRTOS/queue.c **** 
 391:../src/FreeRTOS/queue.c **** 		/* If this is the task that holds the mutex then pxMutexHolder will not
 392:../src/FreeRTOS/queue.c **** 		change outside of this task.  If this task does not hold the mutex then
 393:../src/FreeRTOS/queue.c **** 		pxMutexHolder can never coincidentally equal the tasks handle, and as
 394:../src/FreeRTOS/queue.c **** 		this is the only condition we are interested in it does not matter if
 395:../src/FreeRTOS/queue.c **** 		pxMutexHolder is accessed simultaneously by another task.  Therefore no
 396:../src/FreeRTOS/queue.c **** 		mutual exclusion is required to test the pxMutexHolder variable. */
 397:../src/FreeRTOS/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 4279              		.loc 1 397 0
 4280 0188 7B68     		ldr	r3, [r7, #4]
 4281 018a 5C68     		ldr	r4, [r3, #4]
 4282 018c FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 4283 0190 0346     		mov	r3, r0
 4284 0192 9C42     		cmp	r4, r3
 4285 0194 16D1     		bne	.L7
 398:../src/FreeRTOS/queue.c **** 		{
 399:../src/FreeRTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE( pxMutex );
 400:../src/FreeRTOS/queue.c **** 
 401:../src/FreeRTOS/queue.c **** 			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
 402:../src/FreeRTOS/queue.c **** 			the task handle, therefore no underflow check is required.  Also,
 403:../src/FreeRTOS/queue.c **** 			uxRecursiveCallCount is only modified by the mutex holder, and as
 404:../src/FreeRTOS/queue.c **** 			there can only be one, no mutual exclusion is required to modify the
 405:../src/FreeRTOS/queue.c **** 			uxRecursiveCallCount member. */
 406:../src/FreeRTOS/queue.c **** 			( pxMutex->uxRecursiveCallCount )--;
 4286              		.loc 1 406 0
 4287 0196 7B68     		ldr	r3, [r7, #4]
 4288 0198 DB68     		ldr	r3, [r3, #12]
 4289 019a 03F1FF32 		add	r2, r3, #-1
 4290 019e 7B68     		ldr	r3, [r7, #4]
 4291 01a0 DA60     		str	r2, [r3, #12]
 407:../src/FreeRTOS/queue.c **** 
 408:../src/FreeRTOS/queue.c **** 			/* Have we unwound the call count? */
 409:../src/FreeRTOS/queue.c **** 			if( pxMutex->uxRecursiveCallCount == 0 )
 4292              		.loc 1 409 0
 4293 01a2 7B68     		ldr	r3, [r7, #4]
 4294 01a4 DB68     		ldr	r3, [r3, #12]
 4295 01a6 002B     		cmp	r3, #0
 4296 01a8 08D1     		bne	.L8
 410:../src/FreeRTOS/queue.c **** 			{
 411:../src/FreeRTOS/queue.c **** 				/* Return the mutex.  This will automatically unblock any other
 412:../src/FreeRTOS/queue.c **** 				task that might be waiting to access the mutex. */
 413:../src/FreeRTOS/queue.c **** 				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 4297              		.loc 1 413 0
 4298 01aa 7868     		ldr	r0, [r7, #4]
 4299 01ac 4FF00001 		mov	r1, #0
 4300 01b0 4FF00002 		mov	r2, #0
 4301 01b4 4FF00003 		mov	r3, #0
 4302 01b8 FFF7FEFF 		bl	xQueueGenericSend
 4303              	.L8:
 414:../src/FreeRTOS/queue.c **** 			}
 415:../src/FreeRTOS/queue.c **** 
 416:../src/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 4304              		.loc 1 416 0
 4305 01bc 4FF00103 		mov	r3, #1
 4306 01c0 FB60     		str	r3, [r7, #12]
 4307 01c2 02E0     		b	.L9
 4308              	.L7:
 417:../src/FreeRTOS/queue.c **** 		}
 418:../src/FreeRTOS/queue.c **** 		else
 419:../src/FreeRTOS/queue.c **** 		{
 420:../src/FreeRTOS/queue.c **** 			/* We cannot give the mutex because we are not the holder. */
 421:../src/FreeRTOS/queue.c **** 			xReturn = pdFAIL;
 4309              		.loc 1 421 0
 4310 01c4 4FF00003 		mov	r3, #0
 4311 01c8 FB60     		str	r3, [r7, #12]
 4312              	.L9:
 422:../src/FreeRTOS/queue.c **** 
 423:../src/FreeRTOS/queue.c **** 			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
 424:../src/FreeRTOS/queue.c **** 		}
 425:../src/FreeRTOS/queue.c **** 
 426:../src/FreeRTOS/queue.c **** 		return xReturn;
 4313              		.loc 1 426 0
 4314 01ca FB68     		ldr	r3, [r7, #12]
 427:../src/FreeRTOS/queue.c **** 	}
 4315              		.loc 1 427 0
 4316 01cc 1846     		mov	r0, r3
 4317 01ce 07F11407 		add	r7, r7, #20
 4318 01d2 BD46     		mov	sp, r7
 4319 01d4 90BD     		pop	{r4, r7, pc}
 4320              		.cfi_endproc
 4321              	.LFE31:
 4323 01d6 00BF     		.align	2
 4324              		.global	xQueueTakeMutexRecursive
 4325              		.thumb
 4326              		.thumb_func
 4328              	xQueueTakeMutexRecursive:
 4329              	.LFB32:
 428:../src/FreeRTOS/queue.c **** 
 429:../src/FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 430:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 431:../src/FreeRTOS/queue.c **** 
 432:../src/FreeRTOS/queue.c **** #if configUSE_RECURSIVE_MUTEXES == 1
 433:../src/FreeRTOS/queue.c **** 
 434:../src/FreeRTOS/queue.c **** 	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
 435:../src/FreeRTOS/queue.c **** 	{
 4330              		.loc 1 435 0
 4331              		.cfi_startproc
 4332              		@ args = 0, pretend = 0, frame = 16
 4333              		@ frame_needed = 1, uses_anonymous_args = 0
 4334 01d8 90B5     		push	{r4, r7, lr}
 4335              	.LCFI9:
 4336              		.cfi_def_cfa_offset 12
 4337 01da 85B0     		sub	sp, sp, #20
 4338              	.LCFI10:
 4339              		.cfi_def_cfa_offset 32
 4340 01dc 00AF     		add	r7, sp, #0
 4341              		.cfi_offset 14, -4
 4342              		.cfi_offset 7, -8
 4343              		.cfi_offset 4, -12
 4344              	.LCFI11:
 4345              		.cfi_def_cfa_register 7
 4346 01de 7860     		str	r0, [r7, #4]
 4347 01e0 3960     		str	r1, [r7, #0]
 436:../src/FreeRTOS/queue.c **** 	portBASE_TYPE xReturn;
 437:../src/FreeRTOS/queue.c **** 
 438:../src/FreeRTOS/queue.c **** 		configASSERT( pxMutex );
 439:../src/FreeRTOS/queue.c **** 
 440:../src/FreeRTOS/queue.c **** 		/* Comments regarding mutual exclusion as per those within
 441:../src/FreeRTOS/queue.c **** 		xQueueGiveMutexRecursive(). */
 442:../src/FreeRTOS/queue.c **** 
 443:../src/FreeRTOS/queue.c **** 		traceTAKE_MUTEX_RECURSIVE( pxMutex );
 444:../src/FreeRTOS/queue.c **** 
 445:../src/FreeRTOS/queue.c **** 		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
 4348              		.loc 1 445 0
 4349 01e2 7B68     		ldr	r3, [r7, #4]
 4350 01e4 5C68     		ldr	r4, [r3, #4]
 4351 01e6 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 4352 01ea 0346     		mov	r3, r0
 4353 01ec 9C42     		cmp	r4, r3
 4354 01ee 09D1     		bne	.L11
 446:../src/FreeRTOS/queue.c **** 		{
 447:../src/FreeRTOS/queue.c **** 			( pxMutex->uxRecursiveCallCount )++;
 4355              		.loc 1 447 0
 4356 01f0 7B68     		ldr	r3, [r7, #4]
 4357 01f2 DB68     		ldr	r3, [r3, #12]
 4358 01f4 03F10102 		add	r2, r3, #1
 4359 01f8 7B68     		ldr	r3, [r7, #4]
 4360 01fa DA60     		str	r2, [r3, #12]
 448:../src/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 4361              		.loc 1 448 0
 4362 01fc 4FF00103 		mov	r3, #1
 4363 0200 FB60     		str	r3, [r7, #12]
 4364 0202 11E0     		b	.L12
 4365              	.L11:
 449:../src/FreeRTOS/queue.c **** 		}
 450:../src/FreeRTOS/queue.c **** 		else
 451:../src/FreeRTOS/queue.c **** 		{
 452:../src/FreeRTOS/queue.c **** 			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
 4366              		.loc 1 452 0
 4367 0204 7868     		ldr	r0, [r7, #4]
 4368 0206 4FF00001 		mov	r1, #0
 4369 020a 3A68     		ldr	r2, [r7, #0]
 4370 020c 4FF00003 		mov	r3, #0
 4371 0210 FFF7FEFF 		bl	xQueueGenericReceive
 4372 0214 F860     		str	r0, [r7, #12]
 453:../src/FreeRTOS/queue.c **** 
 454:../src/FreeRTOS/queue.c **** 			/* pdPASS will only be returned if we successfully obtained the mutex,
 455:../src/FreeRTOS/queue.c **** 			we may have blocked to reach here. */
 456:../src/FreeRTOS/queue.c **** 			if( xReturn == pdPASS )
 4373              		.loc 1 456 0
 4374 0216 FB68     		ldr	r3, [r7, #12]
 4375 0218 012B     		cmp	r3, #1
 4376 021a 05D1     		bne	.L12
 457:../src/FreeRTOS/queue.c **** 			{
 458:../src/FreeRTOS/queue.c **** 				( pxMutex->uxRecursiveCallCount )++;
 4377              		.loc 1 458 0
 4378 021c 7B68     		ldr	r3, [r7, #4]
 4379 021e DB68     		ldr	r3, [r3, #12]
 4380 0220 03F10102 		add	r2, r3, #1
 4381 0224 7B68     		ldr	r3, [r7, #4]
 4382 0226 DA60     		str	r2, [r3, #12]
 4383              	.L12:
 459:../src/FreeRTOS/queue.c **** 			}
 460:../src/FreeRTOS/queue.c **** 			else
 461:../src/FreeRTOS/queue.c **** 			{
 462:../src/FreeRTOS/queue.c **** 				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
 463:../src/FreeRTOS/queue.c **** 			}
 464:../src/FreeRTOS/queue.c **** 		}
 465:../src/FreeRTOS/queue.c **** 
 466:../src/FreeRTOS/queue.c **** 		return xReturn;
 4384              		.loc 1 466 0
 4385 0228 FB68     		ldr	r3, [r7, #12]
 467:../src/FreeRTOS/queue.c **** 	}
 4386              		.loc 1 467 0
 4387 022a 1846     		mov	r0, r3
 4388 022c 07F11407 		add	r7, r7, #20
 4389 0230 BD46     		mov	sp, r7
 4390 0232 90BD     		pop	{r4, r7, pc}
 4391              		.cfi_endproc
 4392              	.LFE32:
 4394              		.align	2
 4395              		.global	xQueueGenericSend
 4396              		.thumb
 4397              		.thumb_func
 4399              	xQueueGenericSend:
 4400              	.LFB33:
 468:../src/FreeRTOS/queue.c **** 
 469:../src/FreeRTOS/queue.c **** #endif /* configUSE_RECURSIVE_MUTEXES */
 470:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 471:../src/FreeRTOS/queue.c **** 
 472:../src/FreeRTOS/queue.c **** #if configUSE_COUNTING_SEMAPHORES == 1
 473:../src/FreeRTOS/queue.c **** 
 474:../src/FreeRTOS/queue.c **** 	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE
 475:../src/FreeRTOS/queue.c **** 	{
 476:../src/FreeRTOS/queue.c **** 	xQueueHandle pxHandle;
 477:../src/FreeRTOS/queue.c **** 
 478:../src/FreeRTOS/queue.c **** 		pxHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITE
 479:../src/FreeRTOS/queue.c **** 
 480:../src/FreeRTOS/queue.c **** 		if( pxHandle != NULL )
 481:../src/FreeRTOS/queue.c **** 		{
 482:../src/FreeRTOS/queue.c **** 			pxHandle->uxMessagesWaiting = uxInitialCount;
 483:../src/FreeRTOS/queue.c **** 
 484:../src/FreeRTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE();
 485:../src/FreeRTOS/queue.c **** 		}
 486:../src/FreeRTOS/queue.c **** 		else
 487:../src/FreeRTOS/queue.c **** 		{
 488:../src/FreeRTOS/queue.c **** 			traceCREATE_COUNTING_SEMAPHORE_FAILED();
 489:../src/FreeRTOS/queue.c **** 		}
 490:../src/FreeRTOS/queue.c **** 
 491:../src/FreeRTOS/queue.c **** 		configASSERT( pxHandle );
 492:../src/FreeRTOS/queue.c **** 		return pxHandle;
 493:../src/FreeRTOS/queue.c **** 	}
 494:../src/FreeRTOS/queue.c **** 
 495:../src/FreeRTOS/queue.c **** #endif /* configUSE_COUNTING_SEMAPHORES */
 496:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 497:../src/FreeRTOS/queue.c **** 
 498:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, por
 499:../src/FreeRTOS/queue.c **** {
 4401              		.loc 1 499 0
 4402              		.cfi_startproc
 4403              		@ args = 0, pretend = 0, frame = 32
 4404              		@ frame_needed = 1, uses_anonymous_args = 0
 4405 0234 80B5     		push	{r7, lr}
 4406              	.LCFI12:
 4407              		.cfi_def_cfa_offset 8
 4408 0236 88B0     		sub	sp, sp, #32
 4409              	.LCFI13:
 4410              		.cfi_def_cfa_offset 40
 4411 0238 00AF     		add	r7, sp, #0
 4412              		.cfi_offset 14, -4
 4413              		.cfi_offset 7, -8
 4414              	.LCFI14:
 4415              		.cfi_def_cfa_register 7
 4416 023a F860     		str	r0, [r7, #12]
 4417 023c B960     		str	r1, [r7, #8]
 4418 023e 7A60     		str	r2, [r7, #4]
 4419 0240 3B60     		str	r3, [r7, #0]
 500:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 4420              		.loc 1 500 0
 4421 0242 4FF00003 		mov	r3, #0
 4422 0246 FB61     		str	r3, [r7, #28]
 4423 0248 00E0     		b	.L24
 4424              	.L25:
 501:../src/FreeRTOS/queue.c **** xTimeOutType xTimeOut;
 502:../src/FreeRTOS/queue.c **** 
 503:../src/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 504:../src/FreeRTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 505:../src/FreeRTOS/queue.c **** 
 506:../src/FreeRTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 507:../src/FreeRTOS/queue.c **** 	statements within the function itself.  This is done in the interest
 508:../src/FreeRTOS/queue.c **** 	of execution time efficiency. */
 509:../src/FreeRTOS/queue.c **** 	for( ;; )
 510:../src/FreeRTOS/queue.c **** 	{
 511:../src/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 512:../src/FreeRTOS/queue.c **** 		{
 513:../src/FreeRTOS/queue.c **** 			/* Is there room on the queue now?  To be running we must be
 514:../src/FreeRTOS/queue.c **** 			the highest priority task wanting to access the queue. */
 515:../src/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 516:../src/FreeRTOS/queue.c **** 			{
 517:../src/FreeRTOS/queue.c **** 				traceQUEUE_SEND( pxQueue );
 518:../src/FreeRTOS/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 519:../src/FreeRTOS/queue.c **** 
 520:../src/FreeRTOS/queue.c **** 				/* If there was a task waiting for data to arrive on the
 521:../src/FreeRTOS/queue.c **** 				queue then unblock it now. */
 522:../src/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 523:../src/FreeRTOS/queue.c **** 				{
 524:../src/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 525:../src/FreeRTOS/queue.c **** 					{
 526:../src/FreeRTOS/queue.c **** 						/* The unblocked task has a priority higher than
 527:../src/FreeRTOS/queue.c **** 						our own so yield immediately.  Yes it is ok to do
 528:../src/FreeRTOS/queue.c **** 						this from within the critical section - the kernel
 529:../src/FreeRTOS/queue.c **** 						takes care of that. */
 530:../src/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 531:../src/FreeRTOS/queue.c **** 					}
 532:../src/FreeRTOS/queue.c **** 				}
 533:../src/FreeRTOS/queue.c **** 
 534:../src/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 535:../src/FreeRTOS/queue.c **** 
 536:../src/FreeRTOS/queue.c **** 				/* Return to the original privilege level before exiting the
 537:../src/FreeRTOS/queue.c **** 				function. */
 538:../src/FreeRTOS/queue.c **** 				return pdPASS;
 539:../src/FreeRTOS/queue.c **** 			}
 540:../src/FreeRTOS/queue.c **** 			else
 541:../src/FreeRTOS/queue.c **** 			{
 542:../src/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 543:../src/FreeRTOS/queue.c **** 				{
 544:../src/FreeRTOS/queue.c **** 					/* The queue was full and no block time is specified (or
 545:../src/FreeRTOS/queue.c **** 					the block time has expired) so leave now. */
 546:../src/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 547:../src/FreeRTOS/queue.c **** 
 548:../src/FreeRTOS/queue.c **** 					/* Return to the original privilege level before exiting
 549:../src/FreeRTOS/queue.c **** 					the function. */
 550:../src/FreeRTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 551:../src/FreeRTOS/queue.c **** 					return errQUEUE_FULL;
 552:../src/FreeRTOS/queue.c **** 				}
 553:../src/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 554:../src/FreeRTOS/queue.c **** 				{
 555:../src/FreeRTOS/queue.c **** 					/* The queue was full and a block time was specified so
 556:../src/FreeRTOS/queue.c **** 					configure the timeout structure. */
 557:../src/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 558:../src/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 559:../src/FreeRTOS/queue.c **** 				}
 560:../src/FreeRTOS/queue.c **** 			}
 561:../src/FreeRTOS/queue.c **** 		}
 562:../src/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 563:../src/FreeRTOS/queue.c **** 
 564:../src/FreeRTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 565:../src/FreeRTOS/queue.c **** 		now the critical section has been exited. */
 566:../src/FreeRTOS/queue.c **** 
 567:../src/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 568:../src/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 569:../src/FreeRTOS/queue.c **** 
 570:../src/FreeRTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 571:../src/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 572:../src/FreeRTOS/queue.c **** 		{
 573:../src/FreeRTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 574:../src/FreeRTOS/queue.c **** 			{
 575:../src/FreeRTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 576:../src/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 577:../src/FreeRTOS/queue.c **** 
 578:../src/FreeRTOS/queue.c **** 				/* Unlocking the queue means queue events can effect the
 579:../src/FreeRTOS/queue.c **** 				event list.  It is possible	that interrupts occurring now
 580:../src/FreeRTOS/queue.c **** 				remove this task from the event	list again - but as the
 581:../src/FreeRTOS/queue.c **** 				scheduler is suspended the task will go onto the pending
 582:../src/FreeRTOS/queue.c **** 				ready last instead of the actual ready list. */
 583:../src/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 584:../src/FreeRTOS/queue.c **** 
 585:../src/FreeRTOS/queue.c **** 				/* Resuming the scheduler will move tasks from the pending
 586:../src/FreeRTOS/queue.c **** 				ready list into the ready list - so it is feasible that this
 587:../src/FreeRTOS/queue.c **** 				task is already in a ready list before it yields - in which
 588:../src/FreeRTOS/queue.c **** 				case the yield will not cause a context switch unless there
 589:../src/FreeRTOS/queue.c **** 				is also a higher priority task in the pending ready list. */
 590:../src/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 591:../src/FreeRTOS/queue.c **** 				{
 592:../src/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
 593:../src/FreeRTOS/queue.c **** 				}
 594:../src/FreeRTOS/queue.c **** 			}
 595:../src/FreeRTOS/queue.c **** 			else
 596:../src/FreeRTOS/queue.c **** 			{
 597:../src/FreeRTOS/queue.c **** 				/* Try again. */
 598:../src/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 599:../src/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
 600:../src/FreeRTOS/queue.c **** 			}
 601:../src/FreeRTOS/queue.c **** 		}
 602:../src/FreeRTOS/queue.c **** 		else
 603:../src/FreeRTOS/queue.c **** 		{
 604:../src/FreeRTOS/queue.c **** 			/* The timeout has expired. */
 605:../src/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 606:../src/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
 607:../src/FreeRTOS/queue.c **** 
 608:../src/FreeRTOS/queue.c **** 			/* Return to the original privilege level before exiting the
 609:../src/FreeRTOS/queue.c **** 			function. */
 610:../src/FreeRTOS/queue.c **** 			traceQUEUE_SEND_FAILED( pxQueue );
 611:../src/FreeRTOS/queue.c **** 			return errQUEUE_FULL;
 612:../src/FreeRTOS/queue.c **** 		}
 613:../src/FreeRTOS/queue.c **** 	}
 4425              		.loc 1 613 0
 4426 024a 00BF     		nop
 4427              	.L24:
 511:../src/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 4428              		.loc 1 511 0
 4429 024c FFF7FEFF 		bl	vPortEnterCritical
 515:../src/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 4430              		.loc 1 515 0
 4431 0250 FB68     		ldr	r3, [r7, #12]
 4432 0252 9A6B     		ldr	r2, [r3, #56]
 4433 0254 FB68     		ldr	r3, [r7, #12]
 4434 0256 DB6B     		ldr	r3, [r3, #60]
 4435 0258 9A42     		cmp	r2, r3
 4436 025a 18D2     		bcs	.L14
 518:../src/FreeRTOS/queue.c **** 				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 4437              		.loc 1 518 0
 4438 025c F868     		ldr	r0, [r7, #12]
 4439 025e B968     		ldr	r1, [r7, #8]
 4440 0260 3A68     		ldr	r2, [r7, #0]
 4441 0262 00F02DFA 		bl	prvCopyDataToQueue
 522:../src/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4442              		.loc 1 522 0
 4443 0266 FB68     		ldr	r3, [r7, #12]
 4444 0268 5B6A     		ldr	r3, [r3, #36]
 4445 026a 002B     		cmp	r3, #0
 4446 026c 0AD0     		beq	.L15
 524:../src/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 4447              		.loc 1 524 0
 4448 026e FB68     		ldr	r3, [r7, #12]
 4449 0270 03F12403 		add	r3, r3, #36
 4450 0274 1846     		mov	r0, r3
 4451 0276 FFF7FEFF 		bl	xTaskRemoveFromEventList
 4452 027a 0346     		mov	r3, r0
 4453 027c 012B     		cmp	r3, #1
 4454 027e 01D1     		bne	.L15
 530:../src/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 4455              		.loc 1 530 0
 4456 0280 FFF7FEFF 		bl	vPortYieldFromISR
 4457              	.L15:
 534:../src/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 4458              		.loc 1 534 0
 4459 0284 FFF7FEFF 		bl	vPortExitCritical
 538:../src/FreeRTOS/queue.c **** 				return pdPASS;
 4460              		.loc 1 538 0
 4461 0288 4FF00103 		mov	r3, #1
 4462 028c 5DE0     		b	.L16
 4463              	.L14:
 542:../src/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 4464              		.loc 1 542 0
 4465 028e 7B68     		ldr	r3, [r7, #4]
 4466 0290 002B     		cmp	r3, #0
 4467 0292 04D1     		bne	.L17
 546:../src/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 4468              		.loc 1 546 0
 4469 0294 FFF7FEFF 		bl	vPortExitCritical
 551:../src/FreeRTOS/queue.c **** 					return errQUEUE_FULL;
 4470              		.loc 1 551 0
 4471 0298 4FF00003 		mov	r3, #0
 4472 029c 55E0     		b	.L16
 4473              	.L17:
 553:../src/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 4474              		.loc 1 553 0
 4475 029e FB69     		ldr	r3, [r7, #28]
 4476 02a0 002B     		cmp	r3, #0
 4477 02a2 07D1     		bne	.L18
 557:../src/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 4478              		.loc 1 557 0
 4479 02a4 07F11403 		add	r3, r7, #20
 4480 02a8 1846     		mov	r0, r3
 4481 02aa FFF7FEFF 		bl	vTaskSetTimeOutState
 558:../src/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 4482              		.loc 1 558 0
 4483 02ae 4FF00103 		mov	r3, #1
 4484 02b2 FB61     		str	r3, [r7, #28]
 4485              	.L18:
 562:../src/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 4486              		.loc 1 562 0
 4487 02b4 FFF7FEFF 		bl	vPortExitCritical
 567:../src/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 4488              		.loc 1 567 0
 4489 02b8 FFF7FEFF 		bl	vTaskSuspendAll
 568:../src/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4490              		.loc 1 568 0
 4491 02bc FFF7FEFF 		bl	vPortEnterCritical
 4492 02c0 FB68     		ldr	r3, [r7, #12]
 4493 02c2 5B6C     		ldr	r3, [r3, #68]
 4494 02c4 B3F1FF3F 		cmp	r3, #-1
 4495 02c8 03D1     		bne	.L19
 568:../src/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4496              		.loc 1 568 0 is_stmt 0 discriminator 1
 4497 02ca FB68     		ldr	r3, [r7, #12]
 4498 02cc 4FF00002 		mov	r2, #0
 4499 02d0 5A64     		str	r2, [r3, #68]
 4500              	.L19:
 568:../src/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4501              		.loc 1 568 0 discriminator 2
 4502 02d2 FB68     		ldr	r3, [r7, #12]
 4503 02d4 9B6C     		ldr	r3, [r3, #72]
 4504 02d6 B3F1FF3F 		cmp	r3, #-1
 4505 02da 03D1     		bne	.L20
 568:../src/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4506              		.loc 1 568 0 discriminator 3
 4507 02dc FB68     		ldr	r3, [r7, #12]
 4508 02de 4FF00002 		mov	r2, #0
 4509 02e2 9A64     		str	r2, [r3, #72]
 4510              	.L20:
 568:../src/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4511              		.loc 1 568 0 discriminator 4
 4512 02e4 FFF7FEFF 		bl	vPortExitCritical
 571:../src/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4513              		.loc 1 571 0 is_stmt 1 discriminator 4
 4514 02e8 07F11402 		add	r2, r7, #20
 4515 02ec 07F10403 		add	r3, r7, #4
 4516 02f0 1046     		mov	r0, r2
 4517 02f2 1946     		mov	r1, r3
 4518 02f4 FFF7FEFF 		bl	xTaskCheckForTimeOut
 4519 02f8 0346     		mov	r3, r0
 4520 02fa 002B     		cmp	r3, #0
 4521 02fc 1ED1     		bne	.L21
 573:../src/FreeRTOS/queue.c **** 			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 4522              		.loc 1 573 0
 4523 02fe F868     		ldr	r0, [r7, #12]
 4524 0300 00F0E0FA 		bl	prvIsQueueFull
 4525 0304 0346     		mov	r3, r0
 4526 0306 002B     		cmp	r3, #0
 4527 0308 12D0     		beq	.L22
 576:../src/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 4528              		.loc 1 576 0
 4529 030a FB68     		ldr	r3, [r7, #12]
 4530 030c 03F11002 		add	r2, r3, #16
 4531 0310 7B68     		ldr	r3, [r7, #4]
 4532 0312 1046     		mov	r0, r2
 4533 0314 1946     		mov	r1, r3
 4534 0316 FFF7FEFF 		bl	vTaskPlaceOnEventList
 583:../src/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 4535              		.loc 1 583 0
 4536 031a F868     		ldr	r0, [r7, #12]
 4537 031c 00F05AFA 		bl	prvUnlockQueue
 590:../src/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 4538              		.loc 1 590 0
 4539 0320 FFF7FEFF 		bl	xTaskResumeAll
 4540 0324 0346     		mov	r3, r0
 4541 0326 002B     		cmp	r3, #0
 4542 0328 8FD1     		bne	.L25
 592:../src/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
 4543              		.loc 1 592 0
 4544 032a FFF7FEFF 		bl	vPortYieldFromISR
 4545              		.loc 1 613 0
 4546 032e 8DE7     		b	.L24
 4547              	.L22:
 598:../src/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 4548              		.loc 1 598 0
 4549 0330 F868     		ldr	r0, [r7, #12]
 4550 0332 00F04FFA 		bl	prvUnlockQueue
 599:../src/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
 4551              		.loc 1 599 0
 4552 0336 FFF7FEFF 		bl	xTaskResumeAll
 4553              		.loc 1 613 0
 4554 033a 87E7     		b	.L24
 4555              	.L21:
 605:../src/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 4556              		.loc 1 605 0
 4557 033c F868     		ldr	r0, [r7, #12]
 4558 033e 00F049FA 		bl	prvUnlockQueue
 606:../src/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
 4559              		.loc 1 606 0
 4560 0342 FFF7FEFF 		bl	xTaskResumeAll
 611:../src/FreeRTOS/queue.c **** 			return errQUEUE_FULL;
 4561              		.loc 1 611 0
 4562 0346 4FF00003 		mov	r3, #0
 4563              	.L16:
 614:../src/FreeRTOS/queue.c **** }
 4564              		.loc 1 614 0
 4565 034a 1846     		mov	r0, r3
 4566 034c 07F12007 		add	r7, r7, #32
 4567 0350 BD46     		mov	sp, r7
 4568 0352 80BD     		pop	{r7, pc}
 4569              		.cfi_endproc
 4570              	.LFE33:
 4572              		.align	2
 4573              		.global	xQueueGenericSendFromISR
 4574              		.thumb
 4575              		.thumb_func
 4577              	xQueueGenericSendFromISR:
 4578              	.LFB34:
 615:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 616:../src/FreeRTOS/queue.c **** 
 617:../src/FreeRTOS/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 618:../src/FreeRTOS/queue.c **** 
 619:../src/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue,
 620:../src/FreeRTOS/queue.c **** 	{
 621:../src/FreeRTOS/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 622:../src/FreeRTOS/queue.c **** 	xTimeOutType xTimeOut;
 623:../src/FreeRTOS/queue.c **** 
 624:../src/FreeRTOS/queue.c **** 		configASSERT( pxQueue );
 625:../src/FreeRTOS/queue.c **** 		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE )
 626:../src/FreeRTOS/queue.c **** 
 627:../src/FreeRTOS/queue.c **** 		for( ;; )
 628:../src/FreeRTOS/queue.c **** 		{
 629:../src/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 630:../src/FreeRTOS/queue.c **** 			{
 631:../src/FreeRTOS/queue.c **** 				/* Is there room on the queue now?  To be running we must be
 632:../src/FreeRTOS/queue.c **** 				the highest priority task wanting to access the queue. */
 633:../src/FreeRTOS/queue.c **** 				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 634:../src/FreeRTOS/queue.c **** 				{
 635:../src/FreeRTOS/queue.c **** 					traceQUEUE_SEND( pxQueue );
 636:../src/FreeRTOS/queue.c **** 					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 637:../src/FreeRTOS/queue.c **** 
 638:../src/FreeRTOS/queue.c **** 					/* If there was a task waiting for data to arrive on the
 639:../src/FreeRTOS/queue.c **** 					queue then unblock it now. */
 640:../src/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 641:../src/FreeRTOS/queue.c **** 					{
 642:../src/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 643:../src/FreeRTOS/queue.c **** 						{
 644:../src/FreeRTOS/queue.c **** 							/* The unblocked task has a priority higher than
 645:../src/FreeRTOS/queue.c **** 							our own so yield immediately. */
 646:../src/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 647:../src/FreeRTOS/queue.c **** 						}
 648:../src/FreeRTOS/queue.c **** 					}
 649:../src/FreeRTOS/queue.c **** 
 650:../src/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 651:../src/FreeRTOS/queue.c **** 					return pdPASS;
 652:../src/FreeRTOS/queue.c **** 				}
 653:../src/FreeRTOS/queue.c **** 				else
 654:../src/FreeRTOS/queue.c **** 				{
 655:../src/FreeRTOS/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 656:../src/FreeRTOS/queue.c **** 					{
 657:../src/FreeRTOS/queue.c **** 						taskEXIT_CRITICAL();
 658:../src/FreeRTOS/queue.c **** 						return errQUEUE_FULL;
 659:../src/FreeRTOS/queue.c **** 					}
 660:../src/FreeRTOS/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 661:../src/FreeRTOS/queue.c **** 					{
 662:../src/FreeRTOS/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 663:../src/FreeRTOS/queue.c **** 						xEntryTimeSet = pdTRUE;
 664:../src/FreeRTOS/queue.c **** 					}
 665:../src/FreeRTOS/queue.c **** 				}
 666:../src/FreeRTOS/queue.c **** 			}
 667:../src/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 668:../src/FreeRTOS/queue.c **** 
 669:../src/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 670:../src/FreeRTOS/queue.c **** 			{
 671:../src/FreeRTOS/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 672:../src/FreeRTOS/queue.c **** 				{
 673:../src/FreeRTOS/queue.c **** 					if( prvIsQueueFull( pxQueue ) != pdFALSE )
 674:../src/FreeRTOS/queue.c **** 					{
 675:../src/FreeRTOS/queue.c **** 						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
 676:../src/FreeRTOS/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 677:../src/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 678:../src/FreeRTOS/queue.c **** 					}
 679:../src/FreeRTOS/queue.c **** 				}
 680:../src/FreeRTOS/queue.c **** 				else
 681:../src/FreeRTOS/queue.c **** 				{
 682:../src/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 683:../src/FreeRTOS/queue.c **** 					traceQUEUE_SEND_FAILED( pxQueue );
 684:../src/FreeRTOS/queue.c **** 					return errQUEUE_FULL;
 685:../src/FreeRTOS/queue.c **** 				}
 686:../src/FreeRTOS/queue.c **** 			}
 687:../src/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 688:../src/FreeRTOS/queue.c **** 		}
 689:../src/FreeRTOS/queue.c **** 	}
 690:../src/FreeRTOS/queue.c **** 
 691:../src/FreeRTOS/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 692:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 693:../src/FreeRTOS/queue.c **** 
 694:../src/FreeRTOS/queue.c **** #if configUSE_ALTERNATIVE_API == 1
 695:../src/FreeRTOS/queue.c **** 
 696:../src/FreeRTOS/queue.c **** 	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTic
 697:../src/FreeRTOS/queue.c **** 	{
 698:../src/FreeRTOS/queue.c **** 	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 699:../src/FreeRTOS/queue.c **** 	xTimeOutType xTimeOut;
 700:../src/FreeRTOS/queue.c **** 	signed char *pcOriginalReadPosition;
 701:../src/FreeRTOS/queue.c **** 
 702:../src/FreeRTOS/queue.c **** 		configASSERT( pxQueue );
 703:../src/FreeRTOS/queue.c **** 		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U )
 704:../src/FreeRTOS/queue.c **** 
 705:../src/FreeRTOS/queue.c **** 		for( ;; )
 706:../src/FreeRTOS/queue.c **** 		{
 707:../src/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 708:../src/FreeRTOS/queue.c **** 			{
 709:../src/FreeRTOS/queue.c **** 				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 710:../src/FreeRTOS/queue.c **** 				{
 711:../src/FreeRTOS/queue.c **** 					/* Remember our read position in case we are just peeking. */
 712:../src/FreeRTOS/queue.c **** 					pcOriginalReadPosition = pxQueue->pcReadFrom;
 713:../src/FreeRTOS/queue.c **** 
 714:../src/FreeRTOS/queue.c **** 					prvCopyDataFromQueue( pxQueue, pvBuffer );
 715:../src/FreeRTOS/queue.c **** 
 716:../src/FreeRTOS/queue.c **** 					if( xJustPeeking == pdFALSE )
 717:../src/FreeRTOS/queue.c **** 					{
 718:../src/FreeRTOS/queue.c **** 						traceQUEUE_RECEIVE( pxQueue );
 719:../src/FreeRTOS/queue.c **** 
 720:../src/FreeRTOS/queue.c **** 						/* We are actually removing data. */
 721:../src/FreeRTOS/queue.c **** 						--( pxQueue->uxMessagesWaiting );
 722:../src/FreeRTOS/queue.c **** 
 723:../src/FreeRTOS/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 724:../src/FreeRTOS/queue.c **** 						{
 725:../src/FreeRTOS/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 726:../src/FreeRTOS/queue.c **** 							{
 727:../src/FreeRTOS/queue.c **** 								/* Record the information required to implement
 728:../src/FreeRTOS/queue.c **** 								priority inheritance should it become necessary. */
 729:../src/FreeRTOS/queue.c **** 								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 730:../src/FreeRTOS/queue.c **** 							}
 731:../src/FreeRTOS/queue.c **** 						}
 732:../src/FreeRTOS/queue.c **** 						#endif
 733:../src/FreeRTOS/queue.c **** 
 734:../src/FreeRTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 735:../src/FreeRTOS/queue.c **** 						{
 736:../src/FreeRTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 737:../src/FreeRTOS/queue.c **** 							{
 738:../src/FreeRTOS/queue.c **** 								portYIELD_WITHIN_API();
 739:../src/FreeRTOS/queue.c **** 							}
 740:../src/FreeRTOS/queue.c **** 						}
 741:../src/FreeRTOS/queue.c **** 					}
 742:../src/FreeRTOS/queue.c **** 					else
 743:../src/FreeRTOS/queue.c **** 					{
 744:../src/FreeRTOS/queue.c **** 						traceQUEUE_PEEK( pxQueue );
 745:../src/FreeRTOS/queue.c **** 
 746:../src/FreeRTOS/queue.c **** 						/* We are not removing the data, so reset our read
 747:../src/FreeRTOS/queue.c **** 						pointer. */
 748:../src/FreeRTOS/queue.c **** 						pxQueue->pcReadFrom = pcOriginalReadPosition;
 749:../src/FreeRTOS/queue.c **** 
 750:../src/FreeRTOS/queue.c **** 						/* The data is being left in the queue, so see if there are
 751:../src/FreeRTOS/queue.c **** 						any other tasks waiting for the data. */
 752:../src/FreeRTOS/queue.c **** 						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 753:../src/FreeRTOS/queue.c **** 						{
 754:../src/FreeRTOS/queue.c **** 							/* Tasks that are removed from the event list will get added to
 755:../src/FreeRTOS/queue.c **** 							the pending ready list as the scheduler is still suspended. */
 756:../src/FreeRTOS/queue.c **** 							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 757:../src/FreeRTOS/queue.c **** 							{
 758:../src/FreeRTOS/queue.c **** 								/* The task waiting has a higher priority than this task. */
 759:../src/FreeRTOS/queue.c **** 								portYIELD_WITHIN_API();
 760:../src/FreeRTOS/queue.c **** 							}
 761:../src/FreeRTOS/queue.c **** 						}
 762:../src/FreeRTOS/queue.c **** 
 763:../src/FreeRTOS/queue.c **** 					}
 764:../src/FreeRTOS/queue.c **** 
 765:../src/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 766:../src/FreeRTOS/queue.c **** 					return pdPASS;
 767:../src/FreeRTOS/queue.c **** 				}
 768:../src/FreeRTOS/queue.c **** 				else
 769:../src/FreeRTOS/queue.c **** 				{
 770:../src/FreeRTOS/queue.c **** 					if( xTicksToWait == ( portTickType ) 0 )
 771:../src/FreeRTOS/queue.c **** 					{
 772:../src/FreeRTOS/queue.c **** 						taskEXIT_CRITICAL();
 773:../src/FreeRTOS/queue.c **** 						traceQUEUE_RECEIVE_FAILED( pxQueue );
 774:../src/FreeRTOS/queue.c **** 						return errQUEUE_EMPTY;
 775:../src/FreeRTOS/queue.c **** 					}
 776:../src/FreeRTOS/queue.c **** 					else if( xEntryTimeSet == pdFALSE )
 777:../src/FreeRTOS/queue.c **** 					{
 778:../src/FreeRTOS/queue.c **** 						vTaskSetTimeOutState( &xTimeOut );
 779:../src/FreeRTOS/queue.c **** 						xEntryTimeSet = pdTRUE;
 780:../src/FreeRTOS/queue.c **** 					}
 781:../src/FreeRTOS/queue.c **** 				}
 782:../src/FreeRTOS/queue.c **** 			}
 783:../src/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 784:../src/FreeRTOS/queue.c **** 
 785:../src/FreeRTOS/queue.c **** 			taskENTER_CRITICAL();
 786:../src/FreeRTOS/queue.c **** 			{
 787:../src/FreeRTOS/queue.c **** 				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 788:../src/FreeRTOS/queue.c **** 				{
 789:../src/FreeRTOS/queue.c **** 					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 790:../src/FreeRTOS/queue.c **** 					{
 791:../src/FreeRTOS/queue.c **** 						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 792:../src/FreeRTOS/queue.c **** 
 793:../src/FreeRTOS/queue.c **** 						#if ( configUSE_MUTEXES == 1 )
 794:../src/FreeRTOS/queue.c **** 						{
 795:../src/FreeRTOS/queue.c **** 							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 796:../src/FreeRTOS/queue.c **** 							{
 797:../src/FreeRTOS/queue.c **** 								portENTER_CRITICAL();
 798:../src/FreeRTOS/queue.c **** 									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 799:../src/FreeRTOS/queue.c **** 								portEXIT_CRITICAL();
 800:../src/FreeRTOS/queue.c **** 							}
 801:../src/FreeRTOS/queue.c **** 						}
 802:../src/FreeRTOS/queue.c **** 						#endif
 803:../src/FreeRTOS/queue.c **** 
 804:../src/FreeRTOS/queue.c **** 						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 805:../src/FreeRTOS/queue.c **** 						portYIELD_WITHIN_API();
 806:../src/FreeRTOS/queue.c **** 					}
 807:../src/FreeRTOS/queue.c **** 				}
 808:../src/FreeRTOS/queue.c **** 				else
 809:../src/FreeRTOS/queue.c **** 				{
 810:../src/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 811:../src/FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 812:../src/FreeRTOS/queue.c **** 					return errQUEUE_EMPTY;
 813:../src/FreeRTOS/queue.c **** 				}
 814:../src/FreeRTOS/queue.c **** 			}
 815:../src/FreeRTOS/queue.c **** 			taskEXIT_CRITICAL();
 816:../src/FreeRTOS/queue.c **** 		}
 817:../src/FreeRTOS/queue.c **** 	}
 818:../src/FreeRTOS/queue.c **** 
 819:../src/FreeRTOS/queue.c **** 
 820:../src/FreeRTOS/queue.c **** #endif /* configUSE_ALTERNATIVE_API */
 821:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 822:../src/FreeRTOS/queue.c **** 
 823:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQue
 824:../src/FreeRTOS/queue.c **** {
 4579              		.loc 1 824 0
 4580              		.cfi_startproc
 4581              		@ args = 0, pretend = 0, frame = 24
 4582              		@ frame_needed = 1, uses_anonymous_args = 0
 4583 0354 80B5     		push	{r7, lr}
 4584              	.LCFI15:
 4585              		.cfi_def_cfa_offset 8
 4586 0356 86B0     		sub	sp, sp, #24
 4587              	.LCFI16:
 4588              		.cfi_def_cfa_offset 32
 4589 0358 00AF     		add	r7, sp, #0
 4590              		.cfi_offset 14, -4
 4591              		.cfi_offset 7, -8
 4592              	.LCFI17:
 4593              		.cfi_def_cfa_register 7
 4594 035a F860     		str	r0, [r7, #12]
 4595 035c B960     		str	r1, [r7, #8]
 4596 035e 7A60     		str	r2, [r7, #4]
 4597 0360 3B60     		str	r3, [r7, #0]
 825:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
 826:../src/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
 827:../src/FreeRTOS/queue.c **** 
 828:../src/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 829:../src/FreeRTOS/queue.c **** 	configASSERT( pxHigherPriorityTaskWoken );
 830:../src/FreeRTOS/queue.c **** 	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 
 831:../src/FreeRTOS/queue.c **** 
 832:../src/FreeRTOS/queue.c **** 	/* Similar to xQueueGenericSend, except we don't block if there is no room
 833:../src/FreeRTOS/queue.c **** 	in the queue.  Also we don't directly wake a task that was blocked on a
 834:../src/FreeRTOS/queue.c **** 	queue read, instead we return a flag to say whether a context switch is
 835:../src/FreeRTOS/queue.c **** 	required or not (i.e. has a task with a higher priority than us been woken
 836:../src/FreeRTOS/queue.c **** 	by this	post). */
 837:../src/FreeRTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4598              		.loc 1 837 0
 4599 0362 4FF00003 		mov	r3, #0
 4600 0366 3B61     		str	r3, [r7, #16]
 4601              	@ 837 "../src/FreeRTOS/queue.c" 1
 4602 0368 4FF02800 			mov r0, #40								
 4603 036c 80F31188 		msr basepri, r0							
 4604              	
 4605              	@ 0 "" 2
 838:../src/FreeRTOS/queue.c **** 	{
 839:../src/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 4606              		.loc 1 839 0
 4607              		.thumb
 4608 0370 FB68     		ldr	r3, [r7, #12]
 4609 0372 9A6B     		ldr	r2, [r3, #56]
 4610 0374 FB68     		ldr	r3, [r7, #12]
 4611 0376 DB6B     		ldr	r3, [r3, #60]
 4612 0378 9A42     		cmp	r2, r3
 4613 037a 25D2     		bcs	.L27
 840:../src/FreeRTOS/queue.c **** 		{
 841:../src/FreeRTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR( pxQueue );
 842:../src/FreeRTOS/queue.c **** 
 843:../src/FreeRTOS/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 4614              		.loc 1 843 0
 4615 037c F868     		ldr	r0, [r7, #12]
 4616 037e B968     		ldr	r1, [r7, #8]
 4617 0380 3A68     		ldr	r2, [r7, #0]
 4618 0382 00F09DF9 		bl	prvCopyDataToQueue
 844:../src/FreeRTOS/queue.c **** 
 845:../src/FreeRTOS/queue.c **** 			/* If the queue is locked we do not alter the event list.  This will
 846:../src/FreeRTOS/queue.c **** 			be done when the queue is unlocked later. */
 847:../src/FreeRTOS/queue.c **** 			if( pxQueue->xTxLock == queueUNLOCKED )
 4619              		.loc 1 847 0
 4620 0386 FB68     		ldr	r3, [r7, #12]
 4621 0388 9B6C     		ldr	r3, [r3, #72]
 4622 038a B3F1FF3F 		cmp	r3, #-1
 4623 038e 11D1     		bne	.L28
 848:../src/FreeRTOS/queue.c **** 			{
 849:../src/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4624              		.loc 1 849 0
 4625 0390 FB68     		ldr	r3, [r7, #12]
 4626 0392 5B6A     		ldr	r3, [r3, #36]
 4627 0394 002B     		cmp	r3, #0
 4628 0396 13D0     		beq	.L29
 850:../src/FreeRTOS/queue.c **** 				{
 851:../src/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4629              		.loc 1 851 0
 4630 0398 FB68     		ldr	r3, [r7, #12]
 4631 039a 03F12403 		add	r3, r3, #36
 4632 039e 1846     		mov	r0, r3
 4633 03a0 FFF7FEFF 		bl	xTaskRemoveFromEventList
 4634 03a4 0346     		mov	r3, r0
 4635 03a6 002B     		cmp	r3, #0
 4636 03a8 0AD0     		beq	.L29
 852:../src/FreeRTOS/queue.c **** 					{
 853:../src/FreeRTOS/queue.c **** 						/* The task waiting has a higher priority so record that a
 854:../src/FreeRTOS/queue.c **** 						context	switch is required. */
 855:../src/FreeRTOS/queue.c **** 						*pxHigherPriorityTaskWoken = pdTRUE;
 4637              		.loc 1 855 0
 4638 03aa 7B68     		ldr	r3, [r7, #4]
 4639 03ac 4FF00102 		mov	r2, #1
 4640 03b0 1A60     		str	r2, [r3, #0]
 4641 03b2 05E0     		b	.L29
 4642              	.L28:
 856:../src/FreeRTOS/queue.c **** 					}
 857:../src/FreeRTOS/queue.c **** 				}
 858:../src/FreeRTOS/queue.c **** 			}
 859:../src/FreeRTOS/queue.c **** 			else
 860:../src/FreeRTOS/queue.c **** 			{
 861:../src/FreeRTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
 862:../src/FreeRTOS/queue.c **** 				knows that data was posted while it was locked. */
 863:../src/FreeRTOS/queue.c **** 				++( pxQueue->xTxLock );
 4643              		.loc 1 863 0
 4644 03b4 FB68     		ldr	r3, [r7, #12]
 4645 03b6 9B6C     		ldr	r3, [r3, #72]
 4646 03b8 03F10102 		add	r2, r3, #1
 4647 03bc FB68     		ldr	r3, [r7, #12]
 4648 03be 9A64     		str	r2, [r3, #72]
 4649              	.L29:
 864:../src/FreeRTOS/queue.c **** 			}
 865:../src/FreeRTOS/queue.c **** 
 866:../src/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 4650              		.loc 1 866 0
 4651 03c0 4FF00103 		mov	r3, #1
 4652 03c4 7B61     		str	r3, [r7, #20]
 4653 03c6 02E0     		b	.L30
 4654              	.L27:
 867:../src/FreeRTOS/queue.c **** 		}
 868:../src/FreeRTOS/queue.c **** 		else
 869:../src/FreeRTOS/queue.c **** 		{
 870:../src/FreeRTOS/queue.c **** 			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
 871:../src/FreeRTOS/queue.c **** 			xReturn = errQUEUE_FULL;
 4655              		.loc 1 871 0
 4656 03c8 4FF00003 		mov	r3, #0
 4657 03cc 7B61     		str	r3, [r7, #20]
 4658              	.L30:
 872:../src/FreeRTOS/queue.c **** 		}
 873:../src/FreeRTOS/queue.c **** 	}
 874:../src/FreeRTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 4659              		.loc 1 874 0
 4660              	@ 874 "../src/FreeRTOS/queue.c" 1
 4661 03ce 4FF00000 			mov r0, #0					
 4662 03d2 80F31188 		msr basepri, r0				
 4663              	
 4664              	@ 0 "" 2
 875:../src/FreeRTOS/queue.c **** 
 876:../src/FreeRTOS/queue.c **** 	return xReturn;
 4665              		.loc 1 876 0
 4666              		.thumb
 4667 03d6 7B69     		ldr	r3, [r7, #20]
 877:../src/FreeRTOS/queue.c **** }
 4668              		.loc 1 877 0
 4669 03d8 1846     		mov	r0, r3
 4670 03da 07F11807 		add	r7, r7, #24
 4671 03de BD46     		mov	sp, r7
 4672 03e0 80BD     		pop	{r7, pc}
 4673              		.cfi_endproc
 4674              	.LFE34:
 4676 03e2 00BF     		.align	2
 4677              		.global	xQueueGenericReceive
 4678              		.thumb
 4679              		.thumb_func
 4681              	xQueueGenericReceive:
 4682              	.LFB35:
 878:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
 879:../src/FreeRTOS/queue.c **** 
 880:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickTyp
 881:../src/FreeRTOS/queue.c **** {
 4683              		.loc 1 881 0
 4684              		.cfi_startproc
 4685              		@ args = 0, pretend = 0, frame = 32
 4686              		@ frame_needed = 1, uses_anonymous_args = 0
 4687 03e4 80B5     		push	{r7, lr}
 4688              	.LCFI18:
 4689              		.cfi_def_cfa_offset 8
 4690 03e6 88B0     		sub	sp, sp, #32
 4691              	.LCFI19:
 4692              		.cfi_def_cfa_offset 40
 4693 03e8 00AF     		add	r7, sp, #0
 4694              		.cfi_offset 14, -4
 4695              		.cfi_offset 7, -8
 4696              	.LCFI20:
 4697              		.cfi_def_cfa_register 7
 4698 03ea F860     		str	r0, [r7, #12]
 4699 03ec B960     		str	r1, [r7, #8]
 4700 03ee 7A60     		str	r2, [r7, #4]
 4701 03f0 3B60     		str	r3, [r7, #0]
 882:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 4702              		.loc 1 882 0
 4703 03f2 4FF00003 		mov	r3, #0
 4704 03f6 FB61     		str	r3, [r7, #28]
 4705 03f8 00E0     		b	.L45
 4706              	.L46:
 883:../src/FreeRTOS/queue.c **** xTimeOutType xTimeOut;
 884:../src/FreeRTOS/queue.c **** signed char *pcOriginalReadPosition;
 885:../src/FreeRTOS/queue.c **** 
 886:../src/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
 887:../src/FreeRTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
 888:../src/FreeRTOS/queue.c **** 
 889:../src/FreeRTOS/queue.c **** 	/* This function relaxes the coding standard somewhat to allow return
 890:../src/FreeRTOS/queue.c **** 	statements within the function itself.  This is done in the interest
 891:../src/FreeRTOS/queue.c **** 	of execution time efficiency. */
 892:../src/FreeRTOS/queue.c **** 
 893:../src/FreeRTOS/queue.c **** 	for( ;; )
 894:../src/FreeRTOS/queue.c **** 	{
 895:../src/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 896:../src/FreeRTOS/queue.c **** 		{
 897:../src/FreeRTOS/queue.c **** 			/* Is there data in the queue now?  To be running we must be
 898:../src/FreeRTOS/queue.c **** 			the highest priority task wanting to access the queue. */
 899:../src/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 900:../src/FreeRTOS/queue.c **** 			{
 901:../src/FreeRTOS/queue.c **** 				/* Remember our read position in case we are just peeking. */
 902:../src/FreeRTOS/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 903:../src/FreeRTOS/queue.c **** 
 904:../src/FreeRTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 905:../src/FreeRTOS/queue.c **** 
 906:../src/FreeRTOS/queue.c **** 				if( xJustPeeking == pdFALSE )
 907:../src/FreeRTOS/queue.c **** 				{
 908:../src/FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE( pxQueue );
 909:../src/FreeRTOS/queue.c **** 
 910:../src/FreeRTOS/queue.c **** 					/* We are actually removing data. */
 911:../src/FreeRTOS/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 912:../src/FreeRTOS/queue.c **** 
 913:../src/FreeRTOS/queue.c **** 					#if ( configUSE_MUTEXES == 1 )
 914:../src/FreeRTOS/queue.c **** 					{
 915:../src/FreeRTOS/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 916:../src/FreeRTOS/queue.c **** 						{
 917:../src/FreeRTOS/queue.c **** 							/* Record the information required to implement
 918:../src/FreeRTOS/queue.c **** 							priority inheritance should it become necessary. */
 919:../src/FreeRTOS/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 920:../src/FreeRTOS/queue.c **** 						}
 921:../src/FreeRTOS/queue.c **** 					}
 922:../src/FreeRTOS/queue.c **** 					#endif
 923:../src/FreeRTOS/queue.c **** 
 924:../src/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 925:../src/FreeRTOS/queue.c **** 					{
 926:../src/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 927:../src/FreeRTOS/queue.c **** 						{
 928:../src/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 929:../src/FreeRTOS/queue.c **** 						}
 930:../src/FreeRTOS/queue.c **** 					}
 931:../src/FreeRTOS/queue.c **** 				}
 932:../src/FreeRTOS/queue.c **** 				else
 933:../src/FreeRTOS/queue.c **** 				{
 934:../src/FreeRTOS/queue.c **** 					traceQUEUE_PEEK( pxQueue );
 935:../src/FreeRTOS/queue.c **** 
 936:../src/FreeRTOS/queue.c **** 					/* We are not removing the data, so reset our read
 937:../src/FreeRTOS/queue.c **** 					pointer. */
 938:../src/FreeRTOS/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 939:../src/FreeRTOS/queue.c **** 
 940:../src/FreeRTOS/queue.c **** 					/* The data is being left in the queue, so see if there are
 941:../src/FreeRTOS/queue.c **** 					any other tasks waiting for the data. */
 942:../src/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 943:../src/FreeRTOS/queue.c **** 					{
 944:../src/FreeRTOS/queue.c **** 						/* Tasks that are removed from the event list will get added to
 945:../src/FreeRTOS/queue.c **** 						the pending ready list as the scheduler is still suspended. */
 946:../src/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 947:../src/FreeRTOS/queue.c **** 						{
 948:../src/FreeRTOS/queue.c **** 							/* The task waiting has a higher priority than this task. */
 949:../src/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 950:../src/FreeRTOS/queue.c **** 						}
 951:../src/FreeRTOS/queue.c **** 					}
 952:../src/FreeRTOS/queue.c **** 
 953:../src/FreeRTOS/queue.c **** 				}
 954:../src/FreeRTOS/queue.c **** 
 955:../src/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 956:../src/FreeRTOS/queue.c **** 				return pdPASS;
 957:../src/FreeRTOS/queue.c **** 			}
 958:../src/FreeRTOS/queue.c **** 			else
 959:../src/FreeRTOS/queue.c **** 			{
 960:../src/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 961:../src/FreeRTOS/queue.c **** 				{
 962:../src/FreeRTOS/queue.c **** 					/* The queue was empty and no block time is specified (or
 963:../src/FreeRTOS/queue.c **** 					the block time has expired) so leave now. */
 964:../src/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 965:../src/FreeRTOS/queue.c **** 					traceQUEUE_RECEIVE_FAILED( pxQueue );
 966:../src/FreeRTOS/queue.c **** 					return errQUEUE_EMPTY;
 967:../src/FreeRTOS/queue.c **** 				}
 968:../src/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 969:../src/FreeRTOS/queue.c **** 				{
 970:../src/FreeRTOS/queue.c **** 					/* The queue was empty and a block time was specified so
 971:../src/FreeRTOS/queue.c **** 					configure the timeout structure. */
 972:../src/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 973:../src/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 974:../src/FreeRTOS/queue.c **** 				}
 975:../src/FreeRTOS/queue.c **** 			}
 976:../src/FreeRTOS/queue.c **** 		}
 977:../src/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 978:../src/FreeRTOS/queue.c **** 
 979:../src/FreeRTOS/queue.c **** 		/* Interrupts and other tasks can send to and receive from the queue
 980:../src/FreeRTOS/queue.c **** 		now the critical section has been exited. */
 981:../src/FreeRTOS/queue.c **** 
 982:../src/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 983:../src/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 984:../src/FreeRTOS/queue.c **** 
 985:../src/FreeRTOS/queue.c **** 		/* Update the timeout state to see if it has expired yet. */
 986:../src/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 987:../src/FreeRTOS/queue.c **** 		{
 988:../src/FreeRTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 989:../src/FreeRTOS/queue.c **** 			{
 990:../src/FreeRTOS/queue.c **** 				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
 991:../src/FreeRTOS/queue.c **** 
 992:../src/FreeRTOS/queue.c **** 				#if ( configUSE_MUTEXES == 1 )
 993:../src/FreeRTOS/queue.c **** 				{
 994:../src/FreeRTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 995:../src/FreeRTOS/queue.c **** 					{
 996:../src/FreeRTOS/queue.c **** 						portENTER_CRITICAL();
 997:../src/FreeRTOS/queue.c **** 						{
 998:../src/FreeRTOS/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 999:../src/FreeRTOS/queue.c **** 						}
1000:../src/FreeRTOS/queue.c **** 						portEXIT_CRITICAL();
1001:../src/FreeRTOS/queue.c **** 					}
1002:../src/FreeRTOS/queue.c **** 				}
1003:../src/FreeRTOS/queue.c **** 				#endif
1004:../src/FreeRTOS/queue.c **** 
1005:../src/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1006:../src/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
1007:../src/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
1008:../src/FreeRTOS/queue.c **** 				{
1009:../src/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
1010:../src/FreeRTOS/queue.c **** 				}
1011:../src/FreeRTOS/queue.c **** 			}
1012:../src/FreeRTOS/queue.c **** 			else
1013:../src/FreeRTOS/queue.c **** 			{
1014:../src/FreeRTOS/queue.c **** 				/* Try again. */
1015:../src/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
1016:../src/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
1017:../src/FreeRTOS/queue.c **** 			}
1018:../src/FreeRTOS/queue.c **** 		}
1019:../src/FreeRTOS/queue.c **** 		else
1020:../src/FreeRTOS/queue.c **** 		{
1021:../src/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
1022:../src/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
1023:../src/FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FAILED( pxQueue );
1024:../src/FreeRTOS/queue.c **** 			return errQUEUE_EMPTY;
1025:../src/FreeRTOS/queue.c **** 		}
1026:../src/FreeRTOS/queue.c **** 	}
 4707              		.loc 1 1026 0
 4708 03fa 00BF     		nop
 4709              	.L45:
 895:../src/FreeRTOS/queue.c **** 		taskENTER_CRITICAL();
 4710              		.loc 1 895 0
 4711 03fc FFF7FEFF 		bl	vPortEnterCritical
 899:../src/FreeRTOS/queue.c **** 			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 4712              		.loc 1 899 0
 4713 0400 FB68     		ldr	r3, [r7, #12]
 4714 0402 9B6B     		ldr	r3, [r3, #56]
 4715 0404 002B     		cmp	r3, #0
 4716 0406 40D0     		beq	.L32
 902:../src/FreeRTOS/queue.c **** 				pcOriginalReadPosition = pxQueue->pcReadFrom;
 4717              		.loc 1 902 0
 4718 0408 FB68     		ldr	r3, [r7, #12]
 4719 040a DB68     		ldr	r3, [r3, #12]
 4720 040c BB61     		str	r3, [r7, #24]
 904:../src/FreeRTOS/queue.c **** 				prvCopyDataFromQueue( pxQueue, pvBuffer );
 4721              		.loc 1 904 0
 4722 040e F868     		ldr	r0, [r7, #12]
 4723 0410 B968     		ldr	r1, [r7, #8]
 4724 0412 00F0B7F9 		bl	prvCopyDataFromQueue
 906:../src/FreeRTOS/queue.c **** 				if( xJustPeeking == pdFALSE )
 4725              		.loc 1 906 0
 4726 0416 3B68     		ldr	r3, [r7, #0]
 4727 0418 002B     		cmp	r3, #0
 4728 041a 1FD1     		bne	.L33
 911:../src/FreeRTOS/queue.c **** 					--( pxQueue->uxMessagesWaiting );
 4729              		.loc 1 911 0
 4730 041c FB68     		ldr	r3, [r7, #12]
 4731 041e 9B6B     		ldr	r3, [r3, #56]
 4732 0420 03F1FF32 		add	r2, r3, #-1
 4733 0424 FB68     		ldr	r3, [r7, #12]
 4734 0426 9A63     		str	r2, [r3, #56]
 915:../src/FreeRTOS/queue.c **** 						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4735              		.loc 1 915 0
 4736 0428 FB68     		ldr	r3, [r7, #12]
 4737 042a 1B68     		ldr	r3, [r3, #0]
 4738 042c 002B     		cmp	r3, #0
 4739 042e 05D1     		bne	.L34
 919:../src/FreeRTOS/queue.c **** 							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 4740              		.loc 1 919 0
 4741 0430 FFF7FEFF 		bl	xTaskGetCurrentTaskHandle
 4742 0434 0346     		mov	r3, r0
 4743 0436 1A46     		mov	r2, r3
 4744 0438 FB68     		ldr	r3, [r7, #12]
 4745 043a 5A60     		str	r2, [r3, #4]
 4746              	.L34:
 924:../src/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4747              		.loc 1 924 0
 4748 043c FB68     		ldr	r3, [r7, #12]
 4749 043e 1B69     		ldr	r3, [r3, #16]
 4750 0440 002B     		cmp	r3, #0
 4751 0442 1DD0     		beq	.L35
 926:../src/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 4752              		.loc 1 926 0
 4753 0444 FB68     		ldr	r3, [r7, #12]
 4754 0446 03F11003 		add	r3, r3, #16
 4755 044a 1846     		mov	r0, r3
 4756 044c FFF7FEFF 		bl	xTaskRemoveFromEventList
 4757 0450 0346     		mov	r3, r0
 4758 0452 012B     		cmp	r3, #1
 4759 0454 14D1     		bne	.L35
 928:../src/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 4760              		.loc 1 928 0
 4761 0456 FFF7FEFF 		bl	vPortYieldFromISR
 4762 045a 11E0     		b	.L35
 4763              	.L33:
 938:../src/FreeRTOS/queue.c **** 					pxQueue->pcReadFrom = pcOriginalReadPosition;
 4764              		.loc 1 938 0
 4765 045c FB68     		ldr	r3, [r7, #12]
 4766 045e BA69     		ldr	r2, [r7, #24]
 4767 0460 DA60     		str	r2, [r3, #12]
 942:../src/FreeRTOS/queue.c **** 					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 4768              		.loc 1 942 0
 4769 0462 FB68     		ldr	r3, [r7, #12]
 4770 0464 5B6A     		ldr	r3, [r3, #36]
 4771 0466 002B     		cmp	r3, #0
 4772 0468 0AD0     		beq	.L35
 946:../src/FreeRTOS/queue.c **** 						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 4773              		.loc 1 946 0
 4774 046a FB68     		ldr	r3, [r7, #12]
 4775 046c 03F12403 		add	r3, r3, #36
 4776 0470 1846     		mov	r0, r3
 4777 0472 FFF7FEFF 		bl	xTaskRemoveFromEventList
 4778 0476 0346     		mov	r3, r0
 4779 0478 002B     		cmp	r3, #0
 4780 047a 01D0     		beq	.L35
 949:../src/FreeRTOS/queue.c **** 							portYIELD_WITHIN_API();
 4781              		.loc 1 949 0
 4782 047c FFF7FEFF 		bl	vPortYieldFromISR
 4783              	.L35:
 955:../src/FreeRTOS/queue.c **** 				taskEXIT_CRITICAL();
 4784              		.loc 1 955 0
 4785 0480 FFF7FEFF 		bl	vPortExitCritical
 956:../src/FreeRTOS/queue.c **** 				return pdPASS;
 4786              		.loc 1 956 0
 4787 0484 4FF00103 		mov	r3, #1
 4788 0488 6BE0     		b	.L36
 4789              	.L32:
 960:../src/FreeRTOS/queue.c **** 				if( xTicksToWait == ( portTickType ) 0 )
 4790              		.loc 1 960 0
 4791 048a 7B68     		ldr	r3, [r7, #4]
 4792 048c 002B     		cmp	r3, #0
 4793 048e 04D1     		bne	.L37
 964:../src/FreeRTOS/queue.c **** 					taskEXIT_CRITICAL();
 4794              		.loc 1 964 0
 4795 0490 FFF7FEFF 		bl	vPortExitCritical
 966:../src/FreeRTOS/queue.c **** 					return errQUEUE_EMPTY;
 4796              		.loc 1 966 0
 4797 0494 4FF00003 		mov	r3, #0
 4798 0498 63E0     		b	.L36
 4799              	.L37:
 968:../src/FreeRTOS/queue.c **** 				else if( xEntryTimeSet == pdFALSE )
 4800              		.loc 1 968 0
 4801 049a FB69     		ldr	r3, [r7, #28]
 4802 049c 002B     		cmp	r3, #0
 4803 049e 07D1     		bne	.L38
 972:../src/FreeRTOS/queue.c **** 					vTaskSetTimeOutState( &xTimeOut );
 4804              		.loc 1 972 0
 4805 04a0 07F11003 		add	r3, r7, #16
 4806 04a4 1846     		mov	r0, r3
 4807 04a6 FFF7FEFF 		bl	vTaskSetTimeOutState
 973:../src/FreeRTOS/queue.c **** 					xEntryTimeSet = pdTRUE;
 4808              		.loc 1 973 0
 4809 04aa 4FF00103 		mov	r3, #1
 4810 04ae FB61     		str	r3, [r7, #28]
 4811              	.L38:
 977:../src/FreeRTOS/queue.c **** 		taskEXIT_CRITICAL();
 4812              		.loc 1 977 0
 4813 04b0 FFF7FEFF 		bl	vPortExitCritical
 982:../src/FreeRTOS/queue.c **** 		vTaskSuspendAll();
 4814              		.loc 1 982 0
 4815 04b4 FFF7FEFF 		bl	vTaskSuspendAll
 983:../src/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4816              		.loc 1 983 0
 4817 04b8 FFF7FEFF 		bl	vPortEnterCritical
 4818 04bc FB68     		ldr	r3, [r7, #12]
 4819 04be 5B6C     		ldr	r3, [r3, #68]
 4820 04c0 B3F1FF3F 		cmp	r3, #-1
 4821 04c4 03D1     		bne	.L39
 983:../src/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4822              		.loc 1 983 0 is_stmt 0 discriminator 1
 4823 04c6 FB68     		ldr	r3, [r7, #12]
 4824 04c8 4FF00002 		mov	r2, #0
 4825 04cc 5A64     		str	r2, [r3, #68]
 4826              	.L39:
 983:../src/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4827              		.loc 1 983 0 discriminator 2
 4828 04ce FB68     		ldr	r3, [r7, #12]
 4829 04d0 9B6C     		ldr	r3, [r3, #72]
 4830 04d2 B3F1FF3F 		cmp	r3, #-1
 4831 04d6 03D1     		bne	.L40
 983:../src/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4832              		.loc 1 983 0 discriminator 3
 4833 04d8 FB68     		ldr	r3, [r7, #12]
 4834 04da 4FF00002 		mov	r2, #0
 4835 04de 9A64     		str	r2, [r3, #72]
 4836              	.L40:
 983:../src/FreeRTOS/queue.c **** 		prvLockQueue( pxQueue );
 4837              		.loc 1 983 0 discriminator 4
 4838 04e0 FFF7FEFF 		bl	vPortExitCritical
 986:../src/FreeRTOS/queue.c **** 		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 4839              		.loc 1 986 0 is_stmt 1 discriminator 4
 4840 04e4 07F11002 		add	r2, r7, #16
 4841 04e8 07F10403 		add	r3, r7, #4
 4842 04ec 1046     		mov	r0, r2
 4843 04ee 1946     		mov	r1, r3
 4844 04f0 FFF7FEFF 		bl	xTaskCheckForTimeOut
 4845 04f4 0346     		mov	r3, r0
 4846 04f6 002B     		cmp	r3, #0
 4847 04f8 2CD1     		bne	.L41
 988:../src/FreeRTOS/queue.c **** 			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 4848              		.loc 1 988 0
 4849 04fa F868     		ldr	r0, [r7, #12]
 4850 04fc 00F0BAF9 		bl	prvIsQueueEmpty
 4851 0500 0346     		mov	r3, r0
 4852 0502 002B     		cmp	r3, #0
 4853 0504 20D0     		beq	.L42
 994:../src/FreeRTOS/queue.c **** 					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 4854              		.loc 1 994 0
 4855 0506 FB68     		ldr	r3, [r7, #12]
 4856 0508 1B68     		ldr	r3, [r3, #0]
 4857 050a 002B     		cmp	r3, #0
 4858 050c 08D1     		bne	.L43
 996:../src/FreeRTOS/queue.c **** 						portENTER_CRITICAL();
 4859              		.loc 1 996 0
 4860 050e FFF7FEFF 		bl	vPortEnterCritical
 998:../src/FreeRTOS/queue.c **** 							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 4861              		.loc 1 998 0
 4862 0512 FB68     		ldr	r3, [r7, #12]
 4863 0514 5B68     		ldr	r3, [r3, #4]
 4864 0516 1846     		mov	r0, r3
 4865 0518 FFF7FEFF 		bl	vTaskPriorityInherit
1000:../src/FreeRTOS/queue.c **** 						portEXIT_CRITICAL();
 4866              		.loc 1 1000 0
 4867 051c FFF7FEFF 		bl	vPortExitCritical
 4868              	.L43:
1005:../src/FreeRTOS/queue.c **** 				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 4869              		.loc 1 1005 0
 4870 0520 FB68     		ldr	r3, [r7, #12]
 4871 0522 03F12402 		add	r2, r3, #36
 4872 0526 7B68     		ldr	r3, [r7, #4]
 4873 0528 1046     		mov	r0, r2
 4874 052a 1946     		mov	r1, r3
 4875 052c FFF7FEFF 		bl	vTaskPlaceOnEventList
1006:../src/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 4876              		.loc 1 1006 0
 4877 0530 F868     		ldr	r0, [r7, #12]
 4878 0532 00F04FF9 		bl	prvUnlockQueue
1007:../src/FreeRTOS/queue.c **** 				if( xTaskResumeAll() == pdFALSE )
 4879              		.loc 1 1007 0
 4880 0536 FFF7FEFF 		bl	xTaskResumeAll
 4881 053a 0346     		mov	r3, r0
 4882 053c 002B     		cmp	r3, #0
 4883 053e 7FF45CAF 		bne	.L46
1009:../src/FreeRTOS/queue.c **** 					portYIELD_WITHIN_API();
 4884              		.loc 1 1009 0
 4885 0542 FFF7FEFF 		bl	vPortYieldFromISR
 4886              		.loc 1 1026 0
 4887 0546 59E7     		b	.L45
 4888              	.L42:
1015:../src/FreeRTOS/queue.c **** 				prvUnlockQueue( pxQueue );
 4889              		.loc 1 1015 0
 4890 0548 F868     		ldr	r0, [r7, #12]
 4891 054a 00F043F9 		bl	prvUnlockQueue
1016:../src/FreeRTOS/queue.c **** 				( void ) xTaskResumeAll();
 4892              		.loc 1 1016 0
 4893 054e FFF7FEFF 		bl	xTaskResumeAll
 4894              		.loc 1 1026 0
 4895 0552 53E7     		b	.L45
 4896              	.L41:
1021:../src/FreeRTOS/queue.c **** 			prvUnlockQueue( pxQueue );
 4897              		.loc 1 1021 0
 4898 0554 F868     		ldr	r0, [r7, #12]
 4899 0556 00F03DF9 		bl	prvUnlockQueue
1022:../src/FreeRTOS/queue.c **** 			( void ) xTaskResumeAll();
 4900              		.loc 1 1022 0
 4901 055a FFF7FEFF 		bl	xTaskResumeAll
1024:../src/FreeRTOS/queue.c **** 			return errQUEUE_EMPTY;
 4902              		.loc 1 1024 0
 4903 055e 4FF00003 		mov	r3, #0
 4904              	.L36:
1027:../src/FreeRTOS/queue.c **** }
 4905              		.loc 1 1027 0
 4906 0562 1846     		mov	r0, r3
 4907 0564 07F12007 		add	r7, r7, #32
 4908 0568 BD46     		mov	sp, r7
 4909 056a 80BD     		pop	{r7, pc}
 4910              		.cfi_endproc
 4911              	.LFE35:
 4913              		.align	2
 4914              		.global	xQueueReceiveFromISR
 4915              		.thumb
 4916              		.thumb_func
 4918              	xQueueReceiveFromISR:
 4919              	.LFB36:
1028:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1029:../src/FreeRTOS/queue.c **** 
1030:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed port
1031:../src/FreeRTOS/queue.c **** {
 4920              		.loc 1 1031 0
 4921              		.cfi_startproc
 4922              		@ args = 0, pretend = 0, frame = 24
 4923              		@ frame_needed = 1, uses_anonymous_args = 0
 4924 056c 80B5     		push	{r7, lr}
 4925              	.LCFI21:
 4926              		.cfi_def_cfa_offset 8
 4927 056e 86B0     		sub	sp, sp, #24
 4928              	.LCFI22:
 4929              		.cfi_def_cfa_offset 32
 4930 0570 00AF     		add	r7, sp, #0
 4931              		.cfi_offset 14, -4
 4932              		.cfi_offset 7, -8
 4933              	.LCFI23:
 4934              		.cfi_def_cfa_register 7
 4935 0572 F860     		str	r0, [r7, #12]
 4936 0574 B960     		str	r1, [r7, #8]
 4937 0576 7A60     		str	r2, [r7, #4]
1032:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1033:../src/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1034:../src/FreeRTOS/queue.c **** 
1035:../src/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1036:../src/FreeRTOS/queue.c **** 	configASSERT( pxTaskWoken );
1037:../src/FreeRTOS/queue.c **** 	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) 
1038:../src/FreeRTOS/queue.c **** 
1039:../src/FreeRTOS/queue.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 4938              		.loc 1 1039 0
 4939 0578 4FF00003 		mov	r3, #0
 4940 057c 3B61     		str	r3, [r7, #16]
 4941              	@ 1039 "../src/FreeRTOS/queue.c" 1
 4942 057e 4FF02800 			mov r0, #40								
 4943 0582 80F31188 		msr basepri, r0							
 4944              	
 4945              	@ 0 "" 2
1040:../src/FreeRTOS/queue.c **** 	{
1041:../src/FreeRTOS/queue.c **** 		/* We cannot block from an ISR, so check there is data available. */
1042:../src/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 4946              		.loc 1 1042 0
 4947              		.thumb
 4948 0586 FB68     		ldr	r3, [r7, #12]
 4949 0588 9B6B     		ldr	r3, [r3, #56]
 4950 058a 002B     		cmp	r3, #0
 4951 058c 2AD0     		beq	.L48
1043:../src/FreeRTOS/queue.c **** 		{
1044:../src/FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1045:../src/FreeRTOS/queue.c **** 
1046:../src/FreeRTOS/queue.c **** 			prvCopyDataFromQueue( pxQueue, pvBuffer );
 4952              		.loc 1 1046 0
 4953 058e F868     		ldr	r0, [r7, #12]
 4954 0590 B968     		ldr	r1, [r7, #8]
 4955 0592 00F0F7F8 		bl	prvCopyDataFromQueue
1047:../src/FreeRTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
 4956              		.loc 1 1047 0
 4957 0596 FB68     		ldr	r3, [r7, #12]
 4958 0598 9B6B     		ldr	r3, [r3, #56]
 4959 059a 03F1FF32 		add	r2, r3, #-1
 4960 059e FB68     		ldr	r3, [r7, #12]
 4961 05a0 9A63     		str	r2, [r3, #56]
1048:../src/FreeRTOS/queue.c **** 
1049:../src/FreeRTOS/queue.c **** 			/* If the queue is locked we will not modify the event list.  Instead
1050:../src/FreeRTOS/queue.c **** 			we update the lock count so the task that unlocks the queue will know
1051:../src/FreeRTOS/queue.c **** 			that an ISR has removed data while the queue was locked. */
1052:../src/FreeRTOS/queue.c **** 			if( pxQueue->xRxLock == queueUNLOCKED )
 4962              		.loc 1 1052 0
 4963 05a2 FB68     		ldr	r3, [r7, #12]
 4964 05a4 5B6C     		ldr	r3, [r3, #68]
 4965 05a6 B3F1FF3F 		cmp	r3, #-1
 4966 05aa 11D1     		bne	.L49
1053:../src/FreeRTOS/queue.c **** 			{
1054:../src/FreeRTOS/queue.c **** 				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 4967              		.loc 1 1054 0
 4968 05ac FB68     		ldr	r3, [r7, #12]
 4969 05ae 1B69     		ldr	r3, [r3, #16]
 4970 05b0 002B     		cmp	r3, #0
 4971 05b2 13D0     		beq	.L50
1055:../src/FreeRTOS/queue.c **** 				{
1056:../src/FreeRTOS/queue.c **** 					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 4972              		.loc 1 1056 0
 4973 05b4 FB68     		ldr	r3, [r7, #12]
 4974 05b6 03F11003 		add	r3, r3, #16
 4975 05ba 1846     		mov	r0, r3
 4976 05bc FFF7FEFF 		bl	xTaskRemoveFromEventList
 4977 05c0 0346     		mov	r3, r0
 4978 05c2 002B     		cmp	r3, #0
 4979 05c4 0AD0     		beq	.L50
1057:../src/FreeRTOS/queue.c **** 					{
1058:../src/FreeRTOS/queue.c **** 						/* The task waiting has a higher priority than us so
1059:../src/FreeRTOS/queue.c **** 						force a context switch. */
1060:../src/FreeRTOS/queue.c **** 						*pxTaskWoken = pdTRUE;
 4980              		.loc 1 1060 0
 4981 05c6 7B68     		ldr	r3, [r7, #4]
 4982 05c8 4FF00102 		mov	r2, #1
 4983 05cc 1A60     		str	r2, [r3, #0]
 4984 05ce 05E0     		b	.L50
 4985              	.L49:
1061:../src/FreeRTOS/queue.c **** 					}
1062:../src/FreeRTOS/queue.c **** 				}
1063:../src/FreeRTOS/queue.c **** 			}
1064:../src/FreeRTOS/queue.c **** 			else
1065:../src/FreeRTOS/queue.c **** 			{
1066:../src/FreeRTOS/queue.c **** 				/* Increment the lock count so the task that unlocks the queue
1067:../src/FreeRTOS/queue.c **** 				knows that data was removed while it was locked. */
1068:../src/FreeRTOS/queue.c **** 				++( pxQueue->xRxLock );
 4986              		.loc 1 1068 0
 4987 05d0 FB68     		ldr	r3, [r7, #12]
 4988 05d2 5B6C     		ldr	r3, [r3, #68]
 4989 05d4 03F10102 		add	r2, r3, #1
 4990 05d8 FB68     		ldr	r3, [r7, #12]
 4991 05da 5A64     		str	r2, [r3, #68]
 4992              	.L50:
1069:../src/FreeRTOS/queue.c **** 			}
1070:../src/FreeRTOS/queue.c **** 
1071:../src/FreeRTOS/queue.c **** 			xReturn = pdPASS;
 4993              		.loc 1 1071 0
 4994 05dc 4FF00103 		mov	r3, #1
 4995 05e0 7B61     		str	r3, [r7, #20]
 4996 05e2 02E0     		b	.L51
 4997              	.L48:
1072:../src/FreeRTOS/queue.c **** 		}
1073:../src/FreeRTOS/queue.c **** 		else
1074:../src/FreeRTOS/queue.c **** 		{
1075:../src/FreeRTOS/queue.c **** 			xReturn = pdFAIL;
 4998              		.loc 1 1075 0
 4999 05e4 4FF00003 		mov	r3, #0
 5000 05e8 7B61     		str	r3, [r7, #20]
 5001              	.L51:
1076:../src/FreeRTOS/queue.c **** 			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1077:../src/FreeRTOS/queue.c **** 		}
1078:../src/FreeRTOS/queue.c **** 	}
1079:../src/FreeRTOS/queue.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 5002              		.loc 1 1079 0
 5003              	@ 1079 "../src/FreeRTOS/queue.c" 1
 5004 05ea 4FF00000 			mov r0, #0					
 5005 05ee 80F31188 		msr basepri, r0				
 5006              	
 5007              	@ 0 "" 2
1080:../src/FreeRTOS/queue.c **** 
1081:../src/FreeRTOS/queue.c **** 	return xReturn;
 5008              		.loc 1 1081 0
 5009              		.thumb
 5010 05f2 7B69     		ldr	r3, [r7, #20]
1082:../src/FreeRTOS/queue.c **** }
 5011              		.loc 1 1082 0
 5012 05f4 1846     		mov	r0, r3
 5013 05f6 07F11807 		add	r7, r7, #24
 5014 05fa BD46     		mov	sp, r7
 5015 05fc 80BD     		pop	{r7, pc}
 5016              		.cfi_endproc
 5017              	.LFE36:
 5019 05fe 00BF     		.align	2
 5020              		.global	uxQueueMessagesWaiting
 5021              		.thumb
 5022              		.thumb_func
 5024              	uxQueueMessagesWaiting:
 5025              	.LFB37:
1083:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1084:../src/FreeRTOS/queue.c **** 
1085:../src/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
1086:../src/FreeRTOS/queue.c **** {
 5026              		.loc 1 1086 0
 5027              		.cfi_startproc
 5028              		@ args = 0, pretend = 0, frame = 16
 5029              		@ frame_needed = 1, uses_anonymous_args = 0
 5030 0600 80B5     		push	{r7, lr}
 5031              	.LCFI24:
 5032              		.cfi_def_cfa_offset 8
 5033 0602 84B0     		sub	sp, sp, #16
 5034              	.LCFI25:
 5035              		.cfi_def_cfa_offset 24
 5036 0604 00AF     		add	r7, sp, #0
 5037              		.cfi_offset 14, -4
 5038              		.cfi_offset 7, -8
 5039              	.LCFI26:
 5040              		.cfi_def_cfa_register 7
 5041 0606 7860     		str	r0, [r7, #4]
1087:../src/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxReturn;
1088:../src/FreeRTOS/queue.c **** 
1089:../src/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1090:../src/FreeRTOS/queue.c **** 
1091:../src/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 5042              		.loc 1 1091 0
 5043 0608 FFF7FEFF 		bl	vPortEnterCritical
1092:../src/FreeRTOS/queue.c **** 		uxReturn = pxQueue->uxMessagesWaiting;
 5044              		.loc 1 1092 0
 5045 060c 7B68     		ldr	r3, [r7, #4]
 5046 060e 9B6B     		ldr	r3, [r3, #56]
 5047 0610 FB60     		str	r3, [r7, #12]
1093:../src/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 5048              		.loc 1 1093 0
 5049 0612 FFF7FEFF 		bl	vPortExitCritical
1094:../src/FreeRTOS/queue.c **** 
1095:../src/FreeRTOS/queue.c **** 	return uxReturn;
 5050              		.loc 1 1095 0
 5051 0616 FB68     		ldr	r3, [r7, #12]
1096:../src/FreeRTOS/queue.c **** }
 5052              		.loc 1 1096 0
 5053 0618 1846     		mov	r0, r3
 5054 061a 07F11007 		add	r7, r7, #16
 5055 061e BD46     		mov	sp, r7
 5056 0620 80BD     		pop	{r7, pc}
 5057              		.cfi_endproc
 5058              	.LFE37:
 5060 0622 00BF     		.align	2
 5061              		.global	uxQueueMessagesWaitingFromISR
 5062              		.thumb
 5063              		.thumb_func
 5065              	uxQueueMessagesWaitingFromISR:
 5066              	.LFB38:
1097:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1098:../src/FreeRTOS/queue.c **** 
1099:../src/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
1100:../src/FreeRTOS/queue.c **** {
 5067              		.loc 1 1100 0
 5068              		.cfi_startproc
 5069              		@ args = 0, pretend = 0, frame = 16
 5070              		@ frame_needed = 1, uses_anonymous_args = 0
 5071              		@ link register save eliminated.
 5072 0624 80B4     		push	{r7}
 5073              	.LCFI27:
 5074              		.cfi_def_cfa_offset 4
 5075 0626 85B0     		sub	sp, sp, #20
 5076              	.LCFI28:
 5077              		.cfi_def_cfa_offset 24
 5078 0628 00AF     		add	r7, sp, #0
 5079              		.cfi_offset 7, -4
 5080              	.LCFI29:
 5081              		.cfi_def_cfa_register 7
 5082 062a 7860     		str	r0, [r7, #4]
1101:../src/FreeRTOS/queue.c **** unsigned portBASE_TYPE uxReturn;
1102:../src/FreeRTOS/queue.c **** 
1103:../src/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1104:../src/FreeRTOS/queue.c **** 
1105:../src/FreeRTOS/queue.c **** 	uxReturn = pxQueue->uxMessagesWaiting;
 5083              		.loc 1 1105 0
 5084 062c 7B68     		ldr	r3, [r7, #4]
 5085 062e 9B6B     		ldr	r3, [r3, #56]
 5086 0630 FB60     		str	r3, [r7, #12]
1106:../src/FreeRTOS/queue.c **** 
1107:../src/FreeRTOS/queue.c **** 	return uxReturn;
 5087              		.loc 1 1107 0
 5088 0632 FB68     		ldr	r3, [r7, #12]
1108:../src/FreeRTOS/queue.c **** }
 5089              		.loc 1 1108 0
 5090 0634 1846     		mov	r0, r3
 5091 0636 07F11407 		add	r7, r7, #20
 5092 063a BD46     		mov	sp, r7
 5093 063c 80BC     		pop	{r7}
 5094 063e 7047     		bx	lr
 5095              		.cfi_endproc
 5096              	.LFE38:
 5098              		.align	2
 5099              		.global	vQueueDelete
 5100              		.thumb
 5101              		.thumb_func
 5103              	vQueueDelete:
 5104              	.LFB39:
1109:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1110:../src/FreeRTOS/queue.c **** 
1111:../src/FreeRTOS/queue.c **** void vQueueDelete( xQueueHandle pxQueue )
1112:../src/FreeRTOS/queue.c **** {
 5105              		.loc 1 1112 0
 5106              		.cfi_startproc
 5107              		@ args = 0, pretend = 0, frame = 8
 5108              		@ frame_needed = 1, uses_anonymous_args = 0
 5109 0640 80B5     		push	{r7, lr}
 5110              	.LCFI30:
 5111              		.cfi_def_cfa_offset 8
 5112 0642 82B0     		sub	sp, sp, #8
 5113              	.LCFI31:
 5114              		.cfi_def_cfa_offset 16
 5115 0644 00AF     		add	r7, sp, #0
 5116              		.cfi_offset 14, -4
 5117              		.cfi_offset 7, -8
 5118              	.LCFI32:
 5119              		.cfi_def_cfa_register 7
 5120 0646 7860     		str	r0, [r7, #4]
1113:../src/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1114:../src/FreeRTOS/queue.c **** 
1115:../src/FreeRTOS/queue.c **** 	traceQUEUE_DELETE( pxQueue );
1116:../src/FreeRTOS/queue.c **** 	vQueueUnregisterQueue( pxQueue );
 5121              		.loc 1 1116 0
 5122 0648 7868     		ldr	r0, [r7, #4]
 5123 064a 00F091F9 		bl	vQueueUnregisterQueue
1117:../src/FreeRTOS/queue.c **** 	vPortFree( pxQueue->pcHead );
 5124              		.loc 1 1117 0
 5125 064e 7B68     		ldr	r3, [r7, #4]
 5126 0650 1B68     		ldr	r3, [r3, #0]
 5127 0652 1846     		mov	r0, r3
 5128 0654 FFF7FEFF 		bl	vPortFree
1118:../src/FreeRTOS/queue.c **** 	vPortFree( pxQueue );
 5129              		.loc 1 1118 0
 5130 0658 7868     		ldr	r0, [r7, #4]
 5131 065a FFF7FEFF 		bl	vPortFree
1119:../src/FreeRTOS/queue.c **** }
 5132              		.loc 1 1119 0
 5133 065e 07F10807 		add	r7, r7, #8
 5134 0662 BD46     		mov	sp, r7
 5135 0664 80BD     		pop	{r7, pc}
 5136              		.cfi_endproc
 5137              	.LFE39:
 5139 0666 00BF     		.align	2
 5140              		.global	ucQueueGetQueueNumber
 5141              		.thumb
 5142              		.thumb_func
 5144              	ucQueueGetQueueNumber:
 5145              	.LFB40:
1120:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1121:../src/FreeRTOS/queue.c **** 
1122:../src/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1123:../src/FreeRTOS/queue.c **** 
1124:../src/FreeRTOS/queue.c **** 	unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue )
1125:../src/FreeRTOS/queue.c **** 	{
 5146              		.loc 1 1125 0
 5147              		.cfi_startproc
 5148              		@ args = 0, pretend = 0, frame = 8
 5149              		@ frame_needed = 1, uses_anonymous_args = 0
 5150              		@ link register save eliminated.
 5151 0668 80B4     		push	{r7}
 5152              	.LCFI33:
 5153              		.cfi_def_cfa_offset 4
 5154 066a 83B0     		sub	sp, sp, #12
 5155              	.LCFI34:
 5156              		.cfi_def_cfa_offset 16
 5157 066c 00AF     		add	r7, sp, #0
 5158              		.cfi_offset 7, -4
 5159              	.LCFI35:
 5160              		.cfi_def_cfa_register 7
 5161 066e 7860     		str	r0, [r7, #4]
1126:../src/FreeRTOS/queue.c **** 		return pxQueue->ucQueueNumber;
 5162              		.loc 1 1126 0
 5163 0670 7B68     		ldr	r3, [r7, #4]
 5164 0672 93F84C30 		ldrb	r3, [r3, #76]	@ zero_extendqisi2
1127:../src/FreeRTOS/queue.c **** 	}
 5165              		.loc 1 1127 0
 5166 0676 1846     		mov	r0, r3
 5167 0678 07F10C07 		add	r7, r7, #12
 5168 067c BD46     		mov	sp, r7
 5169 067e 80BC     		pop	{r7}
 5170 0680 7047     		bx	lr
 5171              		.cfi_endproc
 5172              	.LFE40:
 5174 0682 00BF     		.align	2
 5175              		.global	vQueueSetQueueNumber
 5176              		.thumb
 5177              		.thumb_func
 5179              	vQueueSetQueueNumber:
 5180              	.LFB41:
1128:../src/FreeRTOS/queue.c **** 
1129:../src/FreeRTOS/queue.c **** #endif
1130:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1131:../src/FreeRTOS/queue.c **** 
1132:../src/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1133:../src/FreeRTOS/queue.c **** 
1134:../src/FreeRTOS/queue.c **** 	void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber )
1135:../src/FreeRTOS/queue.c **** 	{
 5181              		.loc 1 1135 0
 5182              		.cfi_startproc
 5183              		@ args = 0, pretend = 0, frame = 8
 5184              		@ frame_needed = 1, uses_anonymous_args = 0
 5185              		@ link register save eliminated.
 5186 0684 80B4     		push	{r7}
 5187              	.LCFI36:
 5188              		.cfi_def_cfa_offset 4
 5189 0686 83B0     		sub	sp, sp, #12
 5190              	.LCFI37:
 5191              		.cfi_def_cfa_offset 16
 5192 0688 00AF     		add	r7, sp, #0
 5193              		.cfi_offset 7, -4
 5194              	.LCFI38:
 5195              		.cfi_def_cfa_register 7
 5196 068a 7860     		str	r0, [r7, #4]
 5197 068c 0B46     		mov	r3, r1
 5198 068e FB70     		strb	r3, [r7, #3]
1136:../src/FreeRTOS/queue.c **** 		pxQueue->ucQueueNumber = ucQueueNumber;
 5199              		.loc 1 1136 0
 5200 0690 7B68     		ldr	r3, [r7, #4]
 5201 0692 FA78     		ldrb	r2, [r7, #3]
 5202 0694 83F84C20 		strb	r2, [r3, #76]
1137:../src/FreeRTOS/queue.c **** 	}
 5203              		.loc 1 1137 0
 5204 0698 07F10C07 		add	r7, r7, #12
 5205 069c BD46     		mov	sp, r7
 5206 069e 80BC     		pop	{r7}
 5207 06a0 7047     		bx	lr
 5208              		.cfi_endproc
 5209              	.LFE41:
 5211 06a2 00BF     		.align	2
 5212              		.global	ucQueueGetQueueType
 5213              		.thumb
 5214              		.thumb_func
 5216              	ucQueueGetQueueType:
 5217              	.LFB42:
1138:../src/FreeRTOS/queue.c **** 
1139:../src/FreeRTOS/queue.c **** #endif
1140:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1141:../src/FreeRTOS/queue.c **** 
1142:../src/FreeRTOS/queue.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1143:../src/FreeRTOS/queue.c **** 
1144:../src/FreeRTOS/queue.c **** 	unsigned char ucQueueGetQueueType( xQueueHandle pxQueue )
1145:../src/FreeRTOS/queue.c **** 	{
 5218              		.loc 1 1145 0
 5219              		.cfi_startproc
 5220              		@ args = 0, pretend = 0, frame = 8
 5221              		@ frame_needed = 1, uses_anonymous_args = 0
 5222              		@ link register save eliminated.
 5223 06a4 80B4     		push	{r7}
 5224              	.LCFI39:
 5225              		.cfi_def_cfa_offset 4
 5226 06a6 83B0     		sub	sp, sp, #12
 5227              	.LCFI40:
 5228              		.cfi_def_cfa_offset 16
 5229 06a8 00AF     		add	r7, sp, #0
 5230              		.cfi_offset 7, -4
 5231              	.LCFI41:
 5232              		.cfi_def_cfa_register 7
 5233 06aa 7860     		str	r0, [r7, #4]
1146:../src/FreeRTOS/queue.c **** 		return pxQueue->ucQueueType;
 5234              		.loc 1 1146 0
 5235 06ac 7B68     		ldr	r3, [r7, #4]
 5236 06ae 93F84D30 		ldrb	r3, [r3, #77]	@ zero_extendqisi2
1147:../src/FreeRTOS/queue.c **** 	}
 5237              		.loc 1 1147 0
 5238 06b2 1846     		mov	r0, r3
 5239 06b4 07F10C07 		add	r7, r7, #12
 5240 06b8 BD46     		mov	sp, r7
 5241 06ba 80BC     		pop	{r7}
 5242 06bc 7047     		bx	lr
 5243              		.cfi_endproc
 5244              	.LFE42:
 5246 06be 00BF     		.align	2
 5247              		.thumb
 5248              		.thumb_func
 5250              	prvCopyDataToQueue:
 5251              	.LFB43:
1148:../src/FreeRTOS/queue.c **** 
1149:../src/FreeRTOS/queue.c **** #endif
1150:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1151:../src/FreeRTOS/queue.c **** 
1152:../src/FreeRTOS/queue.c **** static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition
1153:../src/FreeRTOS/queue.c **** {
 5252              		.loc 1 1153 0
 5253              		.cfi_startproc
 5254              		@ args = 0, pretend = 0, frame = 16
 5255              		@ frame_needed = 1, uses_anonymous_args = 0
 5256 06c0 80B5     		push	{r7, lr}
 5257              	.LCFI42:
 5258              		.cfi_def_cfa_offset 8
 5259 06c2 84B0     		sub	sp, sp, #16
 5260              	.LCFI43:
 5261              		.cfi_def_cfa_offset 24
 5262 06c4 00AF     		add	r7, sp, #0
 5263              		.cfi_offset 14, -4
 5264              		.cfi_offset 7, -8
 5265              	.LCFI44:
 5266              		.cfi_def_cfa_register 7
 5267 06c6 F860     		str	r0, [r7, #12]
 5268 06c8 B960     		str	r1, [r7, #8]
 5269 06ca 7A60     		str	r2, [r7, #4]
1154:../src/FreeRTOS/queue.c **** 	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 5270              		.loc 1 1154 0
 5271 06cc FB68     		ldr	r3, [r7, #12]
 5272 06ce 1B6C     		ldr	r3, [r3, #64]
 5273 06d0 002B     		cmp	r3, #0
 5274 06d2 0DD1     		bne	.L59
1155:../src/FreeRTOS/queue.c **** 	{
1156:../src/FreeRTOS/queue.c **** 		#if ( configUSE_MUTEXES == 1 )
1157:../src/FreeRTOS/queue.c **** 		{
1158:../src/FreeRTOS/queue.c **** 			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 5275              		.loc 1 1158 0
 5276 06d4 FB68     		ldr	r3, [r7, #12]
 5277 06d6 1B68     		ldr	r3, [r3, #0]
 5278 06d8 002B     		cmp	r3, #0
 5279 06da 48D1     		bne	.L60
1159:../src/FreeRTOS/queue.c **** 			{
1160:../src/FreeRTOS/queue.c **** 				/* The mutex is no longer being held. */
1161:../src/FreeRTOS/queue.c **** 				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 5280              		.loc 1 1161 0
 5281 06dc FB68     		ldr	r3, [r7, #12]
 5282 06de 5B68     		ldr	r3, [r3, #4]
 5283 06e0 1846     		mov	r0, r3
 5284 06e2 FFF7FEFF 		bl	vTaskPriorityDisinherit
1162:../src/FreeRTOS/queue.c **** 				pxQueue->pxMutexHolder = NULL;
 5285              		.loc 1 1162 0
 5286 06e6 FB68     		ldr	r3, [r7, #12]
 5287 06e8 4FF00002 		mov	r2, #0
 5288 06ec 5A60     		str	r2, [r3, #4]
 5289 06ee 3EE0     		b	.L60
 5290              	.L59:
1163:../src/FreeRTOS/queue.c **** 			}
1164:../src/FreeRTOS/queue.c **** 		}
1165:../src/FreeRTOS/queue.c **** 		#endif
1166:../src/FreeRTOS/queue.c **** 	}
1167:../src/FreeRTOS/queue.c **** 	else if( xPosition == queueSEND_TO_BACK )
 5291              		.loc 1 1167 0
 5292 06f0 7B68     		ldr	r3, [r7, #4]
 5293 06f2 002B     		cmp	r3, #0
 5294 06f4 1AD1     		bne	.L61
1168:../src/FreeRTOS/queue.c **** 	{
1169:../src/FreeRTOS/queue.c **** 		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 5295              		.loc 1 1169 0
 5296 06f6 FB68     		ldr	r3, [r7, #12]
 5297 06f8 9A68     		ldr	r2, [r3, #8]
 5298 06fa FB68     		ldr	r3, [r7, #12]
 5299 06fc 1B6C     		ldr	r3, [r3, #64]
 5300 06fe 1046     		mov	r0, r2
 5301 0700 B968     		ldr	r1, [r7, #8]
 5302 0702 1A46     		mov	r2, r3
 5303 0704 FFF7FEFF 		bl	memcpy
1170:../src/FreeRTOS/queue.c **** 		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 5304              		.loc 1 1170 0
 5305 0708 FB68     		ldr	r3, [r7, #12]
 5306 070a 9A68     		ldr	r2, [r3, #8]
 5307 070c FB68     		ldr	r3, [r7, #12]
 5308 070e 1B6C     		ldr	r3, [r3, #64]
 5309 0710 D218     		adds	r2, r2, r3
 5310 0712 FB68     		ldr	r3, [r7, #12]
 5311 0714 9A60     		str	r2, [r3, #8]
1171:../src/FreeRTOS/queue.c **** 		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 5312              		.loc 1 1171 0
 5313 0716 FB68     		ldr	r3, [r7, #12]
 5314 0718 9A68     		ldr	r2, [r3, #8]
 5315 071a FB68     		ldr	r3, [r7, #12]
 5316 071c 5B68     		ldr	r3, [r3, #4]
 5317 071e 9A42     		cmp	r2, r3
 5318 0720 25D3     		bcc	.L60
1172:../src/FreeRTOS/queue.c **** 		{
1173:../src/FreeRTOS/queue.c **** 			pxQueue->pcWriteTo = pxQueue->pcHead;
 5319              		.loc 1 1173 0
 5320 0722 FB68     		ldr	r3, [r7, #12]
 5321 0724 1A68     		ldr	r2, [r3, #0]
 5322 0726 FB68     		ldr	r3, [r7, #12]
 5323 0728 9A60     		str	r2, [r3, #8]
 5324 072a 20E0     		b	.L60
 5325              	.L61:
1174:../src/FreeRTOS/queue.c **** 		}
1175:../src/FreeRTOS/queue.c **** 	}
1176:../src/FreeRTOS/queue.c **** 	else
1177:../src/FreeRTOS/queue.c **** 	{
1178:../src/FreeRTOS/queue.c **** 		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 5326              		.loc 1 1178 0
 5327 072c FB68     		ldr	r3, [r7, #12]
 5328 072e DA68     		ldr	r2, [r3, #12]
 5329 0730 FB68     		ldr	r3, [r7, #12]
 5330 0732 1B6C     		ldr	r3, [r3, #64]
 5331 0734 1046     		mov	r0, r2
 5332 0736 B968     		ldr	r1, [r7, #8]
 5333 0738 1A46     		mov	r2, r3
 5334 073a FFF7FEFF 		bl	memcpy
1179:../src/FreeRTOS/queue.c **** 		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 5335              		.loc 1 1179 0
 5336 073e FB68     		ldr	r3, [r7, #12]
 5337 0740 DA68     		ldr	r2, [r3, #12]
 5338 0742 FB68     		ldr	r3, [r7, #12]
 5339 0744 1B6C     		ldr	r3, [r3, #64]
 5340 0746 C3F10003 		rsb	r3, r3, #0
 5341 074a D218     		adds	r2, r2, r3
 5342 074c FB68     		ldr	r3, [r7, #12]
 5343 074e DA60     		str	r2, [r3, #12]
1180:../src/FreeRTOS/queue.c **** 		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 5344              		.loc 1 1180 0
 5345 0750 FB68     		ldr	r3, [r7, #12]
 5346 0752 DA68     		ldr	r2, [r3, #12]
 5347 0754 FB68     		ldr	r3, [r7, #12]
 5348 0756 1B68     		ldr	r3, [r3, #0]
 5349 0758 9A42     		cmp	r2, r3
 5350 075a 08D2     		bcs	.L60
1181:../src/FreeRTOS/queue.c **** 		{
1182:../src/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 5351              		.loc 1 1182 0
 5352 075c FB68     		ldr	r3, [r7, #12]
 5353 075e 5A68     		ldr	r2, [r3, #4]
 5354 0760 FB68     		ldr	r3, [r7, #12]
 5355 0762 1B6C     		ldr	r3, [r3, #64]
 5356 0764 C3F10003 		rsb	r3, r3, #0
 5357 0768 D218     		adds	r2, r2, r3
 5358 076a FB68     		ldr	r3, [r7, #12]
 5359 076c DA60     		str	r2, [r3, #12]
 5360              	.L60:
1183:../src/FreeRTOS/queue.c **** 		}
1184:../src/FreeRTOS/queue.c **** 	}
1185:../src/FreeRTOS/queue.c **** 
1186:../src/FreeRTOS/queue.c **** 	++( pxQueue->uxMessagesWaiting );
 5361              		.loc 1 1186 0
 5362 076e FB68     		ldr	r3, [r7, #12]
 5363 0770 9B6B     		ldr	r3, [r3, #56]
 5364 0772 03F10102 		add	r2, r3, #1
 5365 0776 FB68     		ldr	r3, [r7, #12]
 5366 0778 9A63     		str	r2, [r3, #56]
1187:../src/FreeRTOS/queue.c **** }
 5367              		.loc 1 1187 0
 5368 077a 07F11007 		add	r7, r7, #16
 5369 077e BD46     		mov	sp, r7
 5370 0780 80BD     		pop	{r7, pc}
 5371              		.cfi_endproc
 5372              	.LFE43:
 5374 0782 00BF     		.align	2
 5375              		.thumb
 5376              		.thumb_func
 5378              	prvCopyDataFromQueue:
 5379              	.LFB44:
1188:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1189:../src/FreeRTOS/queue.c **** 
1190:../src/FreeRTOS/queue.c **** static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1191:../src/FreeRTOS/queue.c **** {
 5380              		.loc 1 1191 0
 5381              		.cfi_startproc
 5382              		@ args = 0, pretend = 0, frame = 8
 5383              		@ frame_needed = 1, uses_anonymous_args = 0
 5384 0784 80B5     		push	{r7, lr}
 5385              	.LCFI45:
 5386              		.cfi_def_cfa_offset 8
 5387 0786 82B0     		sub	sp, sp, #8
 5388              	.LCFI46:
 5389              		.cfi_def_cfa_offset 16
 5390 0788 00AF     		add	r7, sp, #0
 5391              		.cfi_offset 14, -4
 5392              		.cfi_offset 7, -8
 5393              	.LCFI47:
 5394              		.cfi_def_cfa_register 7
 5395 078a 7860     		str	r0, [r7, #4]
 5396 078c 3960     		str	r1, [r7, #0]
1192:../src/FreeRTOS/queue.c **** 	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 5397              		.loc 1 1192 0
 5398 078e 7B68     		ldr	r3, [r7, #4]
 5399 0790 1B68     		ldr	r3, [r3, #0]
 5400 0792 002B     		cmp	r3, #0
 5401 0794 19D0     		beq	.L62
1193:../src/FreeRTOS/queue.c **** 	{
1194:../src/FreeRTOS/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 5402              		.loc 1 1194 0
 5403 0796 7B68     		ldr	r3, [r7, #4]
 5404 0798 DA68     		ldr	r2, [r3, #12]
 5405 079a 7B68     		ldr	r3, [r7, #4]
 5406 079c 1B6C     		ldr	r3, [r3, #64]
 5407 079e D218     		adds	r2, r2, r3
 5408 07a0 7B68     		ldr	r3, [r7, #4]
 5409 07a2 DA60     		str	r2, [r3, #12]
1195:../src/FreeRTOS/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 5410              		.loc 1 1195 0
 5411 07a4 7B68     		ldr	r3, [r7, #4]
 5412 07a6 DA68     		ldr	r2, [r3, #12]
 5413 07a8 7B68     		ldr	r3, [r7, #4]
 5414 07aa 5B68     		ldr	r3, [r3, #4]
 5415 07ac 9A42     		cmp	r2, r3
 5416 07ae 03D3     		bcc	.L64
1196:../src/FreeRTOS/queue.c **** 		{
1197:../src/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
 5417              		.loc 1 1197 0
 5418 07b0 7B68     		ldr	r3, [r7, #4]
 5419 07b2 1A68     		ldr	r2, [r3, #0]
 5420 07b4 7B68     		ldr	r3, [r7, #4]
 5421 07b6 DA60     		str	r2, [r3, #12]
 5422              	.L64:
1198:../src/FreeRTOS/queue.c **** 		}
1199:../src/FreeRTOS/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 5423              		.loc 1 1199 0
 5424 07b8 7B68     		ldr	r3, [r7, #4]
 5425 07ba DA68     		ldr	r2, [r3, #12]
 5426 07bc 7B68     		ldr	r3, [r7, #4]
 5427 07be 1B6C     		ldr	r3, [r3, #64]
 5428 07c0 3868     		ldr	r0, [r7, #0]
 5429 07c2 1146     		mov	r1, r2
 5430 07c4 1A46     		mov	r2, r3
 5431 07c6 FFF7FEFF 		bl	memcpy
 5432              	.L62:
1200:../src/FreeRTOS/queue.c **** 	}
1201:../src/FreeRTOS/queue.c **** }
 5433              		.loc 1 1201 0
 5434 07ca 07F10807 		add	r7, r7, #8
 5435 07ce BD46     		mov	sp, r7
 5436 07d0 80BD     		pop	{r7, pc}
 5437              		.cfi_endproc
 5438              	.LFE44:
 5440 07d2 00BF     		.align	2
 5441              		.thumb
 5442              		.thumb_func
 5444              	prvUnlockQueue:
 5445              	.LFB45:
1202:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1203:../src/FreeRTOS/queue.c **** 
1204:../src/FreeRTOS/queue.c **** static void prvUnlockQueue( xQueueHandle pxQueue )
1205:../src/FreeRTOS/queue.c **** {
 5446              		.loc 1 1205 0
 5447              		.cfi_startproc
 5448              		@ args = 0, pretend = 0, frame = 8
 5449              		@ frame_needed = 1, uses_anonymous_args = 0
 5450 07d4 80B5     		push	{r7, lr}
 5451              	.LCFI48:
 5452              		.cfi_def_cfa_offset 8
 5453 07d6 82B0     		sub	sp, sp, #8
 5454              	.LCFI49:
 5455              		.cfi_def_cfa_offset 16
 5456 07d8 00AF     		add	r7, sp, #0
 5457              		.cfi_offset 14, -4
 5458              		.cfi_offset 7, -8
 5459              	.LCFI50:
 5460              		.cfi_def_cfa_register 7
 5461 07da 7860     		str	r0, [r7, #4]
1206:../src/FreeRTOS/queue.c **** 	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1207:../src/FreeRTOS/queue.c **** 
1208:../src/FreeRTOS/queue.c **** 	/* The lock counts contains the number of extra data items placed or
1209:../src/FreeRTOS/queue.c **** 	removed from the queue while the queue was locked.  When a queue is
1210:../src/FreeRTOS/queue.c **** 	locked items can be added or removed, but the event lists cannot be
1211:../src/FreeRTOS/queue.c **** 	updated. */
1212:../src/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 5462              		.loc 1 1212 0
 5463 07dc FFF7FEFF 		bl	vPortEnterCritical
1213:../src/FreeRTOS/queue.c **** 	{
1214:../src/FreeRTOS/queue.c **** 		/* See if data was added to the queue while it was locked. */
1215:../src/FreeRTOS/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 5464              		.loc 1 1215 0
 5465 07e0 14E0     		b	.L66
 5466              	.L70:
1216:../src/FreeRTOS/queue.c **** 		{
1217:../src/FreeRTOS/queue.c **** 			/* Data was posted while the queue was locked.  Are any tasks
1218:../src/FreeRTOS/queue.c **** 			blocked waiting for data to become available? */
1219:../src/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 5467              		.loc 1 1219 0
 5468 07e2 7B68     		ldr	r3, [r7, #4]
 5469 07e4 5B6A     		ldr	r3, [r3, #36]
 5470 07e6 002B     		cmp	r3, #0
 5471 07e8 15D0     		beq	.L76
1220:../src/FreeRTOS/queue.c **** 			{
1221:../src/FreeRTOS/queue.c **** 				/* Tasks that are removed from the event list will get added to
1222:../src/FreeRTOS/queue.c **** 				the pending ready list as the scheduler is still suspended. */
1223:../src/FreeRTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 5472              		.loc 1 1223 0
 5473 07ea 7B68     		ldr	r3, [r7, #4]
 5474 07ec 03F12403 		add	r3, r3, #36
 5475 07f0 1846     		mov	r0, r3
 5476 07f2 FFF7FEFF 		bl	xTaskRemoveFromEventList
 5477 07f6 0346     		mov	r3, r0
 5478 07f8 002B     		cmp	r3, #0
 5479 07fa 01D0     		beq	.L68
1224:../src/FreeRTOS/queue.c **** 				{
1225:../src/FreeRTOS/queue.c **** 					/* The task waiting has a higher priority so record that a
1226:../src/FreeRTOS/queue.c **** 					context	switch is required. */
1227:../src/FreeRTOS/queue.c **** 					vTaskMissedYield();
 5480              		.loc 1 1227 0
 5481 07fc FFF7FEFF 		bl	vTaskMissedYield
 5482              	.L68:
1228:../src/FreeRTOS/queue.c **** 				}
1229:../src/FreeRTOS/queue.c **** 
1230:../src/FreeRTOS/queue.c **** 				--( pxQueue->xTxLock );
 5483              		.loc 1 1230 0
 5484 0800 7B68     		ldr	r3, [r7, #4]
 5485 0802 9B6C     		ldr	r3, [r3, #72]
 5486 0804 03F1FF32 		add	r2, r3, #-1
 5487 0808 7B68     		ldr	r3, [r7, #4]
 5488 080a 9A64     		str	r2, [r3, #72]
 5489              	.L66:
1215:../src/FreeRTOS/queue.c **** 		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 5490              		.loc 1 1215 0 discriminator 1
 5491 080c 7B68     		ldr	r3, [r7, #4]
 5492 080e 9B6C     		ldr	r3, [r3, #72]
 5493 0810 002B     		cmp	r3, #0
 5494 0812 E6DC     		bgt	.L70
 5495 0814 00E0     		b	.L69
 5496              	.L76:
1231:../src/FreeRTOS/queue.c **** 			}
1232:../src/FreeRTOS/queue.c **** 			else
1233:../src/FreeRTOS/queue.c **** 			{
1234:../src/FreeRTOS/queue.c **** 				break;
 5497              		.loc 1 1234 0
 5498 0816 00BF     		nop
 5499              	.L69:
1235:../src/FreeRTOS/queue.c **** 			}
1236:../src/FreeRTOS/queue.c **** 		}
1237:../src/FreeRTOS/queue.c **** 
1238:../src/FreeRTOS/queue.c **** 		pxQueue->xTxLock = queueUNLOCKED;
 5500              		.loc 1 1238 0
 5501 0818 7B68     		ldr	r3, [r7, #4]
 5502 081a 4FF0FF32 		mov	r2, #-1
 5503 081e 9A64     		str	r2, [r3, #72]
1239:../src/FreeRTOS/queue.c **** 	}
1240:../src/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 5504              		.loc 1 1240 0
 5505 0820 FFF7FEFF 		bl	vPortExitCritical
1241:../src/FreeRTOS/queue.c **** 
1242:../src/FreeRTOS/queue.c **** 	/* Do the same for the Rx lock. */
1243:../src/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 5506              		.loc 1 1243 0
 5507 0824 FFF7FEFF 		bl	vPortEnterCritical
1244:../src/FreeRTOS/queue.c **** 	{
1245:../src/FreeRTOS/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 5508              		.loc 1 1245 0
 5509 0828 14E0     		b	.L71
 5510              	.L75:
1246:../src/FreeRTOS/queue.c **** 		{
1247:../src/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 5511              		.loc 1 1247 0
 5512 082a 7B68     		ldr	r3, [r7, #4]
 5513 082c 1B69     		ldr	r3, [r3, #16]
 5514 082e 002B     		cmp	r3, #0
 5515 0830 15D0     		beq	.L77
1248:../src/FreeRTOS/queue.c **** 			{
1249:../src/FreeRTOS/queue.c **** 				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 5516              		.loc 1 1249 0
 5517 0832 7B68     		ldr	r3, [r7, #4]
 5518 0834 03F11003 		add	r3, r3, #16
 5519 0838 1846     		mov	r0, r3
 5520 083a FFF7FEFF 		bl	xTaskRemoveFromEventList
 5521 083e 0346     		mov	r3, r0
 5522 0840 002B     		cmp	r3, #0
 5523 0842 01D0     		beq	.L73
1250:../src/FreeRTOS/queue.c **** 				{
1251:../src/FreeRTOS/queue.c **** 					vTaskMissedYield();
 5524              		.loc 1 1251 0
 5525 0844 FFF7FEFF 		bl	vTaskMissedYield
 5526              	.L73:
1252:../src/FreeRTOS/queue.c **** 				}
1253:../src/FreeRTOS/queue.c **** 
1254:../src/FreeRTOS/queue.c **** 				--( pxQueue->xRxLock );
 5527              		.loc 1 1254 0
 5528 0848 7B68     		ldr	r3, [r7, #4]
 5529 084a 5B6C     		ldr	r3, [r3, #68]
 5530 084c 03F1FF32 		add	r2, r3, #-1
 5531 0850 7B68     		ldr	r3, [r7, #4]
 5532 0852 5A64     		str	r2, [r3, #68]
 5533              	.L71:
1245:../src/FreeRTOS/queue.c **** 		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 5534              		.loc 1 1245 0 discriminator 1
 5535 0854 7B68     		ldr	r3, [r7, #4]
 5536 0856 5B6C     		ldr	r3, [r3, #68]
 5537 0858 002B     		cmp	r3, #0
 5538 085a E6DC     		bgt	.L75
 5539 085c 00E0     		b	.L74
 5540              	.L77:
1255:../src/FreeRTOS/queue.c **** 			}
1256:../src/FreeRTOS/queue.c **** 			else
1257:../src/FreeRTOS/queue.c **** 			{
1258:../src/FreeRTOS/queue.c **** 				break;
 5541              		.loc 1 1258 0
 5542 085e 00BF     		nop
 5543              	.L74:
1259:../src/FreeRTOS/queue.c **** 			}
1260:../src/FreeRTOS/queue.c **** 		}
1261:../src/FreeRTOS/queue.c **** 
1262:../src/FreeRTOS/queue.c **** 		pxQueue->xRxLock = queueUNLOCKED;
 5544              		.loc 1 1262 0
 5545 0860 7B68     		ldr	r3, [r7, #4]
 5546 0862 4FF0FF32 		mov	r2, #-1
 5547 0866 5A64     		str	r2, [r3, #68]
1263:../src/FreeRTOS/queue.c **** 	}
1264:../src/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 5548              		.loc 1 1264 0
 5549 0868 FFF7FEFF 		bl	vPortExitCritical
1265:../src/FreeRTOS/queue.c **** }
 5550              		.loc 1 1265 0
 5551 086c 07F10807 		add	r7, r7, #8
 5552 0870 BD46     		mov	sp, r7
 5553 0872 80BD     		pop	{r7, pc}
 5554              		.cfi_endproc
 5555              	.LFE45:
 5557              		.align	2
 5558              		.thumb
 5559              		.thumb_func
 5561              	prvIsQueueEmpty:
 5562              	.LFB46:
1266:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1267:../src/FreeRTOS/queue.c **** 
1268:../src/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
1269:../src/FreeRTOS/queue.c **** {
 5563              		.loc 1 1269 0
 5564              		.cfi_startproc
 5565              		@ args = 0, pretend = 0, frame = 16
 5566              		@ frame_needed = 1, uses_anonymous_args = 0
 5567 0874 80B5     		push	{r7, lr}
 5568              	.LCFI51:
 5569              		.cfi_def_cfa_offset 8
 5570 0876 84B0     		sub	sp, sp, #16
 5571              	.LCFI52:
 5572              		.cfi_def_cfa_offset 24
 5573 0878 00AF     		add	r7, sp, #0
 5574              		.cfi_offset 14, -4
 5575              		.cfi_offset 7, -8
 5576              	.LCFI53:
 5577              		.cfi_def_cfa_register 7
 5578 087a 7860     		str	r0, [r7, #4]
1270:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1271:../src/FreeRTOS/queue.c **** 
1272:../src/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 5579              		.loc 1 1272 0
 5580 087c FFF7FEFF 		bl	vPortEnterCritical
1273:../src/FreeRTOS/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 5581              		.loc 1 1273 0
 5582 0880 7B68     		ldr	r3, [r7, #4]
 5583 0882 9B6B     		ldr	r3, [r3, #56]
 5584 0884 002B     		cmp	r3, #0
 5585 0886 14BF     		ite	ne
 5586 0888 0023     		movne	r3, #0
 5587 088a 0123     		moveq	r3, #1
 5588 088c FB60     		str	r3, [r7, #12]
1274:../src/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 5589              		.loc 1 1274 0
 5590 088e FFF7FEFF 		bl	vPortExitCritical
1275:../src/FreeRTOS/queue.c **** 
1276:../src/FreeRTOS/queue.c **** 	return xReturn;
 5591              		.loc 1 1276 0
 5592 0892 FB68     		ldr	r3, [r7, #12]
1277:../src/FreeRTOS/queue.c **** }
 5593              		.loc 1 1277 0
 5594 0894 1846     		mov	r0, r3
 5595 0896 07F11007 		add	r7, r7, #16
 5596 089a BD46     		mov	sp, r7
 5597 089c 80BD     		pop	{r7, pc}
 5598              		.cfi_endproc
 5599              	.LFE46:
 5601 089e 00BF     		.align	2
 5602              		.global	xQueueIsQueueEmptyFromISR
 5603              		.thumb
 5604              		.thumb_func
 5606              	xQueueIsQueueEmptyFromISR:
 5607              	.LFB47:
1278:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1279:../src/FreeRTOS/queue.c **** 
1280:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
1281:../src/FreeRTOS/queue.c **** {
 5608              		.loc 1 1281 0
 5609              		.cfi_startproc
 5610              		@ args = 0, pretend = 0, frame = 16
 5611              		@ frame_needed = 1, uses_anonymous_args = 0
 5612              		@ link register save eliminated.
 5613 08a0 80B4     		push	{r7}
 5614              	.LCFI54:
 5615              		.cfi_def_cfa_offset 4
 5616 08a2 85B0     		sub	sp, sp, #20
 5617              	.LCFI55:
 5618              		.cfi_def_cfa_offset 24
 5619 08a4 00AF     		add	r7, sp, #0
 5620              		.cfi_offset 7, -4
 5621              	.LCFI56:
 5622              		.cfi_def_cfa_register 7
 5623 08a6 7860     		str	r0, [r7, #4]
1282:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1283:../src/FreeRTOS/queue.c **** 
1284:../src/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1285:../src/FreeRTOS/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 5624              		.loc 1 1285 0
 5625 08a8 7B68     		ldr	r3, [r7, #4]
 5626 08aa 9B6B     		ldr	r3, [r3, #56]
 5627 08ac 002B     		cmp	r3, #0
 5628 08ae 14BF     		ite	ne
 5629 08b0 0023     		movne	r3, #0
 5630 08b2 0123     		moveq	r3, #1
 5631 08b4 FB60     		str	r3, [r7, #12]
1286:../src/FreeRTOS/queue.c **** 
1287:../src/FreeRTOS/queue.c **** 	return xReturn;
 5632              		.loc 1 1287 0
 5633 08b6 FB68     		ldr	r3, [r7, #12]
1288:../src/FreeRTOS/queue.c **** }
 5634              		.loc 1 1288 0
 5635 08b8 1846     		mov	r0, r3
 5636 08ba 07F11407 		add	r7, r7, #20
 5637 08be BD46     		mov	sp, r7
 5638 08c0 80BC     		pop	{r7}
 5639 08c2 7047     		bx	lr
 5640              		.cfi_endproc
 5641              	.LFE47:
 5643              		.align	2
 5644              		.thumb
 5645              		.thumb_func
 5647              	prvIsQueueFull:
 5648              	.LFB48:
1289:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1290:../src/FreeRTOS/queue.c **** 
1291:../src/FreeRTOS/queue.c **** static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
1292:../src/FreeRTOS/queue.c **** {
 5649              		.loc 1 1292 0
 5650              		.cfi_startproc
 5651              		@ args = 0, pretend = 0, frame = 16
 5652              		@ frame_needed = 1, uses_anonymous_args = 0
 5653 08c4 80B5     		push	{r7, lr}
 5654              	.LCFI57:
 5655              		.cfi_def_cfa_offset 8
 5656 08c6 84B0     		sub	sp, sp, #16
 5657              	.LCFI58:
 5658              		.cfi_def_cfa_offset 24
 5659 08c8 00AF     		add	r7, sp, #0
 5660              		.cfi_offset 14, -4
 5661              		.cfi_offset 7, -8
 5662              	.LCFI59:
 5663              		.cfi_def_cfa_register 7
 5664 08ca 7860     		str	r0, [r7, #4]
1293:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1294:../src/FreeRTOS/queue.c **** 
1295:../src/FreeRTOS/queue.c **** 	taskENTER_CRITICAL();
 5665              		.loc 1 1295 0
 5666 08cc FFF7FEFF 		bl	vPortEnterCritical
1296:../src/FreeRTOS/queue.c **** 		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 5667              		.loc 1 1296 0
 5668 08d0 7B68     		ldr	r3, [r7, #4]
 5669 08d2 9A6B     		ldr	r2, [r3, #56]
 5670 08d4 7B68     		ldr	r3, [r7, #4]
 5671 08d6 DB6B     		ldr	r3, [r3, #60]
 5672 08d8 9A42     		cmp	r2, r3
 5673 08da 14BF     		ite	ne
 5674 08dc 0023     		movne	r3, #0
 5675 08de 0123     		moveq	r3, #1
 5676 08e0 FB60     		str	r3, [r7, #12]
1297:../src/FreeRTOS/queue.c **** 	taskEXIT_CRITICAL();
 5677              		.loc 1 1297 0
 5678 08e2 FFF7FEFF 		bl	vPortExitCritical
1298:../src/FreeRTOS/queue.c **** 
1299:../src/FreeRTOS/queue.c **** 	return xReturn;
 5679              		.loc 1 1299 0
 5680 08e6 FB68     		ldr	r3, [r7, #12]
1300:../src/FreeRTOS/queue.c **** }
 5681              		.loc 1 1300 0
 5682 08e8 1846     		mov	r0, r3
 5683 08ea 07F11007 		add	r7, r7, #16
 5684 08ee BD46     		mov	sp, r7
 5685 08f0 80BD     		pop	{r7, pc}
 5686              		.cfi_endproc
 5687              	.LFE48:
 5689 08f2 00BF     		.align	2
 5690              		.global	xQueueIsQueueFullFromISR
 5691              		.thumb
 5692              		.thumb_func
 5694              	xQueueIsQueueFullFromISR:
 5695              	.LFB49:
1301:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1302:../src/FreeRTOS/queue.c **** 
1303:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
1304:../src/FreeRTOS/queue.c **** {
 5696              		.loc 1 1304 0
 5697              		.cfi_startproc
 5698              		@ args = 0, pretend = 0, frame = 16
 5699              		@ frame_needed = 1, uses_anonymous_args = 0
 5700              		@ link register save eliminated.
 5701 08f4 80B4     		push	{r7}
 5702              	.LCFI60:
 5703              		.cfi_def_cfa_offset 4
 5704 08f6 85B0     		sub	sp, sp, #20
 5705              	.LCFI61:
 5706              		.cfi_def_cfa_offset 24
 5707 08f8 00AF     		add	r7, sp, #0
 5708              		.cfi_offset 7, -4
 5709              	.LCFI62:
 5710              		.cfi_def_cfa_register 7
 5711 08fa 7860     		str	r0, [r7, #4]
1305:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1306:../src/FreeRTOS/queue.c **** 
1307:../src/FreeRTOS/queue.c **** 	configASSERT( pxQueue );
1308:../src/FreeRTOS/queue.c **** 	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 5712              		.loc 1 1308 0
 5713 08fc 7B68     		ldr	r3, [r7, #4]
 5714 08fe 9A6B     		ldr	r2, [r3, #56]
 5715 0900 7B68     		ldr	r3, [r7, #4]
 5716 0902 DB6B     		ldr	r3, [r3, #60]
 5717 0904 9A42     		cmp	r2, r3
 5718 0906 14BF     		ite	ne
 5719 0908 0023     		movne	r3, #0
 5720 090a 0123     		moveq	r3, #1
 5721 090c FB60     		str	r3, [r7, #12]
1309:../src/FreeRTOS/queue.c **** 
1310:../src/FreeRTOS/queue.c **** 	return xReturn;
 5722              		.loc 1 1310 0
 5723 090e FB68     		ldr	r3, [r7, #12]
1311:../src/FreeRTOS/queue.c **** }
 5724              		.loc 1 1311 0
 5725 0910 1846     		mov	r0, r3
 5726 0912 07F11407 		add	r7, r7, #20
 5727 0916 BD46     		mov	sp, r7
 5728 0918 80BC     		pop	{r7}
 5729 091a 7047     		bx	lr
 5730              		.cfi_endproc
 5731              	.LFE49:
 5733              		.align	2
 5734              		.global	vQueueAddToRegistry
 5735              		.thumb
 5736              		.thumb_func
 5738              	vQueueAddToRegistry:
 5739              	.LFB50:
1312:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1313:../src/FreeRTOS/queue.c **** 
1314:../src/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1315:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xT
1316:../src/FreeRTOS/queue.c **** {
1317:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1318:../src/FreeRTOS/queue.c **** 
1319:../src/FreeRTOS/queue.c **** 	/* If the queue is already full we may have to block.  A critical section
1320:../src/FreeRTOS/queue.c **** 	is required to prevent an interrupt removing something from the queue
1321:../src/FreeRTOS/queue.c **** 	between the check to see if the queue is full and blocking on the queue. */
1322:../src/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1323:../src/FreeRTOS/queue.c **** 	{
1324:../src/FreeRTOS/queue.c **** 		if( prvIsQueueFull( pxQueue ) != pdFALSE )
1325:../src/FreeRTOS/queue.c **** 		{
1326:../src/FreeRTOS/queue.c **** 			/* The queue is full - do we want to block or just leave without
1327:../src/FreeRTOS/queue.c **** 			posting? */
1328:../src/FreeRTOS/queue.c **** 			if( xTicksToWait > ( portTickType ) 0 )
1329:../src/FreeRTOS/queue.c **** 			{
1330:../src/FreeRTOS/queue.c **** 				/* As this is called from a coroutine we cannot block directly, but
1331:../src/FreeRTOS/queue.c **** 				return indicating that we need to block. */
1332:../src/FreeRTOS/queue.c **** 				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1333:../src/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1334:../src/FreeRTOS/queue.c **** 				return errQUEUE_BLOCKED;
1335:../src/FreeRTOS/queue.c **** 			}
1336:../src/FreeRTOS/queue.c **** 			else
1337:../src/FreeRTOS/queue.c **** 			{
1338:../src/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1339:../src/FreeRTOS/queue.c **** 				return errQUEUE_FULL;
1340:../src/FreeRTOS/queue.c **** 			}
1341:../src/FreeRTOS/queue.c **** 		}
1342:../src/FreeRTOS/queue.c **** 	}
1343:../src/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1344:../src/FreeRTOS/queue.c **** 
1345:../src/FreeRTOS/queue.c **** 	portNOP();
1346:../src/FreeRTOS/queue.c **** 
1347:../src/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1348:../src/FreeRTOS/queue.c **** 	{
1349:../src/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1350:../src/FreeRTOS/queue.c **** 		{
1351:../src/FreeRTOS/queue.c **** 			/* There is room in the queue, copy the data into the queue. */
1352:../src/FreeRTOS/queue.c **** 			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1353:../src/FreeRTOS/queue.c **** 			xReturn = pdPASS;
1354:../src/FreeRTOS/queue.c **** 
1355:../src/FreeRTOS/queue.c **** 			/* Were any co-routines waiting for data to become available? */
1356:../src/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1357:../src/FreeRTOS/queue.c **** 			{
1358:../src/FreeRTOS/queue.c **** 				/* In this instance the co-routine could be placed directly
1359:../src/FreeRTOS/queue.c **** 				into the ready list as we are within a critical section.
1360:../src/FreeRTOS/queue.c **** 				Instead the same pending ready list mechanism is used as if
1361:../src/FreeRTOS/queue.c **** 				the event were caused from within an interrupt. */
1362:../src/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1363:../src/FreeRTOS/queue.c **** 				{
1364:../src/FreeRTOS/queue.c **** 					/* The co-routine waiting has a higher priority so record
1365:../src/FreeRTOS/queue.c **** 					that a yield might be appropriate. */
1366:../src/FreeRTOS/queue.c **** 					xReturn = errQUEUE_YIELD;
1367:../src/FreeRTOS/queue.c **** 				}
1368:../src/FreeRTOS/queue.c **** 			}
1369:../src/FreeRTOS/queue.c **** 		}
1370:../src/FreeRTOS/queue.c **** 		else
1371:../src/FreeRTOS/queue.c **** 		{
1372:../src/FreeRTOS/queue.c **** 			xReturn = errQUEUE_FULL;
1373:../src/FreeRTOS/queue.c **** 		}
1374:../src/FreeRTOS/queue.c **** 	}
1375:../src/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1376:../src/FreeRTOS/queue.c **** 
1377:../src/FreeRTOS/queue.c **** 	return xReturn;
1378:../src/FreeRTOS/queue.c **** }
1379:../src/FreeRTOS/queue.c **** #endif
1380:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1381:../src/FreeRTOS/queue.c **** 
1382:../src/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1383:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWa
1384:../src/FreeRTOS/queue.c **** {
1385:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1386:../src/FreeRTOS/queue.c **** 
1387:../src/FreeRTOS/queue.c **** 	/* If the queue is already empty we may have to block.  A critical section
1388:../src/FreeRTOS/queue.c **** 	is required to prevent an interrupt adding something to the queue
1389:../src/FreeRTOS/queue.c **** 	between the check to see if the queue is empty and blocking on the queue. */
1390:../src/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1391:../src/FreeRTOS/queue.c **** 	{
1392:../src/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
1393:../src/FreeRTOS/queue.c **** 		{
1394:../src/FreeRTOS/queue.c **** 			/* There are no messages in the queue, do we want to block or just
1395:../src/FreeRTOS/queue.c **** 			leave with nothing? */
1396:../src/FreeRTOS/queue.c **** 			if( xTicksToWait > ( portTickType ) 0 )
1397:../src/FreeRTOS/queue.c **** 			{
1398:../src/FreeRTOS/queue.c **** 				/* As this is a co-routine we cannot block directly, but return
1399:../src/FreeRTOS/queue.c **** 				indicating that we need to block. */
1400:../src/FreeRTOS/queue.c **** 				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
1401:../src/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1402:../src/FreeRTOS/queue.c **** 				return errQUEUE_BLOCKED;
1403:../src/FreeRTOS/queue.c **** 			}
1404:../src/FreeRTOS/queue.c **** 			else
1405:../src/FreeRTOS/queue.c **** 			{
1406:../src/FreeRTOS/queue.c **** 				portENABLE_INTERRUPTS();
1407:../src/FreeRTOS/queue.c **** 				return errQUEUE_FULL;
1408:../src/FreeRTOS/queue.c **** 			}
1409:../src/FreeRTOS/queue.c **** 		}
1410:../src/FreeRTOS/queue.c **** 	}
1411:../src/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1412:../src/FreeRTOS/queue.c **** 
1413:../src/FreeRTOS/queue.c **** 	portNOP();
1414:../src/FreeRTOS/queue.c **** 
1415:../src/FreeRTOS/queue.c **** 	portDISABLE_INTERRUPTS();
1416:../src/FreeRTOS/queue.c **** 	{
1417:../src/FreeRTOS/queue.c **** 		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1418:../src/FreeRTOS/queue.c **** 		{
1419:../src/FreeRTOS/queue.c **** 			/* Data is available from the queue. */
1420:../src/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom += pxQueue->uxItemSize;
1421:../src/FreeRTOS/queue.c **** 			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1422:../src/FreeRTOS/queue.c **** 			{
1423:../src/FreeRTOS/queue.c **** 				pxQueue->pcReadFrom = pxQueue->pcHead;
1424:../src/FreeRTOS/queue.c **** 			}
1425:../src/FreeRTOS/queue.c **** 			--( pxQueue->uxMessagesWaiting );
1426:../src/FreeRTOS/queue.c **** 			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1427:../src/FreeRTOS/queue.c **** 
1428:../src/FreeRTOS/queue.c **** 			xReturn = pdPASS;
1429:../src/FreeRTOS/queue.c **** 
1430:../src/FreeRTOS/queue.c **** 			/* Were any co-routines waiting for space to become available? */
1431:../src/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1432:../src/FreeRTOS/queue.c **** 			{
1433:../src/FreeRTOS/queue.c **** 				/* In this instance the co-routine could be placed directly
1434:../src/FreeRTOS/queue.c **** 				into the ready list as we are within a critical section.
1435:../src/FreeRTOS/queue.c **** 				Instead the same pending ready list mechanism is used as if
1436:../src/FreeRTOS/queue.c **** 				the event were caused from within an interrupt. */
1437:../src/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1438:../src/FreeRTOS/queue.c **** 				{
1439:../src/FreeRTOS/queue.c **** 					xReturn = errQUEUE_YIELD;
1440:../src/FreeRTOS/queue.c **** 				}
1441:../src/FreeRTOS/queue.c **** 			}
1442:../src/FreeRTOS/queue.c **** 		}
1443:../src/FreeRTOS/queue.c **** 		else
1444:../src/FreeRTOS/queue.c **** 		{
1445:../src/FreeRTOS/queue.c **** 			xReturn = pdFAIL;
1446:../src/FreeRTOS/queue.c **** 		}
1447:../src/FreeRTOS/queue.c **** 	}
1448:../src/FreeRTOS/queue.c **** 	portENABLE_INTERRUPTS();
1449:../src/FreeRTOS/queue.c **** 
1450:../src/FreeRTOS/queue.c **** 	return xReturn;
1451:../src/FreeRTOS/queue.c **** }
1452:../src/FreeRTOS/queue.c **** #endif
1453:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1454:../src/FreeRTOS/queue.c **** 
1455:../src/FreeRTOS/queue.c **** 
1456:../src/FreeRTOS/queue.c **** 
1457:../src/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1458:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed p
1459:../src/FreeRTOS/queue.c **** {
1460:../src/FreeRTOS/queue.c **** 	/* Cannot block within an ISR so if there is no space on the queue then
1461:../src/FreeRTOS/queue.c **** 	exit without doing anything. */
1462:../src/FreeRTOS/queue.c **** 	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1463:../src/FreeRTOS/queue.c **** 	{
1464:../src/FreeRTOS/queue.c **** 		prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1465:../src/FreeRTOS/queue.c **** 
1466:../src/FreeRTOS/queue.c **** 		/* We only want to wake one co-routine per ISR, so check that a
1467:../src/FreeRTOS/queue.c **** 		co-routine has not already been woken. */
1468:../src/FreeRTOS/queue.c **** 		if( xCoRoutinePreviouslyWoken == pdFALSE )
1469:../src/FreeRTOS/queue.c **** 		{
1470:../src/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1471:../src/FreeRTOS/queue.c **** 			{
1472:../src/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1473:../src/FreeRTOS/queue.c **** 				{
1474:../src/FreeRTOS/queue.c **** 					return pdTRUE;
1475:../src/FreeRTOS/queue.c **** 				}
1476:../src/FreeRTOS/queue.c **** 			}
1477:../src/FreeRTOS/queue.c **** 		}
1478:../src/FreeRTOS/queue.c **** 	}
1479:../src/FreeRTOS/queue.c **** 
1480:../src/FreeRTOS/queue.c **** 	return xCoRoutinePreviouslyWoken;
1481:../src/FreeRTOS/queue.c **** }
1482:../src/FreeRTOS/queue.c **** #endif
1483:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1484:../src/FreeRTOS/queue.c **** 
1485:../src/FreeRTOS/queue.c **** #if configUSE_CO_ROUTINES == 1
1486:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_
1487:../src/FreeRTOS/queue.c **** {
1488:../src/FreeRTOS/queue.c **** signed portBASE_TYPE xReturn;
1489:../src/FreeRTOS/queue.c **** 
1490:../src/FreeRTOS/queue.c **** 	/* We cannot block from an ISR, so check there is data available. If
1491:../src/FreeRTOS/queue.c **** 	not then just leave without doing anything. */
1492:../src/FreeRTOS/queue.c **** 	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1493:../src/FreeRTOS/queue.c **** 	{
1494:../src/FreeRTOS/queue.c **** 		/* Copy the data from the queue. */
1495:../src/FreeRTOS/queue.c **** 		pxQueue->pcReadFrom += pxQueue->uxItemSize;
1496:../src/FreeRTOS/queue.c **** 		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1497:../src/FreeRTOS/queue.c **** 		{
1498:../src/FreeRTOS/queue.c **** 			pxQueue->pcReadFrom = pxQueue->pcHead;
1499:../src/FreeRTOS/queue.c **** 		}
1500:../src/FreeRTOS/queue.c **** 		--( pxQueue->uxMessagesWaiting );
1501:../src/FreeRTOS/queue.c **** 		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1502:../src/FreeRTOS/queue.c **** 
1503:../src/FreeRTOS/queue.c **** 		if( ( *pxCoRoutineWoken ) == pdFALSE )
1504:../src/FreeRTOS/queue.c **** 		{
1505:../src/FreeRTOS/queue.c **** 			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1506:../src/FreeRTOS/queue.c **** 			{
1507:../src/FreeRTOS/queue.c **** 				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1508:../src/FreeRTOS/queue.c **** 				{
1509:../src/FreeRTOS/queue.c **** 					*pxCoRoutineWoken = pdTRUE;
1510:../src/FreeRTOS/queue.c **** 				}
1511:../src/FreeRTOS/queue.c **** 			}
1512:../src/FreeRTOS/queue.c **** 		}
1513:../src/FreeRTOS/queue.c **** 
1514:../src/FreeRTOS/queue.c **** 		xReturn = pdPASS;
1515:../src/FreeRTOS/queue.c **** 	}
1516:../src/FreeRTOS/queue.c **** 	else
1517:../src/FreeRTOS/queue.c **** 	{
1518:../src/FreeRTOS/queue.c **** 		xReturn = pdFAIL;
1519:../src/FreeRTOS/queue.c **** 	}
1520:../src/FreeRTOS/queue.c **** 
1521:../src/FreeRTOS/queue.c **** 	return xReturn;
1522:../src/FreeRTOS/queue.c **** }
1523:../src/FreeRTOS/queue.c **** #endif
1524:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1525:../src/FreeRTOS/queue.c **** 
1526:../src/FreeRTOS/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
1527:../src/FreeRTOS/queue.c **** 
1528:../src/FreeRTOS/queue.c **** 	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
1529:../src/FreeRTOS/queue.c **** 	{
 5740              		.loc 1 1529 0
 5741              		.cfi_startproc
 5742              		@ args = 0, pretend = 0, frame = 16
 5743              		@ frame_needed = 1, uses_anonymous_args = 0
 5744              		@ link register save eliminated.
 5745 091c 80B4     		push	{r7}
 5746              	.LCFI63:
 5747              		.cfi_def_cfa_offset 4
 5748 091e 85B0     		sub	sp, sp, #20
 5749              	.LCFI64:
 5750              		.cfi_def_cfa_offset 24
 5751 0920 00AF     		add	r7, sp, #0
 5752              		.cfi_offset 7, -4
 5753              	.LCFI65:
 5754              		.cfi_def_cfa_register 7
 5755 0922 7860     		str	r0, [r7, #4]
 5756 0924 3960     		str	r1, [r7, #0]
1530:../src/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE ux;
1531:../src/FreeRTOS/queue.c **** 
1532:../src/FreeRTOS/queue.c **** 		/* See if there is an empty space in the registry.  A NULL name denotes
1533:../src/FreeRTOS/queue.c **** 		a free slot. */
1534:../src/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5757              		.loc 1 1534 0
 5758 0926 4FF00003 		mov	r3, #0
 5759 092a FB60     		str	r3, [r7, #12]
 5760 092c 16E0     		b	.L83
 5761              	.L86:
1535:../src/FreeRTOS/queue.c **** 		{
1536:../src/FreeRTOS/queue.c **** 			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 5762              		.loc 1 1536 0
 5763 092e 0F4B     		ldr	r3, .L87
 5764 0930 FA68     		ldr	r2, [r7, #12]
 5765 0932 53F83230 		ldr	r3, [r3, r2, lsl #3]
 5766 0936 002B     		cmp	r3, #0
 5767 0938 0CD1     		bne	.L84
1537:../src/FreeRTOS/queue.c **** 			{
1538:../src/FreeRTOS/queue.c **** 				/* Store the information on this queue. */
1539:../src/FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 5768              		.loc 1 1539 0
 5769 093a 0C4B     		ldr	r3, .L87
 5770 093c FA68     		ldr	r2, [r7, #12]
 5771 093e 3968     		ldr	r1, [r7, #0]
 5772 0940 43F83210 		str	r1, [r3, r2, lsl #3]
1540:../src/FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].xHandle = xQueue;
 5773              		.loc 1 1540 0
 5774 0944 094A     		ldr	r2, .L87
 5775 0946 FB68     		ldr	r3, [r7, #12]
 5776 0948 4FEAC303 		lsl	r3, r3, #3
 5777 094c D318     		adds	r3, r2, r3
 5778 094e 7A68     		ldr	r2, [r7, #4]
 5779 0950 5A60     		str	r2, [r3, #4]
1541:../src/FreeRTOS/queue.c **** 				break;
 5780              		.loc 1 1541 0
 5781 0952 06E0     		b	.L82
 5782              	.L84:
1534:../src/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5783              		.loc 1 1534 0
 5784 0954 FB68     		ldr	r3, [r7, #12]
 5785 0956 03F10103 		add	r3, r3, #1
 5786 095a FB60     		str	r3, [r7, #12]
 5787              	.L83:
1534:../src/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5788              		.loc 1 1534 0 is_stmt 0 discriminator 1
 5789 095c FB68     		ldr	r3, [r7, #12]
 5790 095e 092B     		cmp	r3, #9
 5791 0960 E5D9     		bls	.L86
 5792              	.L82:
1542:../src/FreeRTOS/queue.c **** 			}
1543:../src/FreeRTOS/queue.c **** 		}
1544:../src/FreeRTOS/queue.c **** 	}
 5793              		.loc 1 1544 0 is_stmt 1
 5794 0962 07F11407 		add	r7, r7, #20
 5795 0966 BD46     		mov	sp, r7
 5796 0968 80BC     		pop	{r7}
 5797 096a 7047     		bx	lr
 5798              	.L88:
 5799              		.align	2
 5800              	.L87:
 5801 096c 00000000 		.word	xQueueRegistry
 5802              		.cfi_endproc
 5803              	.LFE50:
 5805              		.align	2
 5806              		.thumb
 5807              		.thumb_func
 5809              	vQueueUnregisterQueue:
 5810              	.LFB51:
1545:../src/FreeRTOS/queue.c **** 
1546:../src/FreeRTOS/queue.c **** #endif
1547:../src/FreeRTOS/queue.c **** /*-----------------------------------------------------------*/
1548:../src/FreeRTOS/queue.c **** 
1549:../src/FreeRTOS/queue.c **** #if configQUEUE_REGISTRY_SIZE > 0
1550:../src/FreeRTOS/queue.c **** 
1551:../src/FreeRTOS/queue.c **** 	static void vQueueUnregisterQueue( xQueueHandle xQueue )
1552:../src/FreeRTOS/queue.c **** 	{
 5811              		.loc 1 1552 0
 5812              		.cfi_startproc
 5813              		@ args = 0, pretend = 0, frame = 16
 5814              		@ frame_needed = 1, uses_anonymous_args = 0
 5815              		@ link register save eliminated.
 5816 0970 80B4     		push	{r7}
 5817              	.LCFI66:
 5818              		.cfi_def_cfa_offset 4
 5819 0972 85B0     		sub	sp, sp, #20
 5820              	.LCFI67:
 5821              		.cfi_def_cfa_offset 24
 5822 0974 00AF     		add	r7, sp, #0
 5823              		.cfi_offset 7, -4
 5824              	.LCFI68:
 5825              		.cfi_def_cfa_register 7
 5826 0976 7860     		str	r0, [r7, #4]
1553:../src/FreeRTOS/queue.c **** 	unsigned portBASE_TYPE ux;
1554:../src/FreeRTOS/queue.c **** 
1555:../src/FreeRTOS/queue.c **** 		/* See if the handle of the queue being unregistered in actually in the
1556:../src/FreeRTOS/queue.c **** 		registry. */
1557:../src/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5827              		.loc 1 1557 0
 5828 0978 4FF00003 		mov	r3, #0
 5829 097c FB60     		str	r3, [r7, #12]
 5830 097e 13E0     		b	.L90
 5831              	.L93:
1558:../src/FreeRTOS/queue.c **** 		{
1559:../src/FreeRTOS/queue.c **** 			if( xQueueRegistry[ ux ].xHandle == xQueue )
 5832              		.loc 1 1559 0
 5833 0980 0D4A     		ldr	r2, .L94
 5834 0982 FB68     		ldr	r3, [r7, #12]
 5835 0984 4FEAC303 		lsl	r3, r3, #3
 5836 0988 D318     		adds	r3, r2, r3
 5837 098a 5A68     		ldr	r2, [r3, #4]
 5838 098c 7B68     		ldr	r3, [r7, #4]
 5839 098e 9A42     		cmp	r2, r3
 5840 0990 06D1     		bne	.L91
1560:../src/FreeRTOS/queue.c **** 			{
1561:../src/FreeRTOS/queue.c **** 				/* Set the name to NULL to show that this slot if free again. */
1562:../src/FreeRTOS/queue.c **** 				xQueueRegistry[ ux ].pcQueueName = NULL;
 5841              		.loc 1 1562 0
 5842 0992 094B     		ldr	r3, .L94
 5843 0994 FA68     		ldr	r2, [r7, #12]
 5844 0996 4FF00001 		mov	r1, #0
 5845 099a 43F83210 		str	r1, [r3, r2, lsl #3]
1563:../src/FreeRTOS/queue.c **** 				break;
 5846              		.loc 1 1563 0
 5847 099e 06E0     		b	.L89
 5848              	.L91:
1557:../src/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5849              		.loc 1 1557 0
 5850 09a0 FB68     		ldr	r3, [r7, #12]
 5851 09a2 03F10103 		add	r3, r3, #1
 5852 09a6 FB60     		str	r3, [r7, #12]
 5853              	.L90:
1557:../src/FreeRTOS/queue.c **** 		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZ
 5854              		.loc 1 1557 0 is_stmt 0 discriminator 1
 5855 09a8 FB68     		ldr	r3, [r7, #12]
 5856 09aa 092B     		cmp	r3, #9
 5857 09ac E8D9     		bls	.L93
 5858              	.L89:
1564:../src/FreeRTOS/queue.c **** 			}
1565:../src/FreeRTOS/queue.c **** 		}
1566:../src/FreeRTOS/queue.c **** 
1567:../src/FreeRTOS/queue.c **** 	}
 5859              		.loc 1 1567 0 is_stmt 1
 5860 09ae 07F11407 		add	r7, r7, #20
 5861 09b2 BD46     		mov	sp, r7
 5862 09b4 80BC     		pop	{r7}
 5863 09b6 7047     		bx	lr
 5864              	.L95:
 5865              		.align	2
 5866              	.L94:
 5867 09b8 00000000 		.word	xQueueRegistry
 5868              		.cfi_endproc
 5869              	.LFE51:
 5871              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 queue.c
                            *COM*:00000050 xQueueRegistry
     /tmp/ccsbGW6l.s:4018   .text:00000000 $t
     /tmp/ccsbGW6l.s:4023   .text:00000000 xQueueGenericCreate
     /tmp/ccsbGW6l.s:4160   .text:000000dc xQueueCreateMutex
     /tmp/ccsbGW6l.s:4399   .text:00000234 xQueueGenericSend
     /tmp/ccsbGW6l.s:4260   .text:00000180 xQueueGiveMutexRecursive
     /tmp/ccsbGW6l.s:4328   .text:000001d8 xQueueTakeMutexRecursive
     /tmp/ccsbGW6l.s:4681   .text:000003e4 xQueueGenericReceive
     /tmp/ccsbGW6l.s:5250   .text:000006c0 prvCopyDataToQueue
     /tmp/ccsbGW6l.s:5647   .text:000008c4 prvIsQueueFull
     /tmp/ccsbGW6l.s:5444   .text:000007d4 prvUnlockQueue
     /tmp/ccsbGW6l.s:4577   .text:00000354 xQueueGenericSendFromISR
     /tmp/ccsbGW6l.s:5378   .text:00000784 prvCopyDataFromQueue
     /tmp/ccsbGW6l.s:5561   .text:00000874 prvIsQueueEmpty
     /tmp/ccsbGW6l.s:4918   .text:0000056c xQueueReceiveFromISR
     /tmp/ccsbGW6l.s:5024   .text:00000600 uxQueueMessagesWaiting
     /tmp/ccsbGW6l.s:5065   .text:00000624 uxQueueMessagesWaitingFromISR
     /tmp/ccsbGW6l.s:5103   .text:00000640 vQueueDelete
     /tmp/ccsbGW6l.s:5809   .text:00000970 vQueueUnregisterQueue
     /tmp/ccsbGW6l.s:5144   .text:00000668 ucQueueGetQueueNumber
     /tmp/ccsbGW6l.s:5179   .text:00000684 vQueueSetQueueNumber
     /tmp/ccsbGW6l.s:5216   .text:000006a4 ucQueueGetQueueType
     /tmp/ccsbGW6l.s:5606   .text:000008a0 xQueueIsQueueEmptyFromISR
     /tmp/ccsbGW6l.s:5694   .text:000008f4 xQueueIsQueueFullFromISR
     /tmp/ccsbGW6l.s:5738   .text:0000091c vQueueAddToRegistry
     /tmp/ccsbGW6l.s:5801   .text:0000096c $d
     /tmp/ccsbGW6l.s:5805   .text:00000970 $t
     /tmp/ccsbGW6l.s:5867   .text:000009b8 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pvPortMalloc
vListInitialise
vPortFree
xTaskGetCurrentTaskHandle
vPortEnterCritical
xTaskRemoveFromEventList
vPortYieldFromISR
vPortExitCritical
vTaskSetTimeOutState
vTaskSuspendAll
xTaskCheckForTimeOut
vTaskPlaceOnEventList
xTaskResumeAll
vTaskPriorityInherit
vTaskPriorityDisinherit
memcpy
vTaskMissedYield
