   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"blocktim.c"
  23              	.Ltext0:
  24              		.file 1 "../src/Common Demo Tasks/blocktim.c"
 3456              		.align	2
 3457              	xTestQueue:
 3458 0000 00000000 		.space	4
 3459              		.align	2
 3460              	xSecondary:
 3461 0004 00000000 		.space	4
 3462              		.align	2
 3463              	xPrimaryCycles:
 3464 0008 00000000 		.space	4
 3465              		.align	2
 3466              	xSecondaryCycles:
 3467 000c 00000000 		.space	4
 3468              		.align	2
 3469              	xErrorOccurred:
 3470 0010 00000000 		.space	4
 3471              		.align	2
 3472              	xRunIndicator:
 3473 0014 00000000 		.space	4
 3474              		.section	.rodata
 3475              		.align	2
 3476              	.LC0:
 3477 0000 426C6F63 		.ascii	"Block_Time_Queue\000"
 3477      6B5F5469 
 3477      6D655F51 
 3477      75657565 
 3477      00
 3478 0011 000000   		.align	2
 3479              	.LC1:
 3480 0014 42546573 		.ascii	"BTest1\000"
 3480      743100
 3481 001b 00       		.align	2
 3482              	.LC2:
 3483 001c 42546573 		.ascii	"BTest2\000"
 3483      743200
 3484 0023 00       		.text
 3485              		.align	2
 3486              		.global	vCreateBlockTimeTasks
 3487              		.thumb
 3488              		.thumb_func
 3490              	vCreateBlockTimeTasks:
 3491              	.LFB29:
   1:../src/Common Demo Tasks/blocktim.c **** /*
   2:../src/Common Demo Tasks/blocktim.c ****     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:../src/Common Demo Tasks/blocktim.c **** 	
   4:../src/Common Demo Tasks/blocktim.c **** 
   5:../src/Common Demo Tasks/blocktim.c ****     ***************************************************************************
   6:../src/Common Demo Tasks/blocktim.c ****      *                                                                       *
   7:../src/Common Demo Tasks/blocktim.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:../src/Common Demo Tasks/blocktim.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:../src/Common Demo Tasks/blocktim.c ****      *    available.                                                         *
  10:../src/Common Demo Tasks/blocktim.c ****      *                                                                       *
  11:../src/Common Demo Tasks/blocktim.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:../src/Common Demo Tasks/blocktim.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:../src/Common Demo Tasks/blocktim.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:../src/Common Demo Tasks/blocktim.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:../src/Common Demo Tasks/blocktim.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:../src/Common Demo Tasks/blocktim.c ****      *    for microcontrollers - completely free of charge!                  *
  17:../src/Common Demo Tasks/blocktim.c ****      *                                                                       *
  18:../src/Common Demo Tasks/blocktim.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:../src/Common Demo Tasks/blocktim.c ****      *                                                                       *
  20:../src/Common Demo Tasks/blocktim.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:../src/Common Demo Tasks/blocktim.c ****      *                                                                       *
  22:../src/Common Demo Tasks/blocktim.c ****     ***************************************************************************
  23:../src/Common Demo Tasks/blocktim.c **** 
  24:../src/Common Demo Tasks/blocktim.c **** 
  25:../src/Common Demo Tasks/blocktim.c ****     This file is part of the FreeRTOS distribution.
  26:../src/Common Demo Tasks/blocktim.c **** 
  27:../src/Common Demo Tasks/blocktim.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:../src/Common Demo Tasks/blocktim.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:../src/Common Demo Tasks/blocktim.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:../src/Common Demo Tasks/blocktim.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:../src/Common Demo Tasks/blocktim.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:../src/Common Demo Tasks/blocktim.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:../src/Common Demo Tasks/blocktim.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:../src/Common Demo Tasks/blocktim.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:../src/Common Demo Tasks/blocktim.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:../src/Common Demo Tasks/blocktim.c ****     more details. You should have received a copy of the GNU General Public
  37:../src/Common Demo Tasks/blocktim.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:../src/Common Demo Tasks/blocktim.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:../src/Common Demo Tasks/blocktim.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:../src/Common Demo Tasks/blocktim.c ****     FreeRTOS WEB site.
  41:../src/Common Demo Tasks/blocktim.c **** 
  42:../src/Common Demo Tasks/blocktim.c ****     1 tab == 4 spaces!
  43:../src/Common Demo Tasks/blocktim.c **** 
  44:../src/Common Demo Tasks/blocktim.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:../src/Common Demo Tasks/blocktim.c ****     contact details.
  46:../src/Common Demo Tasks/blocktim.c **** 
  47:../src/Common Demo Tasks/blocktim.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:../src/Common Demo Tasks/blocktim.c ****     critical systems.
  49:../src/Common Demo Tasks/blocktim.c **** 
  50:../src/Common Demo Tasks/blocktim.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:../src/Common Demo Tasks/blocktim.c ****     licensing and training services.
  52:../src/Common Demo Tasks/blocktim.c **** */
  53:../src/Common Demo Tasks/blocktim.c **** 
  54:../src/Common Demo Tasks/blocktim.c **** /*
  55:../src/Common Demo Tasks/blocktim.c ****  * This file contains some test scenarios that ensure tasks do not exit queue
  56:../src/Common Demo Tasks/blocktim.c ****  * send or receive functions prematurely.  A description of the tests is
  57:../src/Common Demo Tasks/blocktim.c ****  * included within the code.
  58:../src/Common Demo Tasks/blocktim.c ****  */
  59:../src/Common Demo Tasks/blocktim.c **** 
  60:../src/Common Demo Tasks/blocktim.c **** /* Kernel includes. */
  61:../src/Common Demo Tasks/blocktim.c **** #include "FreeRTOS.h"
  62:../src/Common Demo Tasks/blocktim.c **** #include "task.h"
  63:../src/Common Demo Tasks/blocktim.c **** #include "queue.h"
  64:../src/Common Demo Tasks/blocktim.c **** 
  65:../src/Common Demo Tasks/blocktim.c **** /* Demo includes. */
  66:../src/Common Demo Tasks/blocktim.c **** #include "blocktim.h"
  67:../src/Common Demo Tasks/blocktim.c **** 
  68:../src/Common Demo Tasks/blocktim.c **** /* Task priorities.  Allow these to be overridden. */
  69:../src/Common Demo Tasks/blocktim.c **** #ifndef bktPRIMARY_PRIORITY
  70:../src/Common Demo Tasks/blocktim.c **** 	#define bktPRIMARY_PRIORITY		( configMAX_PRIORITIES - 3 )
  71:../src/Common Demo Tasks/blocktim.c **** #endif
  72:../src/Common Demo Tasks/blocktim.c **** 
  73:../src/Common Demo Tasks/blocktim.c **** #ifndef bktSECONDARY_PRIORITY
  74:../src/Common Demo Tasks/blocktim.c **** 	#define bktSECONDARY_PRIORITY	( configMAX_PRIORITIES - 4 )
  75:../src/Common Demo Tasks/blocktim.c **** #endif
  76:../src/Common Demo Tasks/blocktim.c **** 
  77:../src/Common Demo Tasks/blocktim.c **** /* Task behaviour. */
  78:../src/Common Demo Tasks/blocktim.c **** #define bktQUEUE_LENGTH				( 5 )
  79:../src/Common Demo Tasks/blocktim.c **** #define bktSHORT_WAIT				( ( ( portTickType ) 20 ) / portTICK_RATE_MS )
  80:../src/Common Demo Tasks/blocktim.c **** #define bktPRIMARY_BLOCK_TIME		( 10 )
  81:../src/Common Demo Tasks/blocktim.c **** #define bktALLOWABLE_MARGIN			( 15 )
  82:../src/Common Demo Tasks/blocktim.c **** #define bktTIME_TO_BLOCK			( 175 )
  83:../src/Common Demo Tasks/blocktim.c **** #define bktDONT_BLOCK				( ( portTickType ) 0 )
  84:../src/Common Demo Tasks/blocktim.c **** #define bktRUN_INDICATOR			( ( unsigned portBASE_TYPE ) 0x55 )
  85:../src/Common Demo Tasks/blocktim.c **** 
  86:../src/Common Demo Tasks/blocktim.c **** /* The queue on which the tasks block. */
  87:../src/Common Demo Tasks/blocktim.c **** static xQueueHandle xTestQueue;
  88:../src/Common Demo Tasks/blocktim.c **** 
  89:../src/Common Demo Tasks/blocktim.c **** /* Handle to the secondary task is required by the primary task for calls
  90:../src/Common Demo Tasks/blocktim.c **** to vTaskSuspend/Resume(). */
  91:../src/Common Demo Tasks/blocktim.c **** static xTaskHandle xSecondary;
  92:../src/Common Demo Tasks/blocktim.c **** 
  93:../src/Common Demo Tasks/blocktim.c **** /* Used to ensure that tasks are still executing without error. */
  94:../src/Common Demo Tasks/blocktim.c **** static volatile portBASE_TYPE xPrimaryCycles = 0, xSecondaryCycles = 0;
  95:../src/Common Demo Tasks/blocktim.c **** static volatile portBASE_TYPE xErrorOccurred = pdFALSE;
  96:../src/Common Demo Tasks/blocktim.c **** 
  97:../src/Common Demo Tasks/blocktim.c **** /* Provides a simple mechanism for the primary task to know when the
  98:../src/Common Demo Tasks/blocktim.c **** secondary task has executed. */
  99:../src/Common Demo Tasks/blocktim.c **** static volatile unsigned portBASE_TYPE xRunIndicator;
 100:../src/Common Demo Tasks/blocktim.c **** 
 101:../src/Common Demo Tasks/blocktim.c **** /* The two test tasks.  Their behaviour is commented within the files. */
 102:../src/Common Demo Tasks/blocktim.c **** static void vPrimaryBlockTimeTestTask( void *pvParameters );
 103:../src/Common Demo Tasks/blocktim.c **** static void vSecondaryBlockTimeTestTask( void *pvParameters );
 104:../src/Common Demo Tasks/blocktim.c **** 
 105:../src/Common Demo Tasks/blocktim.c **** /*-----------------------------------------------------------*/
 106:../src/Common Demo Tasks/blocktim.c **** 
 107:../src/Common Demo Tasks/blocktim.c **** void vCreateBlockTimeTasks( void )
 108:../src/Common Demo Tasks/blocktim.c **** {
 3492              		.loc 1 108 0
 3493              		.cfi_startproc
 3494              		@ args = 0, pretend = 0, frame = 0
 3495              		@ frame_needed = 1, uses_anonymous_args = 0
 3496 0000 80B5     		push	{r7, lr}
 3497              	.LCFI0:
 3498              		.cfi_def_cfa_offset 8
 3499 0002 84B0     		sub	sp, sp, #16
 3500              	.LCFI1:
 3501              		.cfi_def_cfa_offset 24
 3502 0004 04AF     		add	r7, sp, #16
 3503              		.cfi_offset 14, -4
 3504              		.cfi_offset 7, -8
 3505              	.LCFI2:
 3506              		.cfi_def_cfa 7, 8
 109:../src/Common Demo Tasks/blocktim.c **** 	/* Create the queue on which the two tasks block. */
 110:../src/Common Demo Tasks/blocktim.c ****     xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
 3507              		.loc 1 110 0
 3508 0006 4FF00500 		mov	r0, #5
 3509 000a 4FF00401 		mov	r1, #4
 3510 000e 4FF00002 		mov	r2, #0
 3511 0012 FFF7FEFF 		bl	xQueueGenericCreate
 3512 0016 0246     		mov	r2, r0
 3513 0018 194B     		ldr	r3, .L2
 3514 001a 1A60     		str	r2, [r3, #0]
 111:../src/Common Demo Tasks/blocktim.c **** 
 112:../src/Common Demo Tasks/blocktim.c **** 	/* vQueueAddToRegistry() adds the queue to the queue registry, if one is
 113:../src/Common Demo Tasks/blocktim.c **** 	in use.  The queue registry is provided as a means for kernel aware
 114:../src/Common Demo Tasks/blocktim.c **** 	debuggers to locate queues and has no purpose if a kernel aware debugger
 115:../src/Common Demo Tasks/blocktim.c **** 	is not being used.  The call to vQueueAddToRegistry() will be removed
 116:../src/Common Demo Tasks/blocktim.c **** 	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
 117:../src/Common Demo Tasks/blocktim.c **** 	defined to be less than 1. */
 118:../src/Common Demo Tasks/blocktim.c **** 	vQueueAddToRegistry( xTestQueue, ( signed char * ) "Block_Time_Queue" );
 3515              		.loc 1 118 0
 3516 001c 184B     		ldr	r3, .L2
 3517 001e 1A68     		ldr	r2, [r3, #0]
 3518 0020 184B     		ldr	r3, .L2+4
 3519 0022 1046     		mov	r0, r2
 3520 0024 1946     		mov	r1, r3
 3521 0026 FFF7FEFF 		bl	vQueueAddToRegistry
 119:../src/Common Demo Tasks/blocktim.c **** 
 120:../src/Common Demo Tasks/blocktim.c **** 	/* Create the two test tasks. */
 121:../src/Common Demo Tasks/blocktim.c **** 	xTaskCreate( vPrimaryBlockTimeTestTask, ( signed char * )"BTest1", configMINIMAL_STACK_SIZE, NULL,
 3522              		.loc 1 121 0
 3523 002a 174B     		ldr	r3, .L2+8
 3524 002c 4FF00202 		mov	r2, #2
 3525 0030 0092     		str	r2, [sp, #0]
 3526 0032 4FF00002 		mov	r2, #0
 3527 0036 0192     		str	r2, [sp, #4]
 3528 0038 4FF00002 		mov	r2, #0
 3529 003c 0292     		str	r2, [sp, #8]
 3530 003e 4FF00002 		mov	r2, #0
 3531 0042 0392     		str	r2, [sp, #12]
 3532 0044 1148     		ldr	r0, .L2+12
 3533 0046 1946     		mov	r1, r3
 3534 0048 4FF05002 		mov	r2, #80
 3535 004c 4FF00003 		mov	r3, #0
 3536 0050 FFF7FEFF 		bl	xTaskGenericCreate
 122:../src/Common Demo Tasks/blocktim.c **** 	xTaskCreate( vSecondaryBlockTimeTestTask, ( signed char * )"BTest2", configMINIMAL_STACK_SIZE, NUL
 3537              		.loc 1 122 0
 3538 0054 0E4B     		ldr	r3, .L2+16
 3539 0056 4FF00102 		mov	r2, #1
 3540 005a 0092     		str	r2, [sp, #0]
 3541 005c 0D4A     		ldr	r2, .L2+20
 3542 005e 0192     		str	r2, [sp, #4]
 3543 0060 4FF00002 		mov	r2, #0
 3544 0064 0292     		str	r2, [sp, #8]
 3545 0066 4FF00002 		mov	r2, #0
 3546 006a 0392     		str	r2, [sp, #12]
 3547 006c 0A48     		ldr	r0, .L2+24
 3548 006e 1946     		mov	r1, r3
 3549 0070 4FF05002 		mov	r2, #80
 3550 0074 4FF00003 		mov	r3, #0
 3551 0078 FFF7FEFF 		bl	xTaskGenericCreate
 123:../src/Common Demo Tasks/blocktim.c **** }
 3552              		.loc 1 123 0
 3553 007c BD46     		mov	sp, r7
 3554 007e 80BD     		pop	{r7, pc}
 3555              	.L3:
 3556              		.align	2
 3557              	.L2:
 3558 0080 00000000 		.word	xTestQueue
 3559 0084 00000000 		.word	.LC0
 3560 0088 14000000 		.word	.LC1
 3561 008c 00000000 		.word	vPrimaryBlockTimeTestTask
 3562 0090 1C000000 		.word	.LC2
 3563 0094 04000000 		.word	xSecondary
 3564 0098 00000000 		.word	vSecondaryBlockTimeTestTask
 3565              		.cfi_endproc
 3566              	.LFE29:
 3568              		.align	2
 3569              		.thumb
 3570              		.thumb_func
 3572              	vPrimaryBlockTimeTestTask:
 3573              	.LFB30:
 124:../src/Common Demo Tasks/blocktim.c **** /*-----------------------------------------------------------*/
 125:../src/Common Demo Tasks/blocktim.c **** 
 126:../src/Common Demo Tasks/blocktim.c **** static void vPrimaryBlockTimeTestTask( void *pvParameters )
 127:../src/Common Demo Tasks/blocktim.c **** {
 3574              		.loc 1 127 0
 3575              		.cfi_startproc
 3576              		@ args = 0, pretend = 0, frame = 32
 3577              		@ frame_needed = 1, uses_anonymous_args = 0
 3578 009c 80B5     		push	{r7, lr}
 3579              	.LCFI3:
 3580              		.cfi_def_cfa_offset 8
 3581 009e 88B0     		sub	sp, sp, #32
 3582              	.LCFI4:
 3583              		.cfi_def_cfa_offset 40
 3584 00a0 00AF     		add	r7, sp, #0
 3585              		.cfi_offset 14, -4
 3586              		.cfi_offset 7, -8
 3587              	.LCFI5:
 3588              		.cfi_def_cfa_register 7
 3589 00a2 7860     		str	r0, [r7, #4]
 3590              	.L41:
 128:../src/Common Demo Tasks/blocktim.c **** portBASE_TYPE xItem, xData;
 129:../src/Common Demo Tasks/blocktim.c **** portTickType xTimeWhenBlocking;
 130:../src/Common Demo Tasks/blocktim.c **** portTickType xTimeToBlock, xBlockedTime;
 131:../src/Common Demo Tasks/blocktim.c **** 
 132:../src/Common Demo Tasks/blocktim.c **** 	( void ) pvParameters;
 133:../src/Common Demo Tasks/blocktim.c **** 
 134:../src/Common Demo Tasks/blocktim.c **** 	for( ;; )
 135:../src/Common Demo Tasks/blocktim.c **** 	{
 136:../src/Common Demo Tasks/blocktim.c **** 		/*********************************************************************
 137:../src/Common Demo Tasks/blocktim.c ****         Test 1
 138:../src/Common Demo Tasks/blocktim.c **** 
 139:../src/Common Demo Tasks/blocktim.c ****         Simple block time wakeup test on queue receives. */
 140:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3591              		.loc 1 140 0
 3592 00a4 4FF00003 		mov	r3, #0
 3593 00a8 3B61     		str	r3, [r7, #16]
 3594 00aa 36E0     		b	.L5
 3595              	.L9:
 141:../src/Common Demo Tasks/blocktim.c **** 		{
 142:../src/Common Demo Tasks/blocktim.c **** 			/* The queue is empty. Attempt to read from the queue using a block
 143:../src/Common Demo Tasks/blocktim.c **** 			time.  When we wake, ensure the delta in time is as expected. */
 144:../src/Common Demo Tasks/blocktim.c **** 			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
 3596              		.loc 1 144 0
 3597 00ac 3B69     		ldr	r3, [r7, #16]
 3598 00ae 4FF00A02 		mov	r2, #10
 3599 00b2 02FA03F3 		lsl	r3, r2, r3
 3600 00b6 FB61     		str	r3, [r7, #28]
 145:../src/Common Demo Tasks/blocktim.c **** 
 146:../src/Common Demo Tasks/blocktim.c **** 			xTimeWhenBlocking = xTaskGetTickCount();
 3601              		.loc 1 146 0
 3602 00b8 FFF7FEFF 		bl	xTaskGetTickCount
 3603 00bc B861     		str	r0, [r7, #24]
 147:../src/Common Demo Tasks/blocktim.c **** 
 148:../src/Common Demo Tasks/blocktim.c **** 			/* We should unblock after xTimeToBlock having not received
 149:../src/Common Demo Tasks/blocktim.c **** 			anything on the queue. */
 150:../src/Common Demo Tasks/blocktim.c **** 			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
 3604              		.loc 1 150 0
 3605 00be 9F4B     		ldr	r3, .L42
 3606 00c0 1A68     		ldr	r2, [r3, #0]
 3607 00c2 07F10C03 		add	r3, r7, #12
 3608 00c6 1046     		mov	r0, r2
 3609 00c8 1946     		mov	r1, r3
 3610 00ca FA69     		ldr	r2, [r7, #28]
 3611 00cc 4FF00003 		mov	r3, #0
 3612 00d0 FFF7FEFF 		bl	xQueueGenericReceive
 3613 00d4 0346     		mov	r3, r0
 3614 00d6 002B     		cmp	r3, #0
 3615 00d8 03D0     		beq	.L6
 151:../src/Common Demo Tasks/blocktim.c **** 			{
 152:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3616              		.loc 1 152 0
 3617 00da 994B     		ldr	r3, .L42+4
 3618 00dc 4FF00102 		mov	r2, #1
 3619 00e0 1A60     		str	r2, [r3, #0]
 3620              	.L6:
 153:../src/Common Demo Tasks/blocktim.c **** 			}
 154:../src/Common Demo Tasks/blocktim.c **** 
 155:../src/Common Demo Tasks/blocktim.c **** 			/* How long were we blocked for? */
 156:../src/Common Demo Tasks/blocktim.c **** 			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 3621              		.loc 1 156 0
 3622 00e2 FFF7FEFF 		bl	xTaskGetTickCount
 3623 00e6 0246     		mov	r2, r0
 3624 00e8 BB69     		ldr	r3, [r7, #24]
 3625 00ea D31A     		subs	r3, r2, r3
 3626 00ec 7B61     		str	r3, [r7, #20]
 157:../src/Common Demo Tasks/blocktim.c **** 
 158:../src/Common Demo Tasks/blocktim.c **** 			if( xBlockedTime < xTimeToBlock )
 3627              		.loc 1 158 0
 3628 00ee 7A69     		ldr	r2, [r7, #20]
 3629 00f0 FB69     		ldr	r3, [r7, #28]
 3630 00f2 9A42     		cmp	r2, r3
 3631 00f4 03D2     		bcs	.L7
 159:../src/Common Demo Tasks/blocktim.c **** 			{
 160:../src/Common Demo Tasks/blocktim.c **** 				/* Should not have blocked for less than we requested. */
 161:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3632              		.loc 1 161 0
 3633 00f6 924B     		ldr	r3, .L42+4
 3634 00f8 4FF00102 		mov	r2, #1
 3635 00fc 1A60     		str	r2, [r3, #0]
 3636              	.L7:
 162:../src/Common Demo Tasks/blocktim.c **** 			}
 163:../src/Common Demo Tasks/blocktim.c **** 
 164:../src/Common Demo Tasks/blocktim.c **** 			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 3637              		.loc 1 164 0
 3638 00fe FB69     		ldr	r3, [r7, #28]
 3639 0100 03F10F02 		add	r2, r3, #15
 3640 0104 7B69     		ldr	r3, [r7, #20]
 3641 0106 9A42     		cmp	r2, r3
 3642 0108 03D2     		bcs	.L8
 165:../src/Common Demo Tasks/blocktim.c **** 			{
 166:../src/Common Demo Tasks/blocktim.c **** 				/* Should not have blocked for longer than we requested,
 167:../src/Common Demo Tasks/blocktim.c **** 				although we would not necessarily run as soon as we were
 168:../src/Common Demo Tasks/blocktim.c **** 				unblocked so a margin is allowed. */
 169:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3643              		.loc 1 169 0
 3644 010a 8D4B     		ldr	r3, .L42+4
 3645 010c 4FF00102 		mov	r2, #1
 3646 0110 1A60     		str	r2, [r3, #0]
 3647              	.L8:
 140:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3648              		.loc 1 140 0
 3649 0112 3B69     		ldr	r3, [r7, #16]
 3650 0114 03F10103 		add	r3, r3, #1
 3651 0118 3B61     		str	r3, [r7, #16]
 3652              	.L5:
 140:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3653              		.loc 1 140 0 is_stmt 0 discriminator 1
 3654 011a 3B69     		ldr	r3, [r7, #16]
 3655 011c 042B     		cmp	r3, #4
 3656 011e C5DD     		ble	.L9
 170:../src/Common Demo Tasks/blocktim.c **** 			}
 171:../src/Common Demo Tasks/blocktim.c **** 		}
 172:../src/Common Demo Tasks/blocktim.c **** 
 173:../src/Common Demo Tasks/blocktim.c **** 		/*********************************************************************
 174:../src/Common Demo Tasks/blocktim.c ****         Test 2
 175:../src/Common Demo Tasks/blocktim.c **** 
 176:../src/Common Demo Tasks/blocktim.c ****         Simple block time wakeup test on queue sends.
 177:../src/Common Demo Tasks/blocktim.c **** 
 178:../src/Common Demo Tasks/blocktim.c **** 		First fill the queue.  It should be empty so all sends should pass. */
 179:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3657              		.loc 1 179 0 is_stmt 1
 3658 0120 4FF00003 		mov	r3, #0
 3659 0124 3B61     		str	r3, [r7, #16]
 3660 0126 16E0     		b	.L10
 3661              	.L12:
 180:../src/Common Demo Tasks/blocktim.c **** 		{
 181:../src/Common Demo Tasks/blocktim.c **** 			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 3662              		.loc 1 181 0
 3663 0128 844B     		ldr	r3, .L42
 3664 012a 1A68     		ldr	r2, [r3, #0]
 3665 012c 07F11003 		add	r3, r7, #16
 3666 0130 1046     		mov	r0, r2
 3667 0132 1946     		mov	r1, r3
 3668 0134 4FF00002 		mov	r2, #0
 3669 0138 4FF00003 		mov	r3, #0
 3670 013c FFF7FEFF 		bl	xQueueGenericSend
 3671 0140 0346     		mov	r3, r0
 3672 0142 012B     		cmp	r3, #1
 3673 0144 03D0     		beq	.L11
 182:../src/Common Demo Tasks/blocktim.c **** 			{
 183:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3674              		.loc 1 183 0
 3675 0146 7E4B     		ldr	r3, .L42+4
 3676 0148 4FF00102 		mov	r2, #1
 3677 014c 1A60     		str	r2, [r3, #0]
 3678              	.L11:
 179:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3679              		.loc 1 179 0
 3680 014e 3B69     		ldr	r3, [r7, #16]
 3681 0150 03F10103 		add	r3, r3, #1
 3682 0154 3B61     		str	r3, [r7, #16]
 3683              	.L10:
 179:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3684              		.loc 1 179 0 is_stmt 0 discriminator 1
 3685 0156 3B69     		ldr	r3, [r7, #16]
 3686 0158 042B     		cmp	r3, #4
 3687 015a E5DD     		ble	.L12
 184:../src/Common Demo Tasks/blocktim.c **** 			}
 185:../src/Common Demo Tasks/blocktim.c **** 
 186:../src/Common Demo Tasks/blocktim.c **** 			#if configUSE_PREEMPTION == 0
 187:../src/Common Demo Tasks/blocktim.c **** 				taskYIELD();
 188:../src/Common Demo Tasks/blocktim.c **** 			#endif
 189:../src/Common Demo Tasks/blocktim.c **** 		}
 190:../src/Common Demo Tasks/blocktim.c **** 
 191:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3688              		.loc 1 191 0 is_stmt 1
 3689 015c 4FF00003 		mov	r3, #0
 3690 0160 3B61     		str	r3, [r7, #16]
 3691 0162 36E0     		b	.L13
 3692              	.L17:
 192:../src/Common Demo Tasks/blocktim.c **** 		{
 193:../src/Common Demo Tasks/blocktim.c **** 			/* The queue is full. Attempt to write to the queue using a block
 194:../src/Common Demo Tasks/blocktim.c **** 			time.  When we wake, ensure the delta in time is as expected. */
 195:../src/Common Demo Tasks/blocktim.c **** 			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
 3693              		.loc 1 195 0
 3694 0164 3B69     		ldr	r3, [r7, #16]
 3695 0166 4FF00A02 		mov	r2, #10
 3696 016a 02FA03F3 		lsl	r3, r2, r3
 3697 016e FB61     		str	r3, [r7, #28]
 196:../src/Common Demo Tasks/blocktim.c **** 
 197:../src/Common Demo Tasks/blocktim.c **** 			xTimeWhenBlocking = xTaskGetTickCount();
 3698              		.loc 1 197 0
 3699 0170 FFF7FEFF 		bl	xTaskGetTickCount
 3700 0174 B861     		str	r0, [r7, #24]
 198:../src/Common Demo Tasks/blocktim.c **** 
 199:../src/Common Demo Tasks/blocktim.c **** 			/* We should unblock after xTimeToBlock having not received
 200:../src/Common Demo Tasks/blocktim.c **** 			anything on the queue. */
 201:../src/Common Demo Tasks/blocktim.c **** 			if( xQueueSend( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
 3701              		.loc 1 201 0
 3702 0176 714B     		ldr	r3, .L42
 3703 0178 1A68     		ldr	r2, [r3, #0]
 3704 017a 07F11003 		add	r3, r7, #16
 3705 017e 1046     		mov	r0, r2
 3706 0180 1946     		mov	r1, r3
 3707 0182 FA69     		ldr	r2, [r7, #28]
 3708 0184 4FF00003 		mov	r3, #0
 3709 0188 FFF7FEFF 		bl	xQueueGenericSend
 3710 018c 0346     		mov	r3, r0
 3711 018e 002B     		cmp	r3, #0
 3712 0190 03D0     		beq	.L14
 202:../src/Common Demo Tasks/blocktim.c **** 			{
 203:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3713              		.loc 1 203 0
 3714 0192 6B4B     		ldr	r3, .L42+4
 3715 0194 4FF00102 		mov	r2, #1
 3716 0198 1A60     		str	r2, [r3, #0]
 3717              	.L14:
 204:../src/Common Demo Tasks/blocktim.c **** 			}
 205:../src/Common Demo Tasks/blocktim.c **** 
 206:../src/Common Demo Tasks/blocktim.c **** 			/* How long were we blocked for? */
 207:../src/Common Demo Tasks/blocktim.c **** 			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 3718              		.loc 1 207 0
 3719 019a FFF7FEFF 		bl	xTaskGetTickCount
 3720 019e 0246     		mov	r2, r0
 3721 01a0 BB69     		ldr	r3, [r7, #24]
 3722 01a2 D31A     		subs	r3, r2, r3
 3723 01a4 7B61     		str	r3, [r7, #20]
 208:../src/Common Demo Tasks/blocktim.c **** 
 209:../src/Common Demo Tasks/blocktim.c **** 			if( xBlockedTime < xTimeToBlock )
 3724              		.loc 1 209 0
 3725 01a6 7A69     		ldr	r2, [r7, #20]
 3726 01a8 FB69     		ldr	r3, [r7, #28]
 3727 01aa 9A42     		cmp	r2, r3
 3728 01ac 03D2     		bcs	.L15
 210:../src/Common Demo Tasks/blocktim.c **** 			{
 211:../src/Common Demo Tasks/blocktim.c **** 				/* Should not have blocked for less than we requested. */
 212:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3729              		.loc 1 212 0
 3730 01ae 644B     		ldr	r3, .L42+4
 3731 01b0 4FF00102 		mov	r2, #1
 3732 01b4 1A60     		str	r2, [r3, #0]
 3733              	.L15:
 213:../src/Common Demo Tasks/blocktim.c **** 			}
 214:../src/Common Demo Tasks/blocktim.c **** 
 215:../src/Common Demo Tasks/blocktim.c **** 			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 3734              		.loc 1 215 0
 3735 01b6 FB69     		ldr	r3, [r7, #28]
 3736 01b8 03F10F02 		add	r2, r3, #15
 3737 01bc 7B69     		ldr	r3, [r7, #20]
 3738 01be 9A42     		cmp	r2, r3
 3739 01c0 03D2     		bcs	.L16
 216:../src/Common Demo Tasks/blocktim.c **** 			{
 217:../src/Common Demo Tasks/blocktim.c **** 				/* Should not have blocked for longer than we requested,
 218:../src/Common Demo Tasks/blocktim.c **** 				although we would not necessarily run as soon as we were
 219:../src/Common Demo Tasks/blocktim.c **** 				unblocked so a margin is allowed. */
 220:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3740              		.loc 1 220 0
 3741 01c2 5F4B     		ldr	r3, .L42+4
 3742 01c4 4FF00102 		mov	r2, #1
 3743 01c8 1A60     		str	r2, [r3, #0]
 3744              	.L16:
 191:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3745              		.loc 1 191 0
 3746 01ca 3B69     		ldr	r3, [r7, #16]
 3747 01cc 03F10103 		add	r3, r3, #1
 3748 01d0 3B61     		str	r3, [r7, #16]
 3749              	.L13:
 191:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3750              		.loc 1 191 0 is_stmt 0 discriminator 1
 3751 01d2 3B69     		ldr	r3, [r7, #16]
 3752 01d4 042B     		cmp	r3, #4
 3753 01d6 C5DD     		ble	.L17
 221:../src/Common Demo Tasks/blocktim.c **** 			}
 222:../src/Common Demo Tasks/blocktim.c **** 		}
 223:../src/Common Demo Tasks/blocktim.c **** 
 224:../src/Common Demo Tasks/blocktim.c **** 		/*********************************************************************
 225:../src/Common Demo Tasks/blocktim.c ****         Test 3
 226:../src/Common Demo Tasks/blocktim.c **** 
 227:../src/Common Demo Tasks/blocktim.c **** 		Wake the other task, it will block attempting to post to the queue.
 228:../src/Common Demo Tasks/blocktim.c **** 		When we read from the queue the other task will wake, but before it
 229:../src/Common Demo Tasks/blocktim.c **** 		can run we will post to the queue again.  When the other task runs it
 230:../src/Common Demo Tasks/blocktim.c **** 		will find the queue still full, even though it was woken.  It should
 231:../src/Common Demo Tasks/blocktim.c **** 		recognise that its block time has not expired and return to block for
 232:../src/Common Demo Tasks/blocktim.c **** 		the remains of its block time.
 233:../src/Common Demo Tasks/blocktim.c **** 
 234:../src/Common Demo Tasks/blocktim.c **** 		Wake the other task so it blocks attempting to post to the already
 235:../src/Common Demo Tasks/blocktim.c **** 		full queue. */
 236:../src/Common Demo Tasks/blocktim.c **** 		xRunIndicator = 0;
 3754              		.loc 1 236 0 is_stmt 1
 3755 01d8 5A4B     		ldr	r3, .L42+8
 3756 01da 4FF00002 		mov	r2, #0
 3757 01de 1A60     		str	r2, [r3, #0]
 237:../src/Common Demo Tasks/blocktim.c **** 		vTaskResume( xSecondary );
 3758              		.loc 1 237 0
 3759 01e0 594B     		ldr	r3, .L42+12
 3760 01e2 1B68     		ldr	r3, [r3, #0]
 3761 01e4 1846     		mov	r0, r3
 3762 01e6 FFF7FEFF 		bl	vTaskResume
 238:../src/Common Demo Tasks/blocktim.c **** 
 239:../src/Common Demo Tasks/blocktim.c **** 		/* We need to wait a little to ensure the other task executes. */
 240:../src/Common Demo Tasks/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 3763              		.loc 1 240 0
 3764 01ea 03E0     		b	.L18
 3765              	.L19:
 241:../src/Common Demo Tasks/blocktim.c **** 		{
 242:../src/Common Demo Tasks/blocktim.c **** 			/* The other task has not yet executed. */
 243:../src/Common Demo Tasks/blocktim.c **** 			vTaskDelay( bktSHORT_WAIT );
 3766              		.loc 1 243 0
 3767 01ec 4FF01400 		mov	r0, #20
 3768 01f0 FFF7FEFF 		bl	vTaskDelay
 3769              	.L18:
 240:../src/Common Demo Tasks/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 3770              		.loc 1 240 0 discriminator 1
 3771 01f4 534B     		ldr	r3, .L42+8
 3772 01f6 1B68     		ldr	r3, [r3, #0]
 3773 01f8 552B     		cmp	r3, #85
 3774 01fa F7D1     		bne	.L19
 244:../src/Common Demo Tasks/blocktim.c **** 		}
 245:../src/Common Demo Tasks/blocktim.c **** 		/* Make sure the other task is blocked on the queue. */
 246:../src/Common Demo Tasks/blocktim.c **** 		vTaskDelay( bktSHORT_WAIT );
 3775              		.loc 1 246 0
 3776 01fc 4FF01400 		mov	r0, #20
 3777 0200 FFF7FEFF 		bl	vTaskDelay
 247:../src/Common Demo Tasks/blocktim.c **** 		xRunIndicator = 0;
 3778              		.loc 1 247 0
 3779 0204 4F4B     		ldr	r3, .L42+8
 3780 0206 4FF00002 		mov	r2, #0
 3781 020a 1A60     		str	r2, [r3, #0]
 248:../src/Common Demo Tasks/blocktim.c **** 
 249:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3782              		.loc 1 249 0
 3783 020c 4FF00003 		mov	r3, #0
 3784 0210 3B61     		str	r3, [r7, #16]
 3785 0212 47E0     		b	.L20
 3786              	.L25:
 250:../src/Common Demo Tasks/blocktim.c **** 		{
 251:../src/Common Demo Tasks/blocktim.c **** 			/* Now when we make space on the queue the other task should wake
 252:../src/Common Demo Tasks/blocktim.c **** 			but not execute as this task has higher priority. */
 253:../src/Common Demo Tasks/blocktim.c **** 			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 3787              		.loc 1 253 0
 3788 0214 494B     		ldr	r3, .L42
 3789 0216 1A68     		ldr	r2, [r3, #0]
 3790 0218 07F10C03 		add	r3, r7, #12
 3791 021c 1046     		mov	r0, r2
 3792 021e 1946     		mov	r1, r3
 3793 0220 4FF00002 		mov	r2, #0
 3794 0224 4FF00003 		mov	r3, #0
 3795 0228 FFF7FEFF 		bl	xQueueGenericReceive
 3796 022c 0346     		mov	r3, r0
 3797 022e 012B     		cmp	r3, #1
 3798 0230 03D0     		beq	.L21
 254:../src/Common Demo Tasks/blocktim.c **** 			{
 255:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3799              		.loc 1 255 0
 3800 0232 434B     		ldr	r3, .L42+4
 3801 0234 4FF00102 		mov	r2, #1
 3802 0238 1A60     		str	r2, [r3, #0]
 3803              	.L21:
 256:../src/Common Demo Tasks/blocktim.c **** 			}
 257:../src/Common Demo Tasks/blocktim.c **** 
 258:../src/Common Demo Tasks/blocktim.c **** 			/* Now fill the queue again before the other task gets a chance to
 259:../src/Common Demo Tasks/blocktim.c **** 			execute.  If the other task had executed we would find the queue
 260:../src/Common Demo Tasks/blocktim.c **** 			full ourselves, and the other task have set xRunIndicator. */
 261:../src/Common Demo Tasks/blocktim.c **** 			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 3804              		.loc 1 261 0
 3805 023a 404B     		ldr	r3, .L42
 3806 023c 1A68     		ldr	r2, [r3, #0]
 3807 023e 07F11003 		add	r3, r7, #16
 3808 0242 1046     		mov	r0, r2
 3809 0244 1946     		mov	r1, r3
 3810 0246 4FF00002 		mov	r2, #0
 3811 024a 4FF00003 		mov	r3, #0
 3812 024e FFF7FEFF 		bl	xQueueGenericSend
 3813 0252 0346     		mov	r3, r0
 3814 0254 012B     		cmp	r3, #1
 3815 0256 03D0     		beq	.L22
 262:../src/Common Demo Tasks/blocktim.c **** 			{
 263:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3816              		.loc 1 263 0
 3817 0258 394B     		ldr	r3, .L42+4
 3818 025a 4FF00102 		mov	r2, #1
 3819 025e 1A60     		str	r2, [r3, #0]
 3820              	.L22:
 264:../src/Common Demo Tasks/blocktim.c **** 			}
 265:../src/Common Demo Tasks/blocktim.c **** 
 266:../src/Common Demo Tasks/blocktim.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 3821              		.loc 1 266 0
 3822 0260 384B     		ldr	r3, .L42+8
 3823 0262 1B68     		ldr	r3, [r3, #0]
 3824 0264 552B     		cmp	r3, #85
 3825 0266 03D1     		bne	.L23
 267:../src/Common Demo Tasks/blocktim.c **** 			{
 268:../src/Common Demo Tasks/blocktim.c **** 				/* The other task should not have executed. */
 269:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3826              		.loc 1 269 0
 3827 0268 354B     		ldr	r3, .L42+4
 3828 026a 4FF00102 		mov	r2, #1
 3829 026e 1A60     		str	r2, [r3, #0]
 3830              	.L23:
 270:../src/Common Demo Tasks/blocktim.c **** 			}
 271:../src/Common Demo Tasks/blocktim.c **** 
 272:../src/Common Demo Tasks/blocktim.c **** 			/* Raise the priority of the other task so it executes and blocks
 273:../src/Common Demo Tasks/blocktim.c **** 			on the queue again. */
 274:../src/Common Demo Tasks/blocktim.c **** 			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 3831              		.loc 1 274 0
 3832 0270 354B     		ldr	r3, .L42+12
 3833 0272 1B68     		ldr	r3, [r3, #0]
 3834 0274 1846     		mov	r0, r3
 3835 0276 4FF00401 		mov	r1, #4
 3836 027a FFF7FEFF 		bl	vTaskPrioritySet
 275:../src/Common Demo Tasks/blocktim.c **** 
 276:../src/Common Demo Tasks/blocktim.c **** 			/* The other task should now have re-blocked without exiting the
 277:../src/Common Demo Tasks/blocktim.c **** 			queue function. */
 278:../src/Common Demo Tasks/blocktim.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 3837              		.loc 1 278 0
 3838 027e 314B     		ldr	r3, .L42+8
 3839 0280 1B68     		ldr	r3, [r3, #0]
 3840 0282 552B     		cmp	r3, #85
 3841 0284 03D1     		bne	.L24
 279:../src/Common Demo Tasks/blocktim.c **** 			{
 280:../src/Common Demo Tasks/blocktim.c **** 				/* The other task should not have executed outside of the
 281:../src/Common Demo Tasks/blocktim.c **** 				queue function. */
 282:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3842              		.loc 1 282 0
 3843 0286 2E4B     		ldr	r3, .L42+4
 3844 0288 4FF00102 		mov	r2, #1
 3845 028c 1A60     		str	r2, [r3, #0]
 3846              	.L24:
 283:../src/Common Demo Tasks/blocktim.c **** 			}
 284:../src/Common Demo Tasks/blocktim.c **** 
 285:../src/Common Demo Tasks/blocktim.c **** 			/* Set the priority back down. */
 286:../src/Common Demo Tasks/blocktim.c **** 			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
 3847              		.loc 1 286 0
 3848 028e 2E4B     		ldr	r3, .L42+12
 3849 0290 1B68     		ldr	r3, [r3, #0]
 3850 0292 1846     		mov	r0, r3
 3851 0294 4FF00101 		mov	r1, #1
 3852 0298 FFF7FEFF 		bl	vTaskPrioritySet
 249:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3853              		.loc 1 249 0
 3854 029c 3B69     		ldr	r3, [r7, #16]
 3855 029e 03F10103 		add	r3, r3, #1
 3856 02a2 3B61     		str	r3, [r7, #16]
 3857              	.L20:
 249:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3858              		.loc 1 249 0 is_stmt 0 discriminator 1
 3859 02a4 3B69     		ldr	r3, [r7, #16]
 3860 02a6 042B     		cmp	r3, #4
 3861 02a8 B4DD     		ble	.L25
 287:../src/Common Demo Tasks/blocktim.c **** 		}
 288:../src/Common Demo Tasks/blocktim.c **** 
 289:../src/Common Demo Tasks/blocktim.c **** 		/* Let the other task timeout.  When it unblockes it will check that it
 290:../src/Common Demo Tasks/blocktim.c **** 		unblocked at the correct time, then suspend itself. */
 291:../src/Common Demo Tasks/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 3862              		.loc 1 291 0 is_stmt 1
 3863 02aa 03E0     		b	.L26
 3864              	.L27:
 292:../src/Common Demo Tasks/blocktim.c **** 		{
 293:../src/Common Demo Tasks/blocktim.c **** 			vTaskDelay( bktSHORT_WAIT );
 3865              		.loc 1 293 0
 3866 02ac 4FF01400 		mov	r0, #20
 3867 02b0 FFF7FEFF 		bl	vTaskDelay
 3868              	.L26:
 291:../src/Common Demo Tasks/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 3869              		.loc 1 291 0 discriminator 1
 3870 02b4 234B     		ldr	r3, .L42+8
 3871 02b6 1B68     		ldr	r3, [r3, #0]
 3872 02b8 552B     		cmp	r3, #85
 3873 02ba F7D1     		bne	.L27
 294:../src/Common Demo Tasks/blocktim.c **** 		}
 295:../src/Common Demo Tasks/blocktim.c **** 		vTaskDelay( bktSHORT_WAIT );
 3874              		.loc 1 295 0
 3875 02bc 4FF01400 		mov	r0, #20
 3876 02c0 FFF7FEFF 		bl	vTaskDelay
 296:../src/Common Demo Tasks/blocktim.c **** 		xRunIndicator = 0;
 3877              		.loc 1 296 0
 3878 02c4 1F4B     		ldr	r3, .L42+8
 3879 02c6 4FF00002 		mov	r2, #0
 3880 02ca 1A60     		str	r2, [r3, #0]
 297:../src/Common Demo Tasks/blocktim.c **** 
 298:../src/Common Demo Tasks/blocktim.c **** 
 299:../src/Common Demo Tasks/blocktim.c **** 		/*********************************************************************
 300:../src/Common Demo Tasks/blocktim.c ****         Test 4
 301:../src/Common Demo Tasks/blocktim.c **** 
 302:../src/Common Demo Tasks/blocktim.c **** 		As per test 3 - but with the send and receive the other way around.
 303:../src/Common Demo Tasks/blocktim.c **** 		The other task blocks attempting to read from the queue.
 304:../src/Common Demo Tasks/blocktim.c **** 
 305:../src/Common Demo Tasks/blocktim.c **** 		Empty the queue.  We should find that it is full. */
 306:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3881              		.loc 1 306 0
 3882 02cc 4FF00003 		mov	r3, #0
 3883 02d0 3B61     		str	r3, [r7, #16]
 3884 02d2 16E0     		b	.L28
 3885              	.L30:
 307:../src/Common Demo Tasks/blocktim.c **** 		{
 308:../src/Common Demo Tasks/blocktim.c **** 			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 3886              		.loc 1 308 0
 3887 02d4 194B     		ldr	r3, .L42
 3888 02d6 1A68     		ldr	r2, [r3, #0]
 3889 02d8 07F10C03 		add	r3, r7, #12
 3890 02dc 1046     		mov	r0, r2
 3891 02de 1946     		mov	r1, r3
 3892 02e0 4FF00002 		mov	r2, #0
 3893 02e4 4FF00003 		mov	r3, #0
 3894 02e8 FFF7FEFF 		bl	xQueueGenericReceive
 3895 02ec 0346     		mov	r3, r0
 3896 02ee 012B     		cmp	r3, #1
 3897 02f0 03D0     		beq	.L29
 309:../src/Common Demo Tasks/blocktim.c **** 			{
 310:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3898              		.loc 1 310 0
 3899 02f2 134B     		ldr	r3, .L42+4
 3900 02f4 4FF00102 		mov	r2, #1
 3901 02f8 1A60     		str	r2, [r3, #0]
 3902              	.L29:
 306:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3903              		.loc 1 306 0
 3904 02fa 3B69     		ldr	r3, [r7, #16]
 3905 02fc 03F10103 		add	r3, r3, #1
 3906 0300 3B61     		str	r3, [r7, #16]
 3907              	.L28:
 306:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3908              		.loc 1 306 0 is_stmt 0 discriminator 1
 3909 0302 3B69     		ldr	r3, [r7, #16]
 3910 0304 042B     		cmp	r3, #4
 3911 0306 E5DD     		ble	.L30
 311:../src/Common Demo Tasks/blocktim.c **** 			}
 312:../src/Common Demo Tasks/blocktim.c **** 		}
 313:../src/Common Demo Tasks/blocktim.c **** 
 314:../src/Common Demo Tasks/blocktim.c **** 		/* Wake the other task so it blocks attempting to read from  the
 315:../src/Common Demo Tasks/blocktim.c **** 		already	empty queue. */
 316:../src/Common Demo Tasks/blocktim.c **** 		vTaskResume( xSecondary );
 3912              		.loc 1 316 0 is_stmt 1
 3913 0308 0F4B     		ldr	r3, .L42+12
 3914 030a 1B68     		ldr	r3, [r3, #0]
 3915 030c 1846     		mov	r0, r3
 3916 030e FFF7FEFF 		bl	vTaskResume
 317:../src/Common Demo Tasks/blocktim.c **** 
 318:../src/Common Demo Tasks/blocktim.c **** 		/* We need to wait a little to ensure the other task executes. */
 319:../src/Common Demo Tasks/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 3917              		.loc 1 319 0
 3918 0312 03E0     		b	.L31
 3919              	.L32:
 320:../src/Common Demo Tasks/blocktim.c **** 		{
 321:../src/Common Demo Tasks/blocktim.c **** 			vTaskDelay( bktSHORT_WAIT );
 3920              		.loc 1 321 0
 3921 0314 4FF01400 		mov	r0, #20
 3922 0318 FFF7FEFF 		bl	vTaskDelay
 3923              	.L31:
 319:../src/Common Demo Tasks/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 3924              		.loc 1 319 0 discriminator 1
 3925 031c 094B     		ldr	r3, .L42+8
 3926 031e 1B68     		ldr	r3, [r3, #0]
 3927 0320 552B     		cmp	r3, #85
 3928 0322 F7D1     		bne	.L32
 322:../src/Common Demo Tasks/blocktim.c **** 		}
 323:../src/Common Demo Tasks/blocktim.c **** 		vTaskDelay( bktSHORT_WAIT );
 3929              		.loc 1 323 0
 3930 0324 4FF01400 		mov	r0, #20
 3931 0328 FFF7FEFF 		bl	vTaskDelay
 324:../src/Common Demo Tasks/blocktim.c **** 		xRunIndicator = 0;
 3932              		.loc 1 324 0
 3933 032c 054B     		ldr	r3, .L42+8
 3934 032e 4FF00002 		mov	r2, #0
 3935 0332 1A60     		str	r2, [r3, #0]
 325:../src/Common Demo Tasks/blocktim.c **** 
 326:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 3936              		.loc 1 326 0
 3937 0334 4FF00003 		mov	r3, #0
 3938 0338 3B61     		str	r3, [r7, #16]
 3939 033a 4FE0     		b	.L33
 3940              	.L43:
 3941              		.align	2
 3942              	.L42:
 3943 033c 00000000 		.word	xTestQueue
 3944 0340 10000000 		.word	xErrorOccurred
 3945 0344 14000000 		.word	xRunIndicator
 3946 0348 04000000 		.word	xSecondary
 3947              	.L38:
 327:../src/Common Demo Tasks/blocktim.c **** 		{
 328:../src/Common Demo Tasks/blocktim.c **** 			/* Now when we place an item on the queue the other task should
 329:../src/Common Demo Tasks/blocktim.c **** 			wake but not execute as this task has higher priority. */
 330:../src/Common Demo Tasks/blocktim.c **** 			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 3948              		.loc 1 330 0
 3949 034c 2F4B     		ldr	r3, .L44
 3950 034e 1A68     		ldr	r2, [r3, #0]
 3951 0350 07F11003 		add	r3, r7, #16
 3952 0354 1046     		mov	r0, r2
 3953 0356 1946     		mov	r1, r3
 3954 0358 4FF00002 		mov	r2, #0
 3955 035c 4FF00003 		mov	r3, #0
 3956 0360 FFF7FEFF 		bl	xQueueGenericSend
 3957 0364 0346     		mov	r3, r0
 3958 0366 012B     		cmp	r3, #1
 3959 0368 03D0     		beq	.L34
 331:../src/Common Demo Tasks/blocktim.c **** 			{
 332:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3960              		.loc 1 332 0
 3961 036a 294B     		ldr	r3, .L44+4
 3962 036c 4FF00102 		mov	r2, #1
 3963 0370 1A60     		str	r2, [r3, #0]
 3964              	.L34:
 333:../src/Common Demo Tasks/blocktim.c **** 			}
 334:../src/Common Demo Tasks/blocktim.c **** 
 335:../src/Common Demo Tasks/blocktim.c **** 			/* Now empty the queue again before the other task gets a chance to
 336:../src/Common Demo Tasks/blocktim.c **** 			execute.  If the other task had executed we would find the queue
 337:../src/Common Demo Tasks/blocktim.c **** 			empty ourselves, and the other task would be suspended. */
 338:../src/Common Demo Tasks/blocktim.c **** 			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 3965              		.loc 1 338 0
 3966 0372 264B     		ldr	r3, .L44
 3967 0374 1A68     		ldr	r2, [r3, #0]
 3968 0376 07F10C03 		add	r3, r7, #12
 3969 037a 1046     		mov	r0, r2
 3970 037c 1946     		mov	r1, r3
 3971 037e 4FF00002 		mov	r2, #0
 3972 0382 4FF00003 		mov	r3, #0
 3973 0386 FFF7FEFF 		bl	xQueueGenericReceive
 3974 038a 0346     		mov	r3, r0
 3975 038c 012B     		cmp	r3, #1
 3976 038e 03D0     		beq	.L35
 339:../src/Common Demo Tasks/blocktim.c **** 			{
 340:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3977              		.loc 1 340 0
 3978 0390 1F4B     		ldr	r3, .L44+4
 3979 0392 4FF00102 		mov	r2, #1
 3980 0396 1A60     		str	r2, [r3, #0]
 3981              	.L35:
 341:../src/Common Demo Tasks/blocktim.c **** 			}
 342:../src/Common Demo Tasks/blocktim.c **** 
 343:../src/Common Demo Tasks/blocktim.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 3982              		.loc 1 343 0
 3983 0398 1E4B     		ldr	r3, .L44+8
 3984 039a 1B68     		ldr	r3, [r3, #0]
 3985 039c 552B     		cmp	r3, #85
 3986 039e 03D1     		bne	.L36
 344:../src/Common Demo Tasks/blocktim.c **** 			{
 345:../src/Common Demo Tasks/blocktim.c **** 				/* The other task should not have executed. */
 346:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 3987              		.loc 1 346 0
 3988 03a0 1B4B     		ldr	r3, .L44+4
 3989 03a2 4FF00102 		mov	r2, #1
 3990 03a6 1A60     		str	r2, [r3, #0]
 3991              	.L36:
 347:../src/Common Demo Tasks/blocktim.c **** 			}
 348:../src/Common Demo Tasks/blocktim.c **** 
 349:../src/Common Demo Tasks/blocktim.c **** 			/* Raise the priority of the other task so it executes and blocks
 350:../src/Common Demo Tasks/blocktim.c **** 			on the queue again. */
 351:../src/Common Demo Tasks/blocktim.c **** 			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 3992              		.loc 1 351 0
 3993 03a8 1B4B     		ldr	r3, .L44+12
 3994 03aa 1B68     		ldr	r3, [r3, #0]
 3995 03ac 1846     		mov	r0, r3
 3996 03ae 4FF00401 		mov	r1, #4
 3997 03b2 FFF7FEFF 		bl	vTaskPrioritySet
 352:../src/Common Demo Tasks/blocktim.c **** 
 353:../src/Common Demo Tasks/blocktim.c **** 			/* The other task should now have re-blocked without exiting the
 354:../src/Common Demo Tasks/blocktim.c **** 			queue function. */
 355:../src/Common Demo Tasks/blocktim.c **** 			if( xRunIndicator == bktRUN_INDICATOR )
 3998              		.loc 1 355 0
 3999 03b6 174B     		ldr	r3, .L44+8
 4000 03b8 1B68     		ldr	r3, [r3, #0]
 4001 03ba 552B     		cmp	r3, #85
 4002 03bc 03D1     		bne	.L37
 356:../src/Common Demo Tasks/blocktim.c **** 			{
 357:../src/Common Demo Tasks/blocktim.c **** 				/* The other task should not have executed outside of the
 358:../src/Common Demo Tasks/blocktim.c **** 				queue function. */
 359:../src/Common Demo Tasks/blocktim.c **** 				xErrorOccurred = pdTRUE;
 4003              		.loc 1 359 0
 4004 03be 144B     		ldr	r3, .L44+4
 4005 03c0 4FF00102 		mov	r2, #1
 4006 03c4 1A60     		str	r2, [r3, #0]
 4007              	.L37:
 360:../src/Common Demo Tasks/blocktim.c **** 			}
 361:../src/Common Demo Tasks/blocktim.c **** 			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
 4008              		.loc 1 361 0
 4009 03c6 144B     		ldr	r3, .L44+12
 4010 03c8 1B68     		ldr	r3, [r3, #0]
 4011 03ca 1846     		mov	r0, r3
 4012 03cc 4FF00101 		mov	r1, #1
 4013 03d0 FFF7FEFF 		bl	vTaskPrioritySet
 326:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 4014              		.loc 1 326 0
 4015 03d4 3B69     		ldr	r3, [r7, #16]
 4016 03d6 03F10103 		add	r3, r3, #1
 4017 03da 3B61     		str	r3, [r7, #16]
 4018              	.L33:
 326:../src/Common Demo Tasks/blocktim.c **** 		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 4019              		.loc 1 326 0 is_stmt 0 discriminator 1
 4020 03dc 3B69     		ldr	r3, [r7, #16]
 4021 03de 042B     		cmp	r3, #4
 4022 03e0 B4DD     		ble	.L38
 362:../src/Common Demo Tasks/blocktim.c **** 		}
 363:../src/Common Demo Tasks/blocktim.c **** 
 364:../src/Common Demo Tasks/blocktim.c **** 		/* Let the other task timeout.  When it unblockes it will check that it
 365:../src/Common Demo Tasks/blocktim.c **** 		unblocked at the correct time, then suspend itself. */
 366:../src/Common Demo Tasks/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 4023              		.loc 1 366 0 is_stmt 1
 4024 03e2 03E0     		b	.L39
 4025              	.L40:
 367:../src/Common Demo Tasks/blocktim.c **** 		{
 368:../src/Common Demo Tasks/blocktim.c **** 			vTaskDelay( bktSHORT_WAIT );
 4026              		.loc 1 368 0
 4027 03e4 4FF01400 		mov	r0, #20
 4028 03e8 FFF7FEFF 		bl	vTaskDelay
 4029              	.L39:
 366:../src/Common Demo Tasks/blocktim.c **** 		while( xRunIndicator != bktRUN_INDICATOR )
 4030              		.loc 1 366 0 discriminator 1
 4031 03ec 094B     		ldr	r3, .L44+8
 4032 03ee 1B68     		ldr	r3, [r3, #0]
 4033 03f0 552B     		cmp	r3, #85
 4034 03f2 F7D1     		bne	.L40
 369:../src/Common Demo Tasks/blocktim.c **** 		}
 370:../src/Common Demo Tasks/blocktim.c **** 		vTaskDelay( bktSHORT_WAIT );
 4035              		.loc 1 370 0
 4036 03f4 4FF01400 		mov	r0, #20
 4037 03f8 FFF7FEFF 		bl	vTaskDelay
 371:../src/Common Demo Tasks/blocktim.c **** 
 372:../src/Common Demo Tasks/blocktim.c **** 		xPrimaryCycles++;
 4038              		.loc 1 372 0
 4039 03fc 074B     		ldr	r3, .L44+16
 4040 03fe 1B68     		ldr	r3, [r3, #0]
 4041 0400 03F10102 		add	r2, r3, #1
 4042 0404 054B     		ldr	r3, .L44+16
 4043 0406 1A60     		str	r2, [r3, #0]
 373:../src/Common Demo Tasks/blocktim.c **** 	}
 4044              		.loc 1 373 0
 4045 0408 4CE6     		b	.L41
 4046              	.L45:
 4047 040a 00BF     		.align	2
 4048              	.L44:
 4049 040c 00000000 		.word	xTestQueue
 4050 0410 10000000 		.word	xErrorOccurred
 4051 0414 14000000 		.word	xRunIndicator
 4052 0418 04000000 		.word	xSecondary
 4053 041c 08000000 		.word	xPrimaryCycles
 4054              		.cfi_endproc
 4055              	.LFE30:
 4057              		.align	2
 4058              		.thumb
 4059              		.thumb_func
 4061              	vSecondaryBlockTimeTestTask:
 4062              	.LFB31:
 374:../src/Common Demo Tasks/blocktim.c **** }
 375:../src/Common Demo Tasks/blocktim.c **** /*-----------------------------------------------------------*/
 376:../src/Common Demo Tasks/blocktim.c **** 
 377:../src/Common Demo Tasks/blocktim.c **** static void vSecondaryBlockTimeTestTask( void *pvParameters )
 378:../src/Common Demo Tasks/blocktim.c **** {
 4063              		.loc 1 378 0
 4064              		.cfi_startproc
 4065              		@ args = 0, pretend = 0, frame = 24
 4066              		@ frame_needed = 1, uses_anonymous_args = 0
 4067 0420 80B5     		push	{r7, lr}
 4068              	.LCFI6:
 4069              		.cfi_def_cfa_offset 8
 4070 0422 86B0     		sub	sp, sp, #24
 4071              	.LCFI7:
 4072              		.cfi_def_cfa_offset 32
 4073 0424 00AF     		add	r7, sp, #0
 4074              		.cfi_offset 14, -4
 4075              		.cfi_offset 7, -8
 4076              	.LCFI8:
 4077              		.cfi_def_cfa_register 7
 4078 0426 7860     		str	r0, [r7, #4]
 4079              	.L53:
 379:../src/Common Demo Tasks/blocktim.c **** portTickType xTimeWhenBlocking, xBlockedTime;
 380:../src/Common Demo Tasks/blocktim.c **** portBASE_TYPE xData;
 381:../src/Common Demo Tasks/blocktim.c **** 
 382:../src/Common Demo Tasks/blocktim.c **** 	( void ) pvParameters;
 383:../src/Common Demo Tasks/blocktim.c **** 
 384:../src/Common Demo Tasks/blocktim.c **** 	for( ;; )
 385:../src/Common Demo Tasks/blocktim.c **** 	{
 386:../src/Common Demo Tasks/blocktim.c **** 		/*********************************************************************
 387:../src/Common Demo Tasks/blocktim.c ****         Test 1 and 2
 388:../src/Common Demo Tasks/blocktim.c **** 
 389:../src/Common Demo Tasks/blocktim.c **** 		This task does does not participate in these tests. */
 390:../src/Common Demo Tasks/blocktim.c **** 		vTaskSuspend( NULL );
 4080              		.loc 1 390 0
 4081 0428 4FF00000 		mov	r0, #0
 4082 042c FFF7FEFF 		bl	vTaskSuspend
 391:../src/Common Demo Tasks/blocktim.c **** 
 392:../src/Common Demo Tasks/blocktim.c **** 		/*********************************************************************
 393:../src/Common Demo Tasks/blocktim.c ****         Test 3
 394:../src/Common Demo Tasks/blocktim.c **** 
 395:../src/Common Demo Tasks/blocktim.c **** 		The first thing we do is attempt to read from the queue.  It should be
 396:../src/Common Demo Tasks/blocktim.c **** 		full so we block.  Note the time before we block so we can check the
 397:../src/Common Demo Tasks/blocktim.c **** 		wake time is as per that expected. */
 398:../src/Common Demo Tasks/blocktim.c **** 		xTimeWhenBlocking = xTaskGetTickCount();
 4083              		.loc 1 398 0
 4084 0430 FFF7FEFF 		bl	xTaskGetTickCount
 4085 0434 7861     		str	r0, [r7, #20]
 399:../src/Common Demo Tasks/blocktim.c **** 
 400:../src/Common Demo Tasks/blocktim.c **** 		/* We should unblock after bktTIME_TO_BLOCK having not sent
 401:../src/Common Demo Tasks/blocktim.c **** 		anything to the queue. */
 402:../src/Common Demo Tasks/blocktim.c **** 		xData = 0;
 4086              		.loc 1 402 0
 4087 0436 4FF00003 		mov	r3, #0
 4088 043a FB60     		str	r3, [r7, #12]
 403:../src/Common Demo Tasks/blocktim.c **** 		xRunIndicator = bktRUN_INDICATOR;
 4089              		.loc 1 403 0
 4090 043c 354B     		ldr	r3, .L54
 4091 043e 4FF05502 		mov	r2, #85
 4092 0442 1A60     		str	r2, [r3, #0]
 404:../src/Common Demo Tasks/blocktim.c **** 		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
 4093              		.loc 1 404 0
 4094 0444 344B     		ldr	r3, .L54+4
 4095 0446 1A68     		ldr	r2, [r3, #0]
 4096 0448 07F10C03 		add	r3, r7, #12
 4097 044c 1046     		mov	r0, r2
 4098 044e 1946     		mov	r1, r3
 4099 0450 4FF0AF02 		mov	r2, #175
 4100 0454 4FF00003 		mov	r3, #0
 4101 0458 FFF7FEFF 		bl	xQueueGenericSend
 4102 045c 0346     		mov	r3, r0
 4103 045e 002B     		cmp	r3, #0
 4104 0460 03D0     		beq	.L47
 405:../src/Common Demo Tasks/blocktim.c **** 		{
 406:../src/Common Demo Tasks/blocktim.c **** 			xErrorOccurred = pdTRUE;
 4105              		.loc 1 406 0
 4106 0462 2E4B     		ldr	r3, .L54+8
 4107 0464 4FF00102 		mov	r2, #1
 4108 0468 1A60     		str	r2, [r3, #0]
 4109              	.L47:
 407:../src/Common Demo Tasks/blocktim.c **** 		}
 408:../src/Common Demo Tasks/blocktim.c **** 
 409:../src/Common Demo Tasks/blocktim.c **** 		/* How long were we inside the send function? */
 410:../src/Common Demo Tasks/blocktim.c **** 		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 4110              		.loc 1 410 0
 4111 046a FFF7FEFF 		bl	xTaskGetTickCount
 4112 046e 0246     		mov	r2, r0
 4113 0470 7B69     		ldr	r3, [r7, #20]
 4114 0472 D31A     		subs	r3, r2, r3
 4115 0474 3B61     		str	r3, [r7, #16]
 411:../src/Common Demo Tasks/blocktim.c **** 
 412:../src/Common Demo Tasks/blocktim.c **** 		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
 413:../src/Common Demo Tasks/blocktim.c **** 		if( xBlockedTime < bktTIME_TO_BLOCK )
 4116              		.loc 1 413 0
 4117 0476 3B69     		ldr	r3, [r7, #16]
 4118 0478 AE2B     		cmp	r3, #174
 4119 047a 03D8     		bhi	.L48
 414:../src/Common Demo Tasks/blocktim.c **** 		{
 415:../src/Common Demo Tasks/blocktim.c **** 			xErrorOccurred = pdTRUE;
 4120              		.loc 1 415 0
 4121 047c 274B     		ldr	r3, .L54+8
 4122 047e 4FF00102 		mov	r2, #1
 4123 0482 1A60     		str	r2, [r3, #0]
 4124              	.L48:
 416:../src/Common Demo Tasks/blocktim.c **** 		}
 417:../src/Common Demo Tasks/blocktim.c **** 
 418:../src/Common Demo Tasks/blocktim.c **** 		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
 419:../src/Common Demo Tasks/blocktim.c **** 		either.  A margin is permitted as we would not necessarily run as
 420:../src/Common Demo Tasks/blocktim.c **** 		soon as we unblocked. */
 421:../src/Common Demo Tasks/blocktim.c **** 		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
 4125              		.loc 1 421 0
 4126 0484 3B69     		ldr	r3, [r7, #16]
 4127 0486 BE2B     		cmp	r3, #190
 4128 0488 03D9     		bls	.L49
 422:../src/Common Demo Tasks/blocktim.c **** 		{
 423:../src/Common Demo Tasks/blocktim.c **** 			xErrorOccurred = pdTRUE;
 4129              		.loc 1 423 0
 4130 048a 244B     		ldr	r3, .L54+8
 4131 048c 4FF00102 		mov	r2, #1
 4132 0490 1A60     		str	r2, [r3, #0]
 4133              	.L49:
 424:../src/Common Demo Tasks/blocktim.c **** 		}
 425:../src/Common Demo Tasks/blocktim.c **** 
 426:../src/Common Demo Tasks/blocktim.c **** 		/* Suspend ready for test 3. */
 427:../src/Common Demo Tasks/blocktim.c **** 		xRunIndicator = bktRUN_INDICATOR;
 4134              		.loc 1 427 0
 4135 0492 204B     		ldr	r3, .L54
 4136 0494 4FF05502 		mov	r2, #85
 4137 0498 1A60     		str	r2, [r3, #0]
 428:../src/Common Demo Tasks/blocktim.c **** 		vTaskSuspend( NULL );
 4138              		.loc 1 428 0
 4139 049a 4FF00000 		mov	r0, #0
 4140 049e FFF7FEFF 		bl	vTaskSuspend
 429:../src/Common Demo Tasks/blocktim.c **** 
 430:../src/Common Demo Tasks/blocktim.c **** 		/*********************************************************************
 431:../src/Common Demo Tasks/blocktim.c ****         Test 4
 432:../src/Common Demo Tasks/blocktim.c **** 
 433:../src/Common Demo Tasks/blocktim.c **** 		As per test three, but with the send and receive reversed. */
 434:../src/Common Demo Tasks/blocktim.c **** 		xTimeWhenBlocking = xTaskGetTickCount();
 4141              		.loc 1 434 0
 4142 04a2 FFF7FEFF 		bl	xTaskGetTickCount
 4143 04a6 7861     		str	r0, [r7, #20]
 435:../src/Common Demo Tasks/blocktim.c **** 
 436:../src/Common Demo Tasks/blocktim.c **** 		/* We should unblock after bktTIME_TO_BLOCK having not received
 437:../src/Common Demo Tasks/blocktim.c **** 		anything on the queue. */
 438:../src/Common Demo Tasks/blocktim.c **** 		xRunIndicator = bktRUN_INDICATOR;
 4144              		.loc 1 438 0
 4145 04a8 1A4B     		ldr	r3, .L54
 4146 04aa 4FF05502 		mov	r2, #85
 4147 04ae 1A60     		str	r2, [r3, #0]
 439:../src/Common Demo Tasks/blocktim.c **** 		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
 4148              		.loc 1 439 0
 4149 04b0 194B     		ldr	r3, .L54+4
 4150 04b2 1A68     		ldr	r2, [r3, #0]
 4151 04b4 07F10C03 		add	r3, r7, #12
 4152 04b8 1046     		mov	r0, r2
 4153 04ba 1946     		mov	r1, r3
 4154 04bc 4FF0AF02 		mov	r2, #175
 4155 04c0 4FF00003 		mov	r3, #0
 4156 04c4 FFF7FEFF 		bl	xQueueGenericReceive
 4157 04c8 0346     		mov	r3, r0
 4158 04ca 002B     		cmp	r3, #0
 4159 04cc 03D0     		beq	.L50
 440:../src/Common Demo Tasks/blocktim.c **** 		{
 441:../src/Common Demo Tasks/blocktim.c **** 			xErrorOccurred = pdTRUE;
 4160              		.loc 1 441 0
 4161 04ce 134B     		ldr	r3, .L54+8
 4162 04d0 4FF00102 		mov	r2, #1
 4163 04d4 1A60     		str	r2, [r3, #0]
 4164              	.L50:
 442:../src/Common Demo Tasks/blocktim.c **** 		}
 443:../src/Common Demo Tasks/blocktim.c **** 
 444:../src/Common Demo Tasks/blocktim.c **** 		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 4165              		.loc 1 444 0
 4166 04d6 FFF7FEFF 		bl	xTaskGetTickCount
 4167 04da 0246     		mov	r2, r0
 4168 04dc 7B69     		ldr	r3, [r7, #20]
 4169 04de D31A     		subs	r3, r2, r3
 4170 04e0 3B61     		str	r3, [r7, #16]
 445:../src/Common Demo Tasks/blocktim.c **** 
 446:../src/Common Demo Tasks/blocktim.c **** 		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
 447:../src/Common Demo Tasks/blocktim.c **** 		if( xBlockedTime < bktTIME_TO_BLOCK )
 4171              		.loc 1 447 0
 4172 04e2 3B69     		ldr	r3, [r7, #16]
 4173 04e4 AE2B     		cmp	r3, #174
 4174 04e6 03D8     		bhi	.L51
 448:../src/Common Demo Tasks/blocktim.c **** 		{
 449:../src/Common Demo Tasks/blocktim.c **** 			xErrorOccurred = pdTRUE;
 4175              		.loc 1 449 0
 4176 04e8 0C4B     		ldr	r3, .L54+8
 4177 04ea 4FF00102 		mov	r2, #1
 4178 04ee 1A60     		str	r2, [r3, #0]
 4179              	.L51:
 450:../src/Common Demo Tasks/blocktim.c **** 		}
 451:../src/Common Demo Tasks/blocktim.c **** 
 452:../src/Common Demo Tasks/blocktim.c **** 		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
 453:../src/Common Demo Tasks/blocktim.c **** 		either.  A margin is permitted as we would not necessarily run as soon
 454:../src/Common Demo Tasks/blocktim.c **** 		as we unblocked. */
 455:../src/Common Demo Tasks/blocktim.c **** 		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
 4180              		.loc 1 455 0
 4181 04f0 3B69     		ldr	r3, [r7, #16]
 4182 04f2 BE2B     		cmp	r3, #190
 4183 04f4 03D9     		bls	.L52
 456:../src/Common Demo Tasks/blocktim.c **** 		{
 457:../src/Common Demo Tasks/blocktim.c **** 			xErrorOccurred = pdTRUE;
 4184              		.loc 1 457 0
 4185 04f6 094B     		ldr	r3, .L54+8
 4186 04f8 4FF00102 		mov	r2, #1
 4187 04fc 1A60     		str	r2, [r3, #0]
 4188              	.L52:
 458:../src/Common Demo Tasks/blocktim.c **** 		}
 459:../src/Common Demo Tasks/blocktim.c **** 
 460:../src/Common Demo Tasks/blocktim.c **** 		xRunIndicator = bktRUN_INDICATOR;
 4189              		.loc 1 460 0
 4190 04fe 054B     		ldr	r3, .L54
 4191 0500 4FF05502 		mov	r2, #85
 4192 0504 1A60     		str	r2, [r3, #0]
 461:../src/Common Demo Tasks/blocktim.c **** 
 462:../src/Common Demo Tasks/blocktim.c **** 		xSecondaryCycles++;
 4193              		.loc 1 462 0
 4194 0506 064B     		ldr	r3, .L54+12
 4195 0508 1B68     		ldr	r3, [r3, #0]
 4196 050a 03F10102 		add	r2, r3, #1
 4197 050e 044B     		ldr	r3, .L54+12
 4198 0510 1A60     		str	r2, [r3, #0]
 463:../src/Common Demo Tasks/blocktim.c **** 	}
 4199              		.loc 1 463 0
 4200 0512 89E7     		b	.L53
 4201              	.L55:
 4202              		.align	2
 4203              	.L54:
 4204 0514 14000000 		.word	xRunIndicator
 4205 0518 00000000 		.word	xTestQueue
 4206 051c 10000000 		.word	xErrorOccurred
 4207 0520 0C000000 		.word	xSecondaryCycles
 4208              		.cfi_endproc
 4209              	.LFE31:
 4211              		.align	2
 4212              		.global	xAreBlockTimeTestTasksStillRunning
 4213              		.thumb
 4214              		.thumb_func
 4216              	xAreBlockTimeTestTasksStillRunning:
 4217              	.LFB32:
 464:../src/Common Demo Tasks/blocktim.c **** }
 465:../src/Common Demo Tasks/blocktim.c **** /*-----------------------------------------------------------*/
 466:../src/Common Demo Tasks/blocktim.c **** 
 467:../src/Common Demo Tasks/blocktim.c **** portBASE_TYPE xAreBlockTimeTestTasksStillRunning( void )
 468:../src/Common Demo Tasks/blocktim.c **** {
 4218              		.loc 1 468 0
 4219              		.cfi_startproc
 4220              		@ args = 0, pretend = 0, frame = 8
 4221              		@ frame_needed = 1, uses_anonymous_args = 0
 4222              		@ link register save eliminated.
 4223 0524 80B4     		push	{r7}
 4224              	.LCFI9:
 4225              		.cfi_def_cfa_offset 4
 4226 0526 83B0     		sub	sp, sp, #12
 4227              	.LCFI10:
 4228              		.cfi_def_cfa_offset 16
 4229 0528 00AF     		add	r7, sp, #0
 4230              		.cfi_offset 7, -4
 4231              	.LCFI11:
 4232              		.cfi_def_cfa_register 7
 469:../src/Common Demo Tasks/blocktim.c **** static portBASE_TYPE xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
 470:../src/Common Demo Tasks/blocktim.c **** portBASE_TYPE xReturn = pdPASS;
 4233              		.loc 1 470 0
 4234 052a 4FF00103 		mov	r3, #1
 4235 052e 7B60     		str	r3, [r7, #4]
 471:../src/Common Demo Tasks/blocktim.c **** 
 472:../src/Common Demo Tasks/blocktim.c **** 	/* Have both tasks performed at least one cycle since this function was
 473:../src/Common Demo Tasks/blocktim.c **** 	last called? */
 474:../src/Common Demo Tasks/blocktim.c **** 	if( xPrimaryCycles == xLastPrimaryCycleCount )
 4236              		.loc 1 474 0
 4237 0530 134B     		ldr	r3, .L60
 4238 0532 1A68     		ldr	r2, [r3, #0]
 4239 0534 134B     		ldr	r3, .L60+4
 4240 0536 1B68     		ldr	r3, [r3, #0]
 4241 0538 9A42     		cmp	r2, r3
 4242 053a 02D1     		bne	.L57
 475:../src/Common Demo Tasks/blocktim.c **** 	{
 476:../src/Common Demo Tasks/blocktim.c **** 		xReturn = pdFAIL;
 4243              		.loc 1 476 0
 4244 053c 4FF00003 		mov	r3, #0
 4245 0540 7B60     		str	r3, [r7, #4]
 4246              	.L57:
 477:../src/Common Demo Tasks/blocktim.c **** 	}
 478:../src/Common Demo Tasks/blocktim.c **** 
 479:../src/Common Demo Tasks/blocktim.c **** 	if( xSecondaryCycles == xLastSecondaryCycleCount )
 4247              		.loc 1 479 0
 4248 0542 114B     		ldr	r3, .L60+8
 4249 0544 1A68     		ldr	r2, [r3, #0]
 4250 0546 114B     		ldr	r3, .L60+12
 4251 0548 1B68     		ldr	r3, [r3, #0]
 4252 054a 9A42     		cmp	r2, r3
 4253 054c 02D1     		bne	.L58
 480:../src/Common Demo Tasks/blocktim.c **** 	{
 481:../src/Common Demo Tasks/blocktim.c **** 		xReturn = pdFAIL;
 4254              		.loc 1 481 0
 4255 054e 4FF00003 		mov	r3, #0
 4256 0552 7B60     		str	r3, [r7, #4]
 4257              	.L58:
 482:../src/Common Demo Tasks/blocktim.c **** 	}
 483:../src/Common Demo Tasks/blocktim.c **** 
 484:../src/Common Demo Tasks/blocktim.c **** 	if( xErrorOccurred == pdTRUE )
 4258              		.loc 1 484 0
 4259 0554 0E4B     		ldr	r3, .L60+16
 4260 0556 1B68     		ldr	r3, [r3, #0]
 4261 0558 012B     		cmp	r3, #1
 4262 055a 02D1     		bne	.L59
 485:../src/Common Demo Tasks/blocktim.c **** 	{
 486:../src/Common Demo Tasks/blocktim.c **** 		xReturn = pdFAIL;
 4263              		.loc 1 486 0
 4264 055c 4FF00003 		mov	r3, #0
 4265 0560 7B60     		str	r3, [r7, #4]
 4266              	.L59:
 487:../src/Common Demo Tasks/blocktim.c **** 	}
 488:../src/Common Demo Tasks/blocktim.c **** 
 489:../src/Common Demo Tasks/blocktim.c **** 	xLastSecondaryCycleCount = xSecondaryCycles;
 4267              		.loc 1 489 0
 4268 0562 094B     		ldr	r3, .L60+8
 4269 0564 1A68     		ldr	r2, [r3, #0]
 4270 0566 094B     		ldr	r3, .L60+12
 4271 0568 1A60     		str	r2, [r3, #0]
 490:../src/Common Demo Tasks/blocktim.c **** 	xLastPrimaryCycleCount = xPrimaryCycles;
 4272              		.loc 1 490 0
 4273 056a 054B     		ldr	r3, .L60
 4274 056c 1A68     		ldr	r2, [r3, #0]
 4275 056e 054B     		ldr	r3, .L60+4
 4276 0570 1A60     		str	r2, [r3, #0]
 491:../src/Common Demo Tasks/blocktim.c **** 
 492:../src/Common Demo Tasks/blocktim.c **** 	return xReturn;
 4277              		.loc 1 492 0
 4278 0572 7B68     		ldr	r3, [r7, #4]
 493:../src/Common Demo Tasks/blocktim.c **** }
 4279              		.loc 1 493 0
 4280 0574 1846     		mov	r0, r3
 4281 0576 07F10C07 		add	r7, r7, #12
 4282 057a BD46     		mov	sp, r7
 4283 057c 80BC     		pop	{r7}
 4284 057e 7047     		bx	lr
 4285              	.L61:
 4286              		.align	2
 4287              	.L60:
 4288 0580 08000000 		.word	xPrimaryCycles
 4289 0584 18000000 		.word	xLastPrimaryCycleCount.5274
 4290 0588 0C000000 		.word	xSecondaryCycles
 4291 058c 1C000000 		.word	xLastSecondaryCycleCount.5275
 4292 0590 10000000 		.word	xErrorOccurred
 4293              		.cfi_endproc
 4294              	.LFE32:
 4296              		.bss
 4297              		.align	2
 4298              	xLastPrimaryCycleCount.5274:
 4299 0018 00000000 		.space	4
 4300              		.align	2
 4301              	xLastSecondaryCycleCount.5275:
 4302 001c 00000000 		.space	4
 4303              		.text
 4304              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 blocktim.c
     /tmp/cc9n3Kce.s:3456   .bss:00000000 $d
     /tmp/cc9n3Kce.s:3457   .bss:00000000 xTestQueue
     /tmp/cc9n3Kce.s:3460   .bss:00000004 xSecondary
     /tmp/cc9n3Kce.s:3463   .bss:00000008 xPrimaryCycles
     /tmp/cc9n3Kce.s:3466   .bss:0000000c xSecondaryCycles
     /tmp/cc9n3Kce.s:3469   .bss:00000010 xErrorOccurred
     /tmp/cc9n3Kce.s:3472   .bss:00000014 xRunIndicator
     /tmp/cc9n3Kce.s:3475   .rodata:00000000 $d
     /tmp/cc9n3Kce.s:3485   .text:00000000 $t
     /tmp/cc9n3Kce.s:3490   .text:00000000 vCreateBlockTimeTasks
     /tmp/cc9n3Kce.s:3558   .text:00000080 $d
     /tmp/cc9n3Kce.s:3572   .text:0000009c vPrimaryBlockTimeTestTask
     /tmp/cc9n3Kce.s:4061   .text:00000420 vSecondaryBlockTimeTestTask
     /tmp/cc9n3Kce.s:3568   .text:0000009c $t
     /tmp/cc9n3Kce.s:3943   .text:0000033c $d
     /tmp/cc9n3Kce.s:3949   .text:0000034c $t
     /tmp/cc9n3Kce.s:4049   .text:0000040c $d
     /tmp/cc9n3Kce.s:4057   .text:00000420 $t
     /tmp/cc9n3Kce.s:4204   .text:00000514 $d
     /tmp/cc9n3Kce.s:4211   .text:00000524 $t
     /tmp/cc9n3Kce.s:4216   .text:00000524 xAreBlockTimeTestTasksStillRunning
     /tmp/cc9n3Kce.s:4288   .text:00000580 $d
     /tmp/cc9n3Kce.s:4298   .bss:00000018 xLastPrimaryCycleCount.5274
     /tmp/cc9n3Kce.s:4301   .bss:0000001c xLastSecondaryCycleCount.5275
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
xQueueGenericCreate
vQueueAddToRegistry
xTaskGenericCreate
xTaskGetTickCount
xQueueGenericReceive
xQueueGenericSend
vTaskResume
vTaskDelay
vTaskPrioritySet
vTaskSuspend
